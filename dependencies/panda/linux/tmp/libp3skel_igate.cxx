/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/skel -Ipanda/src/skel -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3skel_igate.cxx -od built/pandac/input/libp3skel.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/skel -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.skel -library libp3skel basicSkel.h config_skel.h p3skel_composite1.cxx typedSkel.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "basicSkel.h"
#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_skel.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "typedSkel.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class BasicSkel
 */
typedef BasicSkel BasicSkel_localtype;
Define_Module_Class(panda3d.skel, BasicSkel, BasicSkel_localtype, BasicSkel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BasicSkel = &Dtool_BasicSkel;
static void Dtool_PyModuleClassInit_BasicSkel(PyObject *module);

/**
 * Forward declarations for top-level class TypedSkel
 */
typedef TypedSkel TypedSkel_localtype;
Define_Module_Class(panda3d.skel, TypedSkel, TypedSkel_localtype, TypedSkel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedSkel = &Dtool_TypedSkel;
static void Dtool_PyModuleClassInit_TypedSkel(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"BasicSkel", &Dtool_BasicSkel},
  {"TypedSkel", &Dtool_TypedSkel},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[0].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[1].type)
  {nullptr, nullptr},
};
#endif

// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class BasicSkel
 */
/**
 * Python function wrapper for:
 * inline void BasicSkel::set_value(int n)
 */
static PyObject *Dtool_BasicSkel_set_value_4(PyObject *self, PyObject *arg) {
  BasicSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BasicSkel, (void **)&local_this, "BasicSkel.set_value")) {
    return nullptr;
  }
  // 1-inline void BasicSkel::set_value(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_value)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const BasicSkel self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BasicSkel_set_value_4_comment =
  "C++ Interface:\n"
  "set_value(const BasicSkel self, int n)\n"
  "\n"
  "// These inline functions allow you to get and set _value.\n"
  "\n"
  "/**\n"
  " * Stores an integer value.\n"
  " */";
#else
static const char *Dtool_BasicSkel_set_value_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BasicSkel::get_value(void)
 */
static PyObject *Dtool_BasicSkel_get_value_5(PyObject *self, PyObject *) {
  BasicSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BasicSkel, (void **)&local_this, "BasicSkel.get_value")) {
    return nullptr;
  }
  // 1-inline int BasicSkel::get_value(void)
  int return_value = ((*local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BasicSkel_get_value_5_comment =
  "C++ Interface:\n"
  "get_value(const BasicSkel self)\n"
  "\n"
  "/**\n"
  " * Retreives a value that was previously stored.\n"
  " */";
#else
static const char *Dtool_BasicSkel_get_value_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BasicSkel::set_value_alt(int n)
 */
static PyObject *Dtool_BasicSkel_set_value_alt_6(PyObject *self, PyObject *arg) {
  BasicSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BasicSkel, (void **)&local_this, "BasicSkel.set_value_alt")) {
    return nullptr;
  }
  // 1-void BasicSkel::set_value_alt(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_value_alt)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_alt(const BasicSkel self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BasicSkel_set_value_alt_6_comment =
  "C++ Interface:\n"
  "set_value_alt(const BasicSkel self, int n)\n"
  "\n"
  "// These do the same thing as the functions above.\n"
  "\n"
  "/**\n"
  " * Stores an integer value.  Exact same functionality as set_value, except\n"
  " * that this isn't an inline function.\n"
  " */";
#else
static const char *Dtool_BasicSkel_set_value_alt_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BasicSkel::get_value_alt(void)
 */
static PyObject *Dtool_BasicSkel_get_value_alt_7(PyObject *self, PyObject *) {
  BasicSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BasicSkel, (void **)&local_this, "BasicSkel.get_value_alt")) {
    return nullptr;
  }
  // 1-int BasicSkel::get_value_alt(void)
  int return_value = ((*local_this).get_value_alt)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BasicSkel_get_value_alt_7_comment =
  "C++ Interface:\n"
  "get_value_alt(const BasicSkel self)\n"
  "\n"
  "/**\n"
  " * Retreives a value that was previously stored.  Exact same functionality as\n"
  " * get_value, except that this isn't an inline function.\n"
  " */";
#else
static const char *Dtool_BasicSkel_get_value_alt_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BasicSkel::BasicSkel(void)
 * inline BasicSkel::BasicSkel(BasicSkel const &) = default
 */
static int Dtool_Init_BasicSkel(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BasicSkel() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BasicSkel::BasicSkel(void)
      BasicSkel *return_value = new BasicSkel();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BasicSkel, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BasicSkel::BasicSkel(BasicSkel const &) = default
      BasicSkel const *arg_this = (BasicSkel *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BasicSkel, 0, "BasicSkel.BasicSkel", true, true);
      if (arg_this != nullptr) {
        BasicSkel *return_value = new BasicSkel(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BasicSkel, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BasicSkel() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BasicSkel()\n"
      "BasicSkel(const BasicSkel param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BasicSkel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BasicSkel) {
    printf("BasicSkel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BasicSkel *local_this = (BasicSkel *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BasicSkel) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BasicSkel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BasicSkel) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TypedSkel
 */
/**
 * Python function wrapper for:
 * inline void TypedSkel::set_value(int n)
 */
static PyObject *Dtool_TypedSkel_set_value_11(PyObject *self, PyObject *arg) {
  TypedSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedSkel, (void **)&local_this, "TypedSkel.set_value")) {
    return nullptr;
  }
  // 1-inline void TypedSkel::set_value(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_value)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const TypedSkel self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedSkel_set_value_11_comment =
  "C++ Interface:\n"
  "set_value(const TypedSkel self, int n)\n"
  "\n"
  "// These inline functions allow you to get and set _value.\n"
  "\n"
  "/**\n"
  " * Stores an integer value.\n"
  " */";
#else
static const char *Dtool_TypedSkel_set_value_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TypedSkel::get_value(void)
 */
static PyObject *Dtool_TypedSkel_get_value_12(PyObject *self, PyObject *) {
  TypedSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedSkel, (void **)&local_this, "TypedSkel.get_value")) {
    return nullptr;
  }
  // 1-inline int TypedSkel::get_value(void)
  int return_value = ((*local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypedSkel_get_value_12_comment =
  "C++ Interface:\n"
  "get_value(const TypedSkel self)\n"
  "\n"
  "/**\n"
  " * Retreives a value that was previously stored.\n"
  " */";
#else
static const char *Dtool_TypedSkel_get_value_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TypedSkel::set_value_alt(int n)
 */
static PyObject *Dtool_TypedSkel_set_value_alt_13(PyObject *self, PyObject *arg) {
  TypedSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedSkel, (void **)&local_this, "TypedSkel.set_value_alt")) {
    return nullptr;
  }
  // 1-void TypedSkel::set_value_alt(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_value_alt)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_alt(const TypedSkel self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedSkel_set_value_alt_13_comment =
  "C++ Interface:\n"
  "set_value_alt(const TypedSkel self, int n)\n"
  "\n"
  "// These do the same thing as the functions above.\n"
  "\n"
  "/**\n"
  " * Stores an integer value.  Exact same functionality as set_value, except\n"
  " * that this isn't an inline function.\n"
  " */";
#else
static const char *Dtool_TypedSkel_set_value_alt_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TypedSkel::get_value_alt(void)
 */
static PyObject *Dtool_TypedSkel_get_value_alt_14(PyObject *self, PyObject *) {
  TypedSkel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedSkel, (void **)&local_this, "TypedSkel.get_value_alt")) {
    return nullptr;
  }
  // 1-int TypedSkel::get_value_alt(void)
  int return_value = ((*local_this).get_value_alt)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypedSkel_get_value_alt_14_comment =
  "C++ Interface:\n"
  "get_value_alt(const TypedSkel self)\n"
  "\n"
  "/**\n"
  " * Retreives a value that was previously stored.  Exact same functionality as\n"
  " * get_value, except that this isn't an inline function.\n"
  " */";
#else
static const char *Dtool_TypedSkel_get_value_alt_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TypedSkel::get_class_type(void)
 */
static PyObject *Dtool_TypedSkel_get_class_type_15(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedSkel::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TypedSkel::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedSkel_get_class_type_15_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedSkel_get_class_type_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypedSkel::TypedSkel(void)
 */
static int Dtool_Init_TypedSkel(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TypedSkel() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TypedSkel() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline TypedSkel::TypedSkel(void)
  TypedSkel *return_value = new TypedSkel();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TypedSkel, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TypedSkel()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TypedSkel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TypedSkel) {
    printf("TypedSkel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TypedSkel *local_this = (TypedSkel *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TypedSkel) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TypedSkel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TypedSkel) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TypedSkel*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for BasicSkel (BasicSkel)
 */
static PyMethodDef Dtool_Methods_BasicSkel[] = {
  {"set_value", &Dtool_BasicSkel_set_value_4, METH_O, (const char *)Dtool_BasicSkel_set_value_4_comment},
  {"setValue", &Dtool_BasicSkel_set_value_4, METH_O, (const char *)Dtool_BasicSkel_set_value_4_comment},
  {"get_value", &Dtool_BasicSkel_get_value_5, METH_NOARGS, (const char *)Dtool_BasicSkel_get_value_5_comment},
  {"getValue", &Dtool_BasicSkel_get_value_5, METH_NOARGS, (const char *)Dtool_BasicSkel_get_value_5_comment},
  {"set_value_alt", &Dtool_BasicSkel_set_value_alt_6, METH_O, (const char *)Dtool_BasicSkel_set_value_alt_6_comment},
  {"setValueAlt", &Dtool_BasicSkel_set_value_alt_6, METH_O, (const char *)Dtool_BasicSkel_set_value_alt_6_comment},
  {"get_value_alt", &Dtool_BasicSkel_get_value_alt_7, METH_NOARGS, (const char *)Dtool_BasicSkel_get_value_alt_7_comment},
  {"getValueAlt", &Dtool_BasicSkel_get_value_alt_7, METH_NOARGS, (const char *)Dtool_BasicSkel_get_value_alt_7_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BasicSkel = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BasicSkel = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.skel.BasicSkel",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BasicSkel,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BasicSkel,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the most basic of the skeleton classes.  It stores an integer, and\n"
    " * will return it on request.\n"
    " *\n"
    " * The skeleton classes are intended to help you learn how to add C++ classes\n"
    " * to panda.  See also the manual, \"Adding C++ Classes to Panda.\"\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BasicSkel,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BasicSkel,
    PyType_GenericAlloc,
    Dtool_new_BasicSkel,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BasicSkel,
  Dtool_UpcastInterface_BasicSkel,
  Dtool_DowncastInterface_BasicSkel,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BasicSkel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BasicSkel._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BasicSkel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BasicSkel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BasicSkel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BasicSkel);
  }
}

/**
 * Python method tables for TypedSkel (TypedSkel)
 */
static PyMethodDef Dtool_Methods_TypedSkel[] = {
  {"set_value", &Dtool_TypedSkel_set_value_11, METH_O, (const char *)Dtool_TypedSkel_set_value_11_comment},
  {"setValue", &Dtool_TypedSkel_set_value_11, METH_O, (const char *)Dtool_TypedSkel_set_value_11_comment},
  {"get_value", &Dtool_TypedSkel_get_value_12, METH_NOARGS, (const char *)Dtool_TypedSkel_get_value_12_comment},
  {"getValue", &Dtool_TypedSkel_get_value_12, METH_NOARGS, (const char *)Dtool_TypedSkel_get_value_12_comment},
  {"set_value_alt", &Dtool_TypedSkel_set_value_alt_13, METH_O, (const char *)Dtool_TypedSkel_set_value_alt_13_comment},
  {"setValueAlt", &Dtool_TypedSkel_set_value_alt_13, METH_O, (const char *)Dtool_TypedSkel_set_value_alt_13_comment},
  {"get_value_alt", &Dtool_TypedSkel_get_value_alt_14, METH_NOARGS, (const char *)Dtool_TypedSkel_get_value_alt_14_comment},
  {"getValueAlt", &Dtool_TypedSkel_get_value_alt_14, METH_NOARGS, (const char *)Dtool_TypedSkel_get_value_alt_14_comment},
  {"get_class_type", &Dtool_TypedSkel_get_class_type_15, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedSkel_get_class_type_15_comment},
  {"getClassType", &Dtool_TypedSkel_get_class_type_15, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedSkel_get_class_type_15_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TypedSkel = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedSkel = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TypedSkel = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TypedSkel = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TypedSkel = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TypedSkel = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.skel.TypedSkel",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedSkel,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TypedSkel,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TypedSkel,
    &Dtool_SequenceMethods_TypedSkel,
    &Dtool_MappingMethods_TypedSkel,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TypedSkel,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Skeleton object that inherits from TypedObject.  Stores an integer, and\n"
    " * will return it on request.\n"
    " *\n"
    " * The skeleton classes are intended to help you learn how to add C++ classes\n"
    " * to panda.  See also the manual, \"Adding C++ Classes to Panda.\"\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TypedSkel,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TypedSkel,
    PyType_GenericAlloc,
    Dtool_new_TypedSkel,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedSkel,
  Dtool_UpcastInterface_TypedSkel,
  Dtool_DowncastInterface_TypedSkel,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TypedSkel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_TypedSkel._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_TypedSkel._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TypedSkel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedSkel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedSkel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedSkel);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3skel_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    TypedSkel::init_type();
    TypeHandle handle = TypedSkel::get_class_type();
    Dtool_TypedSkel._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TypedSkel);
  }
}

void Dtool_libp3skel_BuildInstants(PyObject *module) {
  (void) module;
  // BasicSkel
  Dtool_PyModuleClassInit_BasicSkel(module);
  PyModule_AddObject(module, "BasicSkel", (PyObject *)&Dtool_BasicSkel);
  // TypedSkel
  Dtool_PyModuleClassInit_TypedSkel(module);
  PyModule_AddObject(module, "TypedSkel", (PyObject *)&Dtool_TypedSkel);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3skel_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3skel_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613984,  /* file_identifier */
  "libp3skel",  /* library_name */
  "5lWe",  /* library_hash_name */
  "panda3d.skel",  /* module_name */
  "libp3skel.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  36  /* next_index */
};

Configure(_in_configure_libp3skel);
ConfigureFn(_in_configure_libp3skel) {
  interrogate_request_module(&_in_module_def);
}

