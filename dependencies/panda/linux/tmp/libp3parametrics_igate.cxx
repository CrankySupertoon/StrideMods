/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/parametrics -Ipanda/src/parametrics -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3parametrics_igate.cxx -od built/pandac/input/libp3parametrics.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/parametrics -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3parametrics config_parametrics.h cubicCurveseg.h curveFitter.h hermiteCurve.h nurbsBasisVector.h nurbsCurve.h nurbsCurveEvaluator.h nurbsCurveInterface.h nurbsCurveResult.h nurbsSurfaceEvaluator.h nurbsSurfaceResult.h nurbsVertex.h p3parametrics_composite1.cxx p3parametrics_composite2.cxx parametricCurve.h parametricCurveCollection.h piecewiseCurve.h ropeNode.h sheetNode.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_parametrics.h"
#include "cubicCurveseg.h"
#include "curveFitter.h"
#include "epvector.h"
#include "hermiteCurve.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "nurbsBasisVector.h"
#include "nurbsCurve.h"
#include "nurbsCurveEvaluator.h"
#include "nurbsCurveInterface.h"
#include "nurbsCurveResult.h"
#include "nurbsSurfaceEvaluator.h"
#include "nurbsSurfaceResult.h"
#include "nurbsVertex.h"
#include "pandabase.h"
#include "parametricCurve.h"
#include "parametricCurveCollection.h"
#include "piecewiseCurve.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"
#include "referenceCount.h"
#include "ropeNode.h"
#include "sheetNode.h"
#include "typedef.h"
#include "vector_stdfloat.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ParametricCurve
 */
typedef ParametricCurve ParametricCurve_localtype;
Define_Module_ClassRef(panda3d.core, ParametricCurve, ParametricCurve_localtype, ParametricCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParametricCurve = &Dtool_ParametricCurve;
static void Dtool_PyModuleClassInit_ParametricCurve(PyObject *module);

/**
 * Forward declarations for top-level class CubicCurveseg
 */
typedef CubicCurveseg CubicCurveseg_localtype;
Define_Module_ClassRef(panda3d.core, CubicCurveseg, CubicCurveseg_localtype, CubicCurveseg);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CubicCurveseg = &Dtool_CubicCurveseg;
static void Dtool_PyModuleClassInit_CubicCurveseg(PyObject *module);

/**
 * Forward declarations for top-level class ParametricCurveCollection
 */
typedef ParametricCurveCollection ParametricCurveCollection_localtype;
Define_Module_ClassRef(panda3d.core, ParametricCurveCollection, ParametricCurveCollection_localtype, ParametricCurveCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParametricCurveCollection = &Dtool_ParametricCurveCollection;
static void Dtool_PyModuleClassInit_ParametricCurveCollection(PyObject *module);

/**
 * Forward declarations for top-level class CurveFitter
 */
typedef CurveFitter CurveFitter_localtype;
Define_Module_Class(panda3d.core, CurveFitter, CurveFitter_localtype, CurveFitter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CurveFitter = &Dtool_CurveFitter;
static void Dtool_PyModuleClassInit_CurveFitter(PyObject *module);

/**
 * Forward declarations for top-level class PiecewiseCurve
 */
typedef PiecewiseCurve PiecewiseCurve_localtype;
Define_Module_ClassRef(panda3d.core, PiecewiseCurve, PiecewiseCurve_localtype, PiecewiseCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PiecewiseCurve = &Dtool_PiecewiseCurve;
static void Dtool_PyModuleClassInit_PiecewiseCurve(PyObject *module);

/**
 * Forward declarations for top-level class HermiteCurve
 */
typedef HermiteCurve HermiteCurve_localtype;
Define_Module_ClassRef(panda3d.core, HermiteCurve, HermiteCurve_localtype, HermiteCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HermiteCurve = &Dtool_HermiteCurve;
static void Dtool_PyModuleClassInit_HermiteCurve(PyObject *module);
bool Dtool_ConstCoerce_HermiteCurve(PyObject *args, CPT(HermiteCurve) &coerced);
bool Dtool_Coerce_HermiteCurve(PyObject *args, PT(HermiteCurve) &coerced);

/**
 * Forward declarations for top-level class NurbsCurveInterface
 */
typedef NurbsCurveInterface NurbsCurveInterface_localtype;
Define_Module_Class(panda3d.core, NurbsCurveInterface, NurbsCurveInterface_localtype, NurbsCurveInterface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurveInterface = &Dtool_NurbsCurveInterface;
static void Dtool_PyModuleClassInit_NurbsCurveInterface(PyObject *module);

/**
 * Forward declarations for top-level class NurbsCurve
 */
typedef NurbsCurve NurbsCurve_localtype;
Define_Module_ClassRef(panda3d.core, NurbsCurve, NurbsCurve_localtype, NurbsCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurve = &Dtool_NurbsCurve;
static void Dtool_PyModuleClassInit_NurbsCurve(PyObject *module);
bool Dtool_ConstCoerce_NurbsCurve(PyObject *args, CPT(NurbsCurve) &coerced);
bool Dtool_Coerce_NurbsCurve(PyObject *args, PT(NurbsCurve) &coerced);

/**
 * Forward declarations for top-level class NurbsCurveResult
 */
typedef NurbsCurveResult NurbsCurveResult_localtype;
Define_Module_ClassRef(panda3d.core, NurbsCurveResult, NurbsCurveResult_localtype, NurbsCurveResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurveResult = &Dtool_NurbsCurveResult;
static void Dtool_PyModuleClassInit_NurbsCurveResult(PyObject *module);

/**
 * Forward declarations for top-level class NurbsCurveEvaluator
 */
typedef NurbsCurveEvaluator NurbsCurveEvaluator_localtype;
Define_Module_ClassRef(panda3d.core, NurbsCurveEvaluator, NurbsCurveEvaluator_localtype, NurbsCurveEvaluator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsCurveEvaluator = &Dtool_NurbsCurveEvaluator;
static void Dtool_PyModuleClassInit_NurbsCurveEvaluator(PyObject *module);

/**
 * Forward declarations for top-level class NurbsSurfaceResult
 */
typedef NurbsSurfaceResult NurbsSurfaceResult_localtype;
Define_Module_ClassRef(panda3d.core, NurbsSurfaceResult, NurbsSurfaceResult_localtype, NurbsSurfaceResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsSurfaceResult = &Dtool_NurbsSurfaceResult;
static void Dtool_PyModuleClassInit_NurbsSurfaceResult(PyObject *module);

/**
 * Forward declarations for top-level class NurbsSurfaceEvaluator
 */
typedef NurbsSurfaceEvaluator NurbsSurfaceEvaluator_localtype;
Define_Module_ClassRef(panda3d.core, NurbsSurfaceEvaluator, NurbsSurfaceEvaluator_localtype, NurbsSurfaceEvaluator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NurbsSurfaceEvaluator = &Dtool_NurbsSurfaceEvaluator;
static void Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(PyObject *module);

/**
 * Forward declarations for top-level class RopeNode
 */
typedef RopeNode RopeNode_localtype;
Define_Module_ClassRef(panda3d.core, RopeNode, RopeNode_localtype, RopeNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RopeNode = &Dtool_RopeNode;
static void Dtool_PyModuleClassInit_RopeNode(PyObject *module);

/**
 * Forward declarations for top-level class SheetNode
 */
typedef SheetNode SheetNode_localtype;
Define_Module_ClassRef(panda3d.core, SheetNode, SheetNode_localtype, SheetNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SheetNode = &Dtool_SheetNode;
static void Dtool_PyModuleClassInit_SheetNode(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"ParametricCurve", &Dtool_ParametricCurve},
  {"CubicCurveseg", &Dtool_CubicCurveseg},
  {"ParametricCurveCollection", &Dtool_ParametricCurveCollection},
  {"CurveFitter", &Dtool_CurveFitter},
  {"PiecewiseCurve", &Dtool_PiecewiseCurve},
  {"HermiteCurve", &Dtool_HermiteCurve},
  {"NurbsCurveInterface", &Dtool_NurbsCurveInterface},
  {"NurbsCurve", &Dtool_NurbsCurve},
  {"NurbsCurveResult", &Dtool_NurbsCurveResult},
  {"NurbsCurveEvaluator", &Dtool_NurbsCurveEvaluator},
  {"NurbsSurfaceResult", &Dtool_NurbsSurfaceResult},
  {"NurbsSurfaceEvaluator", &Dtool_NurbsSurfaceEvaluator},
  {"RopeNode", &Dtool_RopeNode},
  {"SheetNode", &Dtool_SheetNode},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[5].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[6].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[7].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[8].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[9].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[10].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[11].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[12].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[13].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[14].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class ParametricCurve
 */
/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::is_valid(void) const
 */
static PyObject *Dtool_ParametricCurve_is_valid_3(PyObject *self, PyObject *) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::is_valid(void) const
  bool return_value = ((*(const ParametricCurve*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_is_valid_3_comment =
  "C++ Interface:\n"
  "is_valid(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns true if the curve is defined.  This base class function always\n"
  " * returns true; derived classes might override this to sometimes return\n"
  " * false.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_is_valid_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat ParametricCurve::get_max_t(void) const
 */
static PyObject *Dtool_ParametricCurve_get_max_t_4(PyObject *self, PyObject *) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat ParametricCurve::get_max_t(void) const
  PN_stdfloat return_value = ((*(const ParametricCurve*)local_this).get_max_t)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_max_t_4_comment =
  "C++ Interface:\n"
  "get_max_t(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the upper bound of t for the entire curve.  The curve is defined in\n"
  " * the range 0.0f <= t <= get_max_t().  This base class function always\n"
  " * returns 1.0f; derived classes might override this to return something else.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_get_max_t_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurve::set_curve_type(int type)
 */
static PyObject *Dtool_ParametricCurve_set_curve_type_5(PyObject *self, PyObject *arg) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.set_curve_type")) {
    return nullptr;
  }
  // 1-void ParametricCurve::set_curve_type(int type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_curve_type)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve_type(const ParametricCurve self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_set_curve_type_5_comment =
  "C++ Interface:\n"
  "set_curve_type(const ParametricCurve self, int type)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating the use to which the curve is intended to be put.\n"
  " * This flag is optional and only serves to provide a hint to the egg reader\n"
  " * and writer code; it has no effect on the curve's behavior.\n"
  " *\n"
  " * Setting the curve type also sets the num_dimensions to 3 or 1 according to\n"
  " * the type.\n"
  " *\n"
  " * THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_set_curve_type_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurve::get_curve_type(void) const
 */
static PyObject *Dtool_ParametricCurve_get_curve_type_6(PyObject *self, PyObject *) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-int ParametricCurve::get_curve_type(void) const
  int return_value = ((*(const ParametricCurve*)local_this).get_curve_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_curve_type_6_comment =
  "C++ Interface:\n"
  "get_curve_type(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating the use to which the curve is intended to be\n"
  " * put.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_get_curve_type_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurve::set_num_dimensions(int num)
 */
static PyObject *Dtool_ParametricCurve_set_num_dimensions_7(PyObject *self, PyObject *arg) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.set_num_dimensions")) {
    return nullptr;
  }
  // 1-void ParametricCurve::set_num_dimensions(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_dimensions)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_dimensions(const ParametricCurve self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_set_num_dimensions_7_comment =
  "C++ Interface:\n"
  "set_num_dimensions(const ParametricCurve self, int num)\n"
  "\n"
  "/**\n"
  " * Specifies the number of significant dimensions in the curve's vertices.\n"
  " * This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three\n"
  " * dimensions; time curves should always have one dimension.  This only serves\n"
  " * as a hint to the mopath editor, and also controls how the curve is written\n"
  " * out.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_set_num_dimensions_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurve::get_num_dimensions(void) const
 */
static PyObject *Dtool_ParametricCurve_get_num_dimensions_8(PyObject *self, PyObject *) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-int ParametricCurve::get_num_dimensions(void) const
  int return_value = ((*(const ParametricCurve*)local_this).get_num_dimensions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_num_dimensions_8_comment =
  "C++ Interface:\n"
  "get_num_dimensions(ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the number of significant dimensions in the curve's vertices, as\n"
  " * set by a previous call to set_num_dimensions().  This is only a hint as to\n"
  " * how the curve is intended to be used; the actual number of dimensions of\n"
  " * any curve is always three.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_get_num_dimensions_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat ParametricCurve::calc_length(void) const
 * PN_stdfloat ParametricCurve::calc_length(PN_stdfloat from, PN_stdfloat to) const
 */
static PyObject *Dtool_ParametricCurve_calc_length_9(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PN_stdfloat ParametricCurve::calc_length(void) const
      PN_stdfloat return_value = ((*(const ParametricCurve*)local_this).calc_length)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-PN_stdfloat ParametricCurve::calc_length(PN_stdfloat from, PN_stdfloat to) const
      float param1;
      float param2;
      static const char *keyword_list[] = {"from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:calc_length", (char **)keyword_list, &param1, &param2)) {
        PN_stdfloat return_value = ((*(const ParametricCurve*)local_this).calc_length)((PN_stdfloat)param1, (PN_stdfloat)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "calc_length() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_length(ParametricCurve self)\n"
      "calc_length(ParametricCurve self, float from, float to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_calc_length_9_comment =
  "C++ Interface:\n"
  "calc_length(ParametricCurve self)\n"
  "calc_length(ParametricCurve self, float from, float to)\n"
  "\n"
  "/**\n"
  " * Approximates the length of the entire curve to within a few decimal places.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Approximates the length of the curve segment from parametric time 'from' to\n"
  " * time 'to'.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_calc_length_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat ParametricCurve::find_length(PN_stdfloat start_t, PN_stdfloat length_offset) const
 */
static PyObject *Dtool_ParametricCurve_find_length_10(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-PN_stdfloat ParametricCurve::find_length(PN_stdfloat start_t, PN_stdfloat length_offset) const
  float param1;
  float param2;
  static const char *keyword_list[] = {"start_t", "length_offset", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:find_length", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const ParametricCurve*)local_this).find_length)((PN_stdfloat)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_length(ParametricCurve self, float start_t, float length_offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_find_length_10_comment =
  "C++ Interface:\n"
  "find_length(ParametricCurve self, float start_t, float length_offset)\n"
  "\n"
  "/**\n"
  " * Returns the parametric value corresponding to the indicated distance along\n"
  " * the curve from the starting parametric value.\n"
  " *\n"
  " * This is the inverse of calc_length(): rather than determining the length\n"
  " * along the curve between two parametric points, it determines the position\n"
  " * in parametric time of a point n units along the curve.\n"
  " *\n"
  " * The search distance must not be negative.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_find_length_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_point(PN_stdfloat t, LVecBase3 &point) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_point_11(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::get_point(PN_stdfloat t, LVecBase3 &point) const = 0
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:get_point", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_point", "LVecBase3f");
    }
    bool return_value = ((*(const ParametricCurve*)local_this).get_point)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(ParametricCurve self, float t, LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_point_11_comment =
  "C++ Interface:\n"
  "get_point(ParametricCurve self, float t, LVecBase3f point)\n";
#else
static const char *Dtool_ParametricCurve_get_point_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_tangent(PN_stdfloat t, LVecBase3 &tangent) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_tangent_12(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::get_tangent(PN_stdfloat t, LVecBase3 &tangent) const = 0
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "tangent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:get_tangent", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_tangent", "LVecBase3f");
    }
    bool return_value = ((*(const ParametricCurve*)local_this).get_tangent)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tangent(ParametricCurve self, float t, LVecBase3f tangent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_tangent_12_comment =
  "C++ Interface:\n"
  "get_tangent(ParametricCurve self, float t, LVecBase3f tangent)\n";
#else
static const char *Dtool_ParametricCurve_get_tangent_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_pt(PN_stdfloat t, LVecBase3 &point, LVecBase3 &tangent) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_pt_13(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::get_pt(PN_stdfloat t, LVecBase3 &point, LVecBase3 &tangent) const = 0
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"t", "point", "tangent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:get_pt", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_pt", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "ParametricCurve.get_pt", "LVecBase3f");
    }
    bool return_value = ((*(const ParametricCurve*)local_this).get_pt)((PN_stdfloat)param1, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pt(ParametricCurve self, float t, LVecBase3f point, LVecBase3f tangent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_pt_13_comment =
  "C++ Interface:\n"
  "get_pt(ParametricCurve self, float t, LVecBase3f point, LVecBase3f tangent)\n";
#else
static const char *Dtool_ParametricCurve_get_pt_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::get_2ndtangent(PN_stdfloat t, LVecBase3 &tangent2) const = 0
 */
static PyObject *Dtool_ParametricCurve_get_2ndtangent_14(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurve)) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::get_2ndtangent(PN_stdfloat t, LVecBase3 &tangent2) const = 0
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "tangent2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:get_2ndtangent", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.get_2ndtangent", "LVecBase3f");
    }
    bool return_value = ((*(const ParametricCurve*)local_this).get_2ndtangent)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_2ndtangent(ParametricCurve self, float t, LVecBase3f tangent2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_2ndtangent_14_comment =
  "C++ Interface:\n"
  "get_2ndtangent(ParametricCurve self, float t, LVecBase3f tangent2)\n";
#else
static const char *Dtool_ParametricCurve_get_2ndtangent_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::adjust_point(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz)
 */
static PyObject *Dtool_ParametricCurve_adjust_point_15(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.adjust_point")) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::adjust_point(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"t", "px", "py", "pz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    bool return_value = ((*local_this).adjust_point)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_point(const ParametricCurve self, float t, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_adjust_point_15_comment =
  "C++ Interface:\n"
  "adjust_point(const ParametricCurve self, float t, float px, float py, float pz)\n"
  "\n"
  "/**\n"
  " * Recomputes the curve such that it passes through the point (px, py, pz) at\n"
  " * time t, but keeps the same tangent value at that point.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_adjust_point_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::adjust_tangent(PN_stdfloat t, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
 */
static PyObject *Dtool_ParametricCurve_adjust_tangent_16(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.adjust_tangent")) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::adjust_tangent(PN_stdfloat t, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"t", "tx", "ty", "tz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_tangent", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    bool return_value = ((*local_this).adjust_tangent)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_tangent(const ParametricCurve self, float t, float tx, float ty, float tz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_adjust_tangent_16_comment =
  "C++ Interface:\n"
  "adjust_tangent(const ParametricCurve self, float t, float tx, float ty, float tz)\n"
  "\n"
  "/**\n"
  " * Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,\n"
  " * but keeps the same position at the point.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_adjust_tangent_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::adjust_pt(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
 */
static PyObject *Dtool_ParametricCurve_adjust_pt_17(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.adjust_pt")) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::adjust_pt(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  static const char *keyword_list[] = {"t", "px", "py", "pz", "tx", "ty", "tz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffff:adjust_pt", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    bool return_value = ((*local_this).adjust_pt)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_pt(const ParametricCurve self, float t, float px, float py, float pz, float tx, float ty, float tz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_adjust_pt_17_comment =
  "C++ Interface:\n"
  "adjust_pt(const ParametricCurve self, float t, float px, float py, float pz, float tx, float ty, float tz)\n"
  "\n"
  "/**\n"
  " * Recomputes the curve such that it passes through the point (px, py, pz)\n"
  " * with the tangent (tx, ty, tz).\n"
  " */";
#else
static const char *Dtool_ParametricCurve_adjust_pt_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::recompute(void)
 */
static PyObject *Dtool_ParametricCurve_recompute_18(PyObject *self, PyObject *) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.recompute")) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::recompute(void)
  bool return_value = ((*local_this).recompute)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_recompute_18_comment =
  "C++ Interface:\n"
  "recompute(const ParametricCurve self)\n"
  "\n"
  "/**\n"
  " * Recalculates the curve, if necessary.  Returns true if the resulting curve\n"
  " * is valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_recompute_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b)
 */
static PyObject *Dtool_ParametricCurve_stitch_19(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.stitch")) {
    return nullptr;
  }
  // 1-virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"a", "b", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:stitch", (char **)keyword_list, &param1, &param2)) {
    ParametricCurve const *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurve, 1, "ParametricCurve.stitch", true, true);
    ParametricCurve const *param2_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ParametricCurve, 2, "ParametricCurve.stitch", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      bool return_value = ((*local_this).stitch)(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stitch(const ParametricCurve self, const ParametricCurve a, const ParametricCurve b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_stitch_19_comment =
  "C++ Interface:\n"
  "stitch(const ParametricCurve self, const ParametricCurve a, const ParametricCurve b)\n"
  "\n"
  "/**\n"
  " * Regenerates this curve as one long curve: the first curve connected end-to-\n"
  " * end with the second one.  Either a or b may be the same as 'this'.\n"
  " *\n"
  " * Returns true if successful, false on failure or if the curve type does not\n"
  " * support stitching.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_stitch_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs = ::CS_default)
 * bool ParametricCurve::write_egg(std::ostream &out, Filename const &filename, CoordinateSystem cs)
 */
static PyObject *Dtool_ParametricCurve_write_egg_20(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurve, (void **)&local_this, "ParametricCurve.write_egg")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "filename")) {
        // 1-bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs)
        Filename arg_local;
        Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "ParametricCurve.write_egg", "Filename");
        }
        bool return_value = ((*local_this).write_egg)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"filename", "cs", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_egg", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ParametricCurve.write_egg", "Filename");
        }
        bool return_value = ((*local_this).write_egg)(*param1_this, (CoordinateSystem)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool ParametricCurve::write_egg(std::ostream &out, Filename const &filename, CoordinateSystem cs)
      PyObject *param1;
      PyObject *param2;
      int param3;
      static const char *keyword_list[] = {"out", "filename", "cs", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:write_egg", (char **)keyword_list, &param1, &param2, &param3)) {
        std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "ParametricCurve.write_egg", false, true);
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurve.write_egg", "Filename");
        }
        if (param1_this != nullptr) {
          bool return_value = ((*local_this).write_egg)(*param1_this, *param2_this, (CoordinateSystem)param3);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write_egg() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_egg(const ParametricCurve self, Filename filename)\n"
      "write_egg(const ParametricCurve self, Filename filename, int cs)\n"
      "write_egg(const ParametricCurve self, ostream out, const Filename filename, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_write_egg_20_comment =
  "C++ Interface:\n"
  "write_egg(const ParametricCurve self, Filename filename)\n"
  "write_egg(const ParametricCurve self, Filename filename, int cs)\n"
  "write_egg(const ParametricCurve self, ostream out, const Filename filename, int cs)\n"
  "\n"
  "/**\n"
  " * Writes an egg description of the nurbs curve to the specified output file.\n"
  " * Returns true if the file is successfully written.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes an egg description of the nurbs curve to the specified output\n"
  " * stream.  Returns true if the file is successfully written.\n"
  " */";
#else
static const char *Dtool_ParametricCurve_write_egg_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParametricCurve::get_class_type(void)
 */
static PyObject *Dtool_ParametricCurve_get_class_type_21(PyObject *, PyObject *) {
  // 1-static TypeHandle ParametricCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParametricCurve::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurve_get_class_type_21_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParametricCurve_get_class_type_21_comment = nullptr;
#endif

static int Dtool_Init_ParametricCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ParametricCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParametricCurve) {
    printf("ParametricCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParametricCurve *local_this = (ParametricCurve *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParametricCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParametricCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParametricCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParametricCurve*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CubicCurveseg
 */
/**
 * Python function wrapper for:
 * static TypeHandle CubicCurveseg::get_class_type(void)
 */
static PyObject *Dtool_CubicCurveseg_get_class_type_23(PyObject *, PyObject *) {
  // 1-static TypeHandle CubicCurveseg::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CubicCurveseg::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CubicCurveseg_get_class_type_23_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CubicCurveseg_get_class_type_23_comment = nullptr;
#endif

static int Dtool_Init_CubicCurveseg(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CubicCurveseg(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CubicCurveseg) {
    printf("CubicCurveseg ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CubicCurveseg *local_this = (CubicCurveseg *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CubicCurveseg) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CubicCurveseg(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CubicCurveseg) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CubicCurveseg*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CubicCurveseg*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParametricCurveCollection
 */
/**
 * Python function wrapper for:
 * void ParametricCurveCollection::add_curve(ParametricCurve *curve)
 * void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index)
 */
static PyObject *Dtool_ParametricCurveCollection_add_curve_27(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.add_curve")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "curve")) {
        // 1-void ParametricCurveCollection::add_curve(ParametricCurve *curve)
        ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.add_curve", false, true);
        if (arg_this != nullptr) {
          ((*local_this).add_curve)(arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"curve", "index", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:add_curve", (char **)keyword_list, &param1, &param2)) {
        ParametricCurve *param1_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.add_curve", false, true);
        if (param1_this != nullptr) {
          ((*local_this).add_curve)(param1_this, (int)param2);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_curve() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
      "add_curve(const ParametricCurveCollection self, ParametricCurve curve, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_add_curve_27_comment =
  "C++ Interface:\n"
  "add_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
  "add_curve(const ParametricCurveCollection self, ParametricCurve curve, int index)\n"
  "\n"
  "/**\n"
  " * Adds a new ParametricCurve to the collection at the indicated index.\n"
  " * @deprecated Use insert_curve(index, curve) instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new ParametricCurve to the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_add_curve_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::insert_curve(std::size_t index, ParametricCurve *curve)
 */
static PyObject *Dtool_ParametricCurveCollection_insert_curve_28(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.insert_curve")) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::insert_curve(std::size_t index, ParametricCurve *curve)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "curve", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_curve", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ParametricCurve *param2_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ParametricCurve, 2, "ParametricCurveCollection.insert_curve", false, true);
    if (param2_this != nullptr) {
      ((*local_this).insert_curve)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_curve(const ParametricCurveCollection self, int index, ParametricCurve curve)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_insert_curve_28_comment =
  "C++ Interface:\n"
  "insert_curve(const ParametricCurveCollection self, int index, ParametricCurve curve)\n"
  "\n"
  "/**\n"
  " * Adds a new ParametricCurve to the collection at the indicated index.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_insert_curve_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurveCollection::add_curves(PandaNode *node)
 */
static PyObject *Dtool_ParametricCurveCollection_add_curves_29(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.add_curves")) {
    return nullptr;
  }
  // 1-int ParametricCurveCollection::add_curves(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "ParametricCurveCollection.add_curves", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).add_curves)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_curves(const ParametricCurveCollection self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_add_curves_29_comment =
  "C++ Interface:\n"
  "add_curves(const ParametricCurveCollection self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds all the curves found in the scene graph rooted at the given node.\n"
  " * Returns the number of curves found.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_add_curves_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
 * void ParametricCurveCollection::remove_curve(std::size_t index)
 */
static PyObject *Dtool_ParametricCurveCollection_remove_curve_30(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.remove_curve")) {
    return nullptr;
  }
  {
    // -2 bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
    ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.remove_curve", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).remove_curve)(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 void ParametricCurveCollection::remove_curve(std::size_t index)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      ((*local_this).remove_curve)(arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: bool ParametricCurveCollection::remove_curve(ParametricCurve *curve)
  // No coercion possible: void ParametricCurveCollection::remove_curve(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
      "remove_curve(const ParametricCurveCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_remove_curve_30_comment =
  "C++ Interface:\n"
  "remove_curve(const ParametricCurveCollection self, ParametricCurve curve)\n"
  "remove_curve(const ParametricCurveCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated ParametricCurve from the collection.  Returns true if\n"
  " * the curve was removed, false if it was not a member of the collection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the indicated ParametricCurve from the collection, by its index\n"
  " * number.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_remove_curve_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::set_curve(std::size_t index, ParametricCurve *curve)
 */
static PyObject *Dtool_ParametricCurveCollection_set_curve_31(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.set_curve")) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::set_curve(std::size_t index, ParametricCurve *curve)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "curve", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_curve", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ParametricCurve *param2_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ParametricCurve, 2, "ParametricCurveCollection.set_curve", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_curve)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve(const ParametricCurveCollection self, int index, ParametricCurve curve)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_set_curve_31_comment =
  "C++ Interface:\n"
  "set_curve(const ParametricCurveCollection self, int index, ParametricCurve curve)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated ParametricCurve from the collection, by its index\n"
  " * number.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_set_curve_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const
 */
static PyObject *Dtool_ParametricCurveCollection_has_curve_32(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const
  ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 1, "ParametricCurveCollection.has_curve", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const ParametricCurveCollection*)local_this).has_curve)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_curve(ParametricCurveCollection self, ParametricCurve curve)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_has_curve_32_comment =
  "C++ Interface:\n"
  "has_curve(ParametricCurveCollection self, ParametricCurve curve)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated ParametricCurve appears in this collection,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_has_curve_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::clear(void)
 */
static PyObject *Dtool_ParametricCurveCollection_clear_33(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.clear")) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_clear_33_comment =
  "C++ Interface:\n"
  "clear(const ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all ParametricCurves from the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_clear_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::clear_timewarps(void)
 */
static PyObject *Dtool_ParametricCurveCollection_clear_timewarps_34(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.clear_timewarps")) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::clear_timewarps(void)
  ((*local_this).clear_timewarps)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_clear_timewarps_34_comment =
  "C++ Interface:\n"
  "clear_timewarps(const ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all the timewarp curves from the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_clear_timewarps_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ParametricCurveCollection::get_num_curves(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_num_curves_35(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-inline int ParametricCurveCollection::get_num_curves(void) const
  int return_value = ((*(const ParametricCurveCollection*)local_this).get_num_curves)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_num_curves_35_comment =
  "C++ Interface:\n"
  "get_num_curves(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of ParametricCurves in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_num_curves_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_curve_36(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_curve)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_curve(ParametricCurveCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_curve_36_comment =
  "C++ Interface:\n"
  "get_curve(ParametricCurveCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth ParametricCurve in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_curve_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_xyz_curve_38(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_xyz_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_xyz_curve_38_comment =
  "C++ Interface:\n"
  "get_xyz_curve(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the first XYZ curve in the collection, if any, or NULL if there are\n"
  " * none.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_xyz_curve_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_hpr_curve_39(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_hpr_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_hpr_curve_39_comment =
  "C++ Interface:\n"
  "get_hpr_curve(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the first HPR curve in the collection, if any, or NULL if there are\n"
  " * none.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_hpr_curve_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_default_curve_40(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_default_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_default_curve_40_comment =
  "C++ Interface:\n"
  "get_default_curve(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * If there is an XYZ curve in the collection, returns it; otherwise, returns\n"
  " * the first curve whose type is unspecified.  Returns NULL if no curve meets\n"
  " * the criteria.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_default_curve_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ParametricCurveCollection::get_num_timewarps(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_num_timewarps_41(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-int ParametricCurveCollection::get_num_timewarps(void) const
  int return_value = ((*(const ParametricCurveCollection*)local_this).get_num_timewarps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_num_timewarps_41_comment =
  "C++ Interface:\n"
  "get_num_timewarps(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of timewarp curves in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_num_timewarps_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_timewarp_curve_42(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_timewarp_curve)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_timewarp_curve(ParametricCurveCollection self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_timewarp_curve_42_comment =
  "C++ Interface:\n"
  "get_timewarp_curve(ParametricCurveCollection self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth timewarp curve in the collection.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_timewarp_curve_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const
 */
static PyObject *Dtool_ParametricCurveCollection_get_max_t_44(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const
  PN_stdfloat return_value = ((*(const ParametricCurveCollection*)local_this).get_max_t)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_get_max_t_44_comment =
  "C++ Interface:\n"
  "get_max_t(ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum T value associated with the *last* curve in the\n"
  " * collection.  Normally, this will be either the XYZ or HPR curve, or a\n"
  " * timewarp curve.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_get_max_t_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::make_even(PN_stdfloat max_t, PN_stdfloat segments_per_unit)
 */
static PyObject *Dtool_ParametricCurveCollection_make_even_54(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.make_even")) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::make_even(PN_stdfloat max_t, PN_stdfloat segments_per_unit)
  float param1;
  float param2;
  static const char *keyword_list[] = {"max_t", "segments_per_unit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:make_even", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).make_even)((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_even(const ParametricCurveCollection self, float max_t, float segments_per_unit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_make_even_54_comment =
  "C++ Interface:\n"
  "make_even(const ParametricCurveCollection self, float max_t, float segments_per_unit)\n"
  "\n"
  "/**\n"
  " * Discards all existing timewarp curves and recomputes a new timewarp curve\n"
  " * that maps distance along the curve to parametric time, so that the distance\n"
  " * between any two points in parametric time is proportional to the\n"
  " * approximate distance of those same two points along the XYZ curve.\n"
  " *\n"
  " * segments_per_unit represents the number of segments to take per each unit\n"
  " * of parametric time of the original XYZ curve.\n"
  " *\n"
  " * The new timewarp curve (and thus, the apparent range of the collection)\n"
  " * will range from 0 to max_t.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_make_even_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::face_forward(PN_stdfloat segments_per_unit)
 */
static PyObject *Dtool_ParametricCurveCollection_face_forward_55(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.face_forward")) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::face_forward(PN_stdfloat segments_per_unit)
  if (PyNumber_Check(arg)) {
    ((*local_this).face_forward)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "face_forward(const ParametricCurveCollection self, float segments_per_unit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_face_forward_55_comment =
  "C++ Interface:\n"
  "face_forward(const ParametricCurveCollection self, float segments_per_unit)\n"
  "\n"
  "/**\n"
  " * Discards the existing HPR curve and generates a new one that looks in the\n"
  " * direction of travel along the XYZ curve, based on the XYZ curve's tangent\n"
  " * at each point.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_face_forward_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::reset_max_t(PN_stdfloat max_t)
 */
static PyObject *Dtool_ParametricCurveCollection_reset_max_t_56(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.reset_max_t")) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::reset_max_t(PN_stdfloat max_t)
  if (PyNumber_Check(arg)) {
    ((*local_this).reset_max_t)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_max_t(const ParametricCurveCollection self, float max_t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_reset_max_t_56_comment =
  "C++ Interface:\n"
  "reset_max_t(const ParametricCurveCollection self, float max_t)\n"
  "\n"
  "/**\n"
  " * Adjusts the apparent length of the curve by applying a new timewarp that\n"
  " * maps the range [0..max_t] to the range [0..get_max_t()].  After this call,\n"
  " * the curve collection will contain one more timewarp curve, and get_max_t()\n"
  " * will return the given max_t value.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_reset_max_t_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs = ::CS_default) const
 * bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &xyz, LVecBase3 &hpr) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_57(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs) const
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"t", "result", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:evaluate", (char **)keyword_list, &param1, &param2)) {
        LMatrix4f param2_local;
        LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.evaluate", "LMatrix4f");
        }
        bool return_value = ((*(const ParametricCurveCollection*)local_this).evaluate)((PN_stdfloat)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &xyz, LVecBase3 &hpr) const
        float param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"t", "xyz", "hpr", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LVecBase3 *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "ParametricCurveCollection.evaluate", false, false);
          LVecBase3 *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "ParametricCurveCollection.evaluate", false, false);
          if (param2_this != nullptr && param3_this != nullptr) {
            bool return_value = ((*(const ParametricCurveCollection*)local_this).evaluate)((PN_stdfloat)param1, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs) const
        float param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"t", "result", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOi:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LMatrix4 *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LMatrix4f, 2, "ParametricCurveCollection.evaluate", false, false);
          if (param2_this != nullptr) {
            bool return_value = ((*(const ParametricCurveCollection*)local_this).evaluate)((PN_stdfloat)param1, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &xyz, LVecBase3 &hpr) const
        float param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"t", "xyz", "hpr", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LVecBase3f param2_local;
          LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param2_this != nullptr) && (param3_this != nullptr)) {
            bool return_value = ((*(const ParametricCurveCollection*)local_this).evaluate)((PN_stdfloat)param1, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs) const
        float param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"t", "result", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fOi:evaluate", (char **)keyword_list, &param1, &param2, &param3)) {
          LMatrix4f param2_local;
          LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
          if ((param2_this != nullptr)) {
            bool return_value = ((*(const ParametricCurveCollection*)local_this).evaluate)((PN_stdfloat)param1, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "evaluate() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate(ParametricCurveCollection self, float t, LMatrix4f result)\n"
      "evaluate(ParametricCurveCollection self, float t, LVecBase3f xyz, LVecBase3f hpr)\n"
      "evaluate(ParametricCurveCollection self, float t, LMatrix4f result, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_57_comment =
  "C++ Interface:\n"
  "evaluate(ParametricCurveCollection self, float t, LMatrix4f result)\n"
  "evaluate(ParametricCurveCollection self, float t, LVecBase3f xyz, LVecBase3f hpr)\n"
  "evaluate(ParametricCurveCollection self, float t, LMatrix4f result, int cs)\n"
  "\n"
  "/**\n"
  " * Computes the position and rotation represented by the first XYZ and HPR\n"
  " * curves in the collection at the given point t, after t has been modified by\n"
  " * all the timewarp curves in the collection applied in sequence, from back to\n"
  " * front.\n"
  " *\n"
  " * Returns true if the point is valid (i.e.  t is within the bounds indicated\n"
  " * by all the timewarp curves and within the bounds of the curves themselves),\n"
  " * or false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the transform matrix representing translation to the position\n"
  " * indicated by the first XYZ curve in the collection and the rotation\n"
  " * indicated by the first HPR curve in the collection, after t has been\n"
  " * modified by all the timewarp curves in the collection applied in sequence,\n"
  " * from back to front.\n"
  " *\n"
  " * Returns true if the point is valid (i.e.  t is within the bounds indicated\n"
  " * by all the timewarp curves and within the bounds of the curves themselves),\n"
  " * or false otherwise.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat ParametricCurveCollection::evaluate_t(PN_stdfloat t) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_t_58(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-PN_stdfloat ParametricCurveCollection::evaluate_t(PN_stdfloat t) const
  if (PyNumber_Check(arg)) {
    PN_stdfloat return_value = ((*(const ParametricCurveCollection*)local_this).evaluate_t)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate_t(ParametricCurveCollection self, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_t_58_comment =
  "C++ Interface:\n"
  "evaluate_t(ParametricCurveCollection self, float t)\n"
  "\n"
  "/**\n"
  " * Determines the value of t that should be passed to the XYZ and HPR curves,\n"
  " * after applying the given value of t to all the timewarps.  Return -1.0f if\n"
  " * the value of t exceeds one of the timewarps' ranges.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_t_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ParametricCurveCollection::evaluate_xyz(PN_stdfloat t, LVecBase3 &xyz) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_xyz_59(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-inline bool ParametricCurveCollection::evaluate_xyz(PN_stdfloat t, LVecBase3 &xyz) const
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "xyz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:evaluate_xyz", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.evaluate_xyz", "LVecBase3f");
    }
    bool return_value = ((*(const ParametricCurveCollection*)local_this).evaluate_xyz)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate_xyz(ParametricCurveCollection self, float t, LVecBase3f xyz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_xyz_59_comment =
  "C++ Interface:\n"
  "evaluate_xyz(ParametricCurveCollection self, float t, LVecBase3f xyz)\n"
  "\n"
  "/**\n"
  " * Computes only the XYZ part of the curves.  See evaluate().\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_xyz_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ParametricCurveCollection::evaluate_hpr(PN_stdfloat t, LVecBase3 &hpr) const
 */
static PyObject *Dtool_ParametricCurveCollection_evaluate_hpr_60(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-inline bool ParametricCurveCollection::evaluate_hpr(PN_stdfloat t, LVecBase3 &hpr) const
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "hpr", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:evaluate_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.evaluate_hpr", "LVecBase3f");
    }
    bool return_value = ((*(const ParametricCurveCollection*)local_this).evaluate_hpr)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate_hpr(ParametricCurveCollection self, float t, LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_evaluate_hpr_60_comment =
  "C++ Interface:\n"
  "evaluate_hpr(ParametricCurveCollection self, float t, LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Computes only the HPR part of the curves.  See evaluate().\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_evaluate_hpr_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, LVecBase3 const &xyz)
 * inline bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_ParametricCurveCollection_adjust_xyz_61(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.adjust_xyz")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, LVecBase3 const &xyz)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"t", "xyz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:adjust_xyz", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.adjust_xyz", "LVecBase3f");
        }
        bool return_value = ((*local_this).adjust_xyz)((PN_stdfloat)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"t", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_xyz", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = ((*local_this).adjust_xyz)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "adjust_xyz() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_xyz(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
      "adjust_xyz(const ParametricCurveCollection self, float t, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_adjust_xyz_61_comment =
  "C++ Interface:\n"
  "adjust_xyz(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
  "adjust_xyz(const ParametricCurveCollection self, float t, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Adjust the XYZ curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjust the XYZ curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_adjust_xyz_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, LVecBase3 const &xyz)
 * inline bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_ParametricCurveCollection_adjust_hpr_62(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.adjust_hpr")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, LVecBase3 const &xyz)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"t", "xyz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:adjust_hpr", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.adjust_hpr", "LVecBase3f");
        }
        bool return_value = ((*local_this).adjust_hpr)((PN_stdfloat)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"t", "h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:adjust_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = ((*local_this).adjust_hpr)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "adjust_hpr() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust_hpr(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
      "adjust_hpr(const ParametricCurveCollection self, float t, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_adjust_hpr_62_comment =
  "C++ Interface:\n"
  "adjust_hpr(const ParametricCurveCollection self, float t, const LVecBase3f xyz)\n"
  "adjust_hpr(const ParametricCurveCollection self, float t, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Adjust the HPR curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjust the HPR curve at the indicated time to the new value.  The curve\n"
  " * shape will change correspondingly.  Returns true if successful, false if\n"
  " * unable to make the adjustment for some reason.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_adjust_hpr_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::recompute(void)
 */
static PyObject *Dtool_ParametricCurveCollection_recompute_63(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.recompute")) {
    return nullptr;
  }
  // 1-bool ParametricCurveCollection::recompute(void)
  bool return_value = ((*local_this).recompute)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_recompute_63_comment =
  "C++ Interface:\n"
  "recompute(const ParametricCurveCollection self)\n"
  "\n"
  "/**\n"
  " * Ensures all the curves are freshly computed and up-to-date.  Returns true\n"
  " * if everything is valid, false if at least one curve is incorrect.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_recompute_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b)
 */
static PyObject *Dtool_ParametricCurveCollection_stitch_64(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.stitch")) {
    return nullptr;
  }
  // 1-bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"a", "b", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:stitch", (char **)keyword_list, &param1, &param2)) {
    ParametricCurveCollection const *param1_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurveCollection, 1, "ParametricCurveCollection.stitch", true, true);
    ParametricCurveCollection const *param2_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ParametricCurveCollection, 2, "ParametricCurveCollection.stitch", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      bool return_value = ((*local_this).stitch)(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stitch(const ParametricCurveCollection self, const ParametricCurveCollection a, const ParametricCurveCollection b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_stitch_64_comment =
  "C++ Interface:\n"
  "stitch(const ParametricCurveCollection self, const ParametricCurveCollection a, const ParametricCurveCollection b)\n"
  "\n"
  "/**\n"
  " * Regenerates this curve as one long curve: the first curve connected end-to-\n"
  " * end with the second one.  Either a or b may be the same as 'this'.  This\n"
  " * will lose any timewarps on the input curves.\n"
  " *\n"
  " * Returns true if successful, false on failure.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_stitch_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_ParametricCurveCollection_output_65(PyObject *self, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ParametricCurveCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ParametricCurveCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ParametricCurveCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_output_65_comment =
  "C++ Interface:\n"
  "output(ParametricCurveCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the ParametricCurveCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_output_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ParametricCurveCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_ParametricCurveCollection_write_66(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParametricCurveCollection)) {
    return nullptr;
  }
  // 1-void ParametricCurveCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "ParametricCurveCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const ParametricCurveCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ParametricCurveCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_write_66_comment =
  "C++ Interface:\n"
  "write(ParametricCurveCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the ParametricCurveCollection\n"
  " * to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_write_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs = ::CS_default)
 * bool ParametricCurveCollection::write_egg(std::ostream &out, Filename const &filename, CoordinateSystem cs)
 */
static PyObject *Dtool_ParametricCurveCollection_write_egg_67(PyObject *self, PyObject *args, PyObject *kwds) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.write_egg")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "filename")) {
        // 1-bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs)
        Filename arg_local;
        Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "ParametricCurveCollection.write_egg", "Filename");
        }
        bool return_value = ((*local_this).write_egg)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"filename", "cs", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_egg", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ParametricCurveCollection.write_egg", "Filename");
        }
        bool return_value = ((*local_this).write_egg)(*param1_this, (CoordinateSystem)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool ParametricCurveCollection::write_egg(std::ostream &out, Filename const &filename, CoordinateSystem cs)
      PyObject *param1;
      PyObject *param2;
      int param3;
      static const char *keyword_list[] = {"out", "filename", "cs", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:write_egg", (char **)keyword_list, &param1, &param2, &param3)) {
        std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "ParametricCurveCollection.write_egg", false, true);
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "ParametricCurveCollection.write_egg", "Filename");
        }
        if (param1_this != nullptr) {
          bool return_value = ((*local_this).write_egg)(*param1_this, *param2_this, (CoordinateSystem)param3);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "write_egg() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_egg(const ParametricCurveCollection self, Filename filename)\n"
      "write_egg(const ParametricCurveCollection self, Filename filename, int cs)\n"
      "write_egg(const ParametricCurveCollection self, ostream out, const Filename filename, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParametricCurveCollection_write_egg_67_comment =
  "C++ Interface:\n"
  "write_egg(const ParametricCurveCollection self, Filename filename)\n"
  "write_egg(const ParametricCurveCollection self, Filename filename, int cs)\n"
  "write_egg(const ParametricCurveCollection self, ostream out, const Filename filename, int cs)\n"
  "\n"
  "/**\n"
  " * Writes an egg description of all the nurbs curves in the collection to the\n"
  " * specified output file.  Returns true if the file is successfully written.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes an egg description of all the nurbs curves in the collection to the\n"
  " * specified output stream.  Returns true if the file is successfully written.\n"
  " */";
#else
static const char *Dtool_ParametricCurveCollection_write_egg_67_comment = nullptr;
#endif

/**
 * sequence length function for property ParametricCurveCollection::curves
 */
static Py_ssize_t Dtool_ParametricCurveCollection_curves_Len(PyObject *self) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_curves)();
}

/**
 * sequence getter for property ParametricCurveCollection::curves
 */
static PyObject *Dtool_ParametricCurveCollection_curves_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_curves)()) {
    PyErr_SetString(PyExc_IndexError, "ParametricCurveCollection.curves[] index out of range");
    return nullptr;
  }
  // 1-inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_curve)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_curve(ParametricCurveCollection self, index)\n");
  }
}

static int Dtool_ParametricCurveCollection_curves_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParametricCurveCollection, (void **)&local_this, "ParametricCurveCollection.curves")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_curves)()) {
    PyErr_SetString(PyExc_IndexError, "ParametricCurveCollection.curves[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_curve(index);
    return 0;
  }
  // 1-void ParametricCurveCollection::set_curve(std::size_t index, ParametricCurve *curve)
  ParametricCurve *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 2, "ParametricCurveCollection.set_curve", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_curve)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_curve(const ParametricCurveCollection self, index, ParametricCurve curve)\n");
  }
  return -1;
}

static PyObject *Dtool_ParametricCurveCollection_curves_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "ParametricCurveCollection.curves");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ParametricCurveCollection_curves_Len;
    wrap->_getitem_func = &Dtool_ParametricCurveCollection_curves_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_ParametricCurveCollection_curves_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_ParametricCurveCollection_xyz_curve_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }

  // 1-ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_xyz_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ParametricCurveCollection_hpr_curve_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }

  // 1-ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_hpr_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_ParametricCurveCollection_default_curve_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }

  // 1-ParametricCurve *ParametricCurveCollection::get_default_curve(void) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_default_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * sequence length function for property ParametricCurveCollection::timewarp_curves
 */
static Py_ssize_t Dtool_ParametricCurveCollection_timewarp_curves_Len(PyObject *self) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_timewarps)();
}

/**
 * sequence getter for property ParametricCurveCollection::timewarp_curves
 */
static PyObject *Dtool_ParametricCurveCollection_timewarp_curves_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_timewarps)()) {
    PyErr_SetString(PyExc_IndexError, "ParametricCurveCollection.timewarp_curves[] index out of range");
    return nullptr;
  }
  // 1-ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const
  ParametricCurve *return_value = ((*(const ParametricCurveCollection*)local_this).get_timewarp_curve)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ParametricCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_timewarp_curve(ParametricCurveCollection self, index)\n");
  }
}

static PyObject *Dtool_ParametricCurveCollection_timewarp_curves_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ParametricCurveCollection.timewarp_curves");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ParametricCurveCollection_timewarp_curves_Len;
    wrap->_getitem_func = &Dtool_ParametricCurveCollection_timewarp_curves_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_ParametricCurveCollection_max_t_Getter(PyObject *self, void *) {
  const ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const
  PN_stdfloat return_value = ((*(const ParametricCurveCollection*)local_this).get_max_t)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * ParametricCurveCollection::ParametricCurveCollection(void)
 * inline ParametricCurveCollection::ParametricCurveCollection(ParametricCurveCollection const &) = default
 */
static int Dtool_Init_ParametricCurveCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ParametricCurveCollection() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-ParametricCurveCollection::ParametricCurveCollection(void)
      ParametricCurveCollection *return_value = new ParametricCurveCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParametricCurveCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ParametricCurveCollection::ParametricCurveCollection(ParametricCurveCollection const &) = default
      ParametricCurveCollection const *arg_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurveCollection, 0, "ParametricCurveCollection.ParametricCurveCollection", true, true);
      if (arg_this != nullptr) {
        ParametricCurveCollection *return_value = new ParametricCurveCollection(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParametricCurveCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ParametricCurveCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParametricCurveCollection()\n"
      "ParametricCurveCollection(const ParametricCurveCollection param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ParametricCurveCollection_get_curves(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_curves)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ParametricCurveCollection_get_curve_36(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ParametricCurveCollection_get_timewarp_curves(PyObject *self, PyObject *) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_timewarps)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ParametricCurveCollection_get_timewarp_curve_42(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ParametricCurveCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParametricCurveCollection) {
    printf("ParametricCurveCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParametricCurveCollection *local_this = (ParametricCurveCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParametricCurveCollection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParametricCurveCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParametricCurveCollection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParametricCurveCollection*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CurveFitter
 */
/**
 * Python function wrapper for:
 * void CurveFitter::reset(void)
 */
static PyObject *Dtool_CurveFitter_reset_71(PyObject *self, PyObject *) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.reset")) {
    return nullptr;
  }
  // 1-void CurveFitter::reset(void)
  ((*local_this).reset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_reset_71_comment =
  "C++ Interface:\n"
  "reset(const CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Removes all the data points previously added to the CurveFitter, and\n"
  " * initializes it for a new curve.\n"
  " */";
#else
static const char *Dtool_CurveFitter_reset_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::add_xyz(PN_stdfloat t, LVecBase3 const &xyz)
 */
static PyObject *Dtool_CurveFitter_add_xyz_72(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.add_xyz")) {
    return nullptr;
  }
  // 1-void CurveFitter::add_xyz(PN_stdfloat t, LVecBase3 const &xyz)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "xyz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:add_xyz", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CurveFitter.add_xyz", "LVecBase3f");
    }
    ((*local_this).add_xyz)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_xyz(const CurveFitter self, float t, const LVecBase3f xyz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_add_xyz_72_comment =
  "C++ Interface:\n"
  "add_xyz(const CurveFitter self, float t, const LVecBase3f xyz)\n"
  "\n"
  "/**\n"
  " * Adds a single sample xyz.\n"
  " */";
#else
static const char *Dtool_CurveFitter_add_xyz_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::add_hpr(PN_stdfloat t, LVecBase3 const &hpr)
 */
static PyObject *Dtool_CurveFitter_add_hpr_73(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.add_hpr")) {
    return nullptr;
  }
  // 1-void CurveFitter::add_hpr(PN_stdfloat t, LVecBase3 const &hpr)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "hpr", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:add_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CurveFitter.add_hpr", "LVecBase3f");
    }
    ((*local_this).add_hpr)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hpr(const CurveFitter self, float t, const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_add_hpr_73_comment =
  "C++ Interface:\n"
  "add_hpr(const CurveFitter self, float t, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Adds a single sample hpr.\n"
  " */";
#else
static const char *Dtool_CurveFitter_add_hpr_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::add_xyz_hpr(PN_stdfloat t, LVecBase3 const &xyz, LVecBase3 const &hpr)
 */
static PyObject *Dtool_CurveFitter_add_xyz_hpr_74(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.add_xyz_hpr")) {
    return nullptr;
  }
  // 1-void CurveFitter::add_xyz_hpr(PN_stdfloat t, LVecBase3 const &xyz, LVecBase3 const &hpr)
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"t", "xyz", "hpr", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:add_xyz_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CurveFitter.add_xyz_hpr", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "CurveFitter.add_xyz_hpr", "LVecBase3f");
    }
    ((*local_this).add_xyz_hpr)((PN_stdfloat)param1, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_xyz_hpr(const CurveFitter self, float t, const LVecBase3f xyz, const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_add_xyz_hpr_74_comment =
  "C++ Interface:\n"
  "add_xyz_hpr(const CurveFitter self, float t, const LVecBase3f xyz, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Adds a single sample xyz & hpr simultaneously.\n"
  " */";
#else
static const char *Dtool_CurveFitter_add_xyz_hpr_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CurveFitter::get_num_samples(void) const
 */
static PyObject *Dtool_CurveFitter_get_num_samples_75(PyObject *self, PyObject *) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-int CurveFitter::get_num_samples(void) const
  int return_value = ((*(const CurveFitter*)local_this).get_num_samples)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_num_samples_75_comment =
  "C++ Interface:\n"
  "get_num_samples(CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Returns the number of sample points that have been added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_num_samples_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat CurveFitter::get_sample_t(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_t_76(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-PN_stdfloat CurveFitter::get_sample_t(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const CurveFitter*)local_this).get_sample_t)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_t(CurveFitter self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_t_76_comment =
  "C++ Interface:\n"
  "get_sample_t(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the parametric value of the nth sample added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_t_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 CurveFitter::get_sample_xyz(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_xyz_77(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-LVecBase3 CurveFitter::get_sample_xyz(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3(((*(const CurveFitter*)local_this).get_sample_xyz)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_xyz(CurveFitter self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_xyz_77_comment =
  "C++ Interface:\n"
  "get_sample_xyz(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the point in space of the nth sample added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_xyz_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 CurveFitter::get_sample_hpr(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_hpr_78(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-LVecBase3 CurveFitter::get_sample_hpr(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3(((*(const CurveFitter*)local_this).get_sample_hpr)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_hpr(CurveFitter self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_hpr_78_comment =
  "C++ Interface:\n"
  "get_sample_hpr(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the orientation of the nth sample added.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_hpr_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 CurveFitter::get_sample_tangent(int n) const
 */
static PyObject *Dtool_CurveFitter_get_sample_tangent_79(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-LVecBase3 CurveFitter::get_sample_tangent(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3(((*(const CurveFitter*)local_this).get_sample_tangent)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_tangent(CurveFitter self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_sample_tangent_79_comment =
  "C++ Interface:\n"
  "get_sample_tangent(CurveFitter self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the tangent associated with the nth sample added.  This is only\n"
  " * meaningful if compute_tangents() has already been called.\n"
  " */";
#else
static const char *Dtool_CurveFitter_get_sample_tangent_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::remove_samples(int begin, int end)
 */
static PyObject *Dtool_CurveFitter_remove_samples_80(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.remove_samples")) {
    return nullptr;
  }
  // 1-void CurveFitter::remove_samples(int begin, int end)
  int param1;
  int param2;
  static const char *keyword_list[] = {"begin", "end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:remove_samples", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).remove_samples)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_samples(const CurveFitter self, int begin, int end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_remove_samples_80_comment =
  "C++ Interface:\n"
  "remove_samples(const CurveFitter self, int begin, int end)\n"
  "\n"
  "/**\n"
  " * Eliminates all samples from index begin, up to but not including index end,\n"
  " * from the database.\n"
  " */";
#else
static const char *Dtool_CurveFitter_remove_samples_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::sample(ParametricCurveCollection *curves, int count)
 */
static PyObject *Dtool_CurveFitter_sample_81(PyObject *self, PyObject *args, PyObject *kwds) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.sample")) {
    return nullptr;
  }
  // 1-void CurveFitter::sample(ParametricCurveCollection *curves, int count)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"curves", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:sample", (char **)keyword_list, &param1, &param2)) {
    ParametricCurveCollection *param1_this = (ParametricCurveCollection *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ParametricCurveCollection, 1, "CurveFitter.sample", false, true);
    if (param1_this != nullptr) {
      ((*local_this).sample)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sample(const CurveFitter self, ParametricCurveCollection curves, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_sample_81_comment =
  "C++ Interface:\n"
  "sample(const CurveFitter self, ParametricCurveCollection curves, int count)\n"
  "\n"
  "/**\n"
  " * Generates a series of data points by sampling the given curve (or xyz/hpr\n"
  " * curves) the indicated number of times.  The sampling is made evenly in\n"
  " * parametric time, and then the timewarps, if any, are applied.\n"
  " */";
#else
static const char *Dtool_CurveFitter_sample_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::wrap_hpr(void)
 */
static PyObject *Dtool_CurveFitter_wrap_hpr_82(PyObject *self, PyObject *) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.wrap_hpr")) {
    return nullptr;
  }
  // 1-void CurveFitter::wrap_hpr(void)
  ((*local_this).wrap_hpr)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_wrap_hpr_82_comment =
  "C++ Interface:\n"
  "wrap_hpr(const CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Resets each HPR data point so that the maximum delta between any two\n"
  " * consecutive points is 180 degrees, which should prevent incorrect HPR\n"
  " * wrapping.\n"
  " */";
#else
static const char *Dtool_CurveFitter_wrap_hpr_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::sort_points(void)
 */
static PyObject *Dtool_CurveFitter_sort_points_83(PyObject *self, PyObject *) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.sort_points")) {
    return nullptr;
  }
  // 1-void CurveFitter::sort_points(void)
  ((*local_this).sort_points)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_sort_points_83_comment =
  "C++ Interface:\n"
  "sort_points(const CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Sorts all the data points in order by parametric time, in case they were\n"
  " * added in an incorrect order.\n"
  " */";
#else
static const char *Dtool_CurveFitter_sort_points_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::desample(PN_stdfloat factor)
 */
static PyObject *Dtool_CurveFitter_desample_84(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.desample")) {
    return nullptr;
  }
  // 1-void CurveFitter::desample(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).desample)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "desample(const CurveFitter self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_desample_84_comment =
  "C++ Interface:\n"
  "desample(const CurveFitter self, float factor)\n"
  "\n"
  "/**\n"
  " * Removes sample points in order to reduce the complexity of a sampled curve.\n"
  " * Keeps one out of every factor samples.  Also keeps the first and the last\n"
  " * samples.\n"
  " */";
#else
static const char *Dtool_CurveFitter_desample_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::compute_tangents(PN_stdfloat scale)
 */
static PyObject *Dtool_CurveFitter_compute_tangents_85(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CurveFitter, (void **)&local_this, "CurveFitter.compute_tangents")) {
    return nullptr;
  }
  // 1-void CurveFitter::compute_tangents(PN_stdfloat scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).compute_tangents)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_tangents(const CurveFitter self, float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_compute_tangents_85_comment =
  "C++ Interface:\n"
  "compute_tangents(const CurveFitter self, float scale)\n"
  "\n"
  "/**\n"
  " * Once a set of points has been built, and prior to calling MakeHermite() or\n"
  " * MakeNurbs(), ComputeTangents() must be called to set up the tangents\n"
  " * correctly (unless the tangents were defined as the points were added).\n"
  " */";
#else
static const char *Dtool_CurveFitter_compute_tangents_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< ParametricCurveCollection > CurveFitter::make_hermite(void) const
 */
static PyObject *Dtool_CurveFitter_make_hermite_86(PyObject *self, PyObject *) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-PointerTo< ParametricCurveCollection > CurveFitter::make_hermite(void) const
  PointerTo< ParametricCurveCollection > return_value = ((*(const CurveFitter*)local_this).make_hermite)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  ParametricCurveCollection *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_ParametricCurveCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_make_hermite_86_comment =
  "C++ Interface:\n"
  "make_hermite(CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Converts the current set of data points into a Hermite curve.\n"
  " */";
#else
static const char *Dtool_CurveFitter_make_hermite_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< ParametricCurveCollection > CurveFitter::make_nurbs(void) const
 */
static PyObject *Dtool_CurveFitter_make_nurbs_87(PyObject *self, PyObject *) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-PointerTo< ParametricCurveCollection > CurveFitter::make_nurbs(void) const
  PointerTo< ParametricCurveCollection > return_value = ((*(const CurveFitter*)local_this).make_nurbs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  ParametricCurveCollection *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_ParametricCurveCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_make_nurbs_87_comment =
  "C++ Interface:\n"
  "make_nurbs(CurveFitter self)\n"
  "\n"
  "/**\n"
  " * Converts the current set of data points into a NURBS curve.  This gives a\n"
  " * smoother curve than produced by MakeHermite().\n"
  " */";
#else
static const char *Dtool_CurveFitter_make_nurbs_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::output(std::ostream &out) const
 */
static PyObject *Dtool_CurveFitter_output_88(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-void CurveFitter::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CurveFitter.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CurveFitter*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CurveFitter self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_output_88_comment =
  "C++ Interface:\n"
  "output(CurveFitter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CurveFitter_output_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CurveFitter::write(std::ostream &out) const
 */
static PyObject *Dtool_CurveFitter_write_89(PyObject *self, PyObject *arg) {
  CurveFitter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CurveFitter)) {
    return nullptr;
  }
  // 1-void CurveFitter::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CurveFitter.write", false, true);
  if (arg_this != nullptr) {
    ((*(const CurveFitter*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CurveFitter self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_write_89_comment =
  "C++ Interface:\n"
  "write(CurveFitter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CurveFitter_write_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CurveFitter::get_class_type(void)
 */
static PyObject *Dtool_CurveFitter_get_class_type_90(PyObject *, PyObject *) {
  // 1-static TypeHandle CurveFitter::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CurveFitter::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CurveFitter_get_class_type_90_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CurveFitter_get_class_type_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CurveFitter::CurveFitter(void)
 * inline CurveFitter::CurveFitter(CurveFitter const &) = default
 */
static int Dtool_Init_CurveFitter(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CurveFitter() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CurveFitter::CurveFitter(void)
      CurveFitter *return_value = new CurveFitter();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CurveFitter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CurveFitter::CurveFitter(CurveFitter const &) = default
      CurveFitter const *arg_this = (CurveFitter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CurveFitter, 0, "CurveFitter.CurveFitter", true, true);
      if (arg_this != nullptr) {
        CurveFitter *return_value = new CurveFitter(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CurveFitter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CurveFitter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CurveFitter()\n"
      "CurveFitter(const CurveFitter param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CurveFitter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CurveFitter) {
    printf("CurveFitter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CurveFitter *local_this = (CurveFitter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CurveFitter) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CurveFitter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CurveFitter) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PiecewiseCurve
 */
/**
 * Python function wrapper for:
 * static TypeHandle PiecewiseCurve::get_class_type(void)
 */
static PyObject *Dtool_PiecewiseCurve_get_class_type_93(PyObject *, PyObject *) {
  // 1-static TypeHandle PiecewiseCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PiecewiseCurve::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PiecewiseCurve_get_class_type_93_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PiecewiseCurve_get_class_type_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PiecewiseCurve::PiecewiseCurve(void)
 */
static int Dtool_Init_PiecewiseCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PiecewiseCurve() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PiecewiseCurve() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-PiecewiseCurve::PiecewiseCurve(void)
  PiecewiseCurve *return_value = new PiecewiseCurve();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PiecewiseCurve, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PiecewiseCurve()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PiecewiseCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PiecewiseCurve) {
    printf("PiecewiseCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PiecewiseCurve *local_this = (PiecewiseCurve *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PiecewiseCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PiecewiseCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PiecewiseCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PiecewiseCurve*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class HermiteCurve
 */
/**
 * Python function wrapper for:
 * int HermiteCurve::get_num_cvs(void) const
 */
static PyObject *Dtool_HermiteCurve_get_num_cvs_96(PyObject *self, PyObject *) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  // 1-int HermiteCurve::get_num_cvs(void) const
  int return_value = ((*(const HermiteCurve*)local_this).get_num_cvs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_num_cvs_96_comment =
  "C++ Interface:\n"
  "get_num_cvs(HermiteCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the number of CV's in the curve.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_num_cvs_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int HermiteCurve::insert_cv(PN_stdfloat t)
 */
static PyObject *Dtool_HermiteCurve_insert_cv_97(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.insert_cv")) {
    return nullptr;
  }
  // 1-int HermiteCurve::insert_cv(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    int return_value = ((*local_this).insert_cv)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_cv(const HermiteCurve self, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_insert_cv_97_comment =
  "C++ Interface:\n"
  "insert_cv(const HermiteCurve self, float t)\n"
  "\n"
  "/**\n"
  " * Inserts a new CV at the given parametric point along the curve.  If this\n"
  " * parametric point is already on the curve, the CV is assigned an index\n"
  " * between its two neighbors and the indices of all following CV's are\n"
  " * incremented by 1; its in and out tangents are chosen to keep the curve\n"
  " * consistent.  If the new parametric point is beyond the end of the existing\n"
  " * curve, the curve is extended to meet it and the new CV's position, in\n"
  " * tangent, and out tangent are set to zero.\n"
  " *\n"
  " * The index number of the new CV is returned.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_insert_cv_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int HermiteCurve::append_cv(int type, LVecBase3 const &v)
 * int HermiteCurve::append_cv(int type, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_append_cv_98(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.append_cv")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline int HermiteCurve::append_cv(int type, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"type", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:append_cv", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.append_cv", "LVecBase3f");
        }
        int return_value = ((*local_this).append_cv)((int)param1, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-int HermiteCurve::append_cv(int type, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"type", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:append_cv", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        int return_value = ((*local_this).append_cv)((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "append_cv() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_cv(const HermiteCurve self, int type, const LVecBase3f v)\n"
      "append_cv(const HermiteCurve self, int type, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_append_cv_98_comment =
  "C++ Interface:\n"
  "append_cv(const HermiteCurve self, int type, const LVecBase3f v)\n"
  "append_cv(const HermiteCurve self, int type, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Adds a new CV to the end of the curve.  The new CV is given initial in/out\n"
  " * tangents of 0.  The return value is the index of the new CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_append_cv_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::remove_cv(int n)
 */
static PyObject *Dtool_HermiteCurve_remove_cv_99(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.remove_cv")) {
    return nullptr;
  }
  // 1-bool HermiteCurve::remove_cv(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).remove_cv)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_cv(const HermiteCurve self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_remove_cv_99_comment =
  "C++ Interface:\n"
  "remove_cv(const HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the given CV from the curve.  Returns true if the CV existed, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_remove_cv_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void HermiteCurve::remove_all_cvs(void)
 */
static PyObject *Dtool_HermiteCurve_remove_all_cvs_100(PyObject *self, PyObject *) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.remove_all_cvs")) {
    return nullptr;
  }
  // 1-void HermiteCurve::remove_all_cvs(void)
  ((*local_this).remove_all_cvs)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_remove_all_cvs_100_comment =
  "C++ Interface:\n"
  "remove_all_cvs(const HermiteCurve self)\n"
  "\n"
  "/**\n"
  " * Removes all CV's from the curve.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_remove_all_cvs_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::set_cv_type(int n, int type)
 */
static PyObject *Dtool_HermiteCurve_set_cv_type_101(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_type")) {
    return nullptr;
  }
  // 1-bool HermiteCurve::set_cv_type(int n, int type)
  int param1;
  int param2;
  static const char *keyword_list[] = {"n", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_cv_type", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).set_cv_type)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_type(const HermiteCurve self, int n, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_type_101_comment =
  "C++ Interface:\n"
  "set_cv_type(const HermiteCurve self, int n, int type)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,\n"
  " * HC_G1, or HC_SMOOTH.\n"
  " *\n"
  " * Other than HC_CUT, these have no effect on the actual curve; it remains up\n"
  " * to user software to impose the constraints these imply.\n"
  " *\n"
  " * HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints\n"
  " * on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH\n"
  " * forces the tangents to be identical.  Setting type type to HC_G1 or\n"
  " * HC_SMOOTH may adjust the out tangent to match the in tangent.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_type_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool HermiteCurve::set_cv_point(int n, LVecBase3 const &v)
 * bool HermiteCurve::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_set_cv_point_102(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_point")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool HermiteCurve::set_cv_point(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_point", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.set_cv_point", "LVecBase3f");
        }
        bool return_value = ((*local_this).set_cv_point)((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-bool HermiteCurve::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = ((*local_this).set_cv_point)((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_point() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_point(const HermiteCurve self, int n, const LVecBase3f v)\n"
      "set_cv_point(const HermiteCurve self, int n, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_point_102_comment =
  "C++ Interface:\n"
  "set_cv_point(const HermiteCurve self, int n, const LVecBase3f v)\n"
  "set_cv_point(const HermiteCurve self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's position.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_point_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool HermiteCurve::set_cv_in(int n, LVecBase3 const &v)
 * bool HermiteCurve::set_cv_in(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_set_cv_in_103(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_in")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool HermiteCurve::set_cv_in(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_in", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.set_cv_in", "LVecBase3f");
        }
        bool return_value = ((*local_this).set_cv_in)((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-bool HermiteCurve::set_cv_in(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_in", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = ((*local_this).set_cv_in)((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_in() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_in(const HermiteCurve self, int n, const LVecBase3f v)\n"
      "set_cv_in(const HermiteCurve self, int n, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_in_103_comment =
  "C++ Interface:\n"
  "set_cv_in(const HermiteCurve self, int n, const LVecBase3f v)\n"
  "set_cv_in(const HermiteCurve self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's in tangent.  Depending on the continuity type, this\n"
  " * may also adjust the out tangent.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_in_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool HermiteCurve::set_cv_out(int n, LVecBase3 const &v)
 * bool HermiteCurve::set_cv_out(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_HermiteCurve_set_cv_out_104(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_out")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool HermiteCurve::set_cv_out(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_out", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.set_cv_out", "LVecBase3f");
        }
        bool return_value = ((*local_this).set_cv_out)((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-bool HermiteCurve::set_cv_out(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_out", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = ((*local_this).set_cv_out)((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_out() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_out(const HermiteCurve self, int n, const LVecBase3f v)\n"
      "set_cv_out(const HermiteCurve self, int n, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_out_104_comment =
  "C++ Interface:\n"
  "set_cv_out(const HermiteCurve self, int n, const LVecBase3f v)\n"
  "set_cv_out(const HermiteCurve self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's out tangent.  Depending on the continuity type, this\n"
  " * may also adjust the in tangent.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_out_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::set_cv_tstart(int n, PN_stdfloat tstart)
 */
static PyObject *Dtool_HermiteCurve_set_cv_tstart_105(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_tstart")) {
    return nullptr;
  }
  // 1-bool HermiteCurve::set_cv_tstart(int n, PN_stdfloat tstart)
  int param1;
  float param2;
  static const char *keyword_list[] = {"n", "tstart", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_cv_tstart", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).set_cv_tstart)((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_tstart(const HermiteCurve self, int n, float tstart)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_tstart_105_comment =
  "C++ Interface:\n"
  "set_cv_tstart(const HermiteCurve self, int n, float tstart)\n"
  "\n"
  "/**\n"
  " * Changes the given CV's parametric starting time.  This may affect the shape\n"
  " * of the curve.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_tstart_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HermiteCurve::set_cv_name(int n, char const *name)
 */
static PyObject *Dtool_HermiteCurve_set_cv_name_106(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HermiteCurve, (void **)&local_this, "HermiteCurve.set_cv_name")) {
    return nullptr;
  }
  // 1-bool HermiteCurve::set_cv_name(int n, char const *name)
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"n", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:set_cv_name", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).set_cv_name)((int)param1, (char const *)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_name(const HermiteCurve self, int n, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_set_cv_name_106_comment =
  "C++ Interface:\n"
  "set_cv_name(const HermiteCurve self, int n, str name)\n"
  "\n"
  "/**\n"
  " * Changes the name associated with a particular CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_set_cv_name_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int HermiteCurve::get_cv_type(int n) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_type_107(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  // 1-int HermiteCurve::get_cv_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const HermiteCurve*)local_this).get_cv_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_type(HermiteCurve self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_type_107_comment =
  "C++ Interface:\n"
  "get_cv_type(HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or\n"
  " * HC_SMOOTH, or 0 if there is no such CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_type_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 const &HermiteCurve::get_cv_point(int n) const
 * void HermiteCurve::get_cv_point(int n, LVecBase3 &v) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_point_108(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-LVecBase3 const &HermiteCurve::get_cv_point(int n) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          LVecBase3 const *return_value = &(((*(const HermiteCurve*)local_this).get_cv_point)((int)arg_val));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
        }
      }
    }
    break;
  case 2:
    {
      // 1-void HermiteCurve::get_cv_point(int n, LVecBase3 &v) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_cv_point", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.get_cv_point", "LVecBase3f");
        }
        ((*(const HermiteCurve*)local_this).get_cv_point)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_cv_point() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_point(HermiteCurve self, int n)\n"
      "get_cv_point(HermiteCurve self, int n, LVecBase3f v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_point_108_comment =
  "C++ Interface:\n"
  "get_cv_point(HermiteCurve self, int n)\n"
  "get_cv_point(HermiteCurve self, int n, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Returns the position of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_point_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 const &HermiteCurve::get_cv_in(int n) const
 * void HermiteCurve::get_cv_in(int n, LVecBase3 &v) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_in_109(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-LVecBase3 const &HermiteCurve::get_cv_in(int n) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          LVecBase3 const *return_value = &(((*(const HermiteCurve*)local_this).get_cv_in)((int)arg_val));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
        }
      }
    }
    break;
  case 2:
    {
      // 1-void HermiteCurve::get_cv_in(int n, LVecBase3 &v) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_cv_in", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.get_cv_in", "LVecBase3f");
        }
        ((*(const HermiteCurve*)local_this).get_cv_in)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_cv_in() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_in(HermiteCurve self, int n)\n"
      "get_cv_in(HermiteCurve self, int n, LVecBase3f v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_in_109_comment =
  "C++ Interface:\n"
  "get_cv_in(HermiteCurve self, int n)\n"
  "get_cv_in(HermiteCurve self, int n, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Returns the in tangent of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_in_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 const &HermiteCurve::get_cv_out(int n) const
 * void HermiteCurve::get_cv_out(int n, LVecBase3 &v) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_out_110(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "n")) {
        // 1-LVecBase3 const &HermiteCurve::get_cv_out(int n) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          LVecBase3 const *return_value = &(((*(const HermiteCurve*)local_this).get_cv_out)((int)arg_val));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
        }
      }
    }
    break;
  case 2:
    {
      // 1-void HermiteCurve::get_cv_out(int n, LVecBase3 &v) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_cv_out", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "HermiteCurve.get_cv_out", "LVecBase3f");
        }
        ((*(const HermiteCurve*)local_this).get_cv_out)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_cv_out() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_out(HermiteCurve self, int n)\n"
      "get_cv_out(HermiteCurve self, int n, LVecBase3f v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_out_110_comment =
  "C++ Interface:\n"
  "get_cv_out(HermiteCurve self, int n)\n"
  "get_cv_out(HermiteCurve self, int n, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Returns the out tangent of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_out_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat HermiteCurve::get_cv_tstart(int n) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_tstart_111(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  // 1-PN_stdfloat HermiteCurve::get_cv_tstart(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const HermiteCurve*)local_this).get_cv_tstart)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_tstart(HermiteCurve self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_tstart_111_comment =
  "C++ Interface:\n"
  "get_cv_tstart(HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the starting point in parametric space of the given CV.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_tstart_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string HermiteCurve::get_cv_name(int n) const
 */
static PyObject *Dtool_HermiteCurve_get_cv_name_112(PyObject *self, PyObject *arg) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  // 1-std::string HermiteCurve::get_cv_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const HermiteCurve*)local_this).get_cv_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_name(HermiteCurve self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_cv_name_112_comment =
  "C++ Interface:\n"
  "get_cv_name(HermiteCurve self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the given CV, or NULL.\n"
  " */";
#else
static const char *Dtool_HermiteCurve_get_cv_name_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void HermiteCurve::write_cv(std::ostream &out, int n) const
 */
static PyObject *Dtool_HermiteCurve_write_cv_113(PyObject *self, PyObject *args, PyObject *kwds) {
  HermiteCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HermiteCurve)) {
    return nullptr;
  }
  // 1-void HermiteCurve::write_cv(std::ostream &out, int n) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "n", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_cv", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "HermiteCurve.write_cv", false, true);
    if (param1_this != nullptr) {
      ((*(const HermiteCurve*)local_this).write_cv)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_cv(HermiteCurve self, ostream out, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_write_cv_113_comment =
  "C++ Interface:\n"
  "write_cv(HermiteCurve self, ostream out, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HermiteCurve_write_cv_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle HermiteCurve::get_class_type(void)
 */
static PyObject *Dtool_HermiteCurve_get_class_type_114(PyObject *, PyObject *) {
  // 1-static TypeHandle HermiteCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((HermiteCurve::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HermiteCurve_get_class_type_114_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_HermiteCurve_get_class_type_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * HermiteCurve::HermiteCurve(void)
 * HermiteCurve::HermiteCurve(ParametricCurve const &pc)
 */
static int Dtool_Init_HermiteCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-HermiteCurve::HermiteCurve(void)
      HermiteCurve *return_value = new HermiteCurve();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HermiteCurve, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pc")) {
        // 1-HermiteCurve::HermiteCurve(ParametricCurve const &pc)
        ParametricCurve const *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 0, "HermiteCurve.HermiteCurve", true, true);
        if (arg_this != nullptr) {
          HermiteCurve *return_value = new HermiteCurve(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HermiteCurve, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HermiteCurve() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HermiteCurve()\n"
      "HermiteCurve(const ParametricCurve pc)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HermiteCurve(PyObject *args, CPT(HermiteCurve) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_HermiteCurve)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HermiteCurve::HermiteCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ParametricCurve);
    if (arg_this != nullptr) {
      HermiteCurve *return_value = new HermiteCurve(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_HermiteCurve(PyObject *args, PT(HermiteCurve) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_HermiteCurve)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HermiteCurve::HermiteCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ParametricCurve);
    if (arg_this != nullptr) {
      HermiteCurve *return_value = new HermiteCurve(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_HermiteCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_HermiteCurve) {
    printf("HermiteCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  HermiteCurve *local_this = (HermiteCurve *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_HermiteCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PiecewiseCurve) {
    return (PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_HermiteCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_HermiteCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PiecewiseCurve) {
    PiecewiseCurve* other_this = (PiecewiseCurve*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (HermiteCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (HermiteCurve*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NurbsCurveInterface
 */
/**
 * Python function wrapper for:
 * virtual void NurbsCurveInterface::set_order(int order) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_set_order_117(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_order")) {
    return nullptr;
  }
  // 1-virtual void NurbsCurveInterface::set_order(int order) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const NurbsCurveInterface self, int order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_order_117_comment =
  "C++ Interface:\n"
  "set_order(const NurbsCurveInterface self, int order)\n";
#else
static const char *Dtool_NurbsCurveInterface_set_order_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int NurbsCurveInterface::get_order(void) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_order_118(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-virtual int NurbsCurveInterface::get_order(void) const = 0
  int return_value = ((*(const NurbsCurveInterface*)local_this).get_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_order_118_comment =
  "C++ Interface:\n"
  "get_order(NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_order_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int NurbsCurveInterface::get_num_cvs(void) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_num_cvs_119(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-virtual int NurbsCurveInterface::get_num_cvs(void) const = 0
  int return_value = ((*(const NurbsCurveInterface*)local_this).get_num_cvs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_num_cvs_119_comment =
  "C++ Interface:\n"
  "get_num_cvs(NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_num_cvs_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int NurbsCurveInterface::get_num_knots(void) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_num_knots_120(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-virtual int NurbsCurveInterface::get_num_knots(void) const = 0
  int return_value = ((*(const NurbsCurveInterface*)local_this).get_num_knots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_num_knots_120_comment =
  "C++ Interface:\n"
  "get_num_knots(NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_num_knots_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::insert_cv(PN_stdfloat t) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_insert_cv_121(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.insert_cv")) {
    return nullptr;
  }
  // 1-virtual bool NurbsCurveInterface::insert_cv(PN_stdfloat t) = 0
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).insert_cv)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_cv(const NurbsCurveInterface self, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_insert_cv_121_comment =
  "C++ Interface:\n"
  "insert_cv(const NurbsCurveInterface self, float t)\n";
#else
static const char *Dtool_NurbsCurveInterface_insert_cv_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveInterface::append_cv(LVecBase3 const &v)
 * inline int NurbsCurveInterface::append_cv(LVecBase4 const &v)
 * inline int NurbsCurveInterface::append_cv(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NurbsCurveInterface_append_cv_122(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.append_cv")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "v")) {
        {
          // -2 inline int NurbsCurveInterface::append_cv(LVecBase3 const &v)
          LVecBase3 const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
          if (arg_this != nullptr) {
            int return_value = ((*local_this).append_cv)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline int NurbsCurveInterface::append_cv(LVecBase4 const &v)
          LVecBase4 const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
          if (arg_this != nullptr) {
            int return_value = ((*local_this).append_cv)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline int NurbsCurveInterface::append_cv(LVecBase3 const &v)
          LVecBase3f arg_local;
          LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
          if ((arg_this != nullptr)) {
            int return_value = ((*local_this).append_cv)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline int NurbsCurveInterface::append_cv(LVecBase4 const &v)
          LVecBase4f arg_local;
          LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
          if ((arg_this != nullptr)) {
            int return_value = ((*local_this).append_cv)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 3:
    {
      // 1-inline int NurbsCurveInterface::append_cv(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:append_cv", (char **)keyword_list, &param1, &param2, &param3)) {
        int return_value = ((*local_this).append_cv)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "append_cv() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_cv(const NurbsCurveInterface self, const LVecBase3f v)\n"
      "append_cv(const NurbsCurveInterface self, const LVecBase4f v)\n"
      "append_cv(const NurbsCurveInterface self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_append_cv_122_comment =
  "C++ Interface:\n"
  "append_cv(const NurbsCurveInterface self, const LVecBase3f v)\n"
  "append_cv(const NurbsCurveInterface self, const LVecBase4f v)\n"
  "append_cv(const NurbsCurveInterface self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_append_cv_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::remove_cv(int n) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_remove_cv_123(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.remove_cv")) {
    return nullptr;
  }
  // 1-virtual bool NurbsCurveInterface::remove_cv(int n) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).remove_cv)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_cv(const NurbsCurveInterface self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_remove_cv_123_comment =
  "C++ Interface:\n"
  "remove_cv(const NurbsCurveInterface self, int n)\n";
#else
static const char *Dtool_NurbsCurveInterface_remove_cv_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void NurbsCurveInterface::remove_all_cvs(void) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_remove_all_cvs_124(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.remove_all_cvs")) {
    return nullptr;
  }
  // 1-virtual void NurbsCurveInterface::remove_all_cvs(void) = 0
  ((*local_this).remove_all_cvs)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_remove_all_cvs_124_comment =
  "C++ Interface:\n"
  "remove_all_cvs(const NurbsCurveInterface self)\n";
#else
static const char *Dtool_NurbsCurveInterface_remove_all_cvs_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3 const &v)
 * inline bool NurbsCurveInterface::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_NurbsCurveInterface_set_cv_point_125(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_cv_point")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3 const &v)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"n", "v", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv_point", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveInterface.set_cv_point", "LVecBase3f");
        }
        bool return_value = ((*local_this).set_cv_point)((int)param1, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool NurbsCurveInterface::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      int param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"n", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ifff:set_cv_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        bool return_value = ((*local_this).set_cv_point)((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_cv_point() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_point(const NurbsCurveInterface self, int n, const LVecBase3f v)\n"
      "set_cv_point(const NurbsCurveInterface self, int n, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_cv_point_125_comment =
  "C++ Interface:\n"
  "set_cv_point(const NurbsCurveInterface self, int n, const LVecBase3f v)\n"
  "set_cv_point(const NurbsCurveInterface self, int n, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Repositions the indicated CV.  Returns true if successful, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Repositions the indicated CV.  Returns true if successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_set_cv_point_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 NurbsCurveInterface::get_cv_point(int n) const
 */
static PyObject *Dtool_NurbsCurveInterface_get_cv_point_126(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-inline LVecBase3 NurbsCurveInterface::get_cv_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3 *return_value = new LVecBase3(((*(const NurbsCurveInterface*)local_this).get_cv_point)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_point(NurbsCurveInterface self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_cv_point_126_comment =
  "C++ Interface:\n"
  "get_cv_point(NurbsCurveInterface self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the position of the indicated CV.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_get_cv_point_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NurbsCurveInterface::set_cv_weight(int n, PN_stdfloat w)
 */
static PyObject *Dtool_NurbsCurveInterface_set_cv_weight_127(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_cv_weight")) {
    return nullptr;
  }
  // 1-bool NurbsCurveInterface::set_cv_weight(int n, PN_stdfloat w)
  int param1;
  float param2;
  static const char *keyword_list[] = {"n", "w", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_cv_weight", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).set_cv_weight)((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv_weight(const NurbsCurveInterface self, int n, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_cv_weight_127_comment =
  "C++ Interface:\n"
  "set_cv_weight(const NurbsCurveInterface self, int n, float w)\n"
  "\n"
  "/**\n"
  " * Sets the weight of the indicated CV without affecting its position in 3-d\n"
  " * space.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_set_cv_weight_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveInterface::get_cv_weight(int n) const
 */
static PyObject *Dtool_NurbsCurveInterface_get_cv_weight_128(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsCurveInterface::get_cv_weight(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const NurbsCurveInterface*)local_this).get_cv_weight)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv_weight(NurbsCurveInterface self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_cv_weight_128_comment =
  "C++ Interface:\n"
  "get_cv_weight(NurbsCurveInterface self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the weight of the indicated CV.\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_get_cv_weight_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4 const &v) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_set_cv_129(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_cv")) {
    return nullptr;
  }
  // 1-virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4 const &v) = 0
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "v", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_cv", (char **)keyword_list, &param1, &param2)) {
    LVecBase4f param2_local;
    LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveInterface.set_cv", "LVecBase4f");
    }
    bool return_value = ((*local_this).set_cv)((int)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv(const NurbsCurveInterface self, int n, const LVecBase4f v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_cv_129_comment =
  "C++ Interface:\n"
  "set_cv(const NurbsCurveInterface self, int n, const LVecBase4f v)\n";
#else
static const char *Dtool_NurbsCurveInterface_set_cv_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LVecBase4 NurbsCurveInterface::get_cv(int n) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_cv_130(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-virtual LVecBase4 NurbsCurveInterface::get_cv(int n) const = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase4 *return_value = new LVecBase4(((*(const NurbsCurveInterface*)local_this).get_cv)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv(NurbsCurveInterface self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_cv_130_comment =
  "C++ Interface:\n"
  "get_cv(NurbsCurveInterface self, int n)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_cv_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool NurbsCurveInterface::set_knot(int n, PN_stdfloat t) = 0
 */
static PyObject *Dtool_NurbsCurveInterface_set_knot_131(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveInterface, (void **)&local_this, "NurbsCurveInterface.set_knot")) {
    return nullptr;
  }
  // 1-virtual bool NurbsCurveInterface::set_knot(int n, PN_stdfloat t) = 0
  int param1;
  float param2;
  static const char *keyword_list[] = {"n", "t", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_knot", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).set_knot)((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_knot(const NurbsCurveInterface self, int n, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_set_knot_131_comment =
  "C++ Interface:\n"
  "set_knot(const NurbsCurveInterface self, int n, float t)\n";
#else
static const char *Dtool_NurbsCurveInterface_set_knot_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat NurbsCurveInterface::get_knot(int n) const = 0
 */
static PyObject *Dtool_NurbsCurveInterface_get_knot_132(PyObject *self, PyObject *arg) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat NurbsCurveInterface::get_knot(int n) const = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const NurbsCurveInterface*)local_this).get_knot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(NurbsCurveInterface self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_knot_132_comment =
  "C++ Interface:\n"
  "get_knot(NurbsCurveInterface self, int n)\n";
#else
static const char *Dtool_NurbsCurveInterface_get_knot_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveInterface::write_cv(std::ostream &out, int n) const
 */
static PyObject *Dtool_NurbsCurveInterface_write_cv_135(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveInterface)) {
    return nullptr;
  }
  // 1-void NurbsCurveInterface::write_cv(std::ostream &out, int n) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "n", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_cv", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "NurbsCurveInterface.write_cv", false, true);
    if (param1_this != nullptr) {
      ((*(const NurbsCurveInterface*)local_this).write_cv)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_cv(NurbsCurveInterface self, ostream out, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_write_cv_135_comment =
  "C++ Interface:\n"
  "write_cv(NurbsCurveInterface self, ostream out, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsCurveInterface_write_cv_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NurbsCurveInterface::get_class_type(void)
 */
static PyObject *Dtool_NurbsCurveInterface_get_class_type_136(PyObject *, PyObject *) {
  // 1-static TypeHandle NurbsCurveInterface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NurbsCurveInterface::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveInterface_get_class_type_136_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NurbsCurveInterface_get_class_type_136_comment = nullptr;
#endif

static int Dtool_Init_NurbsCurveInterface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveInterface_get_cvs(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_cvs)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveInterface_get_cv_130(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveInterface_get_knots(PyObject *self, PyObject *) {
  NurbsCurveInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveInterface, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_knots)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveInterface_get_knot_132(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsCurveInterface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NurbsCurveInterface) {
    printf("NurbsCurveInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NurbsCurveInterface *local_this = (NurbsCurveInterface *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NurbsCurveInterface) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NurbsCurveInterface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NurbsCurveInterface) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NurbsCurve
 */
/**
 * Python function wrapper for:
 * static TypeHandle NurbsCurve::get_class_type(void)
 */
static PyObject *Dtool_NurbsCurve_get_class_type_144(PyObject *, PyObject *) {
  // 1-static TypeHandle NurbsCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NurbsCurve::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurve_get_class_type_144_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NurbsCurve_get_class_type_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void)
 */
static PyObject *Dtool_NurbsCurve_upcast_to_PiecewiseCurve_138(PyObject *self, PyObject *) {
  NurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurve, (void **)&local_this, "NurbsCurve.upcast_to_PiecewiseCurve")) {
    return nullptr;
  }
  // 1-PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void)
  PiecewiseCurve *return_value = (PiecewiseCurve *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PiecewiseCurve, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurve_upcast_to_PiecewiseCurve_138_comment =
  "C++ Interface:\n"
  "upcast_to_PiecewiseCurve(const NurbsCurve self)\n"
  "\n"
  "upcast from NurbsCurve to PiecewiseCurve";
#else
static const char *Dtool_NurbsCurve_upcast_to_PiecewiseCurve_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void)
 */
static PyObject *Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_140(PyObject *self, PyObject *) {
  NurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurve, (void **)&local_this, "NurbsCurve.upcast_to_NurbsCurveInterface")) {
    return nullptr;
  }
  // 1-NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void)
  NurbsCurveInterface *return_value = (NurbsCurveInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NurbsCurveInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_140_comment =
  "C++ Interface:\n"
  "upcast_to_NurbsCurveInterface(const NurbsCurve self)\n"
  "\n"
  "upcast from NurbsCurve to NurbsCurveInterface";
#else
static const char *Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NurbsCurve::NurbsCurve(void)
 * NurbsCurve::NurbsCurve(ParametricCurve const &pc)
 */
static int Dtool_Init_NurbsCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NurbsCurve::NurbsCurve(void)
      NurbsCurve *return_value = new NurbsCurve();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurve, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pc")) {
        // 1-NurbsCurve::NurbsCurve(ParametricCurve const &pc)
        ParametricCurve const *arg_this = (ParametricCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ParametricCurve, 0, "NurbsCurve.NurbsCurve", true, true);
        if (arg_this != nullptr) {
          NurbsCurve *return_value = new NurbsCurve(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurve, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NurbsCurve() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsCurve()\n"
      "NurbsCurve(const ParametricCurve pc)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_NurbsCurve(PyObject *args, CPT(NurbsCurve) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_NurbsCurve)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NurbsCurve::NurbsCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ParametricCurve);
    if (arg_this != nullptr) {
      NurbsCurve *return_value = new NurbsCurve(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_NurbsCurve(PyObject *args, PT(NurbsCurve) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_NurbsCurve)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NurbsCurve::NurbsCurve(ParametricCurve const &pc)
    ParametricCurve const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ParametricCurve);
    if (arg_this != nullptr) {
      NurbsCurve *return_value = new NurbsCurve(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_NurbsCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NurbsCurve) {
    printf("NurbsCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NurbsCurve *local_this = (NurbsCurve *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NurbsCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_NurbsCurveInterface) {
    return (NurbsCurveInterface *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ParametricCurve) {
    return (ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_PiecewiseCurve) {
    return (PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ParametricCurve *)(PiecewiseCurve *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NurbsCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NurbsCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_NurbsCurveInterface) {
    NurbsCurveInterface* other_this = (NurbsCurveInterface*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ParametricCurve) {
    ParametricCurve* other_this = (ParametricCurve*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_PiecewiseCurve) {
    PiecewiseCurve* other_this = (PiecewiseCurve*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (NurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (NurbsCurve*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NurbsCurveResult
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_start_t(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_start_t_146(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_start_t(void) const
  PN_stdfloat return_value = ((*(const NurbsCurveResult*)local_this).get_start_t)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_start_t_146_comment =
  "C++ Interface:\n"
  "get_start_t(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the first legal value of t on the curve.  Usually this is 0.0.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_start_t_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_end_t(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_end_t_147(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_end_t(void) const
  PN_stdfloat return_value = ((*(const NurbsCurveResult*)local_this).get_end_t)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_end_t_147_comment =
  "C++ Interface:\n"
  "get_end_t(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the last legal value of t on the curve.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_end_t_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveResult::eval_point(PN_stdfloat t, LVecBase3 &point)
 */
static PyObject *Dtool_NurbsCurveResult_eval_point_148(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_point")) {
    return nullptr;
  }
  // 1-inline bool NurbsCurveResult::eval_point(PN_stdfloat t, LVecBase3 &point)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:eval_point", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveResult.eval_point", "LVecBase3f");
    }
    bool return_value = ((*local_this).eval_point)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_point(const NurbsCurveResult self, float t, LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_point_148_comment =
  "C++ Interface:\n"
  "eval_point(const NurbsCurveResult self, float t, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Computes the point on the curve corresponding to the indicated value in\n"
  " * parametric time.  Returns true if the t value is valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_point_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveResult::eval_tangent(PN_stdfloat t, LVecBase3 &tangent)
 */
static PyObject *Dtool_NurbsCurveResult_eval_tangent_149(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_tangent")) {
    return nullptr;
  }
  // 1-inline bool NurbsCurveResult::eval_tangent(PN_stdfloat t, LVecBase3 &tangent)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"t", "tangent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:eval_tangent", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveResult.eval_tangent", "LVecBase3f");
    }
    bool return_value = ((*local_this).eval_tangent)((PN_stdfloat)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_tangent(const NurbsCurveResult self, float t, LVecBase3f tangent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_tangent_149_comment =
  "C++ Interface:\n"
  "eval_tangent(const NurbsCurveResult self, float t, LVecBase3f tangent)\n"
  "\n"
  "/**\n"
  " * Computes the tangent to the curve at the indicated point in parametric\n"
  " * time.  This tangent vector will not necessarily be normalized, and could be\n"
  " * zero.  See also eval_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_tangent_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::eval_extended_point(PN_stdfloat t, int d)
 */
static PyObject *Dtool_NurbsCurveResult_eval_extended_point_150(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_extended_point")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::eval_extended_point(PN_stdfloat t, int d)
  float param1;
  int param2;
  static const char *keyword_list[] = {"t", "d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fi:eval_extended_point", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*local_this).eval_extended_point)((PN_stdfloat)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_point(const NurbsCurveResult self, float t, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_extended_point_150_comment =
  "C++ Interface:\n"
  "eval_extended_point(const NurbsCurveResult self, float t, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the curve in n-dimensional space according to the extended\n"
  " * vertices associated with the curve in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_extended_point_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsCurveResult::eval_extended_points(PN_stdfloat t, int d, PN_stdfloat result[], int num_values)
 */
static PyObject *Dtool_NurbsCurveResult_eval_extended_points_151(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.eval_extended_points")) {
    return nullptr;
  }
  // 1-inline bool NurbsCurveResult::eval_extended_points(PN_stdfloat t, int d, PN_stdfloat result[], int num_values)
  float param1;
  int param2;
  PyObject *param3;
  Py_buffer param3_view;
  int param4;
  static const char *keyword_list[] = {"t", "d", "result", "num_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiOi:eval_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    if (PyObject_GetBuffer(param3, &param3_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param3_view.format[0] == 'f' && param3_view.format[1] == 0) {
      bool return_value = ((*local_this).eval_extended_points)((PN_stdfloat)param1, (int)param2, (float *)param3_view.buf, (int)param4);
      PyBuffer_Release(&param3_view);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_points(const NurbsCurveResult self, float t, int d, buffer result, int num_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_extended_points_151_comment =
  "C++ Interface:\n"
  "eval_extended_points(const NurbsCurveResult self, float t, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_extended_points_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveResult::get_num_segments(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_num_segments_152(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-inline int NurbsCurveResult::get_num_segments(void) const
  int return_value = ((*(const NurbsCurveResult*)local_this).get_num_segments)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_num_segments_152_comment =
  "C++ Interface:\n"
  "get_num_segments(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments within the curve.  This\n"
  " * number is usually not important unless you plan to call\n"
  " * eval_segment_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_num_segments_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::eval_segment_point(int segment, PN_stdfloat t, LVecBase3 &point) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_point_153(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-void NurbsCurveResult::eval_segment_point(int segment, PN_stdfloat t, LVecBase3 &point) const
  int param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"segment", "t", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifO:eval_segment_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsCurveResult.eval_segment_point", "LVecBase3f");
    }
    ((*(const NurbsCurveResult*)local_this).eval_segment_point)((int)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_point(NurbsCurveResult self, int segment, float t, LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_point_153_comment =
  "C++ Interface:\n"
  "eval_segment_point(NurbsCurveResult self, int segment, float t, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Evaluates the point on the curve corresponding to the indicated value in\n"
  " * parametric time within the indicated curve segment.  t should be in the\n"
  " * range [0, 1].\n"
  " *\n"
  " * The curve is internally represented as a number of connected (or possibly\n"
  " * unconnected) piecewise continuous segments.  The exact number of segments\n"
  " * for a particular curve depends on the knot vector, and is returned by\n"
  " * get_num_segments().  Normally, eval_point() is used to evaluate a point\n"
  " * along the continuous curve, but when you care more about local continuity,\n"
  " * you can use eval_segment_point() to evaluate the points along each segment.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_point_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::eval_segment_tangent(int segment, PN_stdfloat t, LVecBase3 &tangent) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_tangent_154(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-void NurbsCurveResult::eval_segment_tangent(int segment, PN_stdfloat t, LVecBase3 &tangent) const
  int param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"segment", "t", "tangent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifO:eval_segment_tangent", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsCurveResult.eval_segment_tangent", "LVecBase3f");
    }
    ((*(const NurbsCurveResult*)local_this).eval_segment_tangent)((int)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_tangent(NurbsCurveResult self, int segment, float t, LVecBase3f tangent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_tangent_154_comment =
  "C++ Interface:\n"
  "eval_segment_tangent(NurbsCurveResult self, int segment, float t, LVecBase3f tangent)\n"
  "\n"
  "/**\n"
  " * As eval_segment_point, but computes the tangent to the curve at the\n"
  " * indicated point.  The tangent vector will not necessarily be normalized,\n"
  " * and could be zero, particularly at the endpoints.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_tangent_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsCurveResult::eval_segment_extended_point(int segment, PN_stdfloat t, int d) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_extended_point_155(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-PN_stdfloat NurbsCurveResult::eval_segment_extended_point(int segment, PN_stdfloat t, int d) const
  int param1;
  float param2;
  int param3;
  static const char *keyword_list[] = {"segment", "t", "d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifi:eval_segment_extended_point", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_stdfloat return_value = ((*(const NurbsCurveResult*)local_this).eval_segment_extended_point)((int)param1, (PN_stdfloat)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_point(NurbsCurveResult self, int segment, float t, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_extended_point_155_comment =
  "C++ Interface:\n"
  "eval_segment_extended_point(NurbsCurveResult self, int segment, float t, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the curve in n-dimensional space according to the extended\n"
  " * vertices associated with the curve in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_extended_point_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::eval_segment_extended_points(int segment, PN_stdfloat t, int d, PN_stdfloat result[], int num_values) const
 */
static PyObject *Dtool_NurbsCurveResult_eval_segment_extended_points_156(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-void NurbsCurveResult::eval_segment_extended_points(int segment, PN_stdfloat t, int d, PN_stdfloat result[], int num_values) const
  int param1;
  float param2;
  int param3;
  PyObject *param4;
  Py_buffer param4_view;
  int param5;
  static const char *keyword_list[] = {"segment", "t", "d", "result", "num_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifiOi:eval_segment_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    if (PyObject_GetBuffer(param4, &param4_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param4_view.format[0] == 'f' && param4_view.format[1] == 0) {
      ((*(const NurbsCurveResult*)local_this).eval_segment_extended_points)((int)param1, (PN_stdfloat)param2, (int)param3, (float *)param4_view.buf, (int)param5);
      PyBuffer_Release(&param4_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_points(NurbsCurveResult self, int segment, float t, int d, buffer result, int num_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_eval_segment_extended_points_156_comment =
  "C++ Interface:\n"
  "eval_segment_extended_points(NurbsCurveResult self, int segment, float t, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_eval_segment_extended_points_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_segment_t(int segment, PN_stdfloat t) const
 */
static PyObject *Dtool_NurbsCurveResult_get_segment_t_157(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_segment_t(int segment, PN_stdfloat t) const
  int param1;
  float param2;
  static const char *keyword_list[] = {"segment", "t", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:get_segment_t", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const NurbsCurveResult*)local_this).get_segment_t)((int)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_segment_t(NurbsCurveResult self, int segment, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_segment_t_157_comment =
  "C++ Interface:\n"
  "get_segment_t(NurbsCurveResult self, int segment, float t)\n"
  "\n"
  "/**\n"
  " * Accepts a t value in the range [0, 1], and assumed to be relative to the\n"
  " * indicated segment (as in eval_segment_point()), and returns the\n"
  " * corresponding t value in the entire curve (as in eval_point()).\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_segment_t_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveResult::adaptive_sample(PN_stdfloat tolerance)
 */
static PyObject *Dtool_NurbsCurveResult_adaptive_sample_158(PyObject *self, PyObject *arg) {
  NurbsCurveResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveResult, (void **)&local_this, "NurbsCurveResult.adaptive_sample")) {
    return nullptr;
  }
  // 1-void NurbsCurveResult::adaptive_sample(PN_stdfloat tolerance)
  if (PyNumber_Check(arg)) {
    ((*local_this).adaptive_sample)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adaptive_sample(const NurbsCurveResult self, float tolerance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_adaptive_sample_158_comment =
  "C++ Interface:\n"
  "adaptive_sample(const NurbsCurveResult self, float tolerance)\n"
  "\n"
  "/**\n"
  " * Determines the set of subdivisions necessary to approximate the curve with\n"
  " * a set of linear segments, no point of which is farther than tolerance units\n"
  " * from the actual curve.\n"
  " *\n"
  " * After this call, you may walk through the resulting set of samples with\n"
  " * get_num_samples(), get_sample_t(), and get_sample_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_adaptive_sample_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveResult::get_num_samples(void) const
 */
static PyObject *Dtool_NurbsCurveResult_get_num_samples_159(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-inline int NurbsCurveResult::get_num_samples(void) const
  int return_value = ((*(const NurbsCurveResult*)local_this).get_num_samples)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_num_samples_159_comment =
  "C++ Interface:\n"
  "get_num_samples(NurbsCurveResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of sample points generated by the previous call to\n"
  " * adaptive_sample().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_num_samples_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveResult::get_sample_t(int n) const
 */
static PyObject *Dtool_NurbsCurveResult_get_sample_t_160(PyObject *self, PyObject *arg) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsCurveResult::get_sample_t(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const NurbsCurveResult*)local_this).get_sample_t)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_t(NurbsCurveResult self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_sample_t_160_comment =
  "C++ Interface:\n"
  "get_sample_t(NurbsCurveResult self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the t value of the nth sample point generated by the previous call\n"
  " * to adaptive_sample().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_sample_t_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &NurbsCurveResult::get_sample_point(int n) const
 */
static PyObject *Dtool_NurbsCurveResult_get_sample_point_161(PyObject *self, PyObject *arg) {
  NurbsCurveResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveResult)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &NurbsCurveResult::get_sample_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 const *return_value = &(((*(const NurbsCurveResult*)local_this).get_sample_point)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sample_point(NurbsCurveResult self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveResult_get_sample_point_161_comment =
  "C++ Interface:\n"
  "get_sample_point(NurbsCurveResult self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the point on the curve of the nth sample point generated by the\n"
  " * previous call to adaptive_sample().\n"
  " *\n"
  " * For tangents, or extended points, you should use get_sample_t() and pass it\n"
  " * into eval_tangent() or eval_extended_point().\n"
  " */";
#else
static const char *Dtool_NurbsCurveResult_get_sample_point_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NurbsCurveResult::NurbsCurveResult(NurbsCurveResult const &) = default
 */
static int Dtool_Init_NurbsCurveResult(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NurbsCurveResult() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline NurbsCurveResult::NurbsCurveResult(NurbsCurveResult const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    NurbsCurveResult const *param0_this = (NurbsCurveResult *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NurbsCurveResult, 0, "NurbsCurveResult.NurbsCurveResult", true, true);
    if (param0_this != nullptr) {
      NurbsCurveResult *return_value = new NurbsCurveResult(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurveResult, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsCurveResult(const NurbsCurveResult param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveResult_get_sample_ts(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_samples)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveResult_get_sample_t_160(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveResult_get_sample_points(PyObject *self, PyObject *) {
  NurbsCurveResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveResult, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_samples)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveResult_get_sample_point_161(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsCurveResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NurbsCurveResult) {
    printf("NurbsCurveResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NurbsCurveResult *local_this = (NurbsCurveResult *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NurbsCurveResult) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NurbsCurveResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NurbsCurveResult) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsCurveResult*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NurbsCurveEvaluator
 */
/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_order(int order)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_order_167(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_order")) {
    return nullptr;
  }
  // 1-inline void NurbsCurveEvaluator::set_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const NurbsCurveEvaluator self, int order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_order_167_comment =
  "C++ Interface:\n"
  "set_order(const NurbsCurveEvaluator self, int order)\n"
  "\n"
  "/**\n"
  " * Sets the order of the curve.  This resets the knot vector to the default\n"
  " * knot vector for the number of vertices.\n"
  " *\n"
  " * The order must be 1, 2, 3, or 4, and the value is one more than the degree\n"
  " * of the curve.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_order_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_order(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_order_168(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsCurveEvaluator::get_order(void) const
  int return_value = ((*(const NurbsCurveEvaluator*)local_this).get_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_order_168_comment =
  "C++ Interface:\n"
  "get_order(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the curve as set by a previous call to set_order().\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_order_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::reset(int num_vertices)
 */
static PyObject *Dtool_NurbsCurveEvaluator_reset_169(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.reset")) {
    return nullptr;
  }
  // 1-void NurbsCurveEvaluator::reset(int num_vertices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).reset)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset(const NurbsCurveEvaluator self, int num_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_reset_169_comment =
  "C++ Interface:\n"
  "reset(const NurbsCurveEvaluator self, int num_vertices)\n"
  "\n"
  "/**\n"
  " * Resets all the vertices and knots to their default values, and sets the\n"
  " * curve up with the indicated number of vertices.  You must then call\n"
  " * set_vertex() repeatedly to fill in all of the vertex values appropriately.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_reset_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_num_vertices(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_num_vertices_170(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsCurveEvaluator::get_num_vertices(void) const
  int return_value = ((*(const NurbsCurveEvaluator*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_num_vertices_170_comment =
  "C++ Interface:\n"
  "get_num_vertices(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices in the curve.  This is the number\n"
  " * passed to the last call to reset().\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_num_vertices_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
 * inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &vertex)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_vertex_171(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_vertex")) {
    return nullptr;
  }
  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    PyObject *param2;
    float param3 = 1.0;
    static const char *keyword_list[] = {"i", "vertex", "weight", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3 const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
      if (param2_this != nullptr) {
        ((*local_this).set_vertex)((int)param1, *param2_this, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &vertex)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"i", "vertex", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex", (char **)keyword_list, &param1, &param2)) {
      LVecBase4 const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase4f);
      if (param2_this != nullptr) {
        ((*local_this).set_vertex)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    PyObject *param2;
    float param3 = 1.0;
    static const char *keyword_list[] = {"i", "vertex", "weight", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f param2_local;
      LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
      if ((param2_this != nullptr)) {
        ((*local_this).set_vertex)((int)param1, *param2_this, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &vertex)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"i", "vertex", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex", (char **)keyword_list, &param1, &param2)) {
      LVecBase4f param2_local;
      LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
      if ((param2_this != nullptr)) {
        ((*local_this).set_vertex)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase3f vertex, float weight)\n"
      "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase4f vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_vertex_171_comment =
  "C++ Interface:\n"
  "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase3f vertex, float weight)\n"
  "set_vertex(const NurbsCurveEvaluator self, int i, const LVecBase4f vertex)\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous\n"
  " * space.  In this form, the first three components of the vertex should\n"
  " * already have been scaled by the fourth component, which is the homogeneous\n"
  " * weight.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the curve.  This flavor sets the vertex as a\n"
  " * 3-d coordinate and a weight; the 3-d coordinate values are implicitly\n"
  " * scaled up by the weight factor.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_vertex_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &NurbsCurveEvaluator::get_vertex(int i) const
 * inline LVecBase4 NurbsCurveEvaluator::get_vertex(int i, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_vertex_172(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "i")) {
        // 1-inline LVecBase4 const &NurbsCurveEvaluator::get_vertex(int i) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          LVecBase4 const *return_value = &(((*(const NurbsCurveEvaluator*)local_this).get_vertex)((int)arg_val));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline LVecBase4 NurbsCurveEvaluator::get_vertex(int i, NodePath const &rel_to) const
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"i", "rel_to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_vertex", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "NurbsCurveEvaluator.get_vertex", true, true);
        if (param2_this != nullptr) {
          LVecBase4 *return_value = new LVecBase4(((*(const NurbsCurveEvaluator*)local_this).get_vertex)((int)param1, *param2_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_vertex() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(NurbsCurveEvaluator self, int i)\n"
      "get_vertex(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_vertex_172_comment =
  "C++ Interface:\n"
  "get_vertex(NurbsCurveEvaluator self, int i)\n"
  "get_vertex(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the curve, relative to its indicated\n"
  " * coordinate space.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the curve, relative to the given\n"
  " * coordinate space.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_vertex_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
 * inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &space)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_vertex_space_174(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_vertex_space")) {
    return nullptr;
  }
  {
    // -2 inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"i", "space", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_vertex_space", (char **)keyword_list, &param1, &param2)) {
      NodePath const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
      if (param2_this != nullptr) {
        ((*local_this).set_vertex_space)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &space)
    int param1;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    static const char *keyword_list[] = {"i", "space", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:set_vertex_space", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      ((*local_this).set_vertex_space)((int)param1, std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space)
  // No coercion possible: inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_space(const NurbsCurveEvaluator self, int i, const NodePath space)\n"
      "set_vertex_space(const NurbsCurveEvaluator self, int i, str space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_vertex_space_174_comment =
  "C++ Interface:\n"
  "set_vertex_space(const NurbsCurveEvaluator self, int i, const NodePath space)\n"
  "set_vertex_space(const NurbsCurveEvaluator self, int i, str space)\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty NodePath, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a fixed NodePath, which is always the same\n"
  " * NodePath.  Also see setting the space as a path string, which can specify a\n"
  " * different NodePath for different instances of the curve.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty string, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a string, which describes the path to find the\n"
  " * node relative to the rel_to NodePath when the curve is evaluated.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_vertex_space_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_vertex_space_175(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &rel_to) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "rel_to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_vertex_space", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "NurbsCurveEvaluator.get_vertex_space", true, true);
    if (param2_this != nullptr) {
      NodePath *return_value = new NodePath(((*(const NurbsCurveEvaluator*)local_this).get_vertex_space)((int)param1, *param2_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_space(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_vertex_space_175_comment =
  "C++ Interface:\n"
  "get_vertex_space(NurbsCurveEvaluator self, int i, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate space of the nth control vertex of the curve,\n"
  " * expressed as a NodePath.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_vertex_space_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, PN_stdfloat value)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_extended_vertex_176(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_extended_vertex")) {
    return nullptr;
  }
  // 1-inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, PN_stdfloat value)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"i", "d", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_extended_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_extended_vertex)((int)param1, (int)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertex(const NurbsCurveEvaluator self, int i, int d, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertex_176_comment =
  "C++ Interface:\n"
  "set_extended_vertex(const NurbsCurveEvaluator self, int i, int d, float value)\n"
  "\n"
  "/**\n"
  " * Sets an n-dimensional vertex value.  This allows definition of a NURBS\n"
  " * surface or curve in a sparse n-dimensional space, typically used for\n"
  " * associating additional properties (like color or joint membership) with\n"
  " * each vertex of a surface.\n"
  " *\n"
  " * The value d is an arbitrary integer value and specifies the dimension of\n"
  " * question for this particular vertex.  Any number of dimensions may be\n"
  " * specified, and they need not be consecutive.  If a value for a given\n"
  " * dimension is not specified, is it implicitly 0.0.\n"
  " *\n"
  " * The value is implicitly scaled by the homogenous weight value--that is, the\n"
  " * fourth component of the value passed to set_vertex().  This means the\n"
  " * ordinary vertex must be set first, before the extended vertices can be set.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertex_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsCurveEvaluator::get_extended_vertex(int i, int d) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_extended_vertex_177(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsCurveEvaluator::get_extended_vertex(int i, int d) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_extended_vertex", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const NurbsCurveEvaluator*)local_this).get_extended_vertex)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extended_vertex(NurbsCurveEvaluator self, int i, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_extended_vertex_177_comment =
  "C++ Interface:\n"
  "get_extended_vertex(NurbsCurveEvaluator self, int i, int d)\n"
  "\n"
  "/**\n"
  " * Returns an n-dimensional vertex value.  See set_extended_vertex().  This\n"
  " * returns the value set for the indicated dimension, or 0.0 if nothing has\n"
  " * been set.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_extended_vertex_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::set_extended_vertices(int i, int d, PN_stdfloat const values[], int num_values)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_extended_vertices_178(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_extended_vertices")) {
    return nullptr;
  }
  // 1-void NurbsCurveEvaluator::set_extended_vertices(int i, int d, PN_stdfloat const values[], int num_values)
  int param1;
  int param2;
  PyObject *param3;
  Py_buffer param3_view;
  int param4;
  static const char *keyword_list[] = {"i", "d", "values", "num_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOi:set_extended_vertices", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    if (PyObject_GetBuffer(param3, &param3_view, PyBUF_FORMAT) == 0 && param3_view.format[0] == 'f' && param3_view.format[1] == 0) {
      ((*local_this).set_extended_vertices)((int)param1, (int)param2, (float *)param3_view.buf, (int)param4);
      PyBuffer_Release(&param3_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertices(const NurbsCurveEvaluator self, int i, int d, buffer values, int num_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertices_178_comment =
  "C++ Interface:\n"
  "set_extended_vertices(const NurbsCurveEvaluator self, int i, int d, buffer values, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously sets several extended values in the slots d through (d +\n"
  " * num_values - 1) from the num_values elements of the indicated array.  This\n"
  " * is equivalent to calling set_extended_vertex() num_values times.  See\n"
  " * set_extended_vertex().\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_extended_vertices_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_num_knots(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_num_knots_179(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsCurveEvaluator::get_num_knots(void) const
  int return_value = ((*(const NurbsCurveEvaluator*)local_this).get_num_knots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_num_knots_179_comment =
  "C++ Interface:\n"
  "get_num_knots(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knot values in the curve.  This is based on the\n"
  " * number of vertices and the order.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_num_knots_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::set_knot(int i, PN_stdfloat knot)
 */
static PyObject *Dtool_NurbsCurveEvaluator_set_knot_180(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.set_knot")) {
    return nullptr;
  }
  // 1-void NurbsCurveEvaluator::set_knot(int i, PN_stdfloat knot)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "knot", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_knot", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_knot)((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_knot(const NurbsCurveEvaluator self, int i, float knot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_set_knot_180_comment =
  "C++ Interface:\n"
  "set_knot(const NurbsCurveEvaluator self, int i, float knot)\n"
  "\n"
  "/**\n"
  " * Sets the value of the nth knot.  Each knot value should be greater than or\n"
  " * equal to the preceding value.  If no knot values are set, a default knot\n"
  " * vector is supplied.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_set_knot_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsCurveEvaluator::get_knot(int i) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_knot_181(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-PN_stdfloat NurbsCurveEvaluator::get_knot(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const NurbsCurveEvaluator*)local_this).get_knot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(NurbsCurveEvaluator self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_knot_181_comment =
  "C++ Interface:\n"
  "get_knot(NurbsCurveEvaluator self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the value of the nth knot.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_knot_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::normalize_knots(void)
 */
static PyObject *Dtool_NurbsCurveEvaluator_normalize_knots_183(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsCurveEvaluator, (void **)&local_this, "NurbsCurveEvaluator.normalize_knots")) {
    return nullptr;
  }
  // 1-void NurbsCurveEvaluator::normalize_knots(void)
  ((*local_this).normalize_knots)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_normalize_knots_183_comment =
  "C++ Interface:\n"
  "normalize_knots(const NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Normalizes the knot sequence so that the parametric range of the curve is 0\n"
  " * .. 1.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_normalize_knots_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsCurveEvaluator::get_num_segments(void) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_get_num_segments_184(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsCurveEvaluator::get_num_segments(void) const
  int return_value = ((*(const NurbsCurveEvaluator*)local_this).get_num_segments)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_get_num_segments_184_comment =
  "C++ Interface:\n"
  "get_num_segments(NurbsCurveEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments in the curve.  This is\n"
  " * based on the knot vector.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_get_num_segments_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to = NodePath()) const
 * PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to, LMatrix4 const &mat) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_evaluate_185(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to) const
      PointerTo< NurbsCurveResult > return_value = ((*(const NurbsCurveEvaluator*)local_this).evaluate)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      NurbsCurveResult *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsCurveResult, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "rel_to")) {
        // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to) const
        NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NurbsCurveEvaluator.evaluate", true, true);
        if (arg_this != nullptr) {
          PointerTo< NurbsCurveResult > return_value = ((*(const NurbsCurveEvaluator*)local_this).evaluate)(*arg_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          NurbsCurveResult *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsCurveResult, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to, LMatrix4 const &mat) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"rel_to", "mat", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:evaluate", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NurbsCurveEvaluator.evaluate", true, true);
        LMatrix4f param2_local;
        LMatrix4 const *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "NurbsCurveEvaluator.evaluate", "LMatrix4f");
        }
        if (param1_this != nullptr) {
          PointerTo< NurbsCurveResult > return_value = ((*(const NurbsCurveEvaluator*)local_this).evaluate)(*param1_this, *param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          NurbsCurveResult *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsCurveResult, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "evaluate() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate(NurbsCurveEvaluator self)\n"
      "evaluate(NurbsCurveEvaluator self, const NodePath rel_to)\n"
      "evaluate(NurbsCurveEvaluator self, const NodePath rel_to, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_evaluate_185_comment =
  "C++ Interface:\n"
  "evaluate(NurbsCurveEvaluator self)\n"
  "evaluate(NurbsCurveEvaluator self, const NodePath rel_to)\n"
  "evaluate(NurbsCurveEvaluator self, const NodePath rel_to, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Returns a NurbsCurveResult object that represents the result of applying\n"
  " * the knots to all of the current values of the vertices, transformed into\n"
  " * the indicated coordinate space.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a NurbsCurveResult object that represents the result of applying\n"
  " * the knots to all of the current values of the vertices, transformed into\n"
  " * the indicated coordinate space, and then further transformed by the\n"
  " * indicated matrix.\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_evaluate_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsCurveEvaluator::output(std::ostream &out) const
 */
static PyObject *Dtool_NurbsCurveEvaluator_output_186(PyObject *self, PyObject *arg) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsCurveEvaluator)) {
    return nullptr;
  }
  // 1-void NurbsCurveEvaluator::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "NurbsCurveEvaluator.output", false, true);
  if (arg_this != nullptr) {
    ((*(const NurbsCurveEvaluator*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NurbsCurveEvaluator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsCurveEvaluator_output_186_comment =
  "C++ Interface:\n"
  "output(NurbsCurveEvaluator self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsCurveEvaluator_output_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NurbsCurveEvaluator::NurbsCurveEvaluator(void)
 * inline NurbsCurveEvaluator::NurbsCurveEvaluator(NurbsCurveEvaluator const &) = default
 */
static int Dtool_Init_NurbsCurveEvaluator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NurbsCurveEvaluator() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-NurbsCurveEvaluator::NurbsCurveEvaluator(void)
      NurbsCurveEvaluator *return_value = new NurbsCurveEvaluator();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurveEvaluator, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline NurbsCurveEvaluator::NurbsCurveEvaluator(NurbsCurveEvaluator const &) = default
      NurbsCurveEvaluator const *arg_this = (NurbsCurveEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsCurveEvaluator, 0, "NurbsCurveEvaluator.NurbsCurveEvaluator", true, true);
      if (arg_this != nullptr) {
        NurbsCurveEvaluator *return_value = new NurbsCurveEvaluator(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsCurveEvaluator, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NurbsCurveEvaluator() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsCurveEvaluator()\n"
      "NurbsCurveEvaluator(const NurbsCurveEvaluator param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveEvaluator_get_vertices(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_NurbsCurveEvaluator_get_vertex_172(self, (PyObject *)&args, nullptr);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsCurveEvaluator_get_knots(PyObject *self, PyObject *) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_knots)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsCurveEvaluator_get_knot_181(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsCurveEvaluator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NurbsCurveEvaluator) {
    printf("NurbsCurveEvaluator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NurbsCurveEvaluator *local_this = (NurbsCurveEvaluator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NurbsCurveEvaluator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NurbsCurveEvaluator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NurbsCurveEvaluator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsCurveEvaluator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NurbsSurfaceResult
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_start_u(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_start_u_188(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_start_u(void) const
  PN_stdfloat return_value = ((*(const NurbsSurfaceResult*)local_this).get_start_u)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_start_u_188_comment =
  "C++ Interface:\n"
  "get_start_u(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the first legal value of u on the surface.  Usually this is 0.0.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_start_u_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_end_u(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_end_u_189(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_end_u(void) const
  PN_stdfloat return_value = ((*(const NurbsSurfaceResult*)local_this).get_end_u)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_end_u_189_comment =
  "C++ Interface:\n"
  "get_end_u(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the last legal value of u on the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_end_u_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_start_v(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_start_v_190(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_start_v(void) const
  PN_stdfloat return_value = ((*(const NurbsSurfaceResult*)local_this).get_start_v)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_start_v_190_comment =
  "C++ Interface:\n"
  "get_start_v(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the first legal value of v on the surface.  Usually this is 0.0.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_start_v_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_end_v(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_end_v_191(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_end_v(void) const
  PN_stdfloat return_value = ((*(const NurbsSurfaceResult*)local_this).get_end_v)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_end_v_191_comment =
  "C++ Interface:\n"
  "get_end_v(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the last legal value of v on the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_end_v_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsSurfaceResult::eval_point(PN_stdfloat u, PN_stdfloat v, LVecBase3 &point)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_point_192(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_point")) {
    return nullptr;
  }
  // 1-inline bool NurbsSurfaceResult::eval_point(PN_stdfloat u, PN_stdfloat v, LVecBase3 &point)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"u", "v", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:eval_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsSurfaceResult.eval_point", "LVecBase3f");
    }
    bool return_value = ((*local_this).eval_point)((PN_stdfloat)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_point(const NurbsSurfaceResult self, float u, float v, LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_point_192_comment =
  "C++ Interface:\n"
  "eval_point(const NurbsSurfaceResult self, float u, float v, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Computes the point on the surface corresponding to the indicated value in\n"
  " * parametric time.  Returns true if the u, v values are valid, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_point_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsSurfaceResult::eval_normal(PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_normal_193(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_normal")) {
    return nullptr;
  }
  // 1-inline bool NurbsSurfaceResult::eval_normal(PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal)
  float param1;
  float param2;
  PyObject *param3;
  static const char *keyword_list[] = {"u", "v", "normal", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:eval_normal", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param3_local;
    LVecBase3 *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "NurbsSurfaceResult.eval_normal", "LVecBase3f");
    }
    bool return_value = ((*local_this).eval_normal)((PN_stdfloat)param1, (PN_stdfloat)param2, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_normal(const NurbsSurfaceResult self, float u, float v, LVecBase3f normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_normal_193_comment =
  "C++ Interface:\n"
  "eval_normal(const NurbsSurfaceResult self, float u, float v, LVecBase3f normal)\n"
  "\n"
  "/**\n"
  " * Computes the normal to the surface at the indicated point in parametric\n"
  " * time.  This normal vector will not necessarily be normalized, and could be\n"
  " * zero.  See also eval_point().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_normal_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::eval_extended_point(PN_stdfloat u, PN_stdfloat v, int d)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_extended_point_194(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_extended_point")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::eval_extended_point(PN_stdfloat u, PN_stdfloat v, int d)
  float param1;
  float param2;
  int param3;
  static const char *keyword_list[] = {"u", "v", "d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffi:eval_extended_point", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_stdfloat return_value = ((*local_this).eval_extended_point)((PN_stdfloat)param1, (PN_stdfloat)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_point(const NurbsSurfaceResult self, float u, float v, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_extended_point_194_comment =
  "C++ Interface:\n"
  "eval_extended_point(const NurbsSurfaceResult self, float u, float v, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the surface in n-dimensional space according to the extended\n"
  " * vertices associated with the surface in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_extended_point_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NurbsSurfaceResult::eval_extended_points(PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values)
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_extended_points_195(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceResult, (void **)&local_this, "NurbsSurfaceResult.eval_extended_points")) {
    return nullptr;
  }
  // 1-inline bool NurbsSurfaceResult::eval_extended_points(PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values)
  float param1;
  float param2;
  int param3;
  PyObject *param4;
  Py_buffer param4_view;
  int param5;
  static const char *keyword_list[] = {"u", "v", "d", "result", "num_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffiOi:eval_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    if (PyObject_GetBuffer(param4, &param4_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param4_view.format[0] == 'f' && param4_view.format[1] == 0) {
      bool return_value = ((*local_this).eval_extended_points)((PN_stdfloat)param1, (PN_stdfloat)param2, (int)param3, (float *)param4_view.buf, (int)param5);
      PyBuffer_Release(&param4_view);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_extended_points(const NurbsSurfaceResult self, float u, float v, int d, buffer result, int num_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_extended_points_195_comment =
  "C++ Interface:\n"
  "eval_extended_points(const NurbsSurfaceResult self, float u, float v, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_extended_points_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceResult::get_num_u_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_num_u_segments_196(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceResult::get_num_u_segments(void) const
  int return_value = ((*(const NurbsSurfaceResult*)local_this).get_num_u_segments)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_num_u_segments_196_comment =
  "C++ Interface:\n"
  "get_num_u_segments(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments within the surface in\n"
  " * the U direction.  This number is usually not important unless you plan to\n"
  " * call eval_segment_point().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_num_u_segments_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceResult::get_num_v_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_num_v_segments_197(PyObject *self, PyObject *) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceResult::get_num_v_segments(void) const
  int return_value = ((*(const NurbsSurfaceResult*)local_this).get_num_v_segments)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_num_v_segments_197_comment =
  "C++ Interface:\n"
  "get_num_v_segments(NurbsSurfaceResult self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments within the surface in\n"
  " * the V direction.  This number is usually not important unless you plan to\n"
  " * call eval_segment_point().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_num_v_segments_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceResult::eval_segment_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &point) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_point_198(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-void NurbsSurfaceResult::eval_segment_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &point) const
  int param1;
  int param2;
  float param3;
  float param4;
  PyObject *param5;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffO:eval_segment_point", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase3f param5_local;
    LVecBase3 *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
    if (!(param5_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "NurbsSurfaceResult.eval_segment_point", "LVecBase3f");
    }
    ((*(const NurbsSurfaceResult*)local_this).eval_segment_point)((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_point_198_comment =
  "C++ Interface:\n"
  "eval_segment_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Evaluates the point on the surface corresponding to the indicated value in\n"
  " * parametric time within the indicated surface segment.  u and v should be in\n"
  " * the range [0, 1].\n"
  " *\n"
  " * The surface is internally represented as a number of connected (or possibly\n"
  " * unconnected) piecewise continuous segments.  The exact number of segments\n"
  " * for a particular surface depends on the knot vector, and is returned by\n"
  " * get_num_segments().  Normally, eval_point() is used to evaluate a point\n"
  " * along the continuous surface, but when you care more about local\n"
  " * continuity, you can use eval_segment_point() to evaluate the points along\n"
  " * each segment.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_point_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_normal_199(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal) const
  int param1;
  int param2;
  float param3;
  float param4;
  PyObject *param5;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "normal", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffO:eval_segment_normal", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase3f param5_local;
    LVecBase3 *param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
    if (!(param5_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "NurbsSurfaceResult.eval_segment_normal", "LVecBase3f");
    }
    ((*(const NurbsSurfaceResult*)local_this).eval_segment_normal)((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_normal(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_normal_199_comment =
  "C++ Interface:\n"
  "eval_segment_normal(NurbsSurfaceResult self, int ui, int vi, float u, float v, LVecBase3f normal)\n"
  "\n"
  "/**\n"
  " * As eval_segment_point, but computes the normal to the surface at the\n"
  " * indicated point.  The normal vector will not necessarily be normalized, and\n"
  " * could be zero.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_normal_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_extended_point_200(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-PN_stdfloat NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d) const
  int param1;
  int param2;
  float param3;
  float param4;
  int param5;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffi:eval_segment_extended_point", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PN_stdfloat return_value = ((*(const NurbsSurfaceResult*)local_this).eval_segment_extended_point)((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_point_200_comment =
  "C++ Interface:\n"
  "eval_segment_extended_point(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d)\n"
  "\n"
  "/**\n"
  " * Evaluates the surface in n-dimensional space according to the extended\n"
  " * vertices associated with the surface in the indicated dimension.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_point_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceResult::eval_segment_extended_points(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values) const
 */
static PyObject *Dtool_NurbsSurfaceResult_eval_segment_extended_points_201(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-void NurbsSurfaceResult::eval_segment_extended_points(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values) const
  int param1;
  int param2;
  float param3;
  float param4;
  int param5;
  PyObject *param6;
  Py_buffer param6_view;
  int param7;
  static const char *keyword_list[] = {"ui", "vi", "u", "v", "d", "result", "num_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffiOi:eval_segment_extended_points", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    if (PyObject_GetBuffer(param6, &param6_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param6_view.format[0] == 'f' && param6_view.format[1] == 0) {
      ((*(const NurbsSurfaceResult*)local_this).eval_segment_extended_points)((int)param1, (int)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (int)param5, (float *)param6_view.buf, (int)param7);
      PyBuffer_Release(&param6_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "eval_segment_extended_points(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d, buffer result, int num_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_points_201_comment =
  "C++ Interface:\n"
  "eval_segment_extended_points(NurbsSurfaceResult self, int ui, int vi, float u, float v, int d, buffer result, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously performs eval_extended_point on a contiguous sequence of\n"
  " * dimensions.  The dimensions evaluated are d through (d + num_values - 1);\n"
  " * the results are filled into the num_values elements in the indicated result\n"
  " * array.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_eval_segment_extended_points_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_segment_u(int ui, PN_stdfloat u) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_segment_u_202(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_segment_u(int ui, PN_stdfloat u) const
  int param1;
  float param2;
  static const char *keyword_list[] = {"ui", "u", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:get_segment_u", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const NurbsSurfaceResult*)local_this).get_segment_u)((int)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_segment_u(NurbsSurfaceResult self, int ui, float u)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_segment_u_202_comment =
  "C++ Interface:\n"
  "get_segment_u(NurbsSurfaceResult self, int ui, float u)\n"
  "\n"
  "/**\n"
  " * Accepts a u value in the range [0, 1], and assumed to be relative to the\n"
  " * indicated segment (as in eval_segment_point()), and returns the\n"
  " * corresponding u value in the entire surface (as in eval_point()).\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_segment_u_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceResult::get_segment_v(int vi, PN_stdfloat v) const
 */
static PyObject *Dtool_NurbsSurfaceResult_get_segment_v_203(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceResult)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceResult::get_segment_v(int vi, PN_stdfloat v) const
  int param1;
  float param2;
  static const char *keyword_list[] = {"vi", "v", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:get_segment_v", (char **)keyword_list, &param1, &param2)) {
    PN_stdfloat return_value = ((*(const NurbsSurfaceResult*)local_this).get_segment_v)((int)param1, (PN_stdfloat)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_segment_v(NurbsSurfaceResult self, int vi, float v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceResult_get_segment_v_203_comment =
  "C++ Interface:\n"
  "get_segment_v(NurbsSurfaceResult self, int vi, float v)\n"
  "\n"
  "/**\n"
  " * Accepts a v value in the range [0, 1], and assumed to be relative to the\n"
  " * indicated segment (as in eval_segment_point()), and returns the\n"
  " * corresponding v value in the entire surface (as in eval_point()).\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceResult_get_segment_v_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NurbsSurfaceResult::NurbsSurfaceResult(NurbsSurfaceResult const &) = default
 */
static int Dtool_Init_NurbsSurfaceResult(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NurbsSurfaceResult() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline NurbsSurfaceResult::NurbsSurfaceResult(NurbsSurfaceResult const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    NurbsSurfaceResult const *param0_this = (NurbsSurfaceResult *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NurbsSurfaceResult, 0, "NurbsSurfaceResult.NurbsSurfaceResult", true, true);
    if (param0_this != nullptr) {
      NurbsSurfaceResult *return_value = new NurbsSurfaceResult(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsSurfaceResult, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsSurfaceResult(const NurbsSurfaceResult param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NurbsSurfaceResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NurbsSurfaceResult) {
    printf("NurbsSurfaceResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NurbsSurfaceResult *local_this = (NurbsSurfaceResult *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NurbsSurfaceResult) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NurbsSurfaceResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NurbsSurfaceResult) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsSurfaceResult*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NurbsSurfaceEvaluator
 */
/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_u_order_207(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_u_order")) {
    return nullptr;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_u_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_order(const NurbsSurfaceEvaluator self, int u_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_u_order_207_comment =
  "C++ Interface:\n"
  "set_u_order(const NurbsSurfaceEvaluator self, int u_order)\n"
  "\n"
  "/**\n"
  " * Sets the order of the surface in the U direction.  This resets the knot\n"
  " * vector to the default knot vector for the number of vertices.\n"
  " *\n"
  " * The order must be 1, 2, 3, or 4, and the value is one more than the degree\n"
  " * of the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_u_order_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_u_order(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_u_order_208(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_u_order(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_u_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_u_order_208_comment =
  "C++ Interface:\n"
  "get_u_order(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the U direction as set by a previous\n"
  " * call to set_u_order().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_u_order_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_v_order_209(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_v_order")) {
    return nullptr;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_v_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_order(const NurbsSurfaceEvaluator self, int v_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_v_order_209_comment =
  "C++ Interface:\n"
  "set_v_order(const NurbsSurfaceEvaluator self, int v_order)\n"
  "\n"
  "/**\n"
  " * Sets the order of the surface in the V direction.  This resets the knot\n"
  " * vector to the default knot vector for the number of vertices.\n"
  " *\n"
  " * The order must be 1, 2, 3, or 4, and the value is one more than the degree\n"
  " * of the surface.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_v_order_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_v_order(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_v_order_210(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_v_order(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_v_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_v_order_210_comment =
  "C++ Interface:\n"
  "get_v_order(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the V direction as set by a previous\n"
  " * call to set_v_order().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_v_order_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_reset_211(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.reset")) {
    return nullptr;
  }
  // 1-void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices)
  int param1;
  int param2;
  static const char *keyword_list[] = {"num_u_vertices", "num_v_vertices", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:reset", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).reset)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset(const NurbsSurfaceEvaluator self, int num_u_vertices, int num_v_vertices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_reset_211_comment =
  "C++ Interface:\n"
  "reset(const NurbsSurfaceEvaluator self, int num_u_vertices, int num_v_vertices)\n"
  "\n"
  "/**\n"
  " * Resets all the vertices and knots to their default values, and sets the\n"
  " * surface up with the indicated number of vertices.  You must then call\n"
  " * set_vertex() repeatedly to fill in all of the vertex values appropriately.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_reset_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_212(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_num_u_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_212_comment =
  "C++ Interface:\n"
  "get_num_u_vertices(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices in the U direction on the surface.\n"
  " * This is the number passed to the last call to reset().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_213(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_num_v_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_213_comment =
  "C++ Interface:\n"
  "get_num_v_vertices(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices in the V direction on the surface.\n"
  " * This is the number passed to the last call to reset().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
 * inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &vertex)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_vertex_214(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_vertex")) {
    return nullptr;
  }
  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    int param2;
    PyObject *param3;
    float param4 = 1.0;
    static const char *keyword_list[] = {"ui", "vi", "vertex", "weight", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3 const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3f);
      if (param3_this != nullptr) {
        ((*local_this).set_vertex)((int)param1, (int)param2, *param3_this, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &vertex)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"ui", "vi", "vertex", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4 const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase4f);
      if (param3_this != nullptr) {
        ((*local_this).set_vertex)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &vertex, PN_stdfloat weight = 1.0)
    int param1;
    int param2;
    PyObject *param3;
    float param4 = 1.0;
    static const char *keyword_list[] = {"ui", "vi", "vertex", "weight", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO|f:set_vertex", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3f param3_local;
      LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_vertex)((int)param1, (int)param2, *param3_this, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &vertex)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"ui", "vi", "vertex", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4f param3_local;
      LVecBase4 const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_vertex)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase3f vertex, float weight)\n"
      "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase4f vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_214_comment =
  "C++ Interface:\n"
  "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase3f vertex, float weight)\n"
  "set_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, const LVecBase4f vertex)\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous\n"
  " * space.  In this form, the first three components of the vertex should\n"
  " * already have been scaled by the fourth component, which is the homogeneous\n"
  " * weight.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the nth control vertex of the surface.  This flavor sets the vertex as\n"
  " * a 3-d coordinate and a weight; the 3-d coordinate values are implicitly\n"
  " * scaled up by the weight factor.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const
 * inline LVecBase4 NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_vertex_215(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline LVecBase4 const &NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"ui", "vi", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_vertex", (char **)keyword_list, &param1, &param2)) {
        LVecBase4 const *return_value = &(((*(const NurbsSurfaceEvaluator*)local_this).get_vertex)((int)param1, (int)param2));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVecBase4 NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &rel_to) const
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"ui", "vi", "rel_to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:get_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "NurbsSurfaceEvaluator.get_vertex", true, true);
        if (param3_this != nullptr) {
          LVecBase4 *return_value = new LVecBase4(((*(const NurbsSurfaceEvaluator*)local_this).get_vertex)((int)param1, (int)param2, *param3_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_vertex() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi)\n"
      "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_215_comment =
  "C++ Interface:\n"
  "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi)\n"
  "get_vertex(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the surface, relative to its indicated\n"
  " * coordinate space.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth control vertex of the surface, relative to the given\n"
  " * coordinate space.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
 * inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &space)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_vertex_space_216(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_vertex_space")) {
    return nullptr;
  }
  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"ui", "vi", "space", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_vertex_space", (char **)keyword_list, &param1, &param2, &param3)) {
      NodePath const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_NodePath);
      if (param3_this != nullptr) {
        ((*local_this).set_vertex_space)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &space)
    int param1;
    int param2;
    const char *param3_str = nullptr;
    Py_ssize_t param3_len;
    static const char *keyword_list[] = {"ui", "vi", "space", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iis#:set_vertex_space", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
      ((*local_this).set_vertex_space)((int)param1, (int)param2, std::string(param3_str, param3_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space)
  // No coercion possible: inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, const NodePath space)\n"
      "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, str space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_space_216_comment =
  "C++ Interface:\n"
  "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, const NodePath space)\n"
  "set_vertex_space(const NurbsSurfaceEvaluator self, int ui, int vi, str space)\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty NodePath, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a fixed NodePath, which is always the same\n"
  " * NodePath.  Also see setting the space as a path string, which can specify a\n"
  " * different NodePath for different instances of the surface.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the coordinate space of the nth control vertex.  If this is not\n"
  " * specified, or is set to an empty string, the nth control vertex is deemed\n"
  " * to be in the coordinate space passed to evaluate().\n"
  " *\n"
  " * This specifies the space as a string, which describes the path to find the\n"
  " * node relative to the rel_to NodePath when the surface is evaluated.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_vertex_space_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &rel_to) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_vertex_space_217(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &rel_to) const
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"ui", "vi", "rel_to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:get_vertex_space", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "NurbsSurfaceEvaluator.get_vertex_space", true, true);
    if (param3_this != nullptr) {
      NodePath *return_value = new NodePath(((*(const NurbsSurfaceEvaluator*)local_this).get_vertex_space)((int)param1, (int)param2, *param3_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_space(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_space_217_comment =
  "C++ Interface:\n"
  "get_vertex_space(NurbsSurfaceEvaluator self, int ui, int vi, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate space of the nth control vertex of the surface,\n"
  " * expressed as a NodePath.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_vertex_space_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, PN_stdfloat value)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_extended_vertex_218(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_extended_vertex")) {
    return nullptr;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, PN_stdfloat value)
  int param1;
  int param2;
  int param3;
  float param4;
  static const char *keyword_list[] = {"ui", "vi", "d", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiif:set_extended_vertex", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_extended_vertex)((int)param1, (int)param2, (int)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, int d, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertex_218_comment =
  "C++ Interface:\n"
  "set_extended_vertex(const NurbsSurfaceEvaluator self, int ui, int vi, int d, float value)\n"
  "\n"
  "/**\n"
  " * Sets an n-dimensional vertex value.  This allows definition of a NURBS\n"
  " * surface or surface in a sparse n-dimensional space, typically used for\n"
  " * associating additional properties (like color or joint membership) with\n"
  " * each vertex of a surface.\n"
  " *\n"
  " * The value d is an arbitrary integer value and specifies the dimension of\n"
  " * question for this particular vertex.  Any number of dimensions may be\n"
  " * specified, and they need not be consecutive.  If a value for a given\n"
  " * dimension is not specified, is it implicitly 0.0.\n"
  " *\n"
  " * The value is implicitly scaled by the homogenous weight value--that is, the\n"
  " * fourth component of the value passed to set_vertex().  This means the\n"
  " * ordinary vertex must be set first, before the extended vertices can be set.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertex_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_extended_vertex_219(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"ui", "vi", "d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_extended_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_stdfloat return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_extended_vertex)((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extended_vertex(NurbsSurfaceEvaluator self, int ui, int vi, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_extended_vertex_219_comment =
  "C++ Interface:\n"
  "get_extended_vertex(NurbsSurfaceEvaluator self, int ui, int vi, int d)\n"
  "\n"
  "/**\n"
  " * Returns an n-dimensional vertex value.  See set_extended_vertex().  This\n"
  " * returns the value set for the indicated dimension, or 0.0 if nothing has\n"
  " * been set.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_extended_vertex_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::set_extended_vertices(int ui, int vi, int d, PN_stdfloat const values[], int num_values)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_extended_vertices_220(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_extended_vertices")) {
    return nullptr;
  }
  // 1-void NurbsSurfaceEvaluator::set_extended_vertices(int ui, int vi, int d, PN_stdfloat const values[], int num_values)
  int param1;
  int param2;
  int param3;
  PyObject *param4;
  Py_buffer param4_view;
  int param5;
  static const char *keyword_list[] = {"ui", "vi", "d", "values", "num_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiOi:set_extended_vertices", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    if (PyObject_GetBuffer(param4, &param4_view, PyBUF_FORMAT) == 0 && param4_view.format[0] == 'f' && param4_view.format[1] == 0) {
      ((*local_this).set_extended_vertices)((int)param1, (int)param2, (int)param3, (float *)param4_view.buf, (int)param5);
      PyBuffer_Release(&param4_view);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extended_vertices(const NurbsSurfaceEvaluator self, int ui, int vi, int d, buffer values, int num_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertices_220_comment =
  "C++ Interface:\n"
  "set_extended_vertices(const NurbsSurfaceEvaluator self, int ui, int vi, int d, buffer values, int num_values)\n"
  "\n"
  "/**\n"
  " * Simultaneously sets several extended values in the slots d through (d +\n"
  " * num_values - 1) from the num_values elements of the indicated array.  This\n"
  " * is equivalent to calling set_extended_vertex() num_values times.  See\n"
  " * set_extended_vertex().\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_extended_vertices_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_knots_221(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_num_u_knots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_knots_221_comment =
  "C++ Interface:\n"
  "get_num_u_knots(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knot values in the surface in the U direction.  This\n"
  " * is based on the number of vertices and the order.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_knots_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_u_knot_222(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_u_knot")) {
    return nullptr;
  }
  // 1-void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "knot", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_u_knot", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_u_knot)((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_u_knot_222_comment =
  "C++ Interface:\n"
  "set_u_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n"
  "\n"
  "/**\n"
  " * Sets the value of the nth knot.  Each knot value should be greater than or\n"
  " * equal to the preceding value.  If no knot values are set, a default knot\n"
  " * vector is supplied.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_u_knot_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_u_knot_223(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_u_knot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_knot(NurbsSurfaceEvaluator self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_u_knot_223_comment =
  "C++ Interface:\n"
  "get_u_knot(NurbsSurfaceEvaluator self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the value of the nth knot.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_u_knot_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::normalize_u_knots(void)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_normalize_u_knots_225(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.normalize_u_knots")) {
    return nullptr;
  }
  // 1-void NurbsSurfaceEvaluator::normalize_u_knots(void)
  ((*local_this).normalize_u_knots)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_normalize_u_knots_225_comment =
  "C++ Interface:\n"
  "normalize_u_knots(const NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Normalizes the knot sequence so that the parametric range of the surface in\n"
  " * the U direction is 0 .. 1.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_normalize_u_knots_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_knots_226(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_num_v_knots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_knots_226_comment =
  "C++ Interface:\n"
  "get_num_v_knots(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knot values in the surface in the V direction.  This\n"
  " * is based on the number of vertices and the order.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_knots_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_set_v_knot_227(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.set_v_knot")) {
    return nullptr;
  }
  // 1-void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "knot", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_v_knot", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_v_knot)((int)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_set_v_knot_227_comment =
  "C++ Interface:\n"
  "set_v_knot(const NurbsSurfaceEvaluator self, int i, float knot)\n"
  "\n"
  "/**\n"
  " * Sets the value of the nth knot.  Each knot value should be greater than or\n"
  " * equal to the preceding value.  If no knot values are set, a default knot\n"
  " * vector is supplied.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_set_v_knot_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_v_knot_228(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_v_knot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_knot(NurbsSurfaceEvaluator self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_v_knot_228_comment =
  "C++ Interface:\n"
  "get_v_knot(NurbsSurfaceEvaluator self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the value of the nth knot.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_v_knot_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::normalize_v_knots(void)
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_normalize_v_knots_230(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.normalize_v_knots")) {
    return nullptr;
  }
  // 1-void NurbsSurfaceEvaluator::normalize_v_knots(void)
  ((*local_this).normalize_v_knots)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_normalize_v_knots_230_comment =
  "C++ Interface:\n"
  "normalize_v_knots(const NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Normalizes the knot sequence so that the parametric range of the surface in\n"
  " * the U direction is 0 .. 1.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_normalize_v_knots_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_u_segments_231(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_num_u_segments)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_segments_231_comment =
  "C++ Interface:\n"
  "get_num_u_segments(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments in the surface in the U\n"
  " * direction.  This is based on the knot vector.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_u_segments_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_get_num_v_segments_232(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_num_v_segments)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_segments_232_comment =
  "C++ Interface:\n"
  "get_num_v_segments(NurbsSurfaceEvaluator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of piecewise continuous segments in the surface in the V\n"
  " * direction.  This is based on the knot vector.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_get_num_v_segments_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to = NodePath()) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_evaluate_233(PyObject *self, PyObject *args, PyObject *kwds) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to = NodePath()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "rel_to")) {
    NodePath const *param1_this;
    const NodePath &param1_ref = NodePath();
    if (param1 == nullptr) {
      param1_this = &param1_ref;
    } else {
      param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NurbsSurfaceEvaluator.evaluate", true, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      PointerTo< NurbsSurfaceResult > return_value = ((*(const NurbsSurfaceEvaluator*)local_this).evaluate)(*param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      NurbsSurfaceResult *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_NurbsSurfaceResult, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evaluate(NurbsSurfaceEvaluator self, const NodePath rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_evaluate_233_comment =
  "C++ Interface:\n"
  "evaluate(NurbsSurfaceEvaluator self, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Returns a NurbsSurfaceResult object that represents the result of applying\n"
  " * the knots to all of the current values of the vertices, transformed into\n"
  " * the indicated coordinate space.\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_evaluate_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NurbsSurfaceEvaluator::output(std::ostream &out) const
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_output_234(PyObject *self, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NurbsSurfaceEvaluator)) {
    return nullptr;
  }
  // 1-void NurbsSurfaceEvaluator::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "NurbsSurfaceEvaluator.output", false, true);
  if (arg_this != nullptr) {
    ((*(const NurbsSurfaceEvaluator*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NurbsSurfaceEvaluator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NurbsSurfaceEvaluator_output_234_comment =
  "C++ Interface:\n"
  "output(NurbsSurfaceEvaluator self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NurbsSurfaceEvaluator_output_234_comment = nullptr;
#endif

static PyObject *Dtool_NurbsSurfaceEvaluator_u_order_Getter(PyObject *self, void *) {
  const NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int NurbsSurfaceEvaluator::get_u_order(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_u_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_NurbsSurfaceEvaluator_u_order_Setter(PyObject *self, PyObject *arg, void *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.u_order")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete u_order attribute");
    return -1;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_u_order(int u_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_u_order)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_u_order(const NurbsSurfaceEvaluator self, int u_order)\n");
  }
  return -1;
}

static PyObject *Dtool_NurbsSurfaceEvaluator_v_order_Getter(PyObject *self, void *) {
  const NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int NurbsSurfaceEvaluator::get_v_order(void) const
  int return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_v_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_NurbsSurfaceEvaluator_v_order_Setter(PyObject *self, PyObject *arg, void *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.v_order")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete v_order attribute");
    return -1;
  }
  // 1-inline void NurbsSurfaceEvaluator::set_v_order(int v_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_v_order)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_v_order(const NurbsSurfaceEvaluator self, int v_order)\n");
  }
  return -1;
}

/**
 * sequence length function for property NurbsSurfaceEvaluator::u_knots
 */
static Py_ssize_t Dtool_NurbsSurfaceEvaluator_u_knots_Len(PyObject *self) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_u_knots)();
}

/**
 * sequence getter for property NurbsSurfaceEvaluator::u_knots
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_u_knots_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_u_knots)()) {
    PyErr_SetString(PyExc_IndexError, "NurbsSurfaceEvaluator.u_knots[] index out of range");
    return nullptr;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const
  PN_stdfloat return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_u_knot)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_knot(NurbsSurfaceEvaluator self, index)\n");
  }
}

static int Dtool_NurbsSurfaceEvaluator_u_knots_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.u_knots")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_u_knots)()) {
    PyErr_SetString(PyExc_IndexError, "NurbsSurfaceEvaluator.u_knots[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete u_knots[] attribute");
    return -1;
  }
  // 1-void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_u_knot)(index, (PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_u_knot(const NurbsSurfaceEvaluator self, index, float knot)\n");
  }
  return -1;
}

static PyObject *Dtool_NurbsSurfaceEvaluator_u_knots_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "NurbsSurfaceEvaluator.u_knots");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_NurbsSurfaceEvaluator_u_knots_Len;
    wrap->_getitem_func = &Dtool_NurbsSurfaceEvaluator_u_knots_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_NurbsSurfaceEvaluator_u_knots_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property NurbsSurfaceEvaluator::v_knots
 */
static Py_ssize_t Dtool_NurbsSurfaceEvaluator_v_knots_Len(PyObject *self) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_v_knots)();
}

/**
 * sequence getter for property NurbsSurfaceEvaluator::v_knots
 */
static PyObject *Dtool_NurbsSurfaceEvaluator_v_knots_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_v_knots)()) {
    PyErr_SetString(PyExc_IndexError, "NurbsSurfaceEvaluator.v_knots[] index out of range");
    return nullptr;
  }
  // 1-PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const
  PN_stdfloat return_value = ((*(const NurbsSurfaceEvaluator*)local_this).get_v_knot)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_knot(NurbsSurfaceEvaluator self, index)\n");
  }
}

static int Dtool_NurbsSurfaceEvaluator_v_knots_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this, "NurbsSurfaceEvaluator.v_knots")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_v_knots)()) {
    PyErr_SetString(PyExc_IndexError, "NurbsSurfaceEvaluator.v_knots[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete v_knots[] attribute");
    return -1;
  }
  // 1-void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_v_knot)(index, (PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_v_knot(const NurbsSurfaceEvaluator self, index, float knot)\n");
  }
  return -1;
}

static PyObject *Dtool_NurbsSurfaceEvaluator_v_knots_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "NurbsSurfaceEvaluator.v_knots");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_NurbsSurfaceEvaluator_v_knots_Len;
    wrap->_getitem_func = &Dtool_NurbsSurfaceEvaluator_v_knots_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_NurbsSurfaceEvaluator_v_knots_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void)
 * inline NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(NurbsSurfaceEvaluator const &) = default
 */
static int Dtool_Init_NurbsSurfaceEvaluator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NurbsSurfaceEvaluator() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void)
      NurbsSurfaceEvaluator *return_value = new NurbsSurfaceEvaluator();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsSurfaceEvaluator, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(NurbsSurfaceEvaluator const &) = default
      NurbsSurfaceEvaluator const *arg_this = (NurbsSurfaceEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsSurfaceEvaluator, 0, "NurbsSurfaceEvaluator.NurbsSurfaceEvaluator", true, true);
      if (arg_this != nullptr) {
        NurbsSurfaceEvaluator *return_value = new NurbsSurfaceEvaluator(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NurbsSurfaceEvaluator, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NurbsSurfaceEvaluator() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NurbsSurfaceEvaluator()\n"
      "NurbsSurfaceEvaluator(const NurbsSurfaceEvaluator param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsSurfaceEvaluator_get_u_knots(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_u_knots)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsSurfaceEvaluator_get_u_knot_223(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NurbsSurfaceEvaluator_get_v_knots(PyObject *self, PyObject *) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_v_knots)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NurbsSurfaceEvaluator_get_v_knot_228(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NurbsSurfaceEvaluator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NurbsSurfaceEvaluator) {
    printf("NurbsSurfaceEvaluator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NurbsSurfaceEvaluator *local_this = (NurbsSurfaceEvaluator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NurbsSurfaceEvaluator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NurbsSurfaceEvaluator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NurbsSurfaceEvaluator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NurbsSurfaceEvaluator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RopeNode
 */
/**
 * Python function wrapper for:
 * inline void RopeNode::set_curve(NurbsCurveEvaluator *curve)
 */
static PyObject *Dtool_RopeNode_set_curve_245(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_curve")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_curve(NurbsCurveEvaluator *curve)
  NurbsCurveEvaluator *arg_this = (NurbsCurveEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsCurveEvaluator, 1, "RopeNode.set_curve", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_curve)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve(const RopeNode self, NurbsCurveEvaluator curve)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_curve_245_comment =
  "C++ Interface:\n"
  "set_curve(const RopeNode self, NurbsCurveEvaluator curve)\n"
  "\n"
  "/**\n"
  " * Sets the particular curve represented by the RopeNode.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_curve_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NurbsCurveEvaluator *RopeNode::get_curve(void) const
 */
static PyObject *Dtool_RopeNode_get_curve_246(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline NurbsCurveEvaluator *RopeNode::get_curve(void) const
  NurbsCurveEvaluator *return_value = ((*(const RopeNode*)local_this).get_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NurbsCurveEvaluator, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_curve_246_comment =
  "C++ Interface:\n"
  "get_curve(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the curve represented by the RopeNode.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_curve_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode)
 */
static PyObject *Dtool_RopeNode_set_render_mode_247(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_render_mode")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_render_mode)((RopeNode::RenderMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_mode(const RopeNode self, int render_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_render_mode_247_comment =
  "C++ Interface:\n"
  "set_render_mode(const RopeNode self, int render_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the method used to render the rope.  The simplest is RM_thread,\n"
  " * which just draws a one-pixel line segment.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_render_mode_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RopeNode::RenderMode RopeNode::get_render_mode(void) const
 */
static PyObject *Dtool_RopeNode_get_render_mode_248(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline RopeNode::RenderMode RopeNode::get_render_mode(void) const
  RopeNode::RenderMode return_value = ((*(const RopeNode*)local_this).get_render_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_render_mode_248_comment =
  "C++ Interface:\n"
  "get_render_mode(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the method used to render the rope.  See set_render_mode().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_render_mode_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode)
 */
static PyObject *Dtool_RopeNode_set_uv_mode_249(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_uv_mode")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_uv_mode)((RopeNode::UVMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_mode(const RopeNode self, int uv_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_uv_mode_249_comment =
  "C++ Interface:\n"
  "set_uv_mode(const RopeNode self, int uv_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the algorithm to use to generate UV's for the rope.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_uv_mode_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RopeNode::UVMode RopeNode::get_uv_mode(void) const
 */
static PyObject *Dtool_RopeNode_get_uv_mode_250(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline RopeNode::UVMode RopeNode::get_uv_mode(void) const
  RopeNode::UVMode return_value = ((*(const RopeNode*)local_this).get_uv_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_uv_mode_250_comment =
  "C++ Interface:\n"
  "get_uv_mode(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the algorithm to use to generate UV's for the rope.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_uv_mode_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_uv_direction(bool u_dominant)
 */
static PyObject *Dtool_RopeNode_set_uv_direction_251(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_uv_direction")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_uv_direction(bool u_dominant)
  ((*local_this).set_uv_direction)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_direction(const RopeNode self, bool u_dominant)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_uv_direction_251_comment =
  "C++ Interface:\n"
  "set_uv_direction(const RopeNode self, bool u_dominant)\n"
  "\n"
  "/**\n"
  " * Specify true to vary the U coordinate down the length of the rope, or false\n"
  " * to vary the V coordinate.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_uv_direction_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::get_uv_direction(void) const
 */
static PyObject *Dtool_RopeNode_get_uv_direction_252(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline bool RopeNode::get_uv_direction(void) const
  bool return_value = ((*(const RopeNode*)local_this).get_uv_direction)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_uv_direction_252_comment =
  "C++ Interface:\n"
  "get_uv_direction(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the rope runs down the U coordinate of the texture, or\n"
  " * false if it runs down the V coordinate.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_uv_direction_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_uv_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_RopeNode_set_uv_scale_253(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_uv_scale")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_uv_scale(PN_stdfloat scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_uv_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_scale(const RopeNode self, float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_uv_scale_253_comment =
  "C++ Interface:\n"
  "set_uv_scale(const RopeNode self, float scale)\n"
  "\n"
  "/**\n"
  " * Specifies an additional scaling factor to apply to generated UV's along the\n"
  " * rope.  This scale factor is applied in whichever direction is along the\n"
  " * rope, as specified by set_uv_direction().\n"
  " */";
#else
static const char *Dtool_RopeNode_set_uv_scale_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RopeNode::get_uv_scale(void) const
 */
static PyObject *Dtool_RopeNode_get_uv_scale_254(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat RopeNode::get_uv_scale(void) const
  PN_stdfloat return_value = ((*(const RopeNode*)local_this).get_uv_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_uv_scale_254_comment =
  "C++ Interface:\n"
  "get_uv_scale(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the scaling factor to apply to generated UV's for the rope.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_uv_scale_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode)
 */
static PyObject *Dtool_RopeNode_set_normal_mode_255(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_normal_mode")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_normal_mode)((RopeNode::NormalMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_normal_mode(const RopeNode self, int normal_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_normal_mode_255_comment =
  "C++ Interface:\n"
  "set_normal_mode(const RopeNode self, int normal_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the kind of normals to generate for the rope.  This is only\n"
  " * applicable when the RenderMode is set to RM_tube; in the other render\n"
  " * modes, normals are never generated.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_normal_mode_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const
 */
static PyObject *Dtool_RopeNode_get_normal_mode_256(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const
  RopeNode::NormalMode return_value = ((*(const RopeNode*)local_this).get_normal_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_normal_mode_256_comment =
  "C++ Interface:\n"
  "get_normal_mode(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the kind of normals to generate for the rope.  This is only\n"
  " * applicable when the RenderMode is set to RM_tube.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_normal_mode_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_tube_up(LVector3 const &tube_up)
 */
static PyObject *Dtool_RopeNode_set_tube_up_257(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_tube_up")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_tube_up(LVector3 const &tube_up)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RopeNode.set_tube_up", "LVector3f");
  }
  ((*local_this).set_tube_up)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tube_up(const RopeNode self, const LVector3f tube_up)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_tube_up_257_comment =
  "C++ Interface:\n"
  "set_tube_up(const RopeNode self, const LVector3f tube_up)\n"
  "\n"
  "/**\n"
  " * Specifies a normal vector, generally perpendicular to the main axis of the\n"
  " * starting point of the curve, that controls the \"top\" of the curve, when\n"
  " * RenderMode is RM_tube.  This is used to orient the vertices that make up\n"
  " * the tube.  If this vector is too nearly parallel with the starting\n"
  " * direction of the curve, there may be a tendency for the whole tube to\n"
  " * gimble-lock around its primary axis.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_tube_up_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &RopeNode::get_tube_up(void) const
 */
static PyObject *Dtool_RopeNode_get_tube_up_258(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline LVector3 const &RopeNode::get_tube_up(void) const
  LVector3 const *return_value = &(((*(const RopeNode*)local_this).get_tube_up)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_tube_up_258_comment =
  "C++ Interface:\n"
  "get_tube_up(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the normal vector used to control the \"top\" of the curve, when\n"
  " * RenderMode is RM_tube.  See set_tube_up().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_tube_up_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_use_vertex_color(bool flag)
 */
static PyObject *Dtool_RopeNode_set_use_vertex_color_259(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_use_vertex_color")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_use_vertex_color(bool flag)
  ((*local_this).set_use_vertex_color)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_vertex_color(const RopeNode self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_use_vertex_color_259_comment =
  "C++ Interface:\n"
  "set_use_vertex_color(const RopeNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the \"use vertex color\" flag.  When this is true, the R, G, B, A vertex\n"
  " * color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,\n"
  " * respectively, of the extended vertex values, where n is the value returned\n"
  " * by get_vertex_color_dimension().  Use\n"
  " * NurbsCurveEvaluator::set_extended_vertex() to set these values.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_use_vertex_color_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::get_use_vertex_color(void) const
 */
static PyObject *Dtool_RopeNode_get_use_vertex_color_260(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline bool RopeNode::get_use_vertex_color(void) const
  bool return_value = ((*(const RopeNode*)local_this).get_use_vertex_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_use_vertex_color_260_comment =
  "C++ Interface:\n"
  "get_use_vertex_color(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"use vertex color\" flag.  See set_use_vertex_color().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_use_vertex_color_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int RopeNode::get_vertex_color_dimension(void)
 */
static PyObject *Dtool_RopeNode_get_vertex_color_dimension_261(PyObject *, PyObject *) {
  // 1-static inline int RopeNode::get_vertex_color_dimension(void)
  int return_value = (RopeNode::get_vertex_color_dimension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_vertex_color_dimension_261_comment =
  "C++ Interface:\n"
  "get_vertex_color_dimension()\n"
  "\n"
  "/**\n"
  " * Returns the numeric extended dimension in which the color components should\n"
  " * be found.  See NurbsCurveEvaluator::set_extended_vertex().\n"
  " *\n"
  " * The color components will be expected at (n, n + 1, n + 2, n + 3).\n"
  " */";
#else
static const char *Dtool_RopeNode_get_vertex_color_dimension_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_num_subdiv(int num_subdiv)
 */
static PyObject *Dtool_RopeNode_set_num_subdiv_262(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_num_subdiv")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_num_subdiv(int num_subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_subdiv)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_subdiv(const RopeNode self, int num_subdiv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_num_subdiv_262_comment =
  "C++ Interface:\n"
  "set_num_subdiv(const RopeNode self, int num_subdiv)\n"
  "\n"
  "/**\n"
  " * Specifies the number of subdivisions per cubic segment (that is, per unique\n"
  " * knot value) to draw in a fixed uniform tesselation of the curve.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_num_subdiv_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RopeNode::get_num_subdiv(void) const
 */
static PyObject *Dtool_RopeNode_get_num_subdiv_263(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline int RopeNode::get_num_subdiv(void) const
  int return_value = ((*(const RopeNode*)local_this).get_num_subdiv)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_num_subdiv_263_comment =
  "C++ Interface:\n"
  "get_num_subdiv(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subdivisions per cubic segment to draw.  See\n"
  " * set_num_subdiv().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_num_subdiv_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_num_slices(int num_slices)
 */
static PyObject *Dtool_RopeNode_set_num_slices_264(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_num_slices")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_num_slices(int num_slices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_slices)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_slices(const RopeNode self, int num_slices)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_num_slices_264_comment =
  "C++ Interface:\n"
  "set_num_slices(const RopeNode self, int num_slices)\n"
  "\n"
  "/**\n"
  " * Specifies the number of radial subdivisions to make if RenderMode is\n"
  " * RM_tube.  It is ignored in the other render modes.\n"
  " *\n"
  " * Increasing this number increases the roundness of a cross-section of the\n"
  " * tube.  The minimum value for a dimensional tube is 3; setting it to 2 will\n"
  " * get you a thin piece of tape (which is similar to RM_billboard, except it\n"
  " * won't rotate to face the camera).\n"
  " */";
#else
static const char *Dtool_RopeNode_set_num_slices_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RopeNode::get_num_slices(void) const
 */
static PyObject *Dtool_RopeNode_get_num_slices_265(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline int RopeNode::get_num_slices(void) const
  int return_value = ((*(const RopeNode*)local_this).get_num_slices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_num_slices_265_comment =
  "C++ Interface:\n"
  "get_num_slices(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of radial subdivisions to make if RenderMode is RM_tube.\n"
  " * It is ignored in the other render modes.  See set_num_slices().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_num_slices_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_use_vertex_thickness(bool flag)
 */
static PyObject *Dtool_RopeNode_set_use_vertex_thickness_266(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_use_vertex_thickness")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_use_vertex_thickness(bool flag)
  ((*local_this).set_use_vertex_thickness)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_vertex_thickness(const RopeNode self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_use_vertex_thickness_266_comment =
  "C++ Interface:\n"
  "set_use_vertex_thickness(const RopeNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the \"use vertex thickness\" flag.  When this is true, the vertex\n"
  " * thickness is assumed to be stored as the dimension\n"
  " * get_vertex_thickness_dimension(), of the extended vertex values.  Use\n"
  " * NurbsCurveEvaluator::set_extended_vertex() to set these values.\n"
  " *\n"
  " * In this mode, the overall thickness is also applied as a scale to the\n"
  " * vertex thickness.  Not all render modes support vertex thickness.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_use_vertex_thickness_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::get_use_vertex_thickness(void) const
 */
static PyObject *Dtool_RopeNode_get_use_vertex_thickness_267(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline bool RopeNode::get_use_vertex_thickness(void) const
  bool return_value = ((*(const RopeNode*)local_this).get_use_vertex_thickness)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_use_vertex_thickness_267_comment =
  "C++ Interface:\n"
  "get_use_vertex_thickness(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"use vertex thickness\" flag.  See set_use_vertex_thickness().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_use_vertex_thickness_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int RopeNode::get_vertex_thickness_dimension(void)
 */
static PyObject *Dtool_RopeNode_get_vertex_thickness_dimension_268(PyObject *, PyObject *) {
  // 1-static inline int RopeNode::get_vertex_thickness_dimension(void)
  int return_value = (RopeNode::get_vertex_thickness_dimension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_vertex_thickness_dimension_268_comment =
  "C++ Interface:\n"
  "get_vertex_thickness_dimension()\n"
  "\n"
  "/**\n"
  " * Returns the numeric extended dimension in which the thickness component\n"
  " * should be found.  See NurbsCurveEvaluator::set_extended_vertex().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_vertex_thickness_dimension_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_thickness(PN_stdfloat thickness)
 */
static PyObject *Dtool_RopeNode_set_thickness_269(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_thickness")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_thickness(PN_stdfloat thickness)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_thickness)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thickness(const RopeNode self, float thickness)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_thickness_269_comment =
  "C++ Interface:\n"
  "set_thickness(const RopeNode self, float thickness)\n"
  "\n"
  "/**\n"
  " * Specifies the thickness of the rope, in pixels or in spatial units,\n"
  " * depending on the render mode.  See set_render_mode().\n"
  " *\n"
  " * The thickness may also be specified on a per-vertex basis.  See\n"
  " * set_use_vertex_thickness().\n"
  " */";
#else
static const char *Dtool_RopeNode_set_thickness_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat RopeNode::get_thickness(void) const
 */
static PyObject *Dtool_RopeNode_get_thickness_270(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat RopeNode::get_thickness(void) const
  PN_stdfloat return_value = ((*(const RopeNode*)local_this).get_thickness)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_thickness_270_comment =
  "C++ Interface:\n"
  "get_thickness(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness of the rope.  See set_thickness().\n"
  " */";
#else
static const char *Dtool_RopeNode_get_thickness_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::set_matrix(LMatrix4 const &matrix)
 */
static PyObject *Dtool_RopeNode_set_matrix_271(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.set_matrix")) {
    return nullptr;
  }
  // 1-inline void RopeNode::set_matrix(LMatrix4 const &matrix)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "RopeNode.set_matrix", "LMatrix4f");
  }
  ((*local_this).set_matrix)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_matrix(const RopeNode self, const LMatrix4f matrix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_set_matrix_271_comment =
  "C++ Interface:\n"
  "set_matrix(const RopeNode self, const LMatrix4f matrix)\n"
  "\n"
  "/**\n"
  " * Specifies an optional matrix which is used to transform each control vertex\n"
  " * after it has been transformed into the RopeNode's coordinate space, but\n"
  " * before the polygon vertices are generated.\n"
  " */";
#else
static const char *Dtool_RopeNode_set_matrix_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RopeNode::clear_matrix(void)
 */
static PyObject *Dtool_RopeNode_clear_matrix_272(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.clear_matrix")) {
    return nullptr;
  }
  // 1-inline void RopeNode::clear_matrix(void)
  ((*local_this).clear_matrix)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_clear_matrix_272_comment =
  "C++ Interface:\n"
  "clear_matrix(const RopeNode self)\n"
  "\n"
  "/**\n"
  " * Resets the node's matrix to identity.  See set_matrix().\n"
  " */";
#else
static const char *Dtool_RopeNode_clear_matrix_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RopeNode::has_matrix(void) const
 */
static PyObject *Dtool_RopeNode_has_matrix_273(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline bool RopeNode::has_matrix(void) const
  bool return_value = ((*(const RopeNode*)local_this).has_matrix)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_has_matrix_273_comment =
  "C++ Interface:\n"
  "has_matrix(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the node has a matrix set, false otherwise.  See\n"
  " * set_matrix().\n"
  " */";
#else
static const char *Dtool_RopeNode_has_matrix_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &RopeNode::get_matrix(void) const
 */
static PyObject *Dtool_RopeNode_get_matrix_274(PyObject *self, PyObject *) {
  RopeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RopeNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &RopeNode::get_matrix(void) const
  LMatrix4 const *return_value = &(((*(const RopeNode*)local_this).get_matrix)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_matrix_274_comment =
  "C++ Interface:\n"
  "get_matrix(RopeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the optional matrix which is used to transform each control vertex\n"
  " * after it has been transformed into the RopeNode's coordinate space, but\n"
  " * before the polygon vertices are generated.\n"
  " */";
#else
static const char *Dtool_RopeNode_get_matrix_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RopeNode::reset_bound(NodePath const &rel_to)
 */
static PyObject *Dtool_RopeNode_reset_bound_275(PyObject *self, PyObject *arg) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.reset_bound")) {
    return nullptr;
  }
  // 1-void RopeNode::reset_bound(NodePath const &rel_to)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "RopeNode.reset_bound", true, true);
  if (arg_this != nullptr) {
    ((*local_this).reset_bound)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_bound(const RopeNode self, const NodePath rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_reset_bound_275_comment =
  "C++ Interface:\n"
  "reset_bound(const RopeNode self, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Recomputes the bounding volume.  This is normally called automatically, but\n"
  " * it must occasionally be called explicitly when the curve has changed\n"
  " * properties outside of this node's knowledge.\n"
  " */";
#else
static const char *Dtool_RopeNode_reset_bound_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RopeNode::get_class_type(void)
 */
static PyObject *Dtool_RopeNode_get_class_type_299(PyObject *, PyObject *) {
  // 1-static TypeHandle RopeNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RopeNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RopeNode_get_class_type_299_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RopeNode_get_class_type_299_comment = nullptr;
#endif

static PyObject *Dtool_RopeNode_curve_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NurbsCurveEvaluator *RopeNode::get_curve(void) const
  NurbsCurveEvaluator *return_value = ((*(const RopeNode*)local_this).get_curve)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NurbsCurveEvaluator, true, false);
}

static int Dtool_RopeNode_curve_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.curve")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete curve attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_curve(NurbsCurveEvaluator *curve)
  NurbsCurveEvaluator *arg_this = (NurbsCurveEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsCurveEvaluator, 1, "RopeNode.set_curve", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_curve)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_curve(const RopeNode self, NurbsCurveEvaluator curve)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_render_mode_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RopeNode::RenderMode RopeNode::get_render_mode(void) const
  RopeNode::RenderMode return_value = ((*(const RopeNode*)local_this).get_render_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_render_mode_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.render_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete render_mode attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_render_mode)((RopeNode::RenderMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_render_mode(const RopeNode self, int render_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_uv_mode_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RopeNode::UVMode RopeNode::get_uv_mode(void) const
  RopeNode::UVMode return_value = ((*(const RopeNode*)local_this).get_uv_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_uv_mode_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.uv_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete uv_mode attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_uv_mode)((RopeNode::UVMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_uv_mode(const RopeNode self, int uv_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_uv_direction_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool RopeNode::get_uv_direction(void) const
  bool return_value = ((*(const RopeNode*)local_this).get_uv_direction)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_uv_direction_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.uv_direction")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete uv_direction attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_uv_direction(bool u_dominant)
  ((*local_this).set_uv_direction)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_uv_direction(const RopeNode self, bool u_dominant)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_uv_scale_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat RopeNode::get_uv_scale(void) const
  PN_stdfloat return_value = ((*(const RopeNode*)local_this).get_uv_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_uv_scale_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.uv_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete uv_scale attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_uv_scale(PN_stdfloat scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_uv_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_uv_scale(const RopeNode self, float scale)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_normal_mode_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const
  RopeNode::NormalMode return_value = ((*(const RopeNode*)local_this).get_normal_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_normal_mode_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.normal_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete normal_mode attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_normal_mode)((RopeNode::NormalMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_normal_mode(const RopeNode self, int normal_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_tube_up_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVector3 const &RopeNode::get_tube_up(void) const
  LVector3 const *return_value = &(((*(const RopeNode*)local_this).get_tube_up)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

static int Dtool_RopeNode_tube_up_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.tube_up")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tube_up attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_tube_up(LVector3 const &tube_up)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RopeNode.set_tube_up", "LVector3f");
    return -1;
  }
  ((*local_this).set_tube_up)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tube_up(const RopeNode self, const LVector3f tube_up)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_use_vertex_color_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool RopeNode::get_use_vertex_color(void) const
  bool return_value = ((*(const RopeNode*)local_this).get_use_vertex_color)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_use_vertex_color_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.use_vertex_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete use_vertex_color attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_use_vertex_color(bool flag)
  ((*local_this).set_use_vertex_color)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_use_vertex_color(const RopeNode self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_vertex_color_dimension_Getter(PyObject *self, void *) {
  // 1-static inline int RopeNode::get_vertex_color_dimension(void)
  int return_value = (RopeNode::get_vertex_color_dimension)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_RopeNode_num_subdiv_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int RopeNode::get_num_subdiv(void) const
  int return_value = ((*(const RopeNode*)local_this).get_num_subdiv)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_num_subdiv_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.num_subdiv")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete num_subdiv attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_num_subdiv(int num_subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_num_subdiv)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_num_subdiv(const RopeNode self, int num_subdiv)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_num_slices_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int RopeNode::get_num_slices(void) const
  int return_value = ((*(const RopeNode*)local_this).get_num_slices)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_num_slices_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.num_slices")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete num_slices attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_num_slices(int num_slices)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_num_slices)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_num_slices(const RopeNode self, int num_slices)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_use_vertex_thickness_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool RopeNode::get_use_vertex_thickness(void) const
  bool return_value = ((*(const RopeNode*)local_this).get_use_vertex_thickness)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_use_vertex_thickness_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.use_vertex_thickness")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete use_vertex_thickness attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_use_vertex_thickness(bool flag)
  ((*local_this).set_use_vertex_thickness)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_use_vertex_thickness(const RopeNode self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_vertex_thickness_dimension_Getter(PyObject *self, void *) {
  // 1-static inline int RopeNode::get_vertex_thickness_dimension(void)
  int return_value = (RopeNode::get_vertex_thickness_dimension)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_RopeNode_thickness_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat RopeNode::get_thickness(void) const
  PN_stdfloat return_value = ((*(const RopeNode*)local_this).get_thickness)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RopeNode_thickness_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.thickness")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete thickness attribute");
    return -1;
  }
  // 1-inline void RopeNode::set_thickness(PN_stdfloat thickness)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_thickness)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_thickness(const RopeNode self, float thickness)\n");
  }
  return -1;
}

static PyObject *Dtool_RopeNode_matrix_Getter(PyObject *self, void *) {
  const RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RopeNode, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_matrix()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LMatrix4 const &RopeNode::get_matrix(void) const
  LMatrix4 const *return_value = &(((*(const RopeNode*)local_this).get_matrix)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_RopeNode_matrix_Setter(PyObject *self, PyObject *arg, void *) {
  RopeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RopeNode, (void **)&local_this, "RopeNode.matrix")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete matrix attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_matrix();
    return 0;
  }
  // 1-inline void RopeNode::set_matrix(LMatrix4 const &matrix)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RopeNode.set_matrix", "LMatrix4f");
    return -1;
  }
  ((*local_this).set_matrix)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_matrix(const RopeNode self, const LMatrix4f matrix)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit RopeNode::RopeNode(std::string const &name)
 */
static int Dtool_Init_RopeNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RopeNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit RopeNode::RopeNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      RopeNode *return_value = new RopeNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RopeNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RopeNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RopeNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RopeNode) {
    printf("RopeNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RopeNode *local_this = (RopeNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RopeNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RopeNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RopeNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RopeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RopeNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SheetNode
 */
/**
 * Python function wrapper for:
 * inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface)
 */
static PyObject *Dtool_SheetNode_set_surface_303(PyObject *self, PyObject *arg) {
  SheetNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_surface")) {
    return nullptr;
  }
  // 1-inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface)
  NurbsSurfaceEvaluator *arg_this = (NurbsSurfaceEvaluator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NurbsSurfaceEvaluator, 1, "SheetNode.set_surface", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_surface)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface(const SheetNode self, NurbsSurfaceEvaluator surface)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_surface_303_comment =
  "C++ Interface:\n"
  "set_surface(const SheetNode self, NurbsSurfaceEvaluator surface)\n"
  "\n"
  "/**\n"
  " * Sets the particular surface represented by the SheetNode.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_surface_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const
 */
static PyObject *Dtool_SheetNode_get_surface_304(PyObject *self, PyObject *) {
  SheetNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SheetNode)) {
    return nullptr;
  }
  // 1-inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const
  NurbsSurfaceEvaluator *return_value = ((*(const SheetNode*)local_this).get_surface)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NurbsSurfaceEvaluator, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_surface_304_comment =
  "C++ Interface:\n"
  "get_surface(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the surface represented by the SheetNode.\n"
  " */";
#else
static const char *Dtool_SheetNode_get_surface_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SheetNode::set_use_vertex_color(bool flag)
 */
static PyObject *Dtool_SheetNode_set_use_vertex_color_305(PyObject *self, PyObject *arg) {
  SheetNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_use_vertex_color")) {
    return nullptr;
  }
  // 1-inline void SheetNode::set_use_vertex_color(bool flag)
  ((*local_this).set_use_vertex_color)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_vertex_color(const SheetNode self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_use_vertex_color_305_comment =
  "C++ Interface:\n"
  "set_use_vertex_color(const SheetNode self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the \"use vertex color\" flag.  When this is true, the R, G, B, A vertex\n"
  " * color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,\n"
  " * of the extended vertex values.  Use\n"
  " * NurbsCurveEvaluator::set_extended_vertex() to set these values.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_use_vertex_color_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SheetNode::get_use_vertex_color(void) const
 */
static PyObject *Dtool_SheetNode_get_use_vertex_color_306(PyObject *self, PyObject *) {
  SheetNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SheetNode)) {
    return nullptr;
  }
  // 1-inline bool SheetNode::get_use_vertex_color(void) const
  bool return_value = ((*(const SheetNode*)local_this).get_use_vertex_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_use_vertex_color_306_comment =
  "C++ Interface:\n"
  "get_use_vertex_color(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"use vertex color\" flag.  See set_use_vertex_color().\n"
  " */";
#else
static const char *Dtool_SheetNode_get_use_vertex_color_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SheetNode::set_num_u_subdiv(int num_u_subdiv)
 */
static PyObject *Dtool_SheetNode_set_num_u_subdiv_307(PyObject *self, PyObject *arg) {
  SheetNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_num_u_subdiv")) {
    return nullptr;
  }
  // 1-inline void SheetNode::set_num_u_subdiv(int num_u_subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_u_subdiv)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_u_subdiv(const SheetNode self, int num_u_subdiv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_num_u_subdiv_307_comment =
  "C++ Interface:\n"
  "set_num_u_subdiv(const SheetNode self, int num_u_subdiv)\n"
  "\n"
  "/**\n"
  " * Specifies the number of subdivisions per cubic segment (that is, per unique\n"
  " * knot value) to draw in a fixed uniform tesselation of the surface in the U\n"
  " * direction.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_num_u_subdiv_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SheetNode::get_num_u_subdiv(void) const
 */
static PyObject *Dtool_SheetNode_get_num_u_subdiv_308(PyObject *self, PyObject *) {
  SheetNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SheetNode)) {
    return nullptr;
  }
  // 1-inline int SheetNode::get_num_u_subdiv(void) const
  int return_value = ((*(const SheetNode*)local_this).get_num_u_subdiv)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_num_u_subdiv_308_comment =
  "C++ Interface:\n"
  "get_num_u_subdiv(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subdivisions per cubic segment to draw in the U\n"
  " * direction.  See set_num_u_subdiv().\n"
  " */";
#else
static const char *Dtool_SheetNode_get_num_u_subdiv_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SheetNode::set_num_v_subdiv(int num_v_subdiv)
 */
static PyObject *Dtool_SheetNode_set_num_v_subdiv_309(PyObject *self, PyObject *arg) {
  SheetNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.set_num_v_subdiv")) {
    return nullptr;
  }
  // 1-inline void SheetNode::set_num_v_subdiv(int num_v_subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_v_subdiv)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_v_subdiv(const SheetNode self, int num_v_subdiv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_set_num_v_subdiv_309_comment =
  "C++ Interface:\n"
  "set_num_v_subdiv(const SheetNode self, int num_v_subdiv)\n"
  "\n"
  "/**\n"
  " * Specifies the number of subdivisions per cubic segment (that is, per unique\n"
  " * knot value) to draw in a fixed uniform tesselation of the surface in the V\n"
  " * direction.\n"
  " */";
#else
static const char *Dtool_SheetNode_set_num_v_subdiv_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SheetNode::get_num_v_subdiv(void) const
 */
static PyObject *Dtool_SheetNode_get_num_v_subdiv_310(PyObject *self, PyObject *) {
  SheetNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SheetNode)) {
    return nullptr;
  }
  // 1-inline int SheetNode::get_num_v_subdiv(void) const
  int return_value = ((*(const SheetNode*)local_this).get_num_v_subdiv)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_num_v_subdiv_310_comment =
  "C++ Interface:\n"
  "get_num_v_subdiv(SheetNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subdivisions per cubic segment to draw in the V\n"
  " * direction.  See set_num_v_subdiv().\n"
  " */";
#else
static const char *Dtool_SheetNode_get_num_v_subdiv_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SheetNode::reset_bound(NodePath const &rel_to)
 */
static PyObject *Dtool_SheetNode_reset_bound_311(PyObject *self, PyObject *arg) {
  SheetNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SheetNode, (void **)&local_this, "SheetNode.reset_bound")) {
    return nullptr;
  }
  // 1-void SheetNode::reset_bound(NodePath const &rel_to)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SheetNode.reset_bound", true, true);
  if (arg_this != nullptr) {
    ((*local_this).reset_bound)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_bound(const SheetNode self, const NodePath rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_reset_bound_311_comment =
  "C++ Interface:\n"
  "reset_bound(const SheetNode self, const NodePath rel_to)\n"
  "\n"
  "/**\n"
  " * Recomputes the bounding volume.  This is normally called automatically, but\n"
  " * it must occasionally be called explicitly when the surface has changed\n"
  " * properties outside of this node's knowledge.\n"
  " */";
#else
static const char *Dtool_SheetNode_reset_bound_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SheetNode::get_class_type(void)
 */
static PyObject *Dtool_SheetNode_get_class_type_312(PyObject *, PyObject *) {
  // 1-static TypeHandle SheetNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SheetNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SheetNode_get_class_type_312_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SheetNode_get_class_type_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit SheetNode::SheetNode(std::string const &name)
 */
static int Dtool_Init_SheetNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SheetNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit SheetNode::SheetNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      SheetNode *return_value = new SheetNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SheetNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SheetNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SheetNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SheetNode) {
    printf("SheetNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SheetNode *local_this = (SheetNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SheetNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SheetNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SheetNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SheetNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SheetNode*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for ParametricCurve (ParametricCurve)
 */
static PyMethodDef Dtool_Methods_ParametricCurve[] = {
  {"is_valid", &Dtool_ParametricCurve_is_valid_3, METH_NOARGS, (const char *)Dtool_ParametricCurve_is_valid_3_comment},
  {"isValid", &Dtool_ParametricCurve_is_valid_3, METH_NOARGS, (const char *)Dtool_ParametricCurve_is_valid_3_comment},
  {"get_max_t", &Dtool_ParametricCurve_get_max_t_4, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_max_t_4_comment},
  {"getMaxT", &Dtool_ParametricCurve_get_max_t_4, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_max_t_4_comment},
  {"set_curve_type", &Dtool_ParametricCurve_set_curve_type_5, METH_O, (const char *)Dtool_ParametricCurve_set_curve_type_5_comment},
  {"setCurveType", &Dtool_ParametricCurve_set_curve_type_5, METH_O, (const char *)Dtool_ParametricCurve_set_curve_type_5_comment},
  {"get_curve_type", &Dtool_ParametricCurve_get_curve_type_6, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_curve_type_6_comment},
  {"getCurveType", &Dtool_ParametricCurve_get_curve_type_6, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_curve_type_6_comment},
  {"set_num_dimensions", &Dtool_ParametricCurve_set_num_dimensions_7, METH_O, (const char *)Dtool_ParametricCurve_set_num_dimensions_7_comment},
  {"setNumDimensions", &Dtool_ParametricCurve_set_num_dimensions_7, METH_O, (const char *)Dtool_ParametricCurve_set_num_dimensions_7_comment},
  {"get_num_dimensions", &Dtool_ParametricCurve_get_num_dimensions_8, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_num_dimensions_8_comment},
  {"getNumDimensions", &Dtool_ParametricCurve_get_num_dimensions_8, METH_NOARGS, (const char *)Dtool_ParametricCurve_get_num_dimensions_8_comment},
  {"calc_length", (PyCFunction) &Dtool_ParametricCurve_calc_length_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_calc_length_9_comment},
  {"calcLength", (PyCFunction) &Dtool_ParametricCurve_calc_length_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_calc_length_9_comment},
  {"find_length", (PyCFunction) &Dtool_ParametricCurve_find_length_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_find_length_10_comment},
  {"findLength", (PyCFunction) &Dtool_ParametricCurve_find_length_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_find_length_10_comment},
  {"get_point", (PyCFunction) &Dtool_ParametricCurve_get_point_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_point_11_comment},
  {"getPoint", (PyCFunction) &Dtool_ParametricCurve_get_point_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_point_11_comment},
  {"get_tangent", (PyCFunction) &Dtool_ParametricCurve_get_tangent_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_tangent_12_comment},
  {"getTangent", (PyCFunction) &Dtool_ParametricCurve_get_tangent_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_tangent_12_comment},
  {"get_pt", (PyCFunction) &Dtool_ParametricCurve_get_pt_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_pt_13_comment},
  {"getPt", (PyCFunction) &Dtool_ParametricCurve_get_pt_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_pt_13_comment},
  {"get_2ndtangent", (PyCFunction) &Dtool_ParametricCurve_get_2ndtangent_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_2ndtangent_14_comment},
  {"get2ndtangent", (PyCFunction) &Dtool_ParametricCurve_get_2ndtangent_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_get_2ndtangent_14_comment},
  {"adjust_point", (PyCFunction) &Dtool_ParametricCurve_adjust_point_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_point_15_comment},
  {"adjustPoint", (PyCFunction) &Dtool_ParametricCurve_adjust_point_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_point_15_comment},
  {"adjust_tangent", (PyCFunction) &Dtool_ParametricCurve_adjust_tangent_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_tangent_16_comment},
  {"adjustTangent", (PyCFunction) &Dtool_ParametricCurve_adjust_tangent_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_tangent_16_comment},
  {"adjust_pt", (PyCFunction) &Dtool_ParametricCurve_adjust_pt_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_pt_17_comment},
  {"adjustPt", (PyCFunction) &Dtool_ParametricCurve_adjust_pt_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_adjust_pt_17_comment},
  {"recompute", &Dtool_ParametricCurve_recompute_18, METH_NOARGS, (const char *)Dtool_ParametricCurve_recompute_18_comment},
  {"stitch", (PyCFunction) &Dtool_ParametricCurve_stitch_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_stitch_19_comment},
  {"write_egg", (PyCFunction) &Dtool_ParametricCurve_write_egg_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_write_egg_20_comment},
  {"writeEgg", (PyCFunction) &Dtool_ParametricCurve_write_egg_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurve_write_egg_20_comment},
  {"get_class_type", &Dtool_ParametricCurve_get_class_type_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParametricCurve_get_class_type_21_comment},
  {"getClassType", &Dtool_ParametricCurve_get_class_type_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParametricCurve_get_class_type_21_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ParametricCurve = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParametricCurve = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParametricCurve = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParametricCurve = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParametricCurve = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParametricCurve = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParametricCurve",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParametricCurve,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParametricCurve,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParametricCurve,
    &Dtool_SequenceMethods_ParametricCurve,
    &Dtool_MappingMethods_ParametricCurve,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParametricCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A virtual base class for parametric curves.  This encapsulates all curves\n"
    " * in 3-d space defined for a single parameter t in the range [0,get_max_t()].\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParametricCurve,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParametricCurve,
    PyType_GenericAlloc,
    Dtool_new_ParametricCurve,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParametricCurve,
  Dtool_UpcastInterface_ParametricCurve,
  Dtool_DowncastInterface_ParametricCurve,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ParametricCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_ParametricCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_ParametricCurve._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParametricCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParametricCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParametricCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParametricCurve);
  }
}

/**
 * Python method tables for CubicCurveseg (CubicCurveseg)
 */
static PyMethodDef Dtool_Methods_CubicCurveseg[] = {
  {"get_class_type", &Dtool_CubicCurveseg_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CubicCurveseg_get_class_type_23_comment},
  {"getClassType", &Dtool_CubicCurveseg_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CubicCurveseg_get_class_type_23_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CubicCurveseg = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CubicCurveseg = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CubicCurveseg = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CubicCurveseg = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CubicCurveseg = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CubicCurveseg = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CubicCurveseg",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CubicCurveseg,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CubicCurveseg,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CubicCurveseg,
    &Dtool_SequenceMethods_CubicCurveseg,
    &Dtool_MappingMethods_CubicCurveseg,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CubicCurveseg,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A CubicCurveseg is any curve that can be completely described by four\n"
    " * 4-valued basis vectors, one for each dimension in three-space, and one for\n"
    " * the homogeneous coordinate.  This includes Beziers, Hermites, and NURBS.\n"
    " *\n"
    " * This class encapsulates a single curve segment of the cubic curve.\n"
    " * Normally, when we think of Bezier and Hermite curves, we think of a\n"
    " * piecewise collection of such segments.\n"
    " *\n"
    " * Although this class includes methods such as hermite_basis() and\n"
    " * nurbs_basis(), to generate a Hermite and NURBS curve segment, respectively,\n"
    " * only the final basis vectors are stored: the product of the basis matrix of\n"
    " * the corresponding curve type, and its geometry vectors.  This is the\n"
    " * minimum information needed to evaluate the curve.  However, the individual\n"
    " * CV's that were used to compute these basis vectors are not retained; this\n"
    " * might be handled in a subclass (for instance, HermiteCurve).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CubicCurveseg,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CubicCurveseg,
    PyType_GenericAlloc,
    Dtool_new_CubicCurveseg,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CubicCurveseg,
  Dtool_UpcastInterface_CubicCurveseg,
  Dtool_DowncastInterface_CubicCurveseg,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CubicCurveseg(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParametricCurve(nullptr);
    Dtool_CubicCurveseg._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParametricCurve);
    Dtool_CubicCurveseg._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CubicCurveseg._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CubicCurveseg) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CubicCurveseg)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CubicCurveseg);
  }
}

/**
 * Python method tables for ParametricCurveCollection (ParametricCurveCollection)
 */
static PyMethodDef Dtool_Methods_ParametricCurveCollection[] = {
  {"add_curve", (PyCFunction) &Dtool_ParametricCurveCollection_add_curve_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_add_curve_27_comment},
  {"addCurve", (PyCFunction) &Dtool_ParametricCurveCollection_add_curve_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_add_curve_27_comment},
  {"insert_curve", (PyCFunction) &Dtool_ParametricCurveCollection_insert_curve_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_insert_curve_28_comment},
  {"insertCurve", (PyCFunction) &Dtool_ParametricCurveCollection_insert_curve_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_insert_curve_28_comment},
  {"add_curves", &Dtool_ParametricCurveCollection_add_curves_29, METH_O, (const char *)Dtool_ParametricCurveCollection_add_curves_29_comment},
  {"addCurves", &Dtool_ParametricCurveCollection_add_curves_29, METH_O, (const char *)Dtool_ParametricCurveCollection_add_curves_29_comment},
  {"remove_curve", &Dtool_ParametricCurveCollection_remove_curve_30, METH_O, (const char *)Dtool_ParametricCurveCollection_remove_curve_30_comment},
  {"removeCurve", &Dtool_ParametricCurveCollection_remove_curve_30, METH_O, (const char *)Dtool_ParametricCurveCollection_remove_curve_30_comment},
  {"set_curve", (PyCFunction) &Dtool_ParametricCurveCollection_set_curve_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_set_curve_31_comment},
  {"setCurve", (PyCFunction) &Dtool_ParametricCurveCollection_set_curve_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_set_curve_31_comment},
  {"has_curve", &Dtool_ParametricCurveCollection_has_curve_32, METH_O, (const char *)Dtool_ParametricCurveCollection_has_curve_32_comment},
  {"hasCurve", &Dtool_ParametricCurveCollection_has_curve_32, METH_O, (const char *)Dtool_ParametricCurveCollection_has_curve_32_comment},
  {"clear", &Dtool_ParametricCurveCollection_clear_33, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_clear_33_comment},
  {"clear_timewarps", &Dtool_ParametricCurveCollection_clear_timewarps_34, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_clear_timewarps_34_comment},
  {"clearTimewarps", &Dtool_ParametricCurveCollection_clear_timewarps_34, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_clear_timewarps_34_comment},
  {"get_num_curves", &Dtool_ParametricCurveCollection_get_num_curves_35, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_curves_35_comment},
  {"getNumCurves", &Dtool_ParametricCurveCollection_get_num_curves_35, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_curves_35_comment},
  {"get_curve", &Dtool_ParametricCurveCollection_get_curve_36, METH_O, (const char *)Dtool_ParametricCurveCollection_get_curve_36_comment},
  {"getCurve", &Dtool_ParametricCurveCollection_get_curve_36, METH_O, (const char *)Dtool_ParametricCurveCollection_get_curve_36_comment},
  {"get_xyz_curve", &Dtool_ParametricCurveCollection_get_xyz_curve_38, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_xyz_curve_38_comment},
  {"getXyzCurve", &Dtool_ParametricCurveCollection_get_xyz_curve_38, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_xyz_curve_38_comment},
  {"get_hpr_curve", &Dtool_ParametricCurveCollection_get_hpr_curve_39, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_hpr_curve_39_comment},
  {"getHprCurve", &Dtool_ParametricCurveCollection_get_hpr_curve_39, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_hpr_curve_39_comment},
  {"get_default_curve", &Dtool_ParametricCurveCollection_get_default_curve_40, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_default_curve_40_comment},
  {"getDefaultCurve", &Dtool_ParametricCurveCollection_get_default_curve_40, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_default_curve_40_comment},
  {"get_num_timewarps", &Dtool_ParametricCurveCollection_get_num_timewarps_41, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_timewarps_41_comment},
  {"getNumTimewarps", &Dtool_ParametricCurveCollection_get_num_timewarps_41, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_num_timewarps_41_comment},
  {"get_timewarp_curve", &Dtool_ParametricCurveCollection_get_timewarp_curve_42, METH_O, (const char *)Dtool_ParametricCurveCollection_get_timewarp_curve_42_comment},
  {"getTimewarpCurve", &Dtool_ParametricCurveCollection_get_timewarp_curve_42, METH_O, (const char *)Dtool_ParametricCurveCollection_get_timewarp_curve_42_comment},
  {"get_max_t", &Dtool_ParametricCurveCollection_get_max_t_44, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_max_t_44_comment},
  {"getMaxT", &Dtool_ParametricCurveCollection_get_max_t_44, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_get_max_t_44_comment},
  {"make_even", (PyCFunction) &Dtool_ParametricCurveCollection_make_even_54, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_make_even_54_comment},
  {"makeEven", (PyCFunction) &Dtool_ParametricCurveCollection_make_even_54, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_make_even_54_comment},
  {"face_forward", &Dtool_ParametricCurveCollection_face_forward_55, METH_O, (const char *)Dtool_ParametricCurveCollection_face_forward_55_comment},
  {"faceForward", &Dtool_ParametricCurveCollection_face_forward_55, METH_O, (const char *)Dtool_ParametricCurveCollection_face_forward_55_comment},
  {"reset_max_t", &Dtool_ParametricCurveCollection_reset_max_t_56, METH_O, (const char *)Dtool_ParametricCurveCollection_reset_max_t_56_comment},
  {"resetMaxT", &Dtool_ParametricCurveCollection_reset_max_t_56, METH_O, (const char *)Dtool_ParametricCurveCollection_reset_max_t_56_comment},
  {"evaluate", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_57_comment},
  {"evaluate_t", &Dtool_ParametricCurveCollection_evaluate_t_58, METH_O, (const char *)Dtool_ParametricCurveCollection_evaluate_t_58_comment},
  {"evaluateT", &Dtool_ParametricCurveCollection_evaluate_t_58, METH_O, (const char *)Dtool_ParametricCurveCollection_evaluate_t_58_comment},
  {"evaluate_xyz", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_xyz_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_xyz_59_comment},
  {"evaluateXyz", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_xyz_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_xyz_59_comment},
  {"evaluate_hpr", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_hpr_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_hpr_60_comment},
  {"evaluateHpr", (PyCFunction) &Dtool_ParametricCurveCollection_evaluate_hpr_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_evaluate_hpr_60_comment},
  {"adjust_xyz", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_xyz_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_xyz_61_comment},
  {"adjustXyz", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_xyz_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_xyz_61_comment},
  {"adjust_hpr", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_hpr_62, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_hpr_62_comment},
  {"adjustHpr", (PyCFunction) &Dtool_ParametricCurveCollection_adjust_hpr_62, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_adjust_hpr_62_comment},
  {"recompute", &Dtool_ParametricCurveCollection_recompute_63, METH_NOARGS, (const char *)Dtool_ParametricCurveCollection_recompute_63_comment},
  {"stitch", (PyCFunction) &Dtool_ParametricCurveCollection_stitch_64, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_stitch_64_comment},
  {"output", &Dtool_ParametricCurveCollection_output_65, METH_O, (const char *)Dtool_ParametricCurveCollection_output_65_comment},
  {"write", (PyCFunction) &Dtool_ParametricCurveCollection_write_66, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_write_66_comment},
  {"write_egg", (PyCFunction) &Dtool_ParametricCurveCollection_write_egg_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_write_egg_67_comment},
  {"writeEgg", (PyCFunction) &Dtool_ParametricCurveCollection_write_egg_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParametricCurveCollection_write_egg_67_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_curves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_curves, METH_NOARGS, nullptr},
  { "getCurves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_curves, METH_NOARGS, nullptr},
  {"get_timewarp_curves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_timewarp_curves, METH_NOARGS, nullptr},
  { "getTimewarpCurves", (PyCFunction) &MakeSeq_ParametricCurveCollection_get_timewarp_curves, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ParametricCurveCollection
//////////////////
static PyObject *Dtool_Repr_ParametricCurveCollection(PyObject *self) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ParametricCurveCollection
//////////////////
static PyObject *Dtool_Str_ParametricCurveCollection(PyObject *self) {
  ParametricCurveCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParametricCurveCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ParametricCurveCollection[] = {
  {(char *)"curves", &Dtool_ParametricCurveCollection_curves_Getter, nullptr, nullptr, nullptr},
  {(char *)"xyz_curve", &Dtool_ParametricCurveCollection_xyz_curve_Getter, nullptr, nullptr, nullptr},
  {(char *)"hpr_curve", &Dtool_ParametricCurveCollection_hpr_curve_Getter, nullptr, nullptr, nullptr},
  {(char *)"default_curve", &Dtool_ParametricCurveCollection_default_curve_Getter, nullptr, nullptr, nullptr},
  {(char *)"timewarp_curves", &Dtool_ParametricCurveCollection_timewarp_curves_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_t", &Dtool_ParametricCurveCollection_max_t_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParametricCurveCollection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParametricCurveCollection = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParametricCurveCollection = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParametricCurveCollection = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParametricCurveCollection = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParametricCurveCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParametricCurveCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParametricCurveCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParametricCurveCollection,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ParametricCurveCollection,
    &Dtool_NumberMethods_ParametricCurveCollection,
    &Dtool_SequenceMethods_ParametricCurveCollection,
    &Dtool_MappingMethods_ParametricCurveCollection,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ParametricCurveCollection,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParametricCurveCollection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a set of zero or more ParametricCurves, which may or may not be\n"
    " * related.  If they are related, the set should contain no more than one XYZ\n"
    " * curve, no more than one HPR curve, and zero or more Timewarp curves, which\n"
    " * can then be evaluated as a unit to return a single transformation matrix\n"
    " * for a given unit of time.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParametricCurveCollection,
    nullptr, // tp_members
    Dtool_Properties_ParametricCurveCollection,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParametricCurveCollection,
    PyType_GenericAlloc,
    Dtool_new_ParametricCurveCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParametricCurveCollection,
  Dtool_UpcastInterface_ParametricCurveCollection,
  Dtool_DowncastInterface_ParametricCurveCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ParametricCurveCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ParametricCurveCollection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_ParametricCurveCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParametricCurveCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParametricCurveCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParametricCurveCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParametricCurveCollection);
  }
}

/**
 * Python method tables for CurveFitter (CurveFitter)
 */
static PyMethodDef Dtool_Methods_CurveFitter[] = {
  {"reset", &Dtool_CurveFitter_reset_71, METH_NOARGS, (const char *)Dtool_CurveFitter_reset_71_comment},
  {"add_xyz", (PyCFunction) &Dtool_CurveFitter_add_xyz_72, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_72_comment},
  {"addXyz", (PyCFunction) &Dtool_CurveFitter_add_xyz_72, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_72_comment},
  {"add_hpr", (PyCFunction) &Dtool_CurveFitter_add_hpr_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_hpr_73_comment},
  {"addHpr", (PyCFunction) &Dtool_CurveFitter_add_hpr_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_hpr_73_comment},
  {"add_xyz_hpr", (PyCFunction) &Dtool_CurveFitter_add_xyz_hpr_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_hpr_74_comment},
  {"addXyzHpr", (PyCFunction) &Dtool_CurveFitter_add_xyz_hpr_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_add_xyz_hpr_74_comment},
  {"get_num_samples", &Dtool_CurveFitter_get_num_samples_75, METH_NOARGS, (const char *)Dtool_CurveFitter_get_num_samples_75_comment},
  {"getNumSamples", &Dtool_CurveFitter_get_num_samples_75, METH_NOARGS, (const char *)Dtool_CurveFitter_get_num_samples_75_comment},
  {"get_sample_t", &Dtool_CurveFitter_get_sample_t_76, METH_O, (const char *)Dtool_CurveFitter_get_sample_t_76_comment},
  {"getSampleT", &Dtool_CurveFitter_get_sample_t_76, METH_O, (const char *)Dtool_CurveFitter_get_sample_t_76_comment},
  {"get_sample_xyz", &Dtool_CurveFitter_get_sample_xyz_77, METH_O, (const char *)Dtool_CurveFitter_get_sample_xyz_77_comment},
  {"getSampleXyz", &Dtool_CurveFitter_get_sample_xyz_77, METH_O, (const char *)Dtool_CurveFitter_get_sample_xyz_77_comment},
  {"get_sample_hpr", &Dtool_CurveFitter_get_sample_hpr_78, METH_O, (const char *)Dtool_CurveFitter_get_sample_hpr_78_comment},
  {"getSampleHpr", &Dtool_CurveFitter_get_sample_hpr_78, METH_O, (const char *)Dtool_CurveFitter_get_sample_hpr_78_comment},
  {"get_sample_tangent", &Dtool_CurveFitter_get_sample_tangent_79, METH_O, (const char *)Dtool_CurveFitter_get_sample_tangent_79_comment},
  {"getSampleTangent", &Dtool_CurveFitter_get_sample_tangent_79, METH_O, (const char *)Dtool_CurveFitter_get_sample_tangent_79_comment},
  {"remove_samples", (PyCFunction) &Dtool_CurveFitter_remove_samples_80, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_remove_samples_80_comment},
  {"removeSamples", (PyCFunction) &Dtool_CurveFitter_remove_samples_80, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_remove_samples_80_comment},
  {"sample", (PyCFunction) &Dtool_CurveFitter_sample_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CurveFitter_sample_81_comment},
  {"wrap_hpr", &Dtool_CurveFitter_wrap_hpr_82, METH_NOARGS, (const char *)Dtool_CurveFitter_wrap_hpr_82_comment},
  {"wrapHpr", &Dtool_CurveFitter_wrap_hpr_82, METH_NOARGS, (const char *)Dtool_CurveFitter_wrap_hpr_82_comment},
  {"sort_points", &Dtool_CurveFitter_sort_points_83, METH_NOARGS, (const char *)Dtool_CurveFitter_sort_points_83_comment},
  {"sortPoints", &Dtool_CurveFitter_sort_points_83, METH_NOARGS, (const char *)Dtool_CurveFitter_sort_points_83_comment},
  {"desample", &Dtool_CurveFitter_desample_84, METH_O, (const char *)Dtool_CurveFitter_desample_84_comment},
  {"compute_tangents", &Dtool_CurveFitter_compute_tangents_85, METH_O, (const char *)Dtool_CurveFitter_compute_tangents_85_comment},
  {"computeTangents", &Dtool_CurveFitter_compute_tangents_85, METH_O, (const char *)Dtool_CurveFitter_compute_tangents_85_comment},
  {"make_hermite", &Dtool_CurveFitter_make_hermite_86, METH_NOARGS, (const char *)Dtool_CurveFitter_make_hermite_86_comment},
  {"makeHermite", &Dtool_CurveFitter_make_hermite_86, METH_NOARGS, (const char *)Dtool_CurveFitter_make_hermite_86_comment},
  {"make_nurbs", &Dtool_CurveFitter_make_nurbs_87, METH_NOARGS, (const char *)Dtool_CurveFitter_make_nurbs_87_comment},
  {"makeNurbs", &Dtool_CurveFitter_make_nurbs_87, METH_NOARGS, (const char *)Dtool_CurveFitter_make_nurbs_87_comment},
  {"output", &Dtool_CurveFitter_output_88, METH_O, (const char *)Dtool_CurveFitter_output_88_comment},
  {"write", &Dtool_CurveFitter_write_89, METH_O, (const char *)Dtool_CurveFitter_write_89_comment},
  {"get_class_type", &Dtool_CurveFitter_get_class_type_90, METH_NOARGS | METH_STATIC, (const char *)Dtool_CurveFitter_get_class_type_90_comment},
  {"getClassType", &Dtool_CurveFitter_get_class_type_90, METH_NOARGS | METH_STATIC, (const char *)Dtool_CurveFitter_get_class_type_90_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CurveFitter
//////////////////
static PyObject *Dtool_Repr_CurveFitter(PyObject *self) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CurveFitter
//////////////////
static PyObject *Dtool_Str_CurveFitter(PyObject *self) {
  CurveFitter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CurveFitter, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CurveFitter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CurveFitter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CurveFitter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CurveFitter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CurveFitter,
    &Dtool_NumberMethods_CurveFitter,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CurveFitter,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CurveFitter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CurveFitter,
    PyType_GenericAlloc,
    Dtool_new_CurveFitter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CurveFitter,
  Dtool_UpcastInterface_CurveFitter,
  Dtool_DowncastInterface_CurveFitter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CurveFitter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CurveFitter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CurveFitter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CurveFitter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CurveFitter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CurveFitter);
  }
}

/**
 * Python method tables for PiecewiseCurve (PiecewiseCurve)
 */
static PyMethodDef Dtool_Methods_PiecewiseCurve[] = {
  {"get_class_type", &Dtool_PiecewiseCurve_get_class_type_93, METH_NOARGS | METH_STATIC, (const char *)Dtool_PiecewiseCurve_get_class_type_93_comment},
  {"getClassType", &Dtool_PiecewiseCurve_get_class_type_93, METH_NOARGS | METH_STATIC, (const char *)Dtool_PiecewiseCurve_get_class_type_93_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PiecewiseCurve = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PiecewiseCurve = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PiecewiseCurve = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PiecewiseCurve = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PiecewiseCurve = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PiecewiseCurve = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PiecewiseCurve",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PiecewiseCurve,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PiecewiseCurve,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PiecewiseCurve,
    &Dtool_SequenceMethods_PiecewiseCurve,
    &Dtool_MappingMethods_PiecewiseCurve,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PiecewiseCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A PiecewiseCurve is a curve made up of several curve segments, connected in\n"
    " * a head-to-tail fashion.  The length of each curve segment in parametric\n"
    " * space is definable.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PiecewiseCurve,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PiecewiseCurve,
    PyType_GenericAlloc,
    Dtool_new_PiecewiseCurve,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PiecewiseCurve,
  Dtool_UpcastInterface_PiecewiseCurve,
  Dtool_DowncastInterface_PiecewiseCurve,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PiecewiseCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParametricCurve(nullptr);
    Dtool_PiecewiseCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParametricCurve);
    Dtool_PiecewiseCurve._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PiecewiseCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PiecewiseCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PiecewiseCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PiecewiseCurve);
  }
}

/**
 * Python method tables for HermiteCurve (HermiteCurve)
 */
static PyMethodDef Dtool_Methods_HermiteCurve[] = {
  {"get_num_cvs", &Dtool_HermiteCurve_get_num_cvs_96, METH_NOARGS, (const char *)Dtool_HermiteCurve_get_num_cvs_96_comment},
  {"getNumCvs", &Dtool_HermiteCurve_get_num_cvs_96, METH_NOARGS, (const char *)Dtool_HermiteCurve_get_num_cvs_96_comment},
  {"insert_cv", &Dtool_HermiteCurve_insert_cv_97, METH_O, (const char *)Dtool_HermiteCurve_insert_cv_97_comment},
  {"insertCv", &Dtool_HermiteCurve_insert_cv_97, METH_O, (const char *)Dtool_HermiteCurve_insert_cv_97_comment},
  {"append_cv", (PyCFunction) &Dtool_HermiteCurve_append_cv_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_append_cv_98_comment},
  {"appendCv", (PyCFunction) &Dtool_HermiteCurve_append_cv_98, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_append_cv_98_comment},
  {"remove_cv", &Dtool_HermiteCurve_remove_cv_99, METH_O, (const char *)Dtool_HermiteCurve_remove_cv_99_comment},
  {"removeCv", &Dtool_HermiteCurve_remove_cv_99, METH_O, (const char *)Dtool_HermiteCurve_remove_cv_99_comment},
  {"remove_all_cvs", &Dtool_HermiteCurve_remove_all_cvs_100, METH_NOARGS, (const char *)Dtool_HermiteCurve_remove_all_cvs_100_comment},
  {"removeAllCvs", &Dtool_HermiteCurve_remove_all_cvs_100, METH_NOARGS, (const char *)Dtool_HermiteCurve_remove_all_cvs_100_comment},
  {"set_cv_type", (PyCFunction) &Dtool_HermiteCurve_set_cv_type_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_type_101_comment},
  {"setCvType", (PyCFunction) &Dtool_HermiteCurve_set_cv_type_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_type_101_comment},
  {"set_cv_point", (PyCFunction) &Dtool_HermiteCurve_set_cv_point_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_point_102_comment},
  {"setCvPoint", (PyCFunction) &Dtool_HermiteCurve_set_cv_point_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_point_102_comment},
  {"set_cv_in", (PyCFunction) &Dtool_HermiteCurve_set_cv_in_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_in_103_comment},
  {"setCvIn", (PyCFunction) &Dtool_HermiteCurve_set_cv_in_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_in_103_comment},
  {"set_cv_out", (PyCFunction) &Dtool_HermiteCurve_set_cv_out_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_out_104_comment},
  {"setCvOut", (PyCFunction) &Dtool_HermiteCurve_set_cv_out_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_out_104_comment},
  {"set_cv_tstart", (PyCFunction) &Dtool_HermiteCurve_set_cv_tstart_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_tstart_105_comment},
  {"setCvTstart", (PyCFunction) &Dtool_HermiteCurve_set_cv_tstart_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_tstart_105_comment},
  {"set_cv_name", (PyCFunction) &Dtool_HermiteCurve_set_cv_name_106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_name_106_comment},
  {"setCvName", (PyCFunction) &Dtool_HermiteCurve_set_cv_name_106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_set_cv_name_106_comment},
  {"get_cv_type", &Dtool_HermiteCurve_get_cv_type_107, METH_O, (const char *)Dtool_HermiteCurve_get_cv_type_107_comment},
  {"getCvType", &Dtool_HermiteCurve_get_cv_type_107, METH_O, (const char *)Dtool_HermiteCurve_get_cv_type_107_comment},
  {"get_cv_point", (PyCFunction) &Dtool_HermiteCurve_get_cv_point_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_point_108_comment},
  {"getCvPoint", (PyCFunction) &Dtool_HermiteCurve_get_cv_point_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_point_108_comment},
  {"get_cv_in", (PyCFunction) &Dtool_HermiteCurve_get_cv_in_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_in_109_comment},
  {"getCvIn", (PyCFunction) &Dtool_HermiteCurve_get_cv_in_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_in_109_comment},
  {"get_cv_out", (PyCFunction) &Dtool_HermiteCurve_get_cv_out_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_out_110_comment},
  {"getCvOut", (PyCFunction) &Dtool_HermiteCurve_get_cv_out_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_get_cv_out_110_comment},
  {"get_cv_tstart", &Dtool_HermiteCurve_get_cv_tstart_111, METH_O, (const char *)Dtool_HermiteCurve_get_cv_tstart_111_comment},
  {"getCvTstart", &Dtool_HermiteCurve_get_cv_tstart_111, METH_O, (const char *)Dtool_HermiteCurve_get_cv_tstart_111_comment},
  {"get_cv_name", &Dtool_HermiteCurve_get_cv_name_112, METH_O, (const char *)Dtool_HermiteCurve_get_cv_name_112_comment},
  {"getCvName", &Dtool_HermiteCurve_get_cv_name_112, METH_O, (const char *)Dtool_HermiteCurve_get_cv_name_112_comment},
  {"write_cv", (PyCFunction) &Dtool_HermiteCurve_write_cv_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_write_cv_113_comment},
  {"writeCv", (PyCFunction) &Dtool_HermiteCurve_write_cv_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HermiteCurve_write_cv_113_comment},
  {"get_class_type", &Dtool_HermiteCurve_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_HermiteCurve_get_class_type_114_comment},
  {"getClassType", &Dtool_HermiteCurve_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_HermiteCurve_get_class_type_114_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_HermiteCurve = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HermiteCurve = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_HermiteCurve = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_HermiteCurve = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_HermiteCurve = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_HermiteCurve = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.HermiteCurve",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_HermiteCurve,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_HermiteCurve,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_HermiteCurve,
    &Dtool_SequenceMethods_HermiteCurve,
    &Dtool_MappingMethods_HermiteCurve,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_HermiteCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric curve defined by a sequence of control vertices, each with an\n"
    " * in and out tangent.\n"
    " *\n"
    " * This class is actually implemented as a PiecewiseCurve made up of several\n"
    " * CubicCurvesegs, each of which is created using the hermite_basis() method.\n"
    " * The HermiteCurve class itself keeps its own list of the CV's that are used\n"
    " * to define the curve (since the CubicCurveseg class doesn't retain these).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_HermiteCurve,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_HermiteCurve,
    PyType_GenericAlloc,
    Dtool_new_HermiteCurve,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HermiteCurve,
  Dtool_UpcastInterface_HermiteCurve,
  Dtool_DowncastInterface_HermiteCurve,
  (CoerceFunction)Dtool_ConstCoerce_HermiteCurve,
  (CoerceFunction)Dtool_Coerce_HermiteCurve,
};

static void Dtool_PyModuleClassInit_HermiteCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PiecewiseCurve(nullptr);
    Dtool_HermiteCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PiecewiseCurve);
    Dtool_HermiteCurve._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_HermiteCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HermiteCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HermiteCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HermiteCurve);
  }
}

/**
 * Python method tables for NurbsCurveInterface (NurbsCurveInterface)
 */
static PyMethodDef Dtool_Methods_NurbsCurveInterface[] = {
  {"set_order", &Dtool_NurbsCurveInterface_set_order_117, METH_O, (const char *)Dtool_NurbsCurveInterface_set_order_117_comment},
  {"setOrder", &Dtool_NurbsCurveInterface_set_order_117, METH_O, (const char *)Dtool_NurbsCurveInterface_set_order_117_comment},
  {"get_order", &Dtool_NurbsCurveInterface_get_order_118, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_order_118_comment},
  {"getOrder", &Dtool_NurbsCurveInterface_get_order_118, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_order_118_comment},
  {"get_num_cvs", &Dtool_NurbsCurveInterface_get_num_cvs_119, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_cvs_119_comment},
  {"getNumCvs", &Dtool_NurbsCurveInterface_get_num_cvs_119, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_cvs_119_comment},
  {"get_num_knots", &Dtool_NurbsCurveInterface_get_num_knots_120, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_knots_120_comment},
  {"getNumKnots", &Dtool_NurbsCurveInterface_get_num_knots_120, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_get_num_knots_120_comment},
  {"insert_cv", &Dtool_NurbsCurveInterface_insert_cv_121, METH_O, (const char *)Dtool_NurbsCurveInterface_insert_cv_121_comment},
  {"insertCv", &Dtool_NurbsCurveInterface_insert_cv_121, METH_O, (const char *)Dtool_NurbsCurveInterface_insert_cv_121_comment},
  {"append_cv", (PyCFunction) &Dtool_NurbsCurveInterface_append_cv_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_append_cv_122_comment},
  {"appendCv", (PyCFunction) &Dtool_NurbsCurveInterface_append_cv_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_append_cv_122_comment},
  {"remove_cv", &Dtool_NurbsCurveInterface_remove_cv_123, METH_O, (const char *)Dtool_NurbsCurveInterface_remove_cv_123_comment},
  {"removeCv", &Dtool_NurbsCurveInterface_remove_cv_123, METH_O, (const char *)Dtool_NurbsCurveInterface_remove_cv_123_comment},
  {"remove_all_cvs", &Dtool_NurbsCurveInterface_remove_all_cvs_124, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_remove_all_cvs_124_comment},
  {"removeAllCvs", &Dtool_NurbsCurveInterface_remove_all_cvs_124, METH_NOARGS, (const char *)Dtool_NurbsCurveInterface_remove_all_cvs_124_comment},
  {"set_cv_point", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_point_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_point_125_comment},
  {"setCvPoint", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_point_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_point_125_comment},
  {"get_cv_point", &Dtool_NurbsCurveInterface_get_cv_point_126, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_point_126_comment},
  {"getCvPoint", &Dtool_NurbsCurveInterface_get_cv_point_126, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_point_126_comment},
  {"set_cv_weight", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_weight_127, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_weight_127_comment},
  {"setCvWeight", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_weight_127, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_weight_127_comment},
  {"get_cv_weight", &Dtool_NurbsCurveInterface_get_cv_weight_128, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_weight_128_comment},
  {"getCvWeight", &Dtool_NurbsCurveInterface_get_cv_weight_128, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_weight_128_comment},
  {"set_cv", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_129_comment},
  {"setCv", (PyCFunction) &Dtool_NurbsCurveInterface_set_cv_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_cv_129_comment},
  {"get_cv", &Dtool_NurbsCurveInterface_get_cv_130, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_130_comment},
  {"getCv", &Dtool_NurbsCurveInterface_get_cv_130, METH_O, (const char *)Dtool_NurbsCurveInterface_get_cv_130_comment},
  {"set_knot", (PyCFunction) &Dtool_NurbsCurveInterface_set_knot_131, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_knot_131_comment},
  {"setKnot", (PyCFunction) &Dtool_NurbsCurveInterface_set_knot_131, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_set_knot_131_comment},
  {"get_knot", &Dtool_NurbsCurveInterface_get_knot_132, METH_O, (const char *)Dtool_NurbsCurveInterface_get_knot_132_comment},
  {"getKnot", &Dtool_NurbsCurveInterface_get_knot_132, METH_O, (const char *)Dtool_NurbsCurveInterface_get_knot_132_comment},
  {"write_cv", (PyCFunction) &Dtool_NurbsCurveInterface_write_cv_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_write_cv_135_comment},
  {"writeCv", (PyCFunction) &Dtool_NurbsCurveInterface_write_cv_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveInterface_write_cv_135_comment},
  {"get_class_type", &Dtool_NurbsCurveInterface_get_class_type_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurveInterface_get_class_type_136_comment},
  {"getClassType", &Dtool_NurbsCurveInterface_get_class_type_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurveInterface_get_class_type_136_comment},
  {"get_cvs", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_cvs, METH_NOARGS, nullptr},
  { "getCvs", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_cvs, METH_NOARGS, nullptr},
  {"get_knots", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_knots, METH_NOARGS, nullptr},
  { "getKnots", (PyCFunction) &MakeSeq_NurbsCurveInterface_get_knots, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NurbsCurveInterface = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_NurbsCurveInterface = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NurbsCurveInterface",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurveInterface,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NurbsCurveInterface,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This abstract class defines the interface only for a Nurbs-style curve,\n"
    " * with knots and coordinates in homogeneous space.\n"
    " *\n"
    " * The NurbsCurve class inherits both from this and from ParametricCurve.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NurbsCurveInterface,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NurbsCurveInterface,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurveInterface,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurveInterface,
  Dtool_UpcastInterface_NurbsCurveInterface,
  Dtool_DowncastInterface_NurbsCurveInterface,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NurbsCurveInterface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NurbsCurveInterface._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurveInterface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurveInterface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurveInterface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurveInterface);
  }
}

/**
 * Python method tables for NurbsCurve (NurbsCurve)
 */
static PyMethodDef Dtool_Methods_NurbsCurve[] = {
  {"get_class_type", &Dtool_NurbsCurve_get_class_type_144, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurve_get_class_type_144_comment},
  {"getClassType", &Dtool_NurbsCurve_get_class_type_144, METH_NOARGS | METH_STATIC, (const char *)Dtool_NurbsCurve_get_class_type_144_comment},
  {"upcast_to_PiecewiseCurve", &Dtool_NurbsCurve_upcast_to_PiecewiseCurve_138, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_PiecewiseCurve_138_comment},
  {"upcastToPiecewiseCurve", &Dtool_NurbsCurve_upcast_to_PiecewiseCurve_138, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_PiecewiseCurve_138_comment},
  {"upcast_to_NurbsCurveInterface", &Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_140, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_140_comment},
  {"upcastToNurbsCurveInterface", &Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_140, METH_NOARGS, (const char *)Dtool_NurbsCurve_upcast_to_NurbsCurveInterface_140_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NurbsCurve = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NurbsCurve = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NurbsCurve",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurve,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NurbsCurve,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NurbsCurve,
    &Dtool_SequenceMethods_NurbsCurve,
    &Dtool_MappingMethods_NurbsCurve,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NurbsCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A Nonuniform Rational B-Spline.\n"
    " *\n"
    " * This class is actually implemented as a PiecewiseCurve made up of several\n"
    " * CubicCurvesegs, each of which is created using the nurbs_basis() method.\n"
    " * The list of CV's and knots is kept here, within the NurbsCurve class.\n"
    " *\n"
    " * This class is the original Panda-native implementation of a NURBS curve.\n"
    " * It is typedeffed as \"NurbsCurve\" and performs all NURBS curve functions if\n"
    " * we do not have the NURBS++ library available.\n"
    " *\n"
    " * However, if we *do* have the NURBS++ library, another class exists, the\n"
    " * NurbsPPCurve, which is a wrapper around that library and provides some\n"
    " * additional functionality.  In that case, the other class is typedeffed to\n"
    " * \"NurbsCurve\" instead of this one, and performs most of the NURBS curve\n"
    " * functions.  This class then becomes vestigial.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NurbsCurve,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NurbsCurve,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurve,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurve,
  Dtool_UpcastInterface_NurbsCurve,
  Dtool_DowncastInterface_NurbsCurve,
  (CoerceFunction)Dtool_ConstCoerce_NurbsCurve,
  (CoerceFunction)Dtool_Coerce_NurbsCurve,
};

static void Dtool_PyModuleClassInit_NurbsCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PiecewiseCurve(nullptr);
    Dtool_PyModuleClassInit_NurbsCurveInterface(nullptr);
    Dtool_NurbsCurve._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_PiecewiseCurve, (PyTypeObject *)&Dtool_NurbsCurveInterface);
    Dtool_NurbsCurve._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurve);
  }
}

/**
 * Python method tables for NurbsCurveResult (NurbsCurveResult)
 */
static PyMethodDef Dtool_Methods_NurbsCurveResult[] = {
  {"get_start_t", &Dtool_NurbsCurveResult_get_start_t_146, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_start_t_146_comment},
  {"getStartT", &Dtool_NurbsCurveResult_get_start_t_146, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_start_t_146_comment},
  {"get_end_t", &Dtool_NurbsCurveResult_get_end_t_147, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_end_t_147_comment},
  {"getEndT", &Dtool_NurbsCurveResult_get_end_t_147, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_end_t_147_comment},
  {"eval_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_point_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_point_148_comment},
  {"evalPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_point_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_point_148_comment},
  {"eval_tangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_tangent_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_tangent_149_comment},
  {"evalTangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_tangent_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_tangent_149_comment},
  {"eval_extended_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_point_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_point_150_comment},
  {"evalExtendedPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_point_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_point_150_comment},
  {"eval_extended_points", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_points_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_points_151_comment},
  {"evalExtendedPoints", (PyCFunction) &Dtool_NurbsCurveResult_eval_extended_points_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_extended_points_151_comment},
  {"get_num_segments", &Dtool_NurbsCurveResult_get_num_segments_152, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_segments_152_comment},
  {"getNumSegments", &Dtool_NurbsCurveResult_get_num_segments_152, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_segments_152_comment},
  {"eval_segment_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_point_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_point_153_comment},
  {"evalSegmentPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_point_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_point_153_comment},
  {"eval_segment_tangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_tangent_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_tangent_154_comment},
  {"evalSegmentTangent", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_tangent_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_tangent_154_comment},
  {"eval_segment_extended_point", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_point_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_point_155_comment},
  {"evalSegmentExtendedPoint", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_point_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_point_155_comment},
  {"eval_segment_extended_points", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_points_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_points_156_comment},
  {"evalSegmentExtendedPoints", (PyCFunction) &Dtool_NurbsCurveResult_eval_segment_extended_points_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_eval_segment_extended_points_156_comment},
  {"get_segment_t", (PyCFunction) &Dtool_NurbsCurveResult_get_segment_t_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_get_segment_t_157_comment},
  {"getSegmentT", (PyCFunction) &Dtool_NurbsCurveResult_get_segment_t_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveResult_get_segment_t_157_comment},
  {"adaptive_sample", &Dtool_NurbsCurveResult_adaptive_sample_158, METH_O, (const char *)Dtool_NurbsCurveResult_adaptive_sample_158_comment},
  {"adaptiveSample", &Dtool_NurbsCurveResult_adaptive_sample_158, METH_O, (const char *)Dtool_NurbsCurveResult_adaptive_sample_158_comment},
  {"get_num_samples", &Dtool_NurbsCurveResult_get_num_samples_159, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_samples_159_comment},
  {"getNumSamples", &Dtool_NurbsCurveResult_get_num_samples_159, METH_NOARGS, (const char *)Dtool_NurbsCurveResult_get_num_samples_159_comment},
  {"get_sample_t", &Dtool_NurbsCurveResult_get_sample_t_160, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_t_160_comment},
  {"getSampleT", &Dtool_NurbsCurveResult_get_sample_t_160, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_t_160_comment},
  {"get_sample_point", &Dtool_NurbsCurveResult_get_sample_point_161, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_point_161_comment},
  {"getSamplePoint", &Dtool_NurbsCurveResult_get_sample_point_161, METH_O, (const char *)Dtool_NurbsCurveResult_get_sample_point_161_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_sample_ts", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_ts, METH_NOARGS, nullptr},
  { "getSampleTs", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_ts, METH_NOARGS, nullptr},
  {"get_sample_points", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_points, METH_NOARGS, nullptr},
  { "getSamplePoints", (PyCFunction) &MakeSeq_NurbsCurveResult_get_sample_points, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NurbsCurveResult = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsCurveResult = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NurbsCurveResult = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NurbsCurveResult = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NurbsCurveResult = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NurbsCurveResult = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NurbsCurveResult",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurveResult,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NurbsCurveResult,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NurbsCurveResult,
    &Dtool_SequenceMethods_NurbsCurveResult,
    &Dtool_MappingMethods_NurbsCurveResult,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NurbsCurveResult,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The result of a NurbsCurveEvaluator.  This object represents a curve in a\n"
    " * particular coordinate space.  It can return the point and/or tangent to the\n"
    " * curve at any point.\n"
    " *\n"
    " * This is not related to NurbsCurve, CubicCurveseg or any of the\n"
    " * ParametricCurve-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS curves, and will probably eventually\n"
    " * replace the whole ParametricCurve class hierarchy.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NurbsCurveResult,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NurbsCurveResult,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurveResult,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurveResult,
  Dtool_UpcastInterface_NurbsCurveResult,
  Dtool_DowncastInterface_NurbsCurveResult,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NurbsCurveResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_NurbsCurveResult._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_NurbsCurveResult._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurveResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurveResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurveResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurveResult);
  }
}

/**
 * Python method tables for NurbsCurveEvaluator (NurbsCurveEvaluator)
 */
static PyMethodDef Dtool_Methods_NurbsCurveEvaluator[] = {
  {"set_order", &Dtool_NurbsCurveEvaluator_set_order_167, METH_O, (const char *)Dtool_NurbsCurveEvaluator_set_order_167_comment},
  {"setOrder", &Dtool_NurbsCurveEvaluator_set_order_167, METH_O, (const char *)Dtool_NurbsCurveEvaluator_set_order_167_comment},
  {"get_order", &Dtool_NurbsCurveEvaluator_get_order_168, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_order_168_comment},
  {"getOrder", &Dtool_NurbsCurveEvaluator_get_order_168, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_order_168_comment},
  {"reset", &Dtool_NurbsCurveEvaluator_reset_169, METH_O, (const char *)Dtool_NurbsCurveEvaluator_reset_169_comment},
  {"get_num_vertices", &Dtool_NurbsCurveEvaluator_get_num_vertices_170, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_vertices_170_comment},
  {"getNumVertices", &Dtool_NurbsCurveEvaluator_get_num_vertices_170, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_vertices_170_comment},
  {"set_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_171_comment},
  {"setVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_171_comment},
  {"get_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_172_comment},
  {"getVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_172_comment},
  {"set_vertex_space", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_space_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_space_174_comment},
  {"setVertexSpace", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_vertex_space_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_vertex_space_174_comment},
  {"get_vertex_space", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_space_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_space_175_comment},
  {"getVertexSpace", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_vertex_space_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_vertex_space_175_comment},
  {"set_extended_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertex_176, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertex_176_comment},
  {"setExtendedVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertex_176, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertex_176_comment},
  {"get_extended_vertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_extended_vertex_177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_extended_vertex_177_comment},
  {"getExtendedVertex", (PyCFunction) &Dtool_NurbsCurveEvaluator_get_extended_vertex_177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_get_extended_vertex_177_comment},
  {"set_extended_vertices", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertices_178, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertices_178_comment},
  {"setExtendedVertices", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_extended_vertices_178, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_extended_vertices_178_comment},
  {"get_num_knots", &Dtool_NurbsCurveEvaluator_get_num_knots_179, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_knots_179_comment},
  {"getNumKnots", &Dtool_NurbsCurveEvaluator_get_num_knots_179, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_knots_179_comment},
  {"set_knot", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_knot_180, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_knot_180_comment},
  {"setKnot", (PyCFunction) &Dtool_NurbsCurveEvaluator_set_knot_180, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_set_knot_180_comment},
  {"get_knot", &Dtool_NurbsCurveEvaluator_get_knot_181, METH_O, (const char *)Dtool_NurbsCurveEvaluator_get_knot_181_comment},
  {"getKnot", &Dtool_NurbsCurveEvaluator_get_knot_181, METH_O, (const char *)Dtool_NurbsCurveEvaluator_get_knot_181_comment},
  {"normalize_knots", &Dtool_NurbsCurveEvaluator_normalize_knots_183, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_normalize_knots_183_comment},
  {"normalizeKnots", &Dtool_NurbsCurveEvaluator_normalize_knots_183, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_normalize_knots_183_comment},
  {"get_num_segments", &Dtool_NurbsCurveEvaluator_get_num_segments_184, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_segments_184_comment},
  {"getNumSegments", &Dtool_NurbsCurveEvaluator_get_num_segments_184, METH_NOARGS, (const char *)Dtool_NurbsCurveEvaluator_get_num_segments_184_comment},
  {"evaluate", (PyCFunction) &Dtool_NurbsCurveEvaluator_evaluate_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsCurveEvaluator_evaluate_185_comment},
  {"output", &Dtool_NurbsCurveEvaluator_output_186, METH_O, (const char *)Dtool_NurbsCurveEvaluator_output_186_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_vertices", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_vertices, METH_NOARGS, nullptr},
  { "getVertices", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_vertices, METH_NOARGS, nullptr},
  {"get_knots", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_knots, METH_NOARGS, nullptr},
  { "getKnots", (PyCFunction) &MakeSeq_NurbsCurveEvaluator_get_knots, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     NurbsCurveEvaluator
//////////////////
static PyObject *Dtool_Repr_NurbsCurveEvaluator(PyObject *self) {
  NurbsCurveEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsCurveEvaluator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_NurbsCurveEvaluator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsCurveEvaluator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NurbsCurveEvaluator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NurbsCurveEvaluator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NurbsCurveEvaluator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NurbsCurveEvaluator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NurbsCurveEvaluator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsCurveEvaluator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NurbsCurveEvaluator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_NurbsCurveEvaluator,
    &Dtool_NumberMethods_NurbsCurveEvaluator,
    &Dtool_SequenceMethods_NurbsCurveEvaluator,
    &Dtool_MappingMethods_NurbsCurveEvaluator,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_NurbsCurveEvaluator,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NurbsCurveEvaluator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is an abstraction for evaluating NURBS curves.  It accepts an\n"
    " * array of vertices, each of which may be in a different coordinate space (as\n"
    " * defined by a NodePath), as well as an optional knot vector.\n"
    " *\n"
    " * This is not related to NurbsCurve, CubicCurveseg or any of the\n"
    " * ParametricCurve-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS curves, and will probably eventually\n"
    " * replace the whole ParametricCurve class hierarchy.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NurbsCurveEvaluator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NurbsCurveEvaluator,
    PyType_GenericAlloc,
    Dtool_new_NurbsCurveEvaluator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsCurveEvaluator,
  Dtool_UpcastInterface_NurbsCurveEvaluator,
  Dtool_DowncastInterface_NurbsCurveEvaluator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NurbsCurveEvaluator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_NurbsCurveEvaluator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_NurbsCurveEvaluator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NurbsCurveEvaluator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsCurveEvaluator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsCurveEvaluator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsCurveEvaluator);
  }
}

/**
 * Python method tables for NurbsSurfaceResult (NurbsSurfaceResult)
 */
static PyMethodDef Dtool_Methods_NurbsSurfaceResult[] = {
  {"get_start_u", &Dtool_NurbsSurfaceResult_get_start_u_188, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_u_188_comment},
  {"getStartU", &Dtool_NurbsSurfaceResult_get_start_u_188, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_u_188_comment},
  {"get_end_u", &Dtool_NurbsSurfaceResult_get_end_u_189, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_u_189_comment},
  {"getEndU", &Dtool_NurbsSurfaceResult_get_end_u_189, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_u_189_comment},
  {"get_start_v", &Dtool_NurbsSurfaceResult_get_start_v_190, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_v_190_comment},
  {"getStartV", &Dtool_NurbsSurfaceResult_get_start_v_190, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_start_v_190_comment},
  {"get_end_v", &Dtool_NurbsSurfaceResult_get_end_v_191, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_v_191_comment},
  {"getEndV", &Dtool_NurbsSurfaceResult_get_end_v_191, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_end_v_191_comment},
  {"eval_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_point_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_point_192_comment},
  {"evalPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_point_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_point_192_comment},
  {"eval_normal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_normal_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_normal_193_comment},
  {"evalNormal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_normal_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_normal_193_comment},
  {"eval_extended_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_point_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_point_194_comment},
  {"evalExtendedPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_point_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_point_194_comment},
  {"eval_extended_points", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_points_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_points_195_comment},
  {"evalExtendedPoints", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_extended_points_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_extended_points_195_comment},
  {"get_num_u_segments", &Dtool_NurbsSurfaceResult_get_num_u_segments_196, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_u_segments_196_comment},
  {"getNumUSegments", &Dtool_NurbsSurfaceResult_get_num_u_segments_196, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_u_segments_196_comment},
  {"get_num_v_segments", &Dtool_NurbsSurfaceResult_get_num_v_segments_197, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_v_segments_197_comment},
  {"getNumVSegments", &Dtool_NurbsSurfaceResult_get_num_v_segments_197, METH_NOARGS, (const char *)Dtool_NurbsSurfaceResult_get_num_v_segments_197_comment},
  {"eval_segment_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_point_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_point_198_comment},
  {"evalSegmentPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_point_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_point_198_comment},
  {"eval_segment_normal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_normal_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_normal_199_comment},
  {"evalSegmentNormal", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_normal_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_normal_199_comment},
  {"eval_segment_extended_point", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_point_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_point_200_comment},
  {"evalSegmentExtendedPoint", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_point_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_point_200_comment},
  {"eval_segment_extended_points", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_points_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_points_201_comment},
  {"evalSegmentExtendedPoints", (PyCFunction) &Dtool_NurbsSurfaceResult_eval_segment_extended_points_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_eval_segment_extended_points_201_comment},
  {"get_segment_u", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_u_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_u_202_comment},
  {"getSegmentU", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_u_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_u_202_comment},
  {"get_segment_v", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_v_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_v_203_comment},
  {"getSegmentV", (PyCFunction) &Dtool_NurbsSurfaceResult_get_segment_v_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceResult_get_segment_v_203_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NurbsSurfaceResult = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsSurfaceResult = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NurbsSurfaceResult = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NurbsSurfaceResult = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NurbsSurfaceResult = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NurbsSurfaceResult = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NurbsSurfaceResult",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsSurfaceResult,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NurbsSurfaceResult,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NurbsSurfaceResult,
    &Dtool_SequenceMethods_NurbsSurfaceResult,
    &Dtool_MappingMethods_NurbsSurfaceResult,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NurbsSurfaceResult,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The result of a NurbsSurfaceEvaluator.  This object represents a surface in\n"
    " * a particular coordinate space.  It can return the point and/or normal to\n"
    " * the surface at any point.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NurbsSurfaceResult,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NurbsSurfaceResult,
    PyType_GenericAlloc,
    Dtool_new_NurbsSurfaceResult,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsSurfaceResult,
  Dtool_UpcastInterface_NurbsSurfaceResult,
  Dtool_DowncastInterface_NurbsSurfaceResult,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NurbsSurfaceResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_NurbsSurfaceResult._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_NurbsSurfaceResult._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NurbsSurfaceResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsSurfaceResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsSurfaceResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsSurfaceResult);
  }
}

/**
 * Python method tables for NurbsSurfaceEvaluator (NurbsSurfaceEvaluator)
 */
static PyMethodDef Dtool_Methods_NurbsSurfaceEvaluator[] = {
  {"set_u_order", &Dtool_NurbsSurfaceEvaluator_set_u_order_207, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_order_207_comment},
  {"setUOrder", &Dtool_NurbsSurfaceEvaluator_set_u_order_207, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_order_207_comment},
  {"get_u_order", &Dtool_NurbsSurfaceEvaluator_get_u_order_208, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_order_208_comment},
  {"getUOrder", &Dtool_NurbsSurfaceEvaluator_get_u_order_208, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_order_208_comment},
  {"set_v_order", &Dtool_NurbsSurfaceEvaluator_set_v_order_209, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_order_209_comment},
  {"setVOrder", &Dtool_NurbsSurfaceEvaluator_set_v_order_209, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_order_209_comment},
  {"get_v_order", &Dtool_NurbsSurfaceEvaluator_get_v_order_210, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_order_210_comment},
  {"getVOrder", &Dtool_NurbsSurfaceEvaluator_get_v_order_210, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_order_210_comment},
  {"reset", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_reset_211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_reset_211_comment},
  {"get_num_u_vertices", &Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_212, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_212_comment},
  {"getNumUVertices", &Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_212, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_vertices_212_comment},
  {"get_num_v_vertices", &Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_213, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_213_comment},
  {"getNumVVertices", &Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_213, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_vertices_213_comment},
  {"set_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_214, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_214_comment},
  {"setVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_214, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_214_comment},
  {"get_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_215_comment},
  {"getVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_215_comment},
  {"set_vertex_space", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_space_216, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_space_216_comment},
  {"setVertexSpace", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_vertex_space_216, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_vertex_space_216_comment},
  {"get_vertex_space", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_space_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_space_217_comment},
  {"getVertexSpace", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_vertex_space_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_vertex_space_217_comment},
  {"set_extended_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertex_218, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertex_218_comment},
  {"setExtendedVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertex_218, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertex_218_comment},
  {"get_extended_vertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_extended_vertex_219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_extended_vertex_219_comment},
  {"getExtendedVertex", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_get_extended_vertex_219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_get_extended_vertex_219_comment},
  {"set_extended_vertices", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertices_220, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertices_220_comment},
  {"setExtendedVertices", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_extended_vertices_220, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_extended_vertices_220_comment},
  {"get_num_u_knots", &Dtool_NurbsSurfaceEvaluator_get_num_u_knots_221, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_knots_221_comment},
  {"getNumUKnots", &Dtool_NurbsSurfaceEvaluator_get_num_u_knots_221, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_knots_221_comment},
  {"set_u_knot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_u_knot_222, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_knot_222_comment},
  {"setUKnot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_u_knot_222, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_u_knot_222_comment},
  {"get_u_knot", &Dtool_NurbsSurfaceEvaluator_get_u_knot_223, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_knot_223_comment},
  {"getUKnot", &Dtool_NurbsSurfaceEvaluator_get_u_knot_223, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_u_knot_223_comment},
  {"normalize_u_knots", &Dtool_NurbsSurfaceEvaluator_normalize_u_knots_225, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_u_knots_225_comment},
  {"normalizeUKnots", &Dtool_NurbsSurfaceEvaluator_normalize_u_knots_225, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_u_knots_225_comment},
  {"get_num_v_knots", &Dtool_NurbsSurfaceEvaluator_get_num_v_knots_226, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_knots_226_comment},
  {"getNumVKnots", &Dtool_NurbsSurfaceEvaluator_get_num_v_knots_226, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_knots_226_comment},
  {"set_v_knot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_v_knot_227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_knot_227_comment},
  {"setVKnot", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_set_v_knot_227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_set_v_knot_227_comment},
  {"get_v_knot", &Dtool_NurbsSurfaceEvaluator_get_v_knot_228, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_knot_228_comment},
  {"getVKnot", &Dtool_NurbsSurfaceEvaluator_get_v_knot_228, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_get_v_knot_228_comment},
  {"normalize_v_knots", &Dtool_NurbsSurfaceEvaluator_normalize_v_knots_230, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_v_knots_230_comment},
  {"normalizeVKnots", &Dtool_NurbsSurfaceEvaluator_normalize_v_knots_230, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_normalize_v_knots_230_comment},
  {"get_num_u_segments", &Dtool_NurbsSurfaceEvaluator_get_num_u_segments_231, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_segments_231_comment},
  {"getNumUSegments", &Dtool_NurbsSurfaceEvaluator_get_num_u_segments_231, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_u_segments_231_comment},
  {"get_num_v_segments", &Dtool_NurbsSurfaceEvaluator_get_num_v_segments_232, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_segments_232_comment},
  {"getNumVSegments", &Dtool_NurbsSurfaceEvaluator_get_num_v_segments_232, METH_NOARGS, (const char *)Dtool_NurbsSurfaceEvaluator_get_num_v_segments_232_comment},
  {"evaluate", (PyCFunction) &Dtool_NurbsSurfaceEvaluator_evaluate_233, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NurbsSurfaceEvaluator_evaluate_233_comment},
  {"output", &Dtool_NurbsSurfaceEvaluator_output_234, METH_O, (const char *)Dtool_NurbsSurfaceEvaluator_output_234_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_u_knots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_u_knots, METH_NOARGS, nullptr},
  { "getUKnots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_u_knots, METH_NOARGS, nullptr},
  {"get_v_knots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_v_knots, METH_NOARGS, nullptr},
  { "getVKnots", (PyCFunction) &MakeSeq_NurbsSurfaceEvaluator_get_v_knots, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     NurbsSurfaceEvaluator
//////////////////
static PyObject *Dtool_Repr_NurbsSurfaceEvaluator(PyObject *self) {
  NurbsSurfaceEvaluator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NurbsSurfaceEvaluator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_NurbsSurfaceEvaluator[] = {
  {(char *)"u_order", &Dtool_NurbsSurfaceEvaluator_u_order_Getter, &Dtool_NurbsSurfaceEvaluator_u_order_Setter, nullptr, nullptr},
  {(char *)"v_order", &Dtool_NurbsSurfaceEvaluator_v_order_Getter, &Dtool_NurbsSurfaceEvaluator_v_order_Setter, nullptr, nullptr},
  {(char *)"u_knots", &Dtool_NurbsSurfaceEvaluator_u_knots_Getter, nullptr, nullptr, nullptr},
  {(char *)"v_knots", &Dtool_NurbsSurfaceEvaluator_v_knots_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_NurbsSurfaceEvaluator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NurbsSurfaceEvaluator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NurbsSurfaceEvaluator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NurbsSurfaceEvaluator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NurbsSurfaceEvaluator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NurbsSurfaceEvaluator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NurbsSurfaceEvaluator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NurbsSurfaceEvaluator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NurbsSurfaceEvaluator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_NurbsSurfaceEvaluator,
    &Dtool_NumberMethods_NurbsSurfaceEvaluator,
    &Dtool_SequenceMethods_NurbsSurfaceEvaluator,
    &Dtool_MappingMethods_NurbsSurfaceEvaluator,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_NurbsSurfaceEvaluator,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NurbsSurfaceEvaluator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is an abstraction for evaluating NURBS surfaces.  It accepts an\n"
    " * array of vertices, each of which may be in a different coordinate space (as\n"
    " * defined by a NodePath), as well as an optional knot vector.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NurbsSurfaceEvaluator,
    nullptr, // tp_members
    Dtool_Properties_NurbsSurfaceEvaluator,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NurbsSurfaceEvaluator,
    PyType_GenericAlloc,
    Dtool_new_NurbsSurfaceEvaluator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NurbsSurfaceEvaluator,
  Dtool_UpcastInterface_NurbsSurfaceEvaluator,
  Dtool_DowncastInterface_NurbsSurfaceEvaluator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_NurbsSurfaceEvaluator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_NurbsSurfaceEvaluator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NurbsSurfaceEvaluator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NurbsSurfaceEvaluator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NurbsSurfaceEvaluator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NurbsSurfaceEvaluator);
  }
}

/**
 * Python method tables for RopeNode (RopeNode)
 */
static PyMethodDef Dtool_Methods_RopeNode[] = {
  {"set_curve", &Dtool_RopeNode_set_curve_245, METH_O, (const char *)Dtool_RopeNode_set_curve_245_comment},
  {"setCurve", &Dtool_RopeNode_set_curve_245, METH_O, (const char *)Dtool_RopeNode_set_curve_245_comment},
  {"get_curve", &Dtool_RopeNode_get_curve_246, METH_NOARGS, (const char *)Dtool_RopeNode_get_curve_246_comment},
  {"getCurve", &Dtool_RopeNode_get_curve_246, METH_NOARGS, (const char *)Dtool_RopeNode_get_curve_246_comment},
  {"set_render_mode", &Dtool_RopeNode_set_render_mode_247, METH_O, (const char *)Dtool_RopeNode_set_render_mode_247_comment},
  {"setRenderMode", &Dtool_RopeNode_set_render_mode_247, METH_O, (const char *)Dtool_RopeNode_set_render_mode_247_comment},
  {"get_render_mode", &Dtool_RopeNode_get_render_mode_248, METH_NOARGS, (const char *)Dtool_RopeNode_get_render_mode_248_comment},
  {"getRenderMode", &Dtool_RopeNode_get_render_mode_248, METH_NOARGS, (const char *)Dtool_RopeNode_get_render_mode_248_comment},
  {"set_uv_mode", &Dtool_RopeNode_set_uv_mode_249, METH_O, (const char *)Dtool_RopeNode_set_uv_mode_249_comment},
  {"setUvMode", &Dtool_RopeNode_set_uv_mode_249, METH_O, (const char *)Dtool_RopeNode_set_uv_mode_249_comment},
  {"get_uv_mode", &Dtool_RopeNode_get_uv_mode_250, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_mode_250_comment},
  {"getUvMode", &Dtool_RopeNode_get_uv_mode_250, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_mode_250_comment},
  {"set_uv_direction", &Dtool_RopeNode_set_uv_direction_251, METH_O, (const char *)Dtool_RopeNode_set_uv_direction_251_comment},
  {"setUvDirection", &Dtool_RopeNode_set_uv_direction_251, METH_O, (const char *)Dtool_RopeNode_set_uv_direction_251_comment},
  {"get_uv_direction", &Dtool_RopeNode_get_uv_direction_252, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_direction_252_comment},
  {"getUvDirection", &Dtool_RopeNode_get_uv_direction_252, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_direction_252_comment},
  {"set_uv_scale", &Dtool_RopeNode_set_uv_scale_253, METH_O, (const char *)Dtool_RopeNode_set_uv_scale_253_comment},
  {"setUvScale", &Dtool_RopeNode_set_uv_scale_253, METH_O, (const char *)Dtool_RopeNode_set_uv_scale_253_comment},
  {"get_uv_scale", &Dtool_RopeNode_get_uv_scale_254, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_scale_254_comment},
  {"getUvScale", &Dtool_RopeNode_get_uv_scale_254, METH_NOARGS, (const char *)Dtool_RopeNode_get_uv_scale_254_comment},
  {"set_normal_mode", &Dtool_RopeNode_set_normal_mode_255, METH_O, (const char *)Dtool_RopeNode_set_normal_mode_255_comment},
  {"setNormalMode", &Dtool_RopeNode_set_normal_mode_255, METH_O, (const char *)Dtool_RopeNode_set_normal_mode_255_comment},
  {"get_normal_mode", &Dtool_RopeNode_get_normal_mode_256, METH_NOARGS, (const char *)Dtool_RopeNode_get_normal_mode_256_comment},
  {"getNormalMode", &Dtool_RopeNode_get_normal_mode_256, METH_NOARGS, (const char *)Dtool_RopeNode_get_normal_mode_256_comment},
  {"set_tube_up", &Dtool_RopeNode_set_tube_up_257, METH_O, (const char *)Dtool_RopeNode_set_tube_up_257_comment},
  {"setTubeUp", &Dtool_RopeNode_set_tube_up_257, METH_O, (const char *)Dtool_RopeNode_set_tube_up_257_comment},
  {"get_tube_up", &Dtool_RopeNode_get_tube_up_258, METH_NOARGS, (const char *)Dtool_RopeNode_get_tube_up_258_comment},
  {"getTubeUp", &Dtool_RopeNode_get_tube_up_258, METH_NOARGS, (const char *)Dtool_RopeNode_get_tube_up_258_comment},
  {"set_use_vertex_color", &Dtool_RopeNode_set_use_vertex_color_259, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_color_259_comment},
  {"setUseVertexColor", &Dtool_RopeNode_set_use_vertex_color_259, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_color_259_comment},
  {"get_use_vertex_color", &Dtool_RopeNode_get_use_vertex_color_260, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_color_260_comment},
  {"getUseVertexColor", &Dtool_RopeNode_get_use_vertex_color_260, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_color_260_comment},
  {"get_vertex_color_dimension", &Dtool_RopeNode_get_vertex_color_dimension_261, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_color_dimension_261_comment},
  {"getVertexColorDimension", &Dtool_RopeNode_get_vertex_color_dimension_261, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_color_dimension_261_comment},
  {"set_num_subdiv", &Dtool_RopeNode_set_num_subdiv_262, METH_O, (const char *)Dtool_RopeNode_set_num_subdiv_262_comment},
  {"setNumSubdiv", &Dtool_RopeNode_set_num_subdiv_262, METH_O, (const char *)Dtool_RopeNode_set_num_subdiv_262_comment},
  {"get_num_subdiv", &Dtool_RopeNode_get_num_subdiv_263, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_subdiv_263_comment},
  {"getNumSubdiv", &Dtool_RopeNode_get_num_subdiv_263, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_subdiv_263_comment},
  {"set_num_slices", &Dtool_RopeNode_set_num_slices_264, METH_O, (const char *)Dtool_RopeNode_set_num_slices_264_comment},
  {"setNumSlices", &Dtool_RopeNode_set_num_slices_264, METH_O, (const char *)Dtool_RopeNode_set_num_slices_264_comment},
  {"get_num_slices", &Dtool_RopeNode_get_num_slices_265, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_slices_265_comment},
  {"getNumSlices", &Dtool_RopeNode_get_num_slices_265, METH_NOARGS, (const char *)Dtool_RopeNode_get_num_slices_265_comment},
  {"set_use_vertex_thickness", &Dtool_RopeNode_set_use_vertex_thickness_266, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_thickness_266_comment},
  {"setUseVertexThickness", &Dtool_RopeNode_set_use_vertex_thickness_266, METH_O, (const char *)Dtool_RopeNode_set_use_vertex_thickness_266_comment},
  {"get_use_vertex_thickness", &Dtool_RopeNode_get_use_vertex_thickness_267, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_thickness_267_comment},
  {"getUseVertexThickness", &Dtool_RopeNode_get_use_vertex_thickness_267, METH_NOARGS, (const char *)Dtool_RopeNode_get_use_vertex_thickness_267_comment},
  {"get_vertex_thickness_dimension", &Dtool_RopeNode_get_vertex_thickness_dimension_268, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_thickness_dimension_268_comment},
  {"getVertexThicknessDimension", &Dtool_RopeNode_get_vertex_thickness_dimension_268, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_vertex_thickness_dimension_268_comment},
  {"set_thickness", &Dtool_RopeNode_set_thickness_269, METH_O, (const char *)Dtool_RopeNode_set_thickness_269_comment},
  {"setThickness", &Dtool_RopeNode_set_thickness_269, METH_O, (const char *)Dtool_RopeNode_set_thickness_269_comment},
  {"get_thickness", &Dtool_RopeNode_get_thickness_270, METH_NOARGS, (const char *)Dtool_RopeNode_get_thickness_270_comment},
  {"getThickness", &Dtool_RopeNode_get_thickness_270, METH_NOARGS, (const char *)Dtool_RopeNode_get_thickness_270_comment},
  {"set_matrix", &Dtool_RopeNode_set_matrix_271, METH_O, (const char *)Dtool_RopeNode_set_matrix_271_comment},
  {"setMatrix", &Dtool_RopeNode_set_matrix_271, METH_O, (const char *)Dtool_RopeNode_set_matrix_271_comment},
  {"clear_matrix", &Dtool_RopeNode_clear_matrix_272, METH_NOARGS, (const char *)Dtool_RopeNode_clear_matrix_272_comment},
  {"clearMatrix", &Dtool_RopeNode_clear_matrix_272, METH_NOARGS, (const char *)Dtool_RopeNode_clear_matrix_272_comment},
  {"has_matrix", &Dtool_RopeNode_has_matrix_273, METH_NOARGS, (const char *)Dtool_RopeNode_has_matrix_273_comment},
  {"hasMatrix", &Dtool_RopeNode_has_matrix_273, METH_NOARGS, (const char *)Dtool_RopeNode_has_matrix_273_comment},
  {"get_matrix", &Dtool_RopeNode_get_matrix_274, METH_NOARGS, (const char *)Dtool_RopeNode_get_matrix_274_comment},
  {"getMatrix", &Dtool_RopeNode_get_matrix_274, METH_NOARGS, (const char *)Dtool_RopeNode_get_matrix_274_comment},
  {"reset_bound", &Dtool_RopeNode_reset_bound_275, METH_O, (const char *)Dtool_RopeNode_reset_bound_275_comment},
  {"resetBound", &Dtool_RopeNode_reset_bound_275, METH_O, (const char *)Dtool_RopeNode_reset_bound_275_comment},
  {"get_class_type", &Dtool_RopeNode_get_class_type_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_class_type_299_comment},
  {"getClassType", &Dtool_RopeNode_get_class_type_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_RopeNode_get_class_type_299_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_RopeNode[] = {
  {(char *)"curve", &Dtool_RopeNode_curve_Getter, &Dtool_RopeNode_curve_Setter, nullptr, nullptr},
  {(char *)"render_mode", &Dtool_RopeNode_render_mode_Getter, &Dtool_RopeNode_render_mode_Setter, nullptr, nullptr},
  {(char *)"uv_mode", &Dtool_RopeNode_uv_mode_Getter, &Dtool_RopeNode_uv_mode_Setter, nullptr, nullptr},
  {(char *)"uv_direction", &Dtool_RopeNode_uv_direction_Getter, &Dtool_RopeNode_uv_direction_Setter, nullptr, nullptr},
  {(char *)"uv_scale", &Dtool_RopeNode_uv_scale_Getter, &Dtool_RopeNode_uv_scale_Setter, nullptr, nullptr},
  {(char *)"normal_mode", &Dtool_RopeNode_normal_mode_Getter, &Dtool_RopeNode_normal_mode_Setter, nullptr, nullptr},
  {(char *)"tube_up", &Dtool_RopeNode_tube_up_Getter, &Dtool_RopeNode_tube_up_Setter, nullptr, nullptr},
  {(char *)"use_vertex_color", &Dtool_RopeNode_use_vertex_color_Getter, &Dtool_RopeNode_use_vertex_color_Setter, nullptr, nullptr},
  {(char *)"num_subdiv", &Dtool_RopeNode_num_subdiv_Getter, &Dtool_RopeNode_num_subdiv_Setter, nullptr, nullptr},
  {(char *)"num_slices", &Dtool_RopeNode_num_slices_Getter, &Dtool_RopeNode_num_slices_Setter, nullptr, nullptr},
  {(char *)"use_vertex_thickness", &Dtool_RopeNode_use_vertex_thickness_Getter, &Dtool_RopeNode_use_vertex_thickness_Setter, nullptr, nullptr},
  {(char *)"thickness", &Dtool_RopeNode_thickness_Getter, &Dtool_RopeNode_thickness_Setter, nullptr, nullptr},
  {(char *)"matrix", &Dtool_RopeNode_matrix_Getter, &Dtool_RopeNode_matrix_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RopeNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RopeNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RopeNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RopeNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RopeNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RopeNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RopeNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RopeNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RopeNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RopeNode,
    &Dtool_SequenceMethods_RopeNode,
    &Dtool_MappingMethods_RopeNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RopeNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class draws a visible representation of the NURBS curve stored in its\n"
    " * NurbsCurveEvaluator.  It automatically recomputes the curve every frame.\n"
    " *\n"
    " * This is not related to NurbsCurve, CubicCurveseg or any of the\n"
    " * ParametricCurve-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS curves, and will probably eventually\n"
    " * replace the whole ParametricCurve class hierarchy.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RopeNode,
    nullptr, // tp_members
    Dtool_Properties_RopeNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RopeNode,
    PyType_GenericAlloc,
    Dtool_new_RopeNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RopeNode,
  Dtool_UpcastInterface_RopeNode,
  Dtool_DowncastInterface_RopeNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RopeNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_RopeNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_RopeNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_RopeNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum RopeNode::RenderMode;
    PyDict_SetItemString(dict, "RM_thread", Dtool_WrapValue(RopeNode::RM_thread));
    PyDict_SetItemString(dict, "RMThread", Dtool_WrapValue(RopeNode::RM_thread));
    PyDict_SetItemString(dict, "RM_tape", Dtool_WrapValue(RopeNode::RM_tape));
    PyDict_SetItemString(dict, "RMTape", Dtool_WrapValue(RopeNode::RM_tape));
    PyDict_SetItemString(dict, "RM_billboard", Dtool_WrapValue(RopeNode::RM_billboard));
    PyDict_SetItemString(dict, "RMBillboard", Dtool_WrapValue(RopeNode::RM_billboard));
    PyDict_SetItemString(dict, "RM_tube", Dtool_WrapValue(RopeNode::RM_tube));
    PyDict_SetItemString(dict, "RMTube", Dtool_WrapValue(RopeNode::RM_tube));
    // enum RopeNode::UVMode;
    PyDict_SetItemString(dict, "UV_none", Dtool_WrapValue(RopeNode::UV_none));
    PyDict_SetItemString(dict, "UVNone", Dtool_WrapValue(RopeNode::UV_none));
    PyDict_SetItemString(dict, "UV_parametric", Dtool_WrapValue(RopeNode::UV_parametric));
    PyDict_SetItemString(dict, "UVParametric", Dtool_WrapValue(RopeNode::UV_parametric));
    PyDict_SetItemString(dict, "UV_distance", Dtool_WrapValue(RopeNode::UV_distance));
    PyDict_SetItemString(dict, "UVDistance", Dtool_WrapValue(RopeNode::UV_distance));
    PyDict_SetItemString(dict, "UV_distance2", Dtool_WrapValue(RopeNode::UV_distance2));
    PyDict_SetItemString(dict, "UVDistance2", Dtool_WrapValue(RopeNode::UV_distance2));
    // enum RopeNode::NormalMode;
    PyDict_SetItemString(dict, "NM_none", Dtool_WrapValue(RopeNode::NM_none));
    PyDict_SetItemString(dict, "NMNone", Dtool_WrapValue(RopeNode::NM_none));
    PyDict_SetItemString(dict, "NM_vertex", Dtool_WrapValue(RopeNode::NM_vertex));
    PyDict_SetItemString(dict, "NMVertex", Dtool_WrapValue(RopeNode::NM_vertex));
    static const PyGetSetDef def_vertex_color_dimension = {(char *)"vertex_color_dimension", &Dtool_RopeNode_vertex_color_dimension_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "vertex_color_dimension", Dtool_NewStaticProperty(&Dtool_RopeNode._PyType, &def_vertex_color_dimension));
    static const PyGetSetDef def_vertex_thickness_dimension = {(char *)"vertex_thickness_dimension", &Dtool_RopeNode_vertex_thickness_dimension_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "vertex_thickness_dimension", Dtool_NewStaticProperty(&Dtool_RopeNode._PyType, &def_vertex_thickness_dimension));
    if (PyType_Ready((PyTypeObject *)&Dtool_RopeNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RopeNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RopeNode);
  }
}

/**
 * Python method tables for SheetNode (SheetNode)
 */
static PyMethodDef Dtool_Methods_SheetNode[] = {
  {"set_surface", &Dtool_SheetNode_set_surface_303, METH_O, (const char *)Dtool_SheetNode_set_surface_303_comment},
  {"setSurface", &Dtool_SheetNode_set_surface_303, METH_O, (const char *)Dtool_SheetNode_set_surface_303_comment},
  {"get_surface", &Dtool_SheetNode_get_surface_304, METH_NOARGS, (const char *)Dtool_SheetNode_get_surface_304_comment},
  {"getSurface", &Dtool_SheetNode_get_surface_304, METH_NOARGS, (const char *)Dtool_SheetNode_get_surface_304_comment},
  {"set_use_vertex_color", &Dtool_SheetNode_set_use_vertex_color_305, METH_O, (const char *)Dtool_SheetNode_set_use_vertex_color_305_comment},
  {"setUseVertexColor", &Dtool_SheetNode_set_use_vertex_color_305, METH_O, (const char *)Dtool_SheetNode_set_use_vertex_color_305_comment},
  {"get_use_vertex_color", &Dtool_SheetNode_get_use_vertex_color_306, METH_NOARGS, (const char *)Dtool_SheetNode_get_use_vertex_color_306_comment},
  {"getUseVertexColor", &Dtool_SheetNode_get_use_vertex_color_306, METH_NOARGS, (const char *)Dtool_SheetNode_get_use_vertex_color_306_comment},
  {"set_num_u_subdiv", &Dtool_SheetNode_set_num_u_subdiv_307, METH_O, (const char *)Dtool_SheetNode_set_num_u_subdiv_307_comment},
  {"setNumUSubdiv", &Dtool_SheetNode_set_num_u_subdiv_307, METH_O, (const char *)Dtool_SheetNode_set_num_u_subdiv_307_comment},
  {"get_num_u_subdiv", &Dtool_SheetNode_get_num_u_subdiv_308, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_u_subdiv_308_comment},
  {"getNumUSubdiv", &Dtool_SheetNode_get_num_u_subdiv_308, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_u_subdiv_308_comment},
  {"set_num_v_subdiv", &Dtool_SheetNode_set_num_v_subdiv_309, METH_O, (const char *)Dtool_SheetNode_set_num_v_subdiv_309_comment},
  {"setNumVSubdiv", &Dtool_SheetNode_set_num_v_subdiv_309, METH_O, (const char *)Dtool_SheetNode_set_num_v_subdiv_309_comment},
  {"get_num_v_subdiv", &Dtool_SheetNode_get_num_v_subdiv_310, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_v_subdiv_310_comment},
  {"getNumVSubdiv", &Dtool_SheetNode_get_num_v_subdiv_310, METH_NOARGS, (const char *)Dtool_SheetNode_get_num_v_subdiv_310_comment},
  {"reset_bound", &Dtool_SheetNode_reset_bound_311, METH_O, (const char *)Dtool_SheetNode_reset_bound_311_comment},
  {"resetBound", &Dtool_SheetNode_reset_bound_311, METH_O, (const char *)Dtool_SheetNode_reset_bound_311_comment},
  {"get_class_type", &Dtool_SheetNode_get_class_type_312, METH_NOARGS | METH_STATIC, (const char *)Dtool_SheetNode_get_class_type_312_comment},
  {"getClassType", &Dtool_SheetNode_get_class_type_312, METH_NOARGS | METH_STATIC, (const char *)Dtool_SheetNode_get_class_type_312_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SheetNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SheetNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SheetNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SheetNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SheetNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SheetNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SheetNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SheetNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SheetNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SheetNode,
    &Dtool_SequenceMethods_SheetNode,
    &Dtool_MappingMethods_SheetNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SheetNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class draws a visible representation of the NURBS surface stored in\n"
    " * its NurbsSurfaceEvaluator.  It automatically recomputes the surface every\n"
    " * frame.\n"
    " *\n"
    " * This is not related to NurbsSurface, CubicSurfaceseg or any of the\n"
    " * ParametricSurface-derived objects in this module.  It is a completely\n"
    " * parallel implementation of NURBS surfaces, and will probably eventually\n"
    " * replace the whole ParametricSurface class hierarchy.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SheetNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SheetNode,
    PyType_GenericAlloc,
    Dtool_new_SheetNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SheetNode,
  Dtool_UpcastInterface_SheetNode,
  Dtool_DowncastInterface_SheetNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SheetNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_SheetNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_SheetNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SheetNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SheetNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SheetNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SheetNode);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3parametrics_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    ParametricCurve::init_type();
    TypeHandle handle = ParametricCurve::get_class_type();
    Dtool_ParametricCurve._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParametricCurve);
  }
  {
    CubicCurveseg::init_type();
    TypeHandle handle = CubicCurveseg::get_class_type();
    Dtool_CubicCurveseg._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CubicCurveseg);
  }
  {
    CurveFitter::init_type();
    TypeHandle handle = CurveFitter::get_class_type();
    Dtool_CurveFitter._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CurveFitter);
  }
  {
    PiecewiseCurve::init_type();
    TypeHandle handle = PiecewiseCurve::get_class_type();
    Dtool_PiecewiseCurve._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PiecewiseCurve);
  }
  {
    HermiteCurve::init_type();
    TypeHandle handle = HermiteCurve::get_class_type();
    Dtool_HermiteCurve._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_HermiteCurve);
  }
  {
    NurbsCurveInterface::init_type();
    TypeHandle handle = NurbsCurveInterface::get_class_type();
    Dtool_NurbsCurveInterface._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NurbsCurveInterface);
  }
  {
    NurbsCurve::init_type();
    TypeHandle handle = NurbsCurve::get_class_type();
    Dtool_NurbsCurve._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NurbsCurve);
  }
  {
    RopeNode::init_type();
    TypeHandle handle = RopeNode::get_class_type();
    Dtool_RopeNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RopeNode);
  }
  {
    SheetNode::init_type();
    TypeHandle handle = SheetNode::get_class_type();
    Dtool_SheetNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SheetNode);
  }
}

void Dtool_libp3parametrics_BuildInstants(PyObject *module) {
  (void) module;
  PyModule_AddIntConstant(module, "HC_CUT", 1);
  PyModule_AddIntConstant(module, "HCCUT", 1);
  PyModule_AddIntConstant(module, "HC_FREE", 2);
  PyModule_AddIntConstant(module, "HCFREE", 2);
  PyModule_AddIntConstant(module, "HC_G1", 3);
  PyModule_AddIntConstant(module, "HCG1", 3);
  PyModule_AddIntConstant(module, "HC_SMOOTH", 4);
  PyModule_AddIntConstant(module, "HCSMOOTH", 4);
  PyModule_AddIntConstant(module, "PCT_HPR", 2);
  PyModule_AddIntConstant(module, "PCTHPR", 2);
  PyModule_AddIntConstant(module, "PCT_NONE", 0);
  PyModule_AddIntConstant(module, "PCTNONE", 0);
  PyModule_AddIntConstant(module, "PCT_T", 3);
  PyModule_AddIntConstant(module, "PCTT", 3);
  PyModule_AddIntConstant(module, "PCT_XYZ", 1);
  PyModule_AddIntConstant(module, "PCTXYZ", 1);
  // ParametricCurve
  Dtool_PyModuleClassInit_ParametricCurve(module);
  PyModule_AddObject(module, "ParametricCurve", (PyObject *)&Dtool_ParametricCurve);
  // CubicCurveseg
  Dtool_PyModuleClassInit_CubicCurveseg(module);
  PyModule_AddObject(module, "CubicCurveseg", (PyObject *)&Dtool_CubicCurveseg);
  // ParametricCurveCollection
  Dtool_PyModuleClassInit_ParametricCurveCollection(module);
  PyModule_AddObject(module, "ParametricCurveCollection", (PyObject *)&Dtool_ParametricCurveCollection);
  // CurveFitter
  Dtool_PyModuleClassInit_CurveFitter(module);
  PyModule_AddObject(module, "CurveFitter", (PyObject *)&Dtool_CurveFitter);
  // PiecewiseCurve
  Dtool_PyModuleClassInit_PiecewiseCurve(module);
  PyModule_AddObject(module, "PiecewiseCurve", (PyObject *)&Dtool_PiecewiseCurve);
  // HermiteCurve
  Dtool_PyModuleClassInit_HermiteCurve(module);
  PyModule_AddObject(module, "HermiteCurve", (PyObject *)&Dtool_HermiteCurve);
  // NurbsCurveInterface
  Dtool_PyModuleClassInit_NurbsCurveInterface(module);
  PyModule_AddObject(module, "NurbsCurveInterface", (PyObject *)&Dtool_NurbsCurveInterface);
  // NurbsCurve
  Dtool_PyModuleClassInit_NurbsCurve(module);
  PyModule_AddObject(module, "NurbsCurve", (PyObject *)&Dtool_NurbsCurve);
  // NurbsCurveResult
  Dtool_PyModuleClassInit_NurbsCurveResult(module);
  PyModule_AddObject(module, "NurbsCurveResult", (PyObject *)&Dtool_NurbsCurveResult);
  // NurbsCurveEvaluator
  Dtool_PyModuleClassInit_NurbsCurveEvaluator(module);
  PyModule_AddObject(module, "NurbsCurveEvaluator", (PyObject *)&Dtool_NurbsCurveEvaluator);
  // NurbsSurfaceResult
  Dtool_PyModuleClassInit_NurbsSurfaceResult(module);
  PyModule_AddObject(module, "NurbsSurfaceResult", (PyObject *)&Dtool_NurbsSurfaceResult);
  // NurbsSurfaceEvaluator
  Dtool_PyModuleClassInit_NurbsSurfaceEvaluator(module);
  PyModule_AddObject(module, "NurbsSurfaceEvaluator", (PyObject *)&Dtool_NurbsSurfaceEvaluator);
  // RopeNode
  Dtool_PyModuleClassInit_RopeNode(module);
  PyModule_AddObject(module, "RopeNode", (PyObject *)&Dtool_RopeNode);
  // SheetNode
  Dtool_PyModuleClassInit_SheetNode(module);
  PyModule_AddObject(module, "SheetNode", (PyObject *)&Dtool_SheetNode);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3parametrics_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3parametrics_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613867,  /* file_identifier */
  "libp3parametrics",  /* library_name */
  "UKlv",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3parametrics.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  664  /* next_index */
};

Configure(_in_configure_libp3parametrics);
ConfigureFn(_in_configure_libp3parametrics) {
  interrogate_request_module(&_in_module_def);
}

