/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/pgraphnodes -Ipanda/src/pgraphnodes -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3pgraphnodes_igate.cxx -od built/pandac/input/libp3pgraphnodes.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pgraphnodes -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3pgraphnodes ambientLight.h callbackNode.h computeNode.h config_pgraphnodes.h directionalLight.h fadeLodNode.h fadeLodNodeData.h lightLensNode.h lightNode.h lodNode.h lodNodeType.h nodeCullCallbackData.h p3pgraphnodes_composite1.cxx p3pgraphnodes_composite2.cxx pointLight.h rectangleLight.h sceneGraphAnalyzer.h selectiveChildNode.h sequenceNode.h shaderGenerator.h sphereLight.h spotlight.h switchNode.h uvScrollNode.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "ambientLight.h"
#include "auxSceneData.h"
#include "callbackData.h"
#include "callbackNode.h"
#include "callbackObject.h"
#include "computeNode.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_pgraphnodes.h"
#include "cullTraverser.h"
#include "cullTraverserData.h"
#include "dconfig.h"
#include "directionalLight.h"
#include "fadeLodNode.h"
#include "fadeLodNodeData.h"
#include "lightLensNode.h"
#include "lightNode.h"
#include "lodNode.h"
#include "lodNodeType.h"
#include "nodeCullCallbackData.h"
#include "notifyCategoryProxy.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pointLight.h"
#include "pointerTo.h"
#include "rectangleLight.h"
#include "sceneGraphAnalyzer.h"
#include "selectiveChildNode.h"
#include "sequenceNode.h"
#include "shaderGenerator.h"
#include "sphereLight.h"
#include "spotlight.h"
#include "switchNode.h"
#include "uvScrollNode.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class LightNode
 */
typedef LightNode LightNode_localtype;
Define_Module_ClassRef(panda3d.core, LightNode, LightNode_localtype, LightNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightNode = &Dtool_LightNode;
static void Dtool_PyModuleClassInit_LightNode(PyObject *module);

/**
 * Forward declarations for top-level class AmbientLight
 */
typedef AmbientLight AmbientLight_localtype;
Define_Module_ClassRef(panda3d.core, AmbientLight, AmbientLight_localtype, AmbientLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AmbientLight = &Dtool_AmbientLight;
static void Dtool_PyModuleClassInit_AmbientLight(PyObject *module);

/**
 * Forward declarations for top-level class CallbackNode
 */
typedef CallbackNode CallbackNode_localtype;
Define_Module_ClassRef(panda3d.core, CallbackNode, CallbackNode_localtype, CallbackNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackNode = &Dtool_CallbackNode;
static void Dtool_PyModuleClassInit_CallbackNode(PyObject *module);

/**
 * Forward declarations for top-level class ComputeNode
 */
typedef ComputeNode ComputeNode_localtype;
Define_Module_ClassRef(panda3d.core, ComputeNode, ComputeNode_localtype, ComputeNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ComputeNode = &Dtool_ComputeNode;
static void Dtool_PyModuleClassInit_ComputeNode(PyObject *module);

/**
 * Forward declarations for top-level class LightLensNode
 */
typedef LightLensNode LightLensNode_localtype;
Define_Module_ClassRef(panda3d.core, LightLensNode, LightLensNode_localtype, LightLensNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightLensNode = &Dtool_LightLensNode;
static void Dtool_PyModuleClassInit_LightLensNode(PyObject *module);

/**
 * Forward declarations for top-level class DirectionalLight
 */
typedef DirectionalLight DirectionalLight_localtype;
Define_Module_ClassRef(panda3d.core, DirectionalLight, DirectionalLight_localtype, DirectionalLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DirectionalLight = &Dtool_DirectionalLight;
static void Dtool_PyModuleClassInit_DirectionalLight(PyObject *module);

/**
 * Forward declarations for top-level class LODNode
 */
typedef LODNode LODNode_localtype;
Define_Module_ClassRef(panda3d.core, LODNode, LODNode_localtype, LODNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LODNode = &Dtool_LODNode;
static void Dtool_PyModuleClassInit_LODNode(PyObject *module);

/**
 * Forward declarations for top-level class FadeLODNode
 */
typedef FadeLODNode FadeLODNode_localtype;
Define_Module_ClassRef(panda3d.core, FadeLODNode, FadeLODNode_localtype, FadeLODNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FadeLODNode = &Dtool_FadeLODNode;
static void Dtool_PyModuleClassInit_FadeLODNode(PyObject *module);

/**
 * Forward declarations for top-level class NodeCullCallbackData
 */
typedef NodeCullCallbackData NodeCullCallbackData_localtype;
Define_Module_Class_Private(panda3d.core, NodeCullCallbackData, NodeCullCallbackData_localtype, NodeCullCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeCullCallbackData = &Dtool_NodeCullCallbackData;
static void Dtool_PyModuleClassInit_NodeCullCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class PointLight
 */
typedef PointLight PointLight_localtype;
Define_Module_ClassRef(panda3d.core, PointLight, PointLight_localtype, PointLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointLight = &Dtool_PointLight;
static void Dtool_PyModuleClassInit_PointLight(PyObject *module);

/**
 * Forward declarations for top-level class RectangleLight
 */
typedef RectangleLight RectangleLight_localtype;
Define_Module_ClassRef(panda3d.core, RectangleLight, RectangleLight_localtype, RectangleLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RectangleLight = &Dtool_RectangleLight;
static void Dtool_PyModuleClassInit_RectangleLight(PyObject *module);

/**
 * Forward declarations for top-level class SelectiveChildNode
 */
typedef SelectiveChildNode SelectiveChildNode_localtype;
Define_Module_ClassRef(panda3d.core, SelectiveChildNode, SelectiveChildNode_localtype, SelectiveChildNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SelectiveChildNode = &Dtool_SelectiveChildNode;
static void Dtool_PyModuleClassInit_SelectiveChildNode(PyObject *module);

/**
 * Forward declarations for top-level class SequenceNode
 */
typedef SequenceNode SequenceNode_localtype;
Define_Module_ClassRef(panda3d.core, SequenceNode, SequenceNode_localtype, SequenceNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SequenceNode = &Dtool_SequenceNode;
static void Dtool_PyModuleClassInit_SequenceNode(PyObject *module);

/**
 * Forward declarations for top-level class ShaderGenerator
 */
typedef ShaderGenerator ShaderGenerator_localtype;
Define_Module_ClassRef(panda3d.core, ShaderGenerator, ShaderGenerator_localtype, ShaderGenerator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderGenerator = &Dtool_ShaderGenerator;
static void Dtool_PyModuleClassInit_ShaderGenerator(PyObject *module);
bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced);
bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced);

/**
 * Forward declarations for top-level class SphereLight
 */
typedef SphereLight SphereLight_localtype;
Define_Module_ClassRef(panda3d.core, SphereLight, SphereLight_localtype, SphereLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SphereLight = &Dtool_SphereLight;
static void Dtool_PyModuleClassInit_SphereLight(PyObject *module);

/**
 * Forward declarations for top-level class Spotlight
 */
typedef Spotlight Spotlight_localtype;
Define_Module_ClassRef(panda3d.core, Spotlight, Spotlight_localtype, Spotlight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Spotlight = &Dtool_Spotlight;
static void Dtool_PyModuleClassInit_Spotlight(PyObject *module);
bool Dtool_ConstCoerce_Spotlight(PyObject *args, CPT(Spotlight) &coerced);
bool Dtool_Coerce_Spotlight(PyObject *args, PT(Spotlight) &coerced);

/**
 * Forward declarations for top-level class SwitchNode
 */
typedef SwitchNode SwitchNode_localtype;
Define_Module_ClassRef(panda3d.core, SwitchNode, SwitchNode_localtype, SwitchNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SwitchNode = &Dtool_SwitchNode;
static void Dtool_PyModuleClassInit_SwitchNode(PyObject *module);

/**
 * Forward declarations for top-level class UvScrollNode
 */
typedef UvScrollNode UvScrollNode_localtype;
Define_Module_ClassRef(panda3d.core, UvScrollNode, UvScrollNode_localtype, UvScrollNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UvScrollNode = &Dtool_UvScrollNode;
static void Dtool_PyModuleClassInit_UvScrollNode(PyObject *module);

/**
 * Forward declarations for top-level class SceneGraphAnalyzer
 */
typedef SceneGraphAnalyzer SceneGraphAnalyzer_localtype;
Define_Module_Class(panda3d.core, SceneGraphAnalyzer, SceneGraphAnalyzer_localtype, SceneGraphAnalyzer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SceneGraphAnalyzer = &Dtool_SceneGraphAnalyzer;
static void Dtool_PyModuleClassInit_SceneGraphAnalyzer(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"LightNode", &Dtool_LightNode},
  {"AmbientLight", &Dtool_AmbientLight},
  {"CallbackNode", &Dtool_CallbackNode},
  {"ComputeNode", &Dtool_ComputeNode},
  {"LightLensNode", &Dtool_LightLensNode},
  {"DirectionalLight", &Dtool_DirectionalLight},
  {"LODNode", &Dtool_LODNode},
  {"FadeLODNode", &Dtool_FadeLODNode},
  {"NodeCullCallbackData", &Dtool_NodeCullCallbackData},
  {"PointLight", &Dtool_PointLight},
  {"RectangleLight", &Dtool_RectangleLight},
  {"SelectiveChildNode", &Dtool_SelectiveChildNode},
  {"SequenceNode", &Dtool_SequenceNode},
  {"ShaderGenerator", &Dtool_ShaderGenerator},
  {"SphereLight", &Dtool_SphereLight},
  {"Spotlight", &Dtool_Spotlight},
  {"SwitchNode", &Dtool_SwitchNode},
  {"UvScrollNode", &Dtool_UvScrollNode},
  {"SceneGraphAnalyzer", &Dtool_SceneGraphAnalyzer},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"CallbackObject", nullptr},
#define Dtool_Ptr_CallbackObject (imports[0].type)
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[1].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"LVecBase2i", nullptr},
#define Dtool_Ptr_LVecBase2i (imports[5].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[6].type)
  {"LVecBase3i", nullptr},
#define Dtool_Ptr_LVecBase3i (imports[7].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[8].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[9].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[10].type)
  {"GeomVertexAnimationSpec", nullptr},
#define Dtool_Ptr_GeomVertexAnimationSpec (imports[11].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[12].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[13].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[14].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[15].type)
  {"GraphicsStateGuardianBase", nullptr},
#define Dtool_Ptr_GraphicsStateGuardianBase (imports[16].type)
  {"RenderState", nullptr},
#define Dtool_Ptr_RenderState (imports[17].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[18].type)
  {"Light", nullptr},
#define Dtool_Ptr_Light (imports[19].type)
  {"LensNode", nullptr},
#define Dtool_Ptr_LensNode (imports[20].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[21].type)
  {"Camera", nullptr},
#define Dtool_Ptr_Camera (imports[22].type)
  {"GraphicsOutputBase", nullptr},
#define Dtool_Ptr_GraphicsOutputBase (imports[23].type)
  {"CallbackData", nullptr},
#define Dtool_Ptr_CallbackData (imports[24].type)
  {"CullTraverser", nullptr},
#define Dtool_Ptr_CullTraverser (imports[25].type)
  {"CullTraverserData", nullptr},
#define Dtool_Ptr_CullTraverserData (imports[26].type)
  {"AnimInterface", nullptr},
#define Dtool_Ptr_AnimInterface (imports[27].type)
  {"ShaderAttrib", nullptr},
#define Dtool_Ptr_ShaderAttrib (imports[28].type)
  {nullptr, nullptr},
};
#endif

// CallbackObject
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != nullptr, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != nullptr, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_CallbackObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackObject = &Dtool_CallbackObject;
extern bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced);
extern bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced);
#endif
// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// GeomVertexAnimationSpec
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GeomVertexAnimationSpec;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomVertexAnimationSpec = &Dtool_GeomVertexAnimationSpec;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// GraphicsStateGuardianBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardianBase = &Dtool_GraphicsStateGuardianBase;
#endif
// RenderState
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced) {
  nassertr(Dtool_Ptr_RenderState != nullptr, false);
  nassertr(Dtool_Ptr_RenderState->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(RenderState) &))Dtool_Ptr_RenderState->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_RenderState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderState = &Dtool_RenderState;
extern bool Dtool_ConstCoerce_RenderState(PyObject *args, CPT(RenderState) &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// Light
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Light;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Light = &Dtool_Light;
#endif
// LensNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_LensNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LensNode = &Dtool_LensNode;
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// Camera
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Camera;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Camera = &Dtool_Camera;
#endif
// GraphicsOutputBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutputBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutputBase = &Dtool_GraphicsOutputBase;
#endif
// CallbackData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CallbackData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackData = &Dtool_CallbackData;
#endif
// CullTraverser
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverser;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverser = &Dtool_CullTraverser;
#endif
// CullTraverserData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverserData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverserData = &Dtool_CullTraverserData;
#endif
// AnimInterface
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AnimInterface;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimInterface = &Dtool_AnimInterface;
#endif
// ShaderAttrib
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced) {
  nassertr(Dtool_Ptr_ShaderAttrib != nullptr, false);
  nassertr(Dtool_Ptr_ShaderAttrib->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(ShaderAttrib) &))Dtool_Ptr_ShaderAttrib->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ShaderAttrib;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderAttrib = &Dtool_ShaderAttrib;
extern bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class LightNode
 */
/**
 * Python function wrapper for:
 * virtual void LightNode::output(std::ostream &out) const
 */
static PyObject *Dtool_LightNode_output_8(PyObject *self, PyObject *arg) {
  LightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightNode)) {
    return nullptr;
  }
  // 1-virtual void LightNode::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LightNode.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LightNode*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightNode self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightNode_output_8_comment =
  "C++ Interface:\n"
  "output(LightNode self, ostream out)\n"
  "\n"
  "// We have to explicitly publish these because they resolve the multiple\n"
  "// inheritance.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightNode_output_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void LightNode::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LightNode_write_9(PyObject *self, PyObject *args, PyObject *kwds) {
  LightNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightNode)) {
    return nullptr;
  }
  // 1-virtual void LightNode::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "LightNode.write", false, true);
    if (param1_this != nullptr) {
      ((*(const LightNode*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LightNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightNode_write_9_comment =
  "C++ Interface:\n"
  "write(LightNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightNode_write_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LightNode::get_class_type(void)
 */
static PyObject *Dtool_LightNode_get_class_type_10(PyObject *, PyObject *) {
  // 1-static TypeHandle LightNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LightNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightNode_get_class_type_10_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LightNode_get_class_type_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Light *LightNode::upcast_to_Light(void)
 */
static PyObject *Dtool_LightNode_upcast_to_Light_3(PyObject *self, PyObject *) {
  LightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightNode, (void **)&local_this, "LightNode.upcast_to_Light")) {
    return nullptr;
  }
  // 1-Light *LightNode::upcast_to_Light(void)
  Light *return_value = (Light *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Light, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LightNode_upcast_to_Light_3_comment =
  "C++ Interface:\n"
  "upcast_to_Light(const LightNode self)\n"
  "\n"
  "upcast from LightNode to Light";
#else
static const char *Dtool_LightNode_upcast_to_Light_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PandaNode *LightNode::upcast_to_PandaNode(void)
 */
static PyObject *Dtool_LightNode_upcast_to_PandaNode_6(PyObject *self, PyObject *) {
  LightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightNode, (void **)&local_this, "LightNode.upcast_to_PandaNode")) {
    return nullptr;
  }
  // 1-PandaNode *LightNode::upcast_to_PandaNode(void)
  PandaNode *return_value = (PandaNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightNode_upcast_to_PandaNode_6_comment =
  "C++ Interface:\n"
  "upcast_to_PandaNode(const LightNode self)\n"
  "\n"
  "upcast from LightNode to PandaNode";
#else
static const char *Dtool_LightNode_upcast_to_PandaNode_6_comment = nullptr;
#endif

static int Dtool_Init_LightNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LightNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightNode) {
    printf("LightNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightNode *local_this = (LightNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LightNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LightNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AmbientLight
 */
/**
 * Python function wrapper for:
 * static TypeHandle AmbientLight::get_class_type(void)
 */
static PyObject *Dtool_AmbientLight_get_class_type_14(PyObject *, PyObject *) {
  // 1-static TypeHandle AmbientLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AmbientLight::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AmbientLight_get_class_type_14_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AmbientLight_get_class_type_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit AmbientLight::AmbientLight(std::string const &name)
 */
static int Dtool_Init_AmbientLight(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AmbientLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit AmbientLight::AmbientLight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      AmbientLight *return_value = new AmbientLight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AmbientLight, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AmbientLight(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AmbientLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AmbientLight) {
    printf("AmbientLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AmbientLight *local_this = (AmbientLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AmbientLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightNode) {
    return (LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LightNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AmbientLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AmbientLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightNode) {
    LightNode* other_this = (LightNode*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AmbientLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AmbientLight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackNode
 */
/**
 * Python function wrapper for:
 * inline void CallbackNode::set_cull_callback(CallbackObject *object)
 */
static PyObject *Dtool_CallbackNode_set_cull_callback_18(PyObject *self, PyObject *arg) {
  CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.set_cull_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackNode::set_cull_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_cull_callback", "CallbackObject");
  }
  ((*local_this).set_cull_callback)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_set_cull_callback_18_comment =
  "C++ Interface:\n"
  "set_cull_callback(const CallbackNode self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when this node is visited\n"
  " * during the cull traversal.  This callback will be made during the cull\n"
  " * thread.\n"
  " *\n"
  " * The cull traversal is responsible for determining which nodes are visible\n"
  " * and within the view frustum, and for accumulating state and transform, and\n"
  " * generally building up the list of CullableObjects that are to be eventually\n"
  " * passed to the draw traversal for rendering.\n"
  " *\n"
  " * At the time the cull traversal callback is made, the node has been\n"
  " * determined to be visible and it has passed the bounding-volume test, so it\n"
  " * lies within the view frustum.\n"
  " *\n"
  " * The callback is passed an instance of a NodeCullCallbackData, which\n"
  " * contains pointers to the CullTraverser and CullTraverserData--enough data\n"
  " * to examine the current node and its place within the scene graph.  The\n"
  " * callback *replaces* the normal cull behavior, so if your callback does\n"
  " * nothing, the cull traversal will not continue below this node.  If you wish\n"
  " * the cull traversal to continue to visit this node and below, you must call\n"
  " * cbdata->upcall() from your callback.\n"
  " */";
#else
static const char *Dtool_CallbackNode_set_cull_callback_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackNode::clear_cull_callback(void)
 */
static PyObject *Dtool_CallbackNode_clear_cull_callback_19(PyObject *self, PyObject *) {
  CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.clear_cull_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackNode::clear_cull_callback(void)
  ((*local_this).clear_cull_callback)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_clear_cull_callback_19_comment =
  "C++ Interface:\n"
  "clear_cull_callback(const CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_cull_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_clear_cull_callback_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *CallbackNode::get_cull_callback(void) const
 */
static PyObject *Dtool_CallbackNode_get_cull_callback_20(PyObject *self, PyObject *) {
  CallbackNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackNode)) {
    return nullptr;
  }
  // 1-inline CallbackObject *CallbackNode::get_cull_callback(void) const
  CallbackObject *return_value = ((*(const CallbackNode*)local_this).get_cull_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_get_cull_callback_20_comment =
  "C++ Interface:\n"
  "get_cull_callback(CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_cull_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_get_cull_callback_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackNode::set_draw_callback(CallbackObject *object)
 */
static PyObject *Dtool_CallbackNode_set_draw_callback_24(PyObject *self, PyObject *arg) {
  CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.set_draw_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackNode::set_draw_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_draw_callback", "CallbackObject");
  }
  ((*local_this).set_draw_callback)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_set_draw_callback_24_comment =
  "C++ Interface:\n"
  "set_draw_callback(const CallbackNode self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when this node is visited\n"
  " * during the draw traversal.  This callback will be made during the draw\n"
  " * thread.\n"
  " *\n"
  " * The draw traversal is responsible for actually issuing the commands to the\n"
  " * graphics engine to draw primitives.  Its job is to walk through the list of\n"
  " * CullableObjects build up by the cull traversal, as quickly as possible,\n"
  " * issuing the appropriate commands to draw each one.\n"
  " *\n"
  " * At the time the draw traversal callback is made, the graphics state has\n"
  " * been loaded with the correct modelview transform and render state, and the\n"
  " * primitives (if any) in this node are ready to be drawn.\n"
  " *\n"
  " * The callback is passed an instance of a GeomDrawCallbackData, which\n"
  " * contains pointers to the current state and transform, as well as the\n"
  " * current GSG.  There is a Geom pointer as well, but it will always be NULL\n"
  " * to this callback, since the CallbackNode does not itself contain any Geoms.\n"
  " */";
#else
static const char *Dtool_CallbackNode_set_draw_callback_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackNode::clear_draw_callback(void)
 */
static PyObject *Dtool_CallbackNode_clear_draw_callback_25(PyObject *self, PyObject *) {
  CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.clear_draw_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackNode::clear_draw_callback(void)
  ((*local_this).clear_draw_callback)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_clear_draw_callback_25_comment =
  "C++ Interface:\n"
  "clear_draw_callback(const CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_draw_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_clear_draw_callback_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *CallbackNode::get_draw_callback(void) const
 */
static PyObject *Dtool_CallbackNode_get_draw_callback_26(PyObject *self, PyObject *) {
  CallbackNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackNode)) {
    return nullptr;
  }
  // 1-inline CallbackObject *CallbackNode::get_draw_callback(void) const
  CallbackObject *return_value = ((*(const CallbackNode*)local_this).get_draw_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_get_draw_callback_26_comment =
  "C++ Interface:\n"
  "get_draw_callback(CallbackNode self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_draw_callback().\n"
  " */";
#else
static const char *Dtool_CallbackNode_get_draw_callback_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackNode::get_class_type(void)
 */
static PyObject *Dtool_CallbackNode_get_class_type_28(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackNode_get_class_type_28_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackNode_get_class_type_28_comment = nullptr;
#endif

static PyObject *Dtool_CallbackNode_cull_callback_Getter(PyObject *self, void *) {
  const CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CallbackObject *CallbackNode::get_cull_callback(void) const
  CallbackObject *return_value = ((*(const CallbackNode*)local_this).get_cull_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_CallbackNode_cull_callback_Setter(PyObject *self, PyObject *arg, void *) {
  CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.cull_callback")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cull_callback attribute");
    return -1;
  }
  // 1-inline void CallbackNode::set_cull_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_cull_callback", "CallbackObject");
    return -1;
  }
  ((*local_this).set_cull_callback)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cull_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return -1;
}

static PyObject *Dtool_CallbackNode_draw_callback_Getter(PyObject *self, void *) {
  const CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CallbackObject *CallbackNode::get_draw_callback(void) const
  CallbackObject *return_value = ((*(const CallbackNode*)local_this).get_draw_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_CallbackNode_draw_callback_Setter(PyObject *self, PyObject *arg, void *) {
  CallbackNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackNode, (void **)&local_this, "CallbackNode.draw_callback")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete draw_callback attribute");
    return -1;
  }
  // 1-inline void CallbackNode::set_draw_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CallbackNode.set_draw_callback", "CallbackObject");
    return -1;
  }
  ((*local_this).set_draw_callback)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_draw_callback(const CallbackNode self, CallbackObject object)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit CallbackNode::CallbackNode(std::string const &name)
 */
static int Dtool_Init_CallbackNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CallbackNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit CallbackNode::CallbackNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      CallbackNode *return_value = new CallbackNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CallbackNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CallbackNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CallbackNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackNode) {
    printf("CallbackNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackNode *local_this = (CallbackNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CallbackNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CallbackNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ComputeNode
 */
/**
 * Python function wrapper for:
 * inline void ComputeNode::add_dispatch(LVecBase3i const &num_groups)
 * inline void ComputeNode::add_dispatch(int num_groups_x, int num_groups_y, int num_groups_z)
 */
static PyObject *Dtool_ComputeNode_add_dispatch_32(PyObject *self, PyObject *args, PyObject *kwds) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.add_dispatch")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "num_groups")) {
        // 1-inline void ComputeNode::add_dispatch(LVecBase3i const &num_groups)
        LVecBase3i arg_local;
        LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "ComputeNode.add_dispatch", "LVecBase3i");
        }
        ((*local_this).add_dispatch)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void ComputeNode::add_dispatch(int num_groups_x, int num_groups_y, int num_groups_z)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"num_groups_x", "num_groups_y", "num_groups_z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:add_dispatch", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_dispatch)((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_dispatch() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dispatch(const ComputeNode self, const LVecBase3i num_groups)\n"
      "add_dispatch(const ComputeNode self, int num_groups_x, int num_groups_y, int num_groups_z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_add_dispatch_32_comment =
  "C++ Interface:\n"
  "add_dispatch(const ComputeNode self, const LVecBase3i num_groups)\n"
  "add_dispatch(const ComputeNode self, int num_groups_x, int num_groups_y, int num_groups_z)\n"
  "\n"
  "/**\n"
  " * Adds a dispatch command with the given number of work groups in the X, Y,\n"
  " * and Z dimensions.  Any of these values may be set to 1 if the respective\n"
  " * dimension should not be used.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a dispatch command with the given number of work groups in the X, Y,\n"
  " * and Z dimensions.  Any of these values may be set to 1 if the respective\n"
  " * dimension should not be used.\n"
  " */";
#else
static const char *Dtool_ComputeNode_add_dispatch_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ComputeNode::get_num_dispatches(void) const
 */
static PyObject *Dtool_ComputeNode_get_num_dispatches_33(PyObject *self, PyObject *) {
  ComputeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ComputeNode)) {
    return nullptr;
  }
  // 1-inline std::size_t ComputeNode::get_num_dispatches(void) const
  std::size_t return_value = ((*(const ComputeNode*)local_this).get_num_dispatches)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_get_num_dispatches_33_comment =
  "C++ Interface:\n"
  "get_num_dispatches(ComputeNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of times add_dispatch has been called on this object.\n"
  " */";
#else
static const char *Dtool_ComputeNode_get_num_dispatches_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &ComputeNode::get_dispatch(std::size_t i) const
 */
static PyObject *Dtool_ComputeNode_get_dispatch_34(PyObject *self, PyObject *arg) {
  ComputeNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ComputeNode)) {
    return nullptr;
  }
  // 1-inline LVecBase3i const &ComputeNode::get_dispatch(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    LVecBase3i const *return_value = &(((*(const ComputeNode*)local_this).get_dispatch)(arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dispatch(ComputeNode self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_get_dispatch_34_comment =
  "C++ Interface:\n"
  "get_dispatch(ComputeNode self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the group counts of the nth dispatch associated with this object.\n"
  " */";
#else
static const char *Dtool_ComputeNode_get_dispatch_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &num_groups)
 */
static PyObject *Dtool_ComputeNode_set_dispatch_35(PyObject *self, PyObject *args, PyObject *kwds) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.set_dispatch")) {
    return nullptr;
  }
  // 1-inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &num_groups)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "num_groups", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_dispatch", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    LVecBase3i param2_local;
    LVecBase3i const *param2_this = Dtool_Coerce_LVecBase3i(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ComputeNode.set_dispatch", "LVecBase3i");
    }
    ((*local_this).set_dispatch)((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dispatch(const ComputeNode self, int i, const LVecBase3i num_groups)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_set_dispatch_35_comment =
  "C++ Interface:\n"
  "set_dispatch(const ComputeNode self, int i, const LVecBase3i num_groups)\n"
  "\n"
  "/**\n"
  " * Sets the group counts of the nth dispatch associated with this object.\n"
  " */";
#else
static const char *Dtool_ComputeNode_set_dispatch_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ComputeNode::insert_dispatch(std::size_t i, LVecBase3i const &num_groups)
 */
static PyObject *Dtool_ComputeNode_insert_dispatch_36(PyObject *self, PyObject *args, PyObject *kwds) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.insert_dispatch")) {
    return nullptr;
  }
  // 1-inline void ComputeNode::insert_dispatch(std::size_t i, LVecBase3i const &num_groups)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "num_groups", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_dispatch", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    LVecBase3i param2_local;
    LVecBase3i const *param2_this = Dtool_Coerce_LVecBase3i(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ComputeNode.insert_dispatch", "LVecBase3i");
    }
    ((*local_this).insert_dispatch)((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_dispatch(const ComputeNode self, int i, const LVecBase3i num_groups)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_insert_dispatch_36_comment =
  "C++ Interface:\n"
  "insert_dispatch(const ComputeNode self, int i, const LVecBase3i num_groups)\n"
  "\n"
  "/**\n"
  " * Inserts a dispatch command with the given number of work groups in the X,\n"
  " * Y, and Z dimensions at the given position in the list of dispatch commands.\n"
  " * Any of these values may be set to 1 if the respective dimension should not\n"
  " * be used.\n"
  " */";
#else
static const char *Dtool_ComputeNode_insert_dispatch_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ComputeNode::remove_dispatch(std::size_t i)
 */
static PyObject *Dtool_ComputeNode_remove_dispatch_37(PyObject *self, PyObject *arg) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.remove_dispatch")) {
    return nullptr;
  }
  // 1-inline void ComputeNode::remove_dispatch(std::size_t i)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_dispatch)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_dispatch(const ComputeNode self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_remove_dispatch_37_comment =
  "C++ Interface:\n"
  "remove_dispatch(const ComputeNode self, int i)\n"
  "\n"
  "/**\n"
  " * Erases the given dispatch index from the list.\n"
  " */";
#else
static const char *Dtool_ComputeNode_remove_dispatch_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ComputeNode::clear_dispatches(void)
 */
static PyObject *Dtool_ComputeNode_clear_dispatches_38(PyObject *self, PyObject *) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.clear_dispatches")) {
    return nullptr;
  }
  // 1-inline void ComputeNode::clear_dispatches(void)
  ((*local_this).clear_dispatches)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_clear_dispatches_38_comment =
  "C++ Interface:\n"
  "clear_dispatches(const ComputeNode self)\n"
  "\n"
  "/**\n"
  " * Removes all dispatch commands.\n"
  " */";
#else
static const char *Dtool_ComputeNode_clear_dispatches_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ComputeNode::get_class_type(void)
 */
static PyObject *Dtool_ComputeNode_get_class_type_43(PyObject *, PyObject *) {
  // 1-static TypeHandle ComputeNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ComputeNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ComputeNode_get_class_type_43_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ComputeNode_get_class_type_43_comment = nullptr;
#endif

/**
 * sequence length function for property ComputeNode::dispatches
 */
static Py_ssize_t Dtool_ComputeNode_dispatches_Len(PyObject *self) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_dispatches)();
}

/**
 * sequence getter for property ComputeNode::dispatches
 */
static PyObject *Dtool_ComputeNode_dispatches_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_dispatches)()) {
    PyErr_SetString(PyExc_IndexError, "ComputeNode.dispatches[] index out of range");
    return nullptr;
  }
  // 1-inline LVecBase3i const &ComputeNode::get_dispatch(std::size_t i) const
  LVecBase3i const *return_value = &(((*(const ComputeNode*)local_this).get_dispatch)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dispatch(ComputeNode self, index)\n");
  }
}

static int Dtool_ComputeNode_dispatches_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.dispatches")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_dispatches)()) {
    PyErr_SetString(PyExc_IndexError, "ComputeNode.dispatches[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_dispatch(index);
    return 0;
  }
  // 1-inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &num_groups)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 2, "ComputeNode.set_dispatch", "LVecBase3i");
    return -1;
  }
  ((*local_this).set_dispatch)(index, *arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dispatch(const ComputeNode self, index, const LVecBase3i num_groups)\n");
  }
  return -1;
}

static PyObject *Dtool_ComputeNode_dispatches_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ComputeNode, (void **)&local_this, "ComputeNode.dispatches")) {
    return nullptr;
  }

  // 1-inline void ComputeNode::insert_dispatch(std::size_t i, LVecBase3i const &num_groups)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 2, "ComputeNode.insert_dispatch", "LVecBase3i");
  }
  ((*local_this).insert_dispatch)(index, *arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(Py_None);
  return Py_None;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_dispatch(const ComputeNode self, index, const LVecBase3i num_groups)\n");
  }
  return nullptr;
}

static PyObject *Dtool_ComputeNode_dispatches_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "ComputeNode.dispatches");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ComputeNode_dispatches_Len;
    wrap->_getitem_func = &Dtool_ComputeNode_dispatches_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_ComputeNode_dispatches_Sequence_Setitem;
      wrap->_insert_func = &Dtool_ComputeNode_dispatches_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit ComputeNode::ComputeNode(std::string const &name)
 */
static int Dtool_Init_ComputeNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ComputeNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit ComputeNode::ComputeNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      ComputeNode *return_value = new ComputeNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ComputeNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ComputeNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ComputeNode_get_dispatches(PyObject *self, PyObject *) {
  ComputeNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ComputeNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_dispatches)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ComputeNode_get_dispatch_34(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ComputeNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ComputeNode) {
    printf("ComputeNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ComputeNode *local_this = (ComputeNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ComputeNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ComputeNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ComputeNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ComputeNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ComputeNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightLensNode
 */
/**
 * Python function wrapper for:
 * inline bool LightLensNode::has_specular_color(void) const
 */
static PyObject *Dtool_LightLensNode_has_specular_color_53(PyObject *self, PyObject *) {
  LightLensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightLensNode)) {
    return nullptr;
  }
  // 1-inline bool LightLensNode::has_specular_color(void) const
  bool return_value = ((*(const LightLensNode*)local_this).has_specular_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_has_specular_color_53_comment =
  "C++ Interface:\n"
  "has_specular_color(LightLensNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this light defines a specular color, false if the specular\n"
  " * color is derived automatically from the light color.\n"
  " */";
#else
static const char *Dtool_LightLensNode_has_specular_color_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightLensNode::is_shadow_caster(void) const
 */
static PyObject *Dtool_LightLensNode_is_shadow_caster_54(PyObject *self, PyObject *) {
  LightLensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightLensNode)) {
    return nullptr;
  }
  // 1-inline bool LightLensNode::is_shadow_caster(void) const
  bool return_value = ((*(const LightLensNode*)local_this).is_shadow_caster)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_is_shadow_caster_54_comment =
  "C++ Interface:\n"
  "is_shadow_caster(LightLensNode self)\n"
  "\n"
  "/**\n"
  " * Returns whether this light is configured to cast shadows or not.\n"
  " */";
#else
static const char *Dtool_LightLensNode_is_shadow_caster_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LightLensNode::set_shadow_caster(bool caster)
 * void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = -10)
 */
static PyObject *Dtool_LightLensNode_set_shadow_caster_55(PyObject *self, PyObject *args, PyObject *kwds) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.set_shadow_caster")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "caster")) {
        // 1-void LightLensNode::set_shadow_caster(bool caster)
        ((*local_this).set_shadow_caster)((PyObject_IsTrue(arg) != 0));
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = -10)
      PyObject *param1;
      int param2;
      int param3;
      int param4 = -10;
      static const char *keyword_list[] = {"caster", "buffer_xsize", "buffer_ysize", "sort", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|i:set_shadow_caster", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_shadow_caster)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3, (int)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_shadow_caster() takes 2, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_caster(const LightLensNode self, bool caster)\n"
      "set_shadow_caster(const LightLensNode self, bool caster, int buffer_xsize, int buffer_ysize, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_set_shadow_caster_55_comment =
  "C++ Interface:\n"
  "set_shadow_caster(const LightLensNode self, bool caster)\n"
  "set_shadow_caster(const LightLensNode self, bool caster, int buffer_xsize, int buffer_ysize, int sort)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether this light should cast shadows or not.\n"
  " * This is the variant without buffer size, meaning that the current buffer\n"
  " * size will be kept (512x512 is the default). Note that enabling shadows will\n"
  " * require the shader generator to be enabled on the scene.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether this light should cast shadows or not.\n"
  " * The xsize and ysize parameters specify the size of the shadow buffer that\n"
  " * will be set up, the sort parameter specifies the sort.  Note that enabling\n"
  " * shadows will require the shader generator to be enabled on the scene.\n"
  " */";
#else
static const char *Dtool_LightLensNode_set_shadow_caster_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LightLensNode::get_shadow_buffer_sort(void) const
 */
static PyObject *Dtool_LightLensNode_get_shadow_buffer_sort_56(PyObject *self, PyObject *) {
  LightLensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightLensNode)) {
    return nullptr;
  }
  // 1-inline int LightLensNode::get_shadow_buffer_sort(void) const
  int return_value = ((*(const LightLensNode*)local_this).get_shadow_buffer_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_get_shadow_buffer_sort_56_comment =
  "C++ Interface:\n"
  "get_shadow_buffer_sort(LightLensNode self)\n"
  "\n"
  "/**\n"
  " * Returns the sort of the shadow buffer to be created for this light source.\n"
  " */";
#else
static const char *Dtool_LightLensNode_get_shadow_buffer_sort_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const
 */
static PyObject *Dtool_LightLensNode_get_shadow_buffer_size_57(PyObject *self, PyObject *) {
  LightLensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightLensNode)) {
    return nullptr;
  }
  // 1-inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const LightLensNode*)local_this).get_shadow_buffer_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_get_shadow_buffer_size_57_comment =
  "C++ Interface:\n"
  "get_shadow_buffer_size(LightLensNode self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the shadow buffer to be created for this light source.\n"
  " */";
#else
static const char *Dtool_LightLensNode_get_shadow_buffer_size_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &size)
 */
static PyObject *Dtool_LightLensNode_set_shadow_buffer_size_58(PyObject *self, PyObject *arg) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.set_shadow_buffer_size")) {
    return nullptr;
  }
  // 1-inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &size)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LightLensNode.set_shadow_buffer_size", "LVecBase2i");
  }
  ((*local_this).set_shadow_buffer_size)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_buffer_size(const LightLensNode self, const LVecBase2i size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_set_shadow_buffer_size_58_comment =
  "C++ Interface:\n"
  "set_shadow_buffer_size(const LightLensNode self, const LVecBase2i size)\n"
  "\n"
  "/**\n"
  " * Sets the size of the shadow buffer to be created for this light source.\n"
  " */";
#else
static const char *Dtool_LightLensNode_set_shadow_buffer_size_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutputBase *LightLensNode::get_shadow_buffer(GraphicsStateGuardianBase *gsg)
 */
static PyObject *Dtool_LightLensNode_get_shadow_buffer_59(PyObject *self, PyObject *arg) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.get_shadow_buffer")) {
    return nullptr;
  }
  // 1-inline GraphicsOutputBase *LightLensNode::get_shadow_buffer(GraphicsStateGuardianBase *gsg)
  GraphicsStateGuardianBase *arg_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsStateGuardianBase, 1, "LightLensNode.get_shadow_buffer", false, true);
  if (arg_this != nullptr) {
    GraphicsOutputBase *return_value = ((*local_this).get_shadow_buffer)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutputBase, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shadow_buffer(const LightLensNode self, GraphicsStateGuardianBase gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_get_shadow_buffer_59_comment =
  "C++ Interface:\n"
  "get_shadow_buffer(const LightLensNode self, GraphicsStateGuardianBase gsg)\n"
  "\n"
  "/**\n"
  " * Returns the buffer that has been constructed for a given GSG, or NULL if no\n"
  " * such buffer has (yet) been constructed.  This should be used for debugging\n"
  " * only, you will not need to call this normally.\n"
  " */";
#else
static const char *Dtool_LightLensNode_get_shadow_buffer_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void LightLensNode::output(std::ostream &out) const
 */
static PyObject *Dtool_LightLensNode_output_64(PyObject *self, PyObject *arg) {
  LightLensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightLensNode)) {
    return nullptr;
  }
  // 1-virtual void LightLensNode::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LightLensNode.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LightLensNode*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightLensNode self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_output_64_comment =
  "C++ Interface:\n"
  "output(LightLensNode self, ostream out)\n"
  "\n"
  "// We have to explicitly publish these because they resolve the multiple\n"
  "// inheritance.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightLensNode_output_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void LightLensNode::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LightLensNode_write_65(PyObject *self, PyObject *args, PyObject *kwds) {
  LightLensNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightLensNode)) {
    return nullptr;
  }
  // 1-virtual void LightLensNode::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "LightLensNode.write", false, true);
    if (param1_this != nullptr) {
      ((*(const LightLensNode*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LightLensNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_write_65_comment =
  "C++ Interface:\n"
  "write(LightLensNode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LightLensNode_write_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LightLensNode::get_class_type(void)
 */
static PyObject *Dtool_LightLensNode_get_class_type_66(PyObject *, PyObject *) {
  // 1-static TypeHandle LightLensNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LightLensNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_get_class_type_66_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LightLensNode_get_class_type_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Light *LightLensNode::upcast_to_Light(void)
 */
static PyObject *Dtool_LightLensNode_upcast_to_Light_47(PyObject *self, PyObject *) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.upcast_to_Light")) {
    return nullptr;
  }
  // 1-Light *LightLensNode::upcast_to_Light(void)
  Light *return_value = (Light *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Light, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_upcast_to_Light_47_comment =
  "C++ Interface:\n"
  "upcast_to_Light(const LightLensNode self)\n"
  "\n"
  "upcast from LightLensNode to Light";
#else
static const char *Dtool_LightLensNode_upcast_to_Light_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Camera *LightLensNode::upcast_to_Camera(void)
 */
static PyObject *Dtool_LightLensNode_upcast_to_Camera_50(PyObject *self, PyObject *) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.upcast_to_Camera")) {
    return nullptr;
  }
  // 1-Camera *LightLensNode::upcast_to_Camera(void)
  Camera *return_value = (Camera *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Camera, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LightLensNode_upcast_to_Camera_50_comment =
  "C++ Interface:\n"
  "upcast_to_Camera(const LightLensNode self)\n"
  "\n"
  "upcast from LightLensNode to Camera";
#else
static const char *Dtool_LightLensNode_upcast_to_Camera_50_comment = nullptr;
#endif

static PyObject *Dtool_LightLensNode_shadow_caster_Getter(PyObject *self, void *) {
  const LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LightLensNode::is_shadow_caster(void) const
  bool return_value = ((*(const LightLensNode*)local_this).is_shadow_caster)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LightLensNode_shadow_buffer_size_Getter(PyObject *self, void *) {
  const LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const LightLensNode*)local_this).get_shadow_buffer_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static int Dtool_LightLensNode_shadow_buffer_size_Setter(PyObject *self, PyObject *arg, void *) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightLensNode, (void **)&local_this, "LightLensNode.shadow_buffer_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shadow_buffer_size attribute");
    return -1;
  }
  // 1-inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &size)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LightLensNode.set_shadow_buffer_size", "LVecBase2i");
    return -1;
  }
  ((*local_this).set_shadow_buffer_size)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_buffer_size(const LightLensNode self, const LVecBase2i size)\n");
  }
  return -1;
}

static int Dtool_Init_LightLensNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LightLensNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightLensNode) {
    printf("LightLensNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightLensNode *local_this = (LightLensNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightLensNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightLensNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LightLensNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LightLensNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DirectionalLight
 */
/**
 * Python function wrapper for:
 * inline void DirectionalLight::set_specular_color(LColor const &color)
 */
static PyObject *Dtool_DirectionalLight_set_specular_color_69(PyObject *self, PyObject *arg) {
  DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.set_specular_color")) {
    return nullptr;
  }
  // 1-inline void DirectionalLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_specular_color", "LVecBase4f");
  }
  ((*local_this).set_specular_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specular_color(const DirectionalLight self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_set_specular_color_69_comment =
  "C++ Interface:\n"
  "set_specular_color(const DirectionalLight self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the color of specular highlights generated by the light.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_set_specular_color_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DirectionalLight::clear_specular_color(void)
 */
static PyObject *Dtool_DirectionalLight_clear_specular_color_70(PyObject *self, PyObject *) {
  DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.clear_specular_color")) {
    return nullptr;
  }
  // 1-inline void DirectionalLight::clear_specular_color(void)
  ((*local_this).clear_specular_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_clear_specular_color_70_comment =
  "C++ Interface:\n"
  "clear_specular_color(const DirectionalLight self)\n"
  "\n"
  "/**\n"
  " * Clears a custom specular color setting, meaning that the specular color\n"
  " * will now come from the color.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_clear_specular_color_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &DirectionalLight::get_point(void) const
 */
static PyObject *Dtool_DirectionalLight_get_point_77(PyObject *self, PyObject *) {
  DirectionalLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DirectionalLight)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &DirectionalLight::get_point(void) const
  LPoint3 const *return_value = &(((*(const DirectionalLight*)local_this).get_point)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_get_point_77_comment =
  "C++ Interface:\n"
  "get_point(DirectionalLight self)\n"
  "\n"
  "/**\n"
  " * Returns the point in space at which the light is located.  This is local to\n"
  " * the coordinate space in which the light is assigned.\n"
  " *\n"
  " * This actually has no bearing on the visual effect of the light, since the\n"
  " * light is rendered as if it were infinitely far away.  This is only used to\n"
  " * create a visible representation of the light.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_get_point_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DirectionalLight::set_point(LPoint3 const &point)
 */
static PyObject *Dtool_DirectionalLight_set_point_78(PyObject *self, PyObject *arg) {
  DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.set_point")) {
    return nullptr;
  }
  // 1-inline void DirectionalLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_point", "LPoint3f");
  }
  ((*local_this).set_point)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point(const DirectionalLight self, const LPoint3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_set_point_78_comment =
  "C++ Interface:\n"
  "set_point(const DirectionalLight self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Sets the point in space at which the light is located.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_set_point_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &DirectionalLight::get_direction(void) const
 */
static PyObject *Dtool_DirectionalLight_get_direction_83(PyObject *self, PyObject *) {
  DirectionalLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DirectionalLight)) {
    return nullptr;
  }
  // 1-inline LVector3 const &DirectionalLight::get_direction(void) const
  LVector3 const *return_value = &(((*(const DirectionalLight*)local_this).get_direction)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_get_direction_83_comment =
  "C++ Interface:\n"
  "get_direction(DirectionalLight self)\n"
  "\n"
  "/**\n"
  " * Returns the direction in which the light is aimed.  This is local to the\n"
  " * coordinate space in which the light is assigned.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_get_direction_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DirectionalLight::set_direction(LVector3 const &direction)
 */
static PyObject *Dtool_DirectionalLight_set_direction_84(PyObject *self, PyObject *arg) {
  DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.set_direction")) {
    return nullptr;
  }
  // 1-inline void DirectionalLight::set_direction(LVector3 const &direction)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_direction", "LVector3f");
  }
  ((*local_this).set_direction)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direction(const DirectionalLight self, const LVector3f direction)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_set_direction_84_comment =
  "C++ Interface:\n"
  "set_direction(const DirectionalLight self, const LVector3f direction)\n"
  "\n"
  "/**\n"
  " * Sets the direction in which the light is aimed.\n"
  " */";
#else
static const char *Dtool_DirectionalLight_set_direction_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DirectionalLight::get_class_type(void)
 */
static PyObject *Dtool_DirectionalLight_get_class_type_89(PyObject *, PyObject *) {
  // 1-static TypeHandle DirectionalLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DirectionalLight::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DirectionalLight_get_class_type_89_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DirectionalLight_get_class_type_89_comment = nullptr;
#endif

static PyObject *Dtool_DirectionalLight_specular_color_Getter(PyObject *self, void *) {
  const DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DirectionalLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline LColor const &DirectionalLight::get_specular_color(void) const final
  LColor const *return_value = &(((*(const DirectionalLight*)local_this).get_specular_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_DirectionalLight_specular_color_Setter(PyObject *self, PyObject *arg, void *) {
  DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.specular_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete specular_color attribute");
    return -1;
  }
  // 1-inline void DirectionalLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_specular_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_specular_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specular_color(const DirectionalLight self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_DirectionalLight_point_Getter(PyObject *self, void *) {
  const DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DirectionalLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &DirectionalLight::get_point(void) const
  LPoint3 const *return_value = &(((*(const DirectionalLight*)local_this).get_point)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_DirectionalLight_point_Setter(PyObject *self, PyObject *arg, void *) {
  DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.point")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete point attribute");
    return -1;
  }
  // 1-inline void DirectionalLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_point", "LPoint3f");
    return -1;
  }
  ((*local_this).set_point)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point(const DirectionalLight self, const LPoint3f point)\n");
  }
  return -1;
}

static PyObject *Dtool_DirectionalLight_direction_Getter(PyObject *self, void *) {
  const DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DirectionalLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVector3 const &DirectionalLight::get_direction(void) const
  LVector3 const *return_value = &(((*(const DirectionalLight*)local_this).get_direction)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

static int Dtool_DirectionalLight_direction_Setter(PyObject *self, PyObject *arg, void *) {
  DirectionalLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DirectionalLight, (void **)&local_this, "DirectionalLight.direction")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete direction attribute");
    return -1;
  }
  // 1-inline void DirectionalLight::set_direction(LVector3 const &direction)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DirectionalLight.set_direction", "LVector3f");
    return -1;
  }
  ((*local_this).set_direction)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direction(const DirectionalLight self, const LVector3f direction)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit DirectionalLight::DirectionalLight(std::string const &name)
 */
static int Dtool_Init_DirectionalLight(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "DirectionalLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit DirectionalLight::DirectionalLight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      DirectionalLight *return_value = new DirectionalLight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DirectionalLight, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DirectionalLight(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DirectionalLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DirectionalLight) {
    printf("DirectionalLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DirectionalLight *local_this = (DirectionalLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DirectionalLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DirectionalLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DirectionalLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DirectionalLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DirectionalLight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LODNode
 */
/**
 * Python function wrapper for:
 * static PointerTo< LODNode > LODNode::make_default_lod(std::string const &name)
 */
static PyObject *Dtool_LODNode_make_default_lod_93(PyObject *, PyObject *arg) {
  // 1-static PointerTo< LODNode > LODNode::make_default_lod(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    PointerTo< LODNode > return_value = (LODNode::make_default_lod)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    LODNode *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LODNode, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_default_lod(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_make_default_lod_93_comment =
  "C++ Interface:\n"
  "make_default_lod(str name)\n"
  "\n"
  "/**\n"
  " * Creates a new LODNode of the type specified by the default-lod-type config\n"
  " * variable.\n"
  " */";
#else
static const char *Dtool_LODNode_make_default_lod_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::add_switch(PN_stdfloat in, PN_stdfloat out)
 */
static PyObject *Dtool_LODNode_add_switch_94(PyObject *self, PyObject *args, PyObject *kwds) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.add_switch")) {
    return nullptr;
  }
  // 1-inline void LODNode::add_switch(PN_stdfloat in, PN_stdfloat out)
  float param1;
  float param2;
  static const char *keyword_list[] = {"in", "out", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_switch", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).add_switch)((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_switch(const LODNode self, float in, float out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_add_switch_94_comment =
  "C++ Interface:\n"
  "add_switch(const LODNode self, float in, float out)\n"
  "\n"
  "/**\n"
  " * Adds a switch range to the LODNode.  This implies that the corresponding\n"
  " * child node has been parented to the node.\n"
  " *\n"
  " * The sense of in vs.  out distances is as if the object were coming towards\n"
  " * you from far away: it switches \"in\" at the far distance, and switches \"out\"\n"
  " * at the close distance.  Thus, \"in\" should be larger than \"out\".\n"
  " */";
#else
static const char *Dtool_LODNode_add_switch_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LODNode::set_switch(int index, PN_stdfloat in, PN_stdfloat out)
 */
static PyObject *Dtool_LODNode_set_switch_95(PyObject *self, PyObject *args, PyObject *kwds) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.set_switch")) {
    return nullptr;
  }
  // 1-inline bool LODNode::set_switch(int index, PN_stdfloat in, PN_stdfloat out)
  int param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"index", "in", "out", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iff:set_switch", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*local_this).set_switch)((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_switch(const LODNode self, int index, float in, float out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_set_switch_95_comment =
  "C++ Interface:\n"
  "set_switch(const LODNode self, int index, float in, float out)\n"
  "\n"
  "/**\n"
  " * Changes the switching range of a particular child of the LODNode.  See\n"
  " * add_switch().\n"
  " */";
#else
static const char *Dtool_LODNode_set_switch_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::clear_switches(void)
 */
static PyObject *Dtool_LODNode_clear_switches_96(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.clear_switches")) {
    return nullptr;
  }
  // 1-inline void LODNode::clear_switches(void)
  ((*local_this).clear_switches)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_clear_switches_96_comment =
  "C++ Interface:\n"
  "clear_switches(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Removes the set of switching ranges for the LODNode, presumably in\n"
  " * conjunction with removing all of its children.  See add_switch().\n"
  " */";
#else
static const char *Dtool_LODNode_clear_switches_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LODNode::get_num_switches(void) const
 */
static PyObject *Dtool_LODNode_get_num_switches_97(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline int LODNode::get_num_switches(void) const
  int return_value = ((*(const LODNode*)local_this).get_num_switches)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_num_switches_97_comment =
  "C++ Interface:\n"
  "get_num_switches(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of switch ranges added to the LODNode.  This should\n"
  " * correspond to the number of children of the node in order for the LODNode\n"
  " * to function correctly.\n"
  " */";
#else
static const char *Dtool_LODNode_get_num_switches_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LODNode::get_in(int index) const
 */
static PyObject *Dtool_LODNode_get_in_98(PyObject *self, PyObject *arg) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LODNode::get_in(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const LODNode*)local_this).get_in)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in(LODNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_in_98_comment =
  "C++ Interface:\n"
  "get_in(LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the \"in\" distance of the indicated switch range.  This should be\n"
  " * larger than the \"out\" distance of the same range.\n"
  " */";
#else
static const char *Dtool_LODNode_get_in_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LODNode::get_out(int index) const
 */
static PyObject *Dtool_LODNode_get_out_100(PyObject *self, PyObject *arg) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LODNode::get_out(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const LODNode*)local_this).get_out)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out(LODNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_out_100_comment =
  "C++ Interface:\n"
  "get_out(LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the \"out\" distance of the indicated switch range.  This should be\n"
  " * smaller than the \"in\" distance of the same range.\n"
  " */";
#else
static const char *Dtool_LODNode_get_out_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LODNode::get_lowest_switch(void) const
 */
static PyObject *Dtool_LODNode_get_lowest_switch_102(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline int LODNode::get_lowest_switch(void) const
  int return_value = ((*(const LODNode*)local_this).get_lowest_switch)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_lowest_switch_102_comment =
  "C++ Interface:\n"
  "get_lowest_switch(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the child with the lowest level of detail; that\n"
  " * is, the one that is designed to be seen from the farthest away.  This is\n"
  " * usually the first child, but it is not necessarily so.\n"
  " */";
#else
static const char *Dtool_LODNode_get_lowest_switch_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LODNode::get_highest_switch(void) const
 */
static PyObject *Dtool_LODNode_get_highest_switch_103(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline int LODNode::get_highest_switch(void) const
  int return_value = ((*(const LODNode*)local_this).get_highest_switch)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_highest_switch_103_comment =
  "C++ Interface:\n"
  "get_highest_switch(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the child with the highest level of detail;\n"
  " * that is, the one that is designed to be seen from the closest to the\n"
  " * camera.  This is usually the last child, but it is not necessarily so.\n"
  " */";
#else
static const char *Dtool_LODNode_get_highest_switch_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::force_switch(int index)
 */
static PyObject *Dtool_LODNode_force_switch_104(PyObject *self, PyObject *arg) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.force_switch")) {
    return nullptr;
  }
  // 1-inline void LODNode::force_switch(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).force_switch)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "force_switch(const LODNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_force_switch_104_comment =
  "C++ Interface:\n"
  "force_switch(const LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Forces the LODNode to show the indicated level instead of the level that\n"
  " * would normally be shown based on the distance from the camera.\n"
  " */";
#else
static const char *Dtool_LODNode_force_switch_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::clear_force_switch(void)
 */
static PyObject *Dtool_LODNode_clear_force_switch_105(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.clear_force_switch")) {
    return nullptr;
  }
  // 1-inline void LODNode::clear_force_switch(void)
  ((*local_this).clear_force_switch)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_clear_force_switch_105_comment =
  "C++ Interface:\n"
  "clear_force_switch(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to force_switch() and releases the\n"
  " * LODNode to once again display the normal level.\n"
  " */";
#else
static const char *Dtool_LODNode_clear_force_switch_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::set_lod_scale(PN_stdfloat value)
 */
static PyObject *Dtool_LODNode_set_lod_scale_106(PyObject *self, PyObject *arg) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.set_lod_scale")) {
    return nullptr;
  }
  // 1-inline void LODNode::set_lod_scale(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_scale(const LODNode self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_set_lod_scale_106_comment =
  "C++ Interface:\n"
  "set_lod_scale(const LODNode self, float value)\n"
  "\n"
  "// for performance tuning, increasing this value should improve performance\n"
  "// at the cost of model quality\n"
  "\n"
  "// for performance tuning, increasing this value should improve performance\n"
  "// at the cost of model quality\n"
  "\n"
  "/**\n"
  " * Sets the multiplier for lod distances.  A higher value means you'll see\n"
  " * farther switchs than normal\n"
  " */";
#else
static const char *Dtool_LODNode_set_lod_scale_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LODNode::get_lod_scale(void) const
 */
static PyObject *Dtool_LODNode_get_lod_scale_107(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LODNode::get_lod_scale(void) const
  PN_stdfloat return_value = ((*(const LODNode*)local_this).get_lod_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_lod_scale_107_comment =
  "C++ Interface:\n"
  "get_lod_scale(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the multiplier for lod distances\n"
  " */";
#else
static const char *Dtool_LODNode_get_lod_scale_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LODNode::set_center(LPoint3 const &center)
 */
static PyObject *Dtool_LODNode_set_center_108(PyObject *self, PyObject *arg) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.set_center")) {
    return nullptr;
  }
  // 1-inline void LODNode::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LODNode.set_center", "LPoint3f");
  }
  ((*local_this).set_center)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const LODNode self, const LPoint3f center)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_set_center_108_comment =
  "C++ Interface:\n"
  "set_center(const LODNode self, const LPoint3f center)\n"
  "\n"
  "/**\n"
  " * Specifies the center of the LOD.  This is the point that is compared to the\n"
  " * camera (in camera space) to determine the particular LOD that should be\n"
  " * chosen.\n"
  " */";
#else
static const char *Dtool_LODNode_set_center_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &LODNode::get_center(void) const
 */
static PyObject *Dtool_LODNode_get_center_109(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &LODNode::get_center(void) const
  LPoint3 const *return_value = &(((*(const LODNode*)local_this).get_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_center_109_comment =
  "C++ Interface:\n"
  "get_center(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the center of the LOD.  This is the point that is compared to the\n"
  " * camera (in camera space) to determine the particular LOD that should be\n"
  " * chosen.\n"
  " */";
#else
static const char *Dtool_LODNode_get_center_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LODNode::show_switch(int index)
 * void LODNode::show_switch(int index, LColor const &color)
 */
static PyObject *Dtool_LODNode_show_switch_119(PyObject *self, PyObject *args, PyObject *kwds) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.show_switch")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "index")) {
        // 1-void LODNode::show_switch(int index)
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          ((*local_this).show_switch)((int)arg_val);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void LODNode::show_switch(int index, LColor const &color)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"index", "color", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:show_switch", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param2_local;
        LColor const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LODNode.show_switch", "LVecBase4f");
        }
        ((*local_this).show_switch)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "show_switch() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_switch(const LODNode self, int index)\n"
      "show_switch(const LODNode self, int index, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_show_switch_119_comment =
  "C++ Interface:\n"
  "show_switch(const LODNode self, int index)\n"
  "show_switch(const LODNode self, int index, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * This is provided as a debugging aid.  show_switch() will put the LODNode\n"
  " * into a special mode where rather than computing and drawing the appropriate\n"
  " * level of the LOD, a ring is drawn around the LODNode center indicating the\n"
  " * switch distances from the camera for the indicated level, and the geometry\n"
  " * of the indicated level is drawn in wireframe.\n"
  " *\n"
  " * Multiple different levels can be visualized this way at once.  Call\n"
  " * hide_switch() or hide_all_switches() to undo this mode and restore the\n"
  " * LODNode to its normal behavior.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This is provided as a debugging aid.  show_switch() will put the LODNode\n"
  " * into a special mode where rather than computing and drawing the appropriate\n"
  " * level of the LOD, a ring is drawn around the LODNode center indicating the\n"
  " * switch distances from the camera for the indicated level, and the geometry\n"
  " * of the indicated level is drawn in wireframe.\n"
  " *\n"
  " * Multiple different levels can be visualized this way at once.  Call\n"
  " * hide_switch() or hide_all_switches() to undo this mode and restore the\n"
  " * LODNode to its normal behavior.\n"
  " */";
#else
static const char *Dtool_LODNode_show_switch_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LODNode::hide_switch(int index)
 */
static PyObject *Dtool_LODNode_hide_switch_120(PyObject *self, PyObject *arg) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.hide_switch")) {
    return nullptr;
  }
  // 1-void LODNode::hide_switch(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).hide_switch)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hide_switch(const LODNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LODNode_hide_switch_120_comment =
  "C++ Interface:\n"
  "hide_switch(const LODNode self, int index)\n"
  "\n"
  "/**\n"
  " * Disables a previous call to show_switch().\n"
  " */";
#else
static const char *Dtool_LODNode_hide_switch_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LODNode::show_all_switches(void)
 */
static PyObject *Dtool_LODNode_show_all_switches_121(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.show_all_switches")) {
    return nullptr;
  }
  // 1-void LODNode::show_all_switches(void)
  ((*local_this).show_all_switches)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_show_all_switches_121_comment =
  "C++ Interface:\n"
  "show_all_switches(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Shows all levels in their default colors.\n"
  " */";
#else
static const char *Dtool_LODNode_show_all_switches_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LODNode::hide_all_switches(void)
 */
static PyObject *Dtool_LODNode_hide_all_switches_122(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.hide_all_switches")) {
    return nullptr;
  }
  // 1-void LODNode::hide_all_switches(void)
  ((*local_this).hide_all_switches)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LODNode_hide_all_switches_122_comment =
  "C++ Interface:\n"
  "hide_all_switches(const LODNode self)\n"
  "\n"
  "/**\n"
  " * Hides all levels, restoring the LODNode to normal operation.\n"
  " */";
#else
static const char *Dtool_LODNode_hide_all_switches_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LODNode::is_any_shown(void) const
 */
static PyObject *Dtool_LODNode_is_any_shown_123(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-inline bool LODNode::is_any_shown(void) const
  bool return_value = ((*(const LODNode*)local_this).is_any_shown)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_is_any_shown_123_comment =
  "C++ Interface:\n"
  "is_any_shown(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if any switch has been shown with show_switch(), indicating\n"
  " * the LODNode is in debug show mode; or false if it is in the normal mode.\n"
  " */";
#else
static const char *Dtool_LODNode_is_any_shown_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool LODNode::verify_child_bounds(void) const
 */
static PyObject *Dtool_LODNode_verify_child_bounds_124(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LODNode)) {
    return nullptr;
  }
  // 1-bool LODNode::verify_child_bounds(void) const
  bool return_value = ((*(const LODNode*)local_this).verify_child_bounds)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_verify_child_bounds_124_comment =
  "C++ Interface:\n"
  "verify_child_bounds(LODNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the bounding volumes for the geometry of each fhild node\n"
  " * entirely fits within the switch_in radius for that child, or false\n"
  " * otherwise.  It is almost always a mistake for the geometry of an LOD level\n"
  " * to be larger than its switch_in radius.\n"
  " */";
#else
static const char *Dtool_LODNode_verify_child_bounds_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LODNode::get_class_type(void)
 */
static PyObject *Dtool_LODNode_get_class_type_125(PyObject *, PyObject *) {
  // 1-static TypeHandle LODNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LODNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LODNode_get_class_type_125_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LODNode_get_class_type_125_comment = nullptr;
#endif

/**
 * sequence length function for property LODNode::ins
 */
static Py_ssize_t Dtool_LODNode_ins_Len(PyObject *self) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_switches)();
}

/**
 * sequence getter for property LODNode::ins
 */
static PyObject *Dtool_LODNode_ins_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_switches)()) {
    PyErr_SetString(PyExc_IndexError, "LODNode.ins[] index out of range");
    return nullptr;
  }
  // 1-inline PN_stdfloat LODNode::get_in(int index) const
  PN_stdfloat return_value = ((*(const LODNode*)local_this).get_in)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in(LODNode self, index)\n");
  }
}

static PyObject *Dtool_LODNode_ins_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "LODNode.ins");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_LODNode_ins_Len;
    wrap->_getitem_func = &Dtool_LODNode_ins_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property LODNode::outs
 */
static Py_ssize_t Dtool_LODNode_outs_Len(PyObject *self) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_switches)();
}

/**
 * sequence getter for property LODNode::outs
 */
static PyObject *Dtool_LODNode_outs_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_switches)()) {
    PyErr_SetString(PyExc_IndexError, "LODNode.outs[] index out of range");
    return nullptr;
  }
  // 1-inline PN_stdfloat LODNode::get_out(int index) const
  PN_stdfloat return_value = ((*(const LODNode*)local_this).get_out)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out(LODNode self, index)\n");
  }
}

static PyObject *Dtool_LODNode_outs_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "LODNode.outs");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_LODNode_outs_Len;
    wrap->_getitem_func = &Dtool_LODNode_outs_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_LODNode_lowest_switch_Getter(PyObject *self, void *) {
  const LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int LODNode::get_lowest_switch(void) const
  int return_value = ((*(const LODNode*)local_this).get_lowest_switch)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LODNode_highest_switch_Getter(PyObject *self, void *) {
  const LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int LODNode::get_highest_switch(void) const
  int return_value = ((*(const LODNode*)local_this).get_highest_switch)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LODNode_lod_scale_Getter(PyObject *self, void *) {
  const LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat LODNode::get_lod_scale(void) const
  PN_stdfloat return_value = ((*(const LODNode*)local_this).get_lod_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LODNode_lod_scale_Setter(PyObject *self, PyObject *arg, void *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.lod_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete lod_scale attribute");
    return -1;
  }
  // 1-inline void LODNode::set_lod_scale(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod_scale(const LODNode self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LODNode_center_Getter(PyObject *self, void *) {
  const LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &LODNode::get_center(void) const
  LPoint3 const *return_value = &(((*(const LODNode*)local_this).get_center)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_LODNode_center_Setter(PyObject *self, PyObject *arg, void *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LODNode, (void **)&local_this, "LODNode.center")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete center attribute");
    return -1;
  }
  // 1-inline void LODNode::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LODNode.set_center", "LPoint3f");
    return -1;
  }
  ((*local_this).set_center)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center(const LODNode self, const LPoint3f center)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline explicit LODNode::LODNode(std::string const &name)
 */
static int Dtool_Init_LODNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LODNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-inline explicit LODNode::LODNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      LODNode *return_value = new LODNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LODNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LODNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LODNode_get_ins(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_switches)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LODNode_get_in_98(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LODNode_get_outs(PyObject *self, PyObject *) {
  LODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LODNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_switches)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LODNode_get_out_100(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LODNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LODNode) {
    printf("LODNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LODNode *local_this = (LODNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LODNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LODNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LODNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LODNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FadeLODNode
 */
/**
 * Python function wrapper for:
 * inline void FadeLODNode::set_fade_time(PN_stdfloat t)
 */
static PyObject *Dtool_FadeLODNode_set_fade_time_129(PyObject *self, PyObject *arg) {
  FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.set_fade_time")) {
    return nullptr;
  }
  // 1-inline void FadeLODNode::set_fade_time(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_fade_time)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fade_time(const FadeLODNode self, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_set_fade_time_129_comment =
  "C++ Interface:\n"
  "set_fade_time(const FadeLODNode self, float t)\n"
  "\n"
  "/**\n"
  " * set the time taken to complete an LOD switch\n"
  " */";
#else
static const char *Dtool_FadeLODNode_set_fade_time_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FadeLODNode::get_fade_time(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_time_130(PyObject *self, PyObject *) {
  FadeLODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FadeLODNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat FadeLODNode::get_fade_time(void) const
  PN_stdfloat return_value = ((*(const FadeLODNode*)local_this).get_fade_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_time_130_comment =
  "C++ Interface:\n"
  "get_fade_time(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * get the time taken to complete an LOD switch\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_time_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void FadeLODNode::set_fade_bin(std::string const &name, int draw_order)
 */
static PyObject *Dtool_FadeLODNode_set_fade_bin_132(PyObject *self, PyObject *args, PyObject *kwds) {
  FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.set_fade_bin")) {
    return nullptr;
  }
  // 1-void FadeLODNode::set_fade_bin(std::string const &name, int draw_order)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"name", "draw_order", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_fade_bin", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    ((*local_this).set_fade_bin)(std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fade_bin(const FadeLODNode self, str name, int draw_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_set_fade_bin_132_comment =
  "C++ Interface:\n"
  "set_fade_bin(const FadeLODNode self, str name, int draw_order)\n"
  "\n"
  "/**\n"
  " * Specifies the cull bin and draw order that is assigned to the fading part\n"
  " * of the geometry during a transition.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_set_fade_bin_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &FadeLODNode::get_fade_bin_name(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_bin_name_133(PyObject *self, PyObject *) {
  FadeLODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FadeLODNode)) {
    return nullptr;
  }
  // 1-inline std::string const &FadeLODNode::get_fade_bin_name(void) const
  std::string const &return_value = ((*(const FadeLODNode*)local_this).get_fade_bin_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_bin_name_133_comment =
  "C++ Interface:\n"
  "get_fade_bin_name(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the cull bin that is assigned to the fading part of the geometry\n"
  " * during a transition.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_bin_name_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FadeLODNode::get_fade_bin_draw_order(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_bin_draw_order_134(PyObject *self, PyObject *) {
  FadeLODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FadeLODNode)) {
    return nullptr;
  }
  // 1-inline int FadeLODNode::get_fade_bin_draw_order(void) const
  int return_value = ((*(const FadeLODNode*)local_this).get_fade_bin_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_bin_draw_order_134_comment =
  "C++ Interface:\n"
  "get_fade_bin_draw_order(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the draw order that is assigned (along with the bin name) to the\n"
  " * fading part of the geometry during a transition.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_bin_draw_order_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void FadeLODNode::set_fade_state_override(int override)
 */
static PyObject *Dtool_FadeLODNode_set_fade_state_override_140(PyObject *self, PyObject *arg) {
  FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.set_fade_state_override")) {
    return nullptr;
  }
  // 1-void FadeLODNode::set_fade_state_override(int override)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_fade_state_override)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fade_state_override(const FadeLODNode self, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_set_fade_state_override_140_comment =
  "C++ Interface:\n"
  "set_fade_state_override(const FadeLODNode self, int override)\n"
  "\n"
  "/**\n"
  " * Specifies the override value that is applied to the state changes necessary\n"
  " * to apply the fade effect.  This should be larger than any attrib overrides\n"
  " * on the fading geometry.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_set_fade_state_override_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FadeLODNode::get_fade_state_override(void) const
 */
static PyObject *Dtool_FadeLODNode_get_fade_state_override_141(PyObject *self, PyObject *) {
  FadeLODNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FadeLODNode)) {
    return nullptr;
  }
  // 1-inline int FadeLODNode::get_fade_state_override(void) const
  int return_value = ((*(const FadeLODNode*)local_this).get_fade_state_override)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_fade_state_override_141_comment =
  "C++ Interface:\n"
  "get_fade_state_override(FadeLODNode self)\n"
  "\n"
  "/**\n"
  " * Returns the override value that is applied to the state changes necessary\n"
  " * to apply the fade effect.  This should be larger than any attrib overrides\n"
  " * on the fading geometry.\n"
  " */";
#else
static const char *Dtool_FadeLODNode_get_fade_state_override_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FadeLODNode::get_class_type(void)
 */
static PyObject *Dtool_FadeLODNode_get_class_type_143(PyObject *, PyObject *) {
  // 1-static TypeHandle FadeLODNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FadeLODNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FadeLODNode_get_class_type_143_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FadeLODNode_get_class_type_143_comment = nullptr;
#endif

static PyObject *Dtool_FadeLODNode_fade_time_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat FadeLODNode::get_fade_time(void) const
  PN_stdfloat return_value = ((*(const FadeLODNode*)local_this).get_fade_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FadeLODNode_fade_time_Setter(PyObject *self, PyObject *arg, void *) {
  FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.fade_time")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fade_time attribute");
    return -1;
  }
  // 1-inline void FadeLODNode::set_fade_time(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_fade_time)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fade_time(const FadeLODNode self, float t)\n");
  }
  return -1;
}

static PyObject *Dtool_FadeLODNode_fade_bin_name_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &FadeLODNode::get_fade_bin_name(void) const
  std::string const &return_value = ((*(const FadeLODNode*)local_this).get_fade_bin_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_FadeLODNode_fade_bin_draw_order_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FadeLODNode::get_fade_bin_draw_order(void) const
  int return_value = ((*(const FadeLODNode*)local_this).get_fade_bin_draw_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_FadeLODNode_fade_state_override_Getter(PyObject *self, void *) {
  const FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FadeLODNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FadeLODNode::get_fade_state_override(void) const
  int return_value = ((*(const FadeLODNode*)local_this).get_fade_state_override)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FadeLODNode_fade_state_override_Setter(PyObject *self, PyObject *arg, void *) {
  FadeLODNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FadeLODNode, (void **)&local_this, "FadeLODNode.fade_state_override")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fade_state_override attribute");
    return -1;
  }
  // 1-void FadeLODNode::set_fade_state_override(int override)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_fade_state_override)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fade_state_override(const FadeLODNode self, int override)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit FadeLODNode::FadeLODNode(std::string const &name)
 */
static int Dtool_Init_FadeLODNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FadeLODNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit FadeLODNode::FadeLODNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      FadeLODNode *return_value = new FadeLODNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FadeLODNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FadeLODNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_FadeLODNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FadeLODNode) {
    printf("FadeLODNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FadeLODNode *local_this = (FadeLODNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FadeLODNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LODNode) {
    return (LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LODNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FadeLODNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FadeLODNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LODNode) {
    LODNode* other_this = (LODNode*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (FadeLODNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (FadeLODNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NodeCullCallbackData
 */
/**
 * Python function wrapper for:
 * inline CullTraverser *NodeCullCallbackData::get_trav(void) const
 */
static PyObject *Dtool_NodeCullCallbackData_get_trav_147(PyObject *self, PyObject *) {
  NodeCullCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeCullCallbackData)) {
    return nullptr;
  }
  // 1-inline CullTraverser *NodeCullCallbackData::get_trav(void) const
  CullTraverser *return_value = ((*(const NodeCullCallbackData*)local_this).get_trav)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CullTraverser, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NodeCullCallbackData_get_trav_147_comment =
  "C++ Interface:\n"
  "get_trav(NodeCullCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the CullTraverser in use at the time of the callback.  This object\n"
  " * contains data that does not change during the traversal, such as the\n"
  " * DisplayRegion and Camera in use.\n"
  " */";
#else
static const char *Dtool_NodeCullCallbackData_get_trav_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CullTraverserData &NodeCullCallbackData::get_data(void) const
 */
static PyObject *Dtool_NodeCullCallbackData_get_data_148(PyObject *self, PyObject *) {
  NodeCullCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeCullCallbackData)) {
    return nullptr;
  }
  // 1-inline CullTraverserData &NodeCullCallbackData::get_data(void) const
  CullTraverserData *return_value = &(((*(const NodeCullCallbackData*)local_this).get_data)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CullTraverserData, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeCullCallbackData_get_data_148_comment =
  "C++ Interface:\n"
  "get_data(NodeCullCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the CullTraverserData in use at the time of the callback.  This\n"
  " * object contains data that changes at each node of the traversal, such as\n"
  " * the current node and the current net transform to that node.\n"
  " */";
#else
static const char *Dtool_NodeCullCallbackData_get_data_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodeCullCallbackData::get_class_type(void)
 */
static PyObject *Dtool_NodeCullCallbackData_get_class_type_149(PyObject *, PyObject *) {
  // 1-static TypeHandle NodeCullCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NodeCullCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeCullCallbackData_get_class_type_149_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodeCullCallbackData_get_class_type_149_comment = nullptr;
#endif

static int Dtool_Init_NodeCullCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_NodeCullCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NodeCullCallbackData) {
    printf("NodeCullCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NodeCullCallbackData *local_this = (NodeCullCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NodeCullCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NodeCullCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NodeCullCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (NodeCullCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NodeCullCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointLight
 */
/**
 * Python function wrapper for:
 * inline void PointLight::set_specular_color(LColor const &color)
 */
static PyObject *Dtool_PointLight_set_specular_color_152(PyObject *self, PyObject *arg) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_specular_color")) {
    return nullptr;
  }
  // 1-inline void PointLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_specular_color", "LVecBase4f");
  }
  ((*local_this).set_specular_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specular_color(const PointLight self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_specular_color_152_comment =
  "C++ Interface:\n"
  "set_specular_color(const PointLight self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the color of specular highlights generated by the light.\n"
  " */";
#else
static const char *Dtool_PointLight_set_specular_color_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::clear_specular_color(void)
 */
static PyObject *Dtool_PointLight_clear_specular_color_153(PyObject *self, PyObject *) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.clear_specular_color")) {
    return nullptr;
  }
  // 1-inline void PointLight::clear_specular_color(void)
  ((*local_this).clear_specular_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointLight_clear_specular_color_153_comment =
  "C++ Interface:\n"
  "clear_specular_color(const PointLight self)\n"
  "\n"
  "/**\n"
  " * Clears a custom specular color setting, meaning that the specular color\n"
  " * will now come from the color.\n"
  " */";
#else
static const char *Dtool_PointLight_clear_specular_color_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::set_attenuation(LVecBase3 const &attenuation)
 */
static PyObject *Dtool_PointLight_set_attenuation_156(PyObject *self, PyObject *arg) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_attenuation")) {
    return nullptr;
  }
  // 1-inline void PointLight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_attenuation", "LVecBase3f");
  }
  ((*local_this).set_attenuation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attenuation(const PointLight self, const LVecBase3f attenuation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_attenuation_156_comment =
  "C++ Interface:\n"
  "set_attenuation(const PointLight self, const LVecBase3f attenuation)\n"
  "\n"
  "/**\n"
  " * Sets the terms of the attenuation equation for the light.  These are, in\n"
  " * order, the constant, linear, and quadratic terms based on the distance from\n"
  " * the point to the vertex.\n"
  " */";
#else
static const char *Dtool_PointLight_set_attenuation_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PointLight::get_max_distance(void) const
 */
static PyObject *Dtool_PointLight_get_max_distance_162(PyObject *self, PyObject *) {
  PointLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointLight)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PointLight::get_max_distance(void) const
  PN_stdfloat return_value = ((*(const PointLight*)local_this).get_max_distance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_max_distance_162_comment =
  "C++ Interface:\n"
  "get_max_distance(PointLight self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum distance at which the light has any effect, as previously\n"
  " * specified by set_max_distance.\n"
  " */";
#else
static const char *Dtool_PointLight_get_max_distance_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::set_max_distance(PN_stdfloat max_distance)
 */
static PyObject *Dtool_PointLight_set_max_distance_163(PyObject *self, PyObject *arg) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_max_distance")) {
    return nullptr;
  }
  // 1-inline void PointLight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_distance(const PointLight self, float max_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_max_distance_163_comment =
  "C++ Interface:\n"
  "set_max_distance(const PointLight self, float max_distance)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the light's sphere of influence.  Beyond this distance, the\n"
  " * light may be attenuated to zero, if this is supported by the shader.\n"
  " */";
#else
static const char *Dtool_PointLight_set_max_distance_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &PointLight::get_point(void) const
 */
static PyObject *Dtool_PointLight_get_point_165(PyObject *self, PyObject *) {
  PointLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointLight)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &PointLight::get_point(void) const
  LPoint3 const *return_value = &(((*(const PointLight*)local_this).get_point)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_point_165_comment =
  "C++ Interface:\n"
  "get_point(PointLight self)\n"
  "\n"
  "/**\n"
  " * Returns the point in space at which the light is located.  This is local to\n"
  " * the coordinate space in which the light is assigned, and is usually 0.\n"
  " */";
#else
static const char *Dtool_PointLight_get_point_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointLight::set_point(LPoint3 const &point)
 */
static PyObject *Dtool_PointLight_set_point_166(PyObject *self, PyObject *arg) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.set_point")) {
    return nullptr;
  }
  // 1-inline void PointLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_point", "LPoint3f");
  }
  ((*local_this).set_point)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point(const PointLight self, const LPoint3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointLight_set_point_166_comment =
  "C++ Interface:\n"
  "set_point(const PointLight self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Sets the point in space at which the light is located.  Usually 0.\n"
  " */";
#else
static const char *Dtool_PointLight_set_point_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PointLight::get_class_type(void)
 */
static PyObject *Dtool_PointLight_get_class_type_168(PyObject *, PyObject *) {
  // 1-static TypeHandle PointLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PointLight::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PointLight_get_class_type_168_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PointLight_get_class_type_168_comment = nullptr;
#endif

static PyObject *Dtool_PointLight_specular_color_Getter(PyObject *self, void *) {
  const PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline LColor const &PointLight::get_specular_color(void) const final
  LColor const *return_value = &(((*(const PointLight*)local_this).get_specular_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_PointLight_specular_color_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.specular_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete specular_color attribute");
    return -1;
  }
  // 1-inline void PointLight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_specular_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_specular_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specular_color(const PointLight self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_PointLight_attenuation_Getter(PyObject *self, void *) {
  const PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline LVecBase3 const &PointLight::get_attenuation(void) const final
  LVecBase3 const *return_value = &(((*(const PointLight*)local_this).get_attenuation)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_PointLight_attenuation_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.attenuation")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete attenuation attribute");
    return -1;
  }
  // 1-inline void PointLight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_attenuation", "LVecBase3f");
    return -1;
  }
  ((*local_this).set_attenuation)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_attenuation(const PointLight self, const LVecBase3f attenuation)\n");
  }
  return -1;
}

static PyObject *Dtool_PointLight_max_distance_Getter(PyObject *self, void *) {
  const PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat PointLight::get_max_distance(void) const
  PN_stdfloat return_value = ((*(const PointLight*)local_this).get_max_distance)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PointLight_max_distance_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.max_distance")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_distance attribute");
    return -1;
  }
  // 1-inline void PointLight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_distance(const PointLight self, float max_distance)\n");
  }
  return -1;
}

static PyObject *Dtool_PointLight_point_Getter(PyObject *self, void *) {
  const PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &PointLight::get_point(void) const
  LPoint3 const *return_value = &(((*(const PointLight*)local_this).get_point)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_PointLight_point_Setter(PyObject *self, PyObject *arg, void *) {
  PointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointLight, (void **)&local_this, "PointLight.point")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete point attribute");
    return -1;
  }
  // 1-inline void PointLight::set_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PointLight.set_point", "LPoint3f");
    return -1;
  }
  ((*local_this).set_point)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point(const PointLight self, const LPoint3f point)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit PointLight::PointLight(std::string const &name)
 */
static int Dtool_Init_PointLight(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PointLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit PointLight::PointLight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      PointLight *return_value = new PointLight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointLight, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointLight(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PointLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointLight) {
    printf("PointLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointLight *local_this = (PointLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PointLight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RectangleLight
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat RectangleLight::get_max_distance(void) const
 */
static PyObject *Dtool_RectangleLight_get_max_distance_172(PyObject *self, PyObject *) {
  RectangleLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RectangleLight)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat RectangleLight::get_max_distance(void) const
  PN_stdfloat return_value = ((*(const RectangleLight*)local_this).get_max_distance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RectangleLight_get_max_distance_172_comment =
  "C++ Interface:\n"
  "get_max_distance(RectangleLight self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum distance at which the light has any effect, as previously\n"
  " * specified by set_max_distance.\n"
  " */";
#else
static const char *Dtool_RectangleLight_get_max_distance_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RectangleLight::set_max_distance(PN_stdfloat max_distance)
 */
static PyObject *Dtool_RectangleLight_set_max_distance_173(PyObject *self, PyObject *arg) {
  RectangleLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RectangleLight, (void **)&local_this, "RectangleLight.set_max_distance")) {
    return nullptr;
  }
  // 1-inline void RectangleLight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_distance(const RectangleLight self, float max_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RectangleLight_set_max_distance_173_comment =
  "C++ Interface:\n"
  "set_max_distance(const RectangleLight self, float max_distance)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the light's sphere of influence.  Beyond this distance, the\n"
  " * light may be attenuated to zero, if this is supported by the shader.\n"
  " */";
#else
static const char *Dtool_RectangleLight_set_max_distance_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle RectangleLight::get_class_type(void)
 */
static PyObject *Dtool_RectangleLight_get_class_type_175(PyObject *, PyObject *) {
  // 1-static TypeHandle RectangleLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((RectangleLight::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_RectangleLight_get_class_type_175_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_RectangleLight_get_class_type_175_comment = nullptr;
#endif

static PyObject *Dtool_RectangleLight_max_distance_Getter(PyObject *self, void *) {
  const RectangleLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RectangleLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat RectangleLight::get_max_distance(void) const
  PN_stdfloat return_value = ((*(const RectangleLight*)local_this).get_max_distance)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RectangleLight_max_distance_Setter(PyObject *self, PyObject *arg, void *) {
  RectangleLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RectangleLight, (void **)&local_this, "RectangleLight.max_distance")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_distance attribute");
    return -1;
  }
  // 1-inline void RectangleLight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_distance(const RectangleLight self, float max_distance)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit RectangleLight::RectangleLight(std::string const &name)
 */
static int Dtool_Init_RectangleLight(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RectangleLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit RectangleLight::RectangleLight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      RectangleLight *return_value = new RectangleLight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RectangleLight, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RectangleLight(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RectangleLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RectangleLight) {
    printf("RectangleLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RectangleLight *local_this = (RectangleLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RectangleLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RectangleLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RectangleLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (RectangleLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (RectangleLight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SelectiveChildNode
 */
/**
 * Python function wrapper for:
 * static TypeHandle SelectiveChildNode::get_class_type(void)
 */
static PyObject *Dtool_SelectiveChildNode_get_class_type_179(PyObject *, PyObject *) {
  // 1-static TypeHandle SelectiveChildNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SelectiveChildNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SelectiveChildNode_get_class_type_179_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SelectiveChildNode_get_class_type_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit SelectiveChildNode::SelectiveChildNode(std::string const &name)
 */
static int Dtool_Init_SelectiveChildNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SelectiveChildNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-inline explicit SelectiveChildNode::SelectiveChildNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      SelectiveChildNode *return_value = new SelectiveChildNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SelectiveChildNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SelectiveChildNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SelectiveChildNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SelectiveChildNode) {
    printf("SelectiveChildNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SelectiveChildNode *local_this = (SelectiveChildNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SelectiveChildNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SelectiveChildNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SelectiveChildNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SelectiveChildNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SequenceNode
 */
/**
 * Python function wrapper for:
 * virtual int SequenceNode::get_num_frames(void) const
 */
static PyObject *Dtool_SequenceNode_get_num_frames_188(PyObject *self, PyObject *) {
  SequenceNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SequenceNode)) {
    return nullptr;
  }
  // 1-virtual int SequenceNode::get_num_frames(void) const
  int return_value = ((*(const SequenceNode*)local_this).get_num_frames)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_get_num_frames_188_comment =
  "C++ Interface:\n"
  "get_num_frames(SequenceNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames in the animation.  This is a property of the\n"
  " * animation and may not be directly adjusted by the user (although it may\n"
  " * change without warning with certain kinds of animations, since this is a\n"
  " * virtual method that may be overridden).\n"
  " */";
#else
static const char *Dtool_SequenceNode_get_num_frames_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SequenceNode::set_frame_rate(double frame_rate)
 */
static PyObject *Dtool_SequenceNode_set_frame_rate_189(PyObject *self, PyObject *arg) {
  SequenceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SequenceNode, (void **)&local_this, "SequenceNode.set_frame_rate")) {
    return nullptr;
  }
  // 1-inline void SequenceNode::set_frame_rate(double frame_rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_frame_rate)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_rate(const SequenceNode self, double frame_rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_set_frame_rate_189_comment =
  "C++ Interface:\n"
  "set_frame_rate(const SequenceNode self, double frame_rate)\n"
  "\n"
  "/**\n"
  " * Changes the advertised frame rate of the SequenceNode.  This can be used in\n"
  " * conjunction with get_play_rate() to change the effective frame rate of the\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_SequenceNode_set_frame_rate_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SequenceNode::get_class_type(void)
 */
static PyObject *Dtool_SequenceNode_get_class_type_193(PyObject *, PyObject *) {
  // 1-static TypeHandle SequenceNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SequenceNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_get_class_type_193_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SequenceNode_get_class_type_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void)
 */
static PyObject *Dtool_SequenceNode_upcast_to_SelectiveChildNode_182(PyObject *self, PyObject *) {
  SequenceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SequenceNode, (void **)&local_this, "SequenceNode.upcast_to_SelectiveChildNode")) {
    return nullptr;
  }
  // 1-SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void)
  SelectiveChildNode *return_value = (SelectiveChildNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SelectiveChildNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_upcast_to_SelectiveChildNode_182_comment =
  "C++ Interface:\n"
  "upcast_to_SelectiveChildNode(const SequenceNode self)\n"
  "\n"
  "upcast from SequenceNode to SelectiveChildNode";
#else
static const char *Dtool_SequenceNode_upcast_to_SelectiveChildNode_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimInterface *SequenceNode::upcast_to_AnimInterface(void)
 */
static PyObject *Dtool_SequenceNode_upcast_to_AnimInterface_185(PyObject *self, PyObject *) {
  SequenceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SequenceNode, (void **)&local_this, "SequenceNode.upcast_to_AnimInterface")) {
    return nullptr;
  }
  // 1-AnimInterface *SequenceNode::upcast_to_AnimInterface(void)
  AnimInterface *return_value = (AnimInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AnimInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SequenceNode_upcast_to_AnimInterface_185_comment =
  "C++ Interface:\n"
  "upcast_to_AnimInterface(const SequenceNode self)\n"
  "\n"
  "upcast from SequenceNode to AnimInterface";
#else
static const char *Dtool_SequenceNode_upcast_to_AnimInterface_185_comment = nullptr;
#endif

static PyObject *Dtool_SequenceNode_frame_rate_Getter(PyObject *self, void *) {
  const SequenceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SequenceNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double SequenceNode::get_frame_rate(void) const
  double return_value = ((*(const SequenceNode*)local_this).get_frame_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SequenceNode_frame_rate_Setter(PyObject *self, PyObject *arg, void *) {
  SequenceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SequenceNode, (void **)&local_this, "SequenceNode.frame_rate")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame_rate attribute");
    return -1;
  }
  // 1-inline void SequenceNode::set_frame_rate(double frame_rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_frame_rate)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_rate(const SequenceNode self, double frame_rate)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline explicit SequenceNode::SequenceNode(std::string const &name)
 */
static int Dtool_Init_SequenceNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SequenceNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-inline explicit SequenceNode::SequenceNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      SequenceNode *return_value = new SequenceNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SequenceNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SequenceNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SequenceNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SequenceNode) {
    printf("SequenceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SequenceNode *local_this = (SequenceNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SequenceNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimInterface) {
    return (AnimInterface *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_SelectiveChildNode) {
    return (SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SequenceNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SequenceNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimInterface) {
    AnimInterface* other_this = (AnimInterface*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_SelectiveChildNode) {
    SelectiveChildNode* other_this = (SelectiveChildNode*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SequenceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SequenceNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderGenerator
 */
/**
 * Python function wrapper for:
 * virtual ConstPointerTo< ShaderAttrib > ShaderGenerator::synthesize_shader(RenderState const *rs, GeomVertexAnimationSpec const &anim)
 */
static PyObject *Dtool_ShaderGenerator_synthesize_shader_198(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderGenerator, (void **)&local_this, "ShaderGenerator.synthesize_shader")) {
    return nullptr;
  }
  // 1-virtual ConstPointerTo< ShaderAttrib > ShaderGenerator::synthesize_shader(RenderState const *rs, GeomVertexAnimationSpec const &anim)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"rs", "anim", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:synthesize_shader", (char **)keyword_list, &param1, &param2)) {
    CPT(RenderState) param1_this;
    if (!Dtool_ConstCoerce_RenderState(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderGenerator.synthesize_shader", "RenderState");
    }
    GeomVertexAnimationSpec const *param2_this = (GeomVertexAnimationSpec *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeomVertexAnimationSpec, 2, "ShaderGenerator.synthesize_shader", true, true);
    if (param2_this != nullptr) {
      ConstPointerTo< ShaderAttrib > return_value = ((*local_this).synthesize_shader)(std::move(param1_this), *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      ShaderAttrib const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_ShaderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "synthesize_shader(const ShaderGenerator self, const RenderState rs, const GeomVertexAnimationSpec anim)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderGenerator_synthesize_shader_198_comment =
  "C++ Interface:\n"
  "synthesize_shader(const ShaderGenerator self, const RenderState rs, const GeomVertexAnimationSpec anim)\n"
  "\n"
  "/**\n"
  " * This is the routine that implements the next-gen fixed function pipeline by\n"
  " * synthesizing a shader.  It also takes care of setting up any buffers needed\n"
  " * to produce the requested effects.\n"
  " *\n"
  " * Currently supports:\n"
  " * - flat colors\n"
  " * - vertex colors\n"
  " * - lighting\n"
  " * - normal maps, even multiple\n"
  " * - gloss maps, but not multiple\n"
  " * - glow maps, but not multiple\n"
  " * - materials, but not updates to materials\n"
  " * - 2D textures\n"
  " * - all texture stage modes, including combine modes\n"
  " * - color scale attrib\n"
  " * - light ramps (for cartoon shading)\n"
  " * - shadow mapping\n"
  " * - most texgen modes\n"
  " * - texmatrix\n"
  " * - 1D/2D/3D textures, cube textures, 2D tex arrays\n"
  " * - linear/exp/exp2 fog\n"
  " * - animation\n"
  " *\n"
  " * Potential optimizations\n"
  " * - omit attenuation calculations if attenuation off\n"
  " *\n"
  " */";
#else
static const char *Dtool_ShaderGenerator_synthesize_shader_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ShaderGenerator::rehash_generated_shaders(void)
 */
static PyObject *Dtool_ShaderGenerator_rehash_generated_shaders_199(PyObject *self, PyObject *) {
  ShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderGenerator, (void **)&local_this, "ShaderGenerator.rehash_generated_shaders")) {
    return nullptr;
  }
  // 1-void ShaderGenerator::rehash_generated_shaders(void)
  ((*local_this).rehash_generated_shaders)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShaderGenerator_rehash_generated_shaders_199_comment =
  "C++ Interface:\n"
  "rehash_generated_shaders(const ShaderGenerator self)\n"
  "\n"
  "/**\n"
  " * Rehashes all the states with generated shaders, removing the ones that are\n"
  " * no longer fresh.\n"
  " *\n"
  " * Call this if certain state has changed in such a way as to require a rerun\n"
  " * of the shader generator.  This should be rare because in most cases, the\n"
  " * shader generator will automatically regenerate shaders as necessary.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_ShaderGenerator_rehash_generated_shaders_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ShaderGenerator::clear_generated_shaders(void)
 */
static PyObject *Dtool_ShaderGenerator_clear_generated_shaders_200(PyObject *self, PyObject *) {
  ShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderGenerator, (void **)&local_this, "ShaderGenerator.clear_generated_shaders")) {
    return nullptr;
  }
  // 1-void ShaderGenerator::clear_generated_shaders(void)
  ((*local_this).clear_generated_shaders)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShaderGenerator_clear_generated_shaders_200_comment =
  "C++ Interface:\n"
  "clear_generated_shaders(const ShaderGenerator self)\n"
  "\n"
  "/**\n"
  " * Removes all previously generated shaders, requiring all shaders to be\n"
  " * regenerated.  Does not clear cache of compiled shaders.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_ShaderGenerator_clear_generated_shaders_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderGenerator::get_class_type(void)
 */
static PyObject *Dtool_ShaderGenerator_get_class_type_201(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderGenerator::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShaderGenerator::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderGenerator_get_class_type_201_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderGenerator_get_class_type_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase const *gsg)
 * inline ShaderGenerator::ShaderGenerator(ShaderGenerator const &) = default
 */
static int Dtool_Init_ShaderGenerator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ShaderGenerator() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ShaderGenerator::ShaderGenerator(ShaderGenerator const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      ShaderGenerator const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ShaderGenerator);
      if (param0_this != nullptr) {
        ShaderGenerator *return_value = new ShaderGenerator(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderGenerator, true, false);
      }
    }
  }

  {
    // -2 ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase const *gsg)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "gsg")) {
      GraphicsStateGuardianBase const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GraphicsStateGuardianBase);
      if (param0_this != nullptr) {
        ShaderGenerator *return_value = new ShaderGenerator(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderGenerator, true, false);
      }
    }
  }

  {
    // -2 inline ShaderGenerator::ShaderGenerator(ShaderGenerator const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(ShaderGenerator) param0_this;
      if (Dtool_ConstCoerce_ShaderGenerator(param0, param0_this)) {
        ShaderGenerator *return_value = new ShaderGenerator(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderGenerator, true, false);
      }
    }
  }

  // No coercion possible: ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase const *gsg)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShaderGenerator(const ShaderGenerator param0)\n"
      "ShaderGenerator(const GraphicsStateGuardianBase gsg)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShaderGenerator)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase const *gsg)
    GraphicsStateGuardianBase const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GraphicsStateGuardianBase);
    if (arg_this != nullptr) {
      ShaderGenerator *return_value = new ShaderGenerator(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShaderGenerator)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase const *gsg)
    GraphicsStateGuardianBase const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GraphicsStateGuardianBase);
    if (arg_this != nullptr) {
      ShaderGenerator *return_value = new ShaderGenerator(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ShaderGenerator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderGenerator) {
    printf("ShaderGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderGenerator *local_this = (ShaderGenerator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderGenerator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderGenerator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderGenerator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ShaderGenerator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SphereLight
 */
/**
 * Python function wrapper for:
 * inline PN_stdfloat SphereLight::get_radius(void) const
 */
static PyObject *Dtool_SphereLight_get_radius_204(PyObject *self, PyObject *) {
  SphereLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SphereLight)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SphereLight::get_radius(void) const
  PN_stdfloat return_value = ((*(const SphereLight*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SphereLight_get_radius_204_comment =
  "C++ Interface:\n"
  "get_radius(SphereLight self)\n"
  "\n"
  "/**\n"
  " * Returns the radius of the sphere.\n"
  " */";
#else
static const char *Dtool_SphereLight_get_radius_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SphereLight::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_SphereLight_set_radius_205(PyObject *self, PyObject *arg) {
  SphereLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SphereLight, (void **)&local_this, "SphereLight.set_radius")) {
    return nullptr;
  }
  // 1-inline void SphereLight::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const SphereLight self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SphereLight_set_radius_205_comment =
  "C++ Interface:\n"
  "set_radius(const SphereLight self, float radius)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the sphere.\n"
  " */";
#else
static const char *Dtool_SphereLight_set_radius_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SphereLight::get_class_type(void)
 */
static PyObject *Dtool_SphereLight_get_class_type_207(PyObject *, PyObject *) {
  // 1-static TypeHandle SphereLight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SphereLight::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SphereLight_get_class_type_207_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SphereLight_get_class_type_207_comment = nullptr;
#endif

static PyObject *Dtool_SphereLight_radius_Getter(PyObject *self, void *) {
  const SphereLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SphereLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat SphereLight::get_radius(void) const
  PN_stdfloat return_value = ((*(const SphereLight*)local_this).get_radius)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SphereLight_radius_Setter(PyObject *self, PyObject *arg, void *) {
  SphereLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SphereLight, (void **)&local_this, "SphereLight.radius")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void SphereLight::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const SphereLight self, float radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit SphereLight::SphereLight(std::string const &name)
 */
static int Dtool_Init_SphereLight(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SphereLight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit SphereLight::SphereLight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      SphereLight *return_value = new SphereLight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SphereLight, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SphereLight(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SphereLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SphereLight) {
    printf("SphereLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SphereLight *local_this = (SphereLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SphereLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointLight) {
    return (PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *)(PointLight *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SphereLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SphereLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_PointLight) {
    PointLight* other_this = (PointLight*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SphereLight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SphereLight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Spotlight
 */
/**
 * Python function wrapper for:
 * inline void Spotlight::set_exponent(PN_stdfloat exponent)
 */
static PyObject *Dtool_Spotlight_set_exponent_211(PyObject *self, PyObject *arg) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_exponent")) {
    return nullptr;
  }
  // 1-inline void Spotlight::set_exponent(PN_stdfloat exponent)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_exponent)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_exponent(const Spotlight self, float exponent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_exponent_211_comment =
  "C++ Interface:\n"
  "set_exponent(const Spotlight self, float exponent)\n"
  "\n"
  "/**\n"
  " * Sets the exponent that controls the amount of light falloff from the center\n"
  " * of the spotlight.  The light is attenuated by the cosine of the angle\n"
  " * between the direction of the light and the direction of the point being\n"
  " * lighted, raised to the power of this exponent.  Thus, higher exponents\n"
  " * result in a more focused light source, regardless of the field-of-view of\n"
  " * the lens.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_exponent_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::set_specular_color(LColor const &color)
 */
static PyObject *Dtool_Spotlight_set_specular_color_214(PyObject *self, PyObject *arg) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_specular_color")) {
    return nullptr;
  }
  // 1-inline void Spotlight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_specular_color", "LVecBase4f");
  }
  ((*local_this).set_specular_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_specular_color(const Spotlight self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_specular_color_214_comment =
  "C++ Interface:\n"
  "set_specular_color(const Spotlight self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the color of specular highlights generated by the light.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_specular_color_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::clear_specular_color(void)
 */
static PyObject *Dtool_Spotlight_clear_specular_color_215(PyObject *self, PyObject *) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.clear_specular_color")) {
    return nullptr;
  }
  // 1-inline void Spotlight::clear_specular_color(void)
  ((*local_this).clear_specular_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_clear_specular_color_215_comment =
  "C++ Interface:\n"
  "clear_specular_color(const Spotlight self)\n"
  "\n"
  "/**\n"
  " * Clears a custom specular color setting, meaning that the specular color\n"
  " * will now come from the color.\n"
  " */";
#else
static const char *Dtool_Spotlight_clear_specular_color_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::set_attenuation(LVecBase3 const &attenuation)
 */
static PyObject *Dtool_Spotlight_set_attenuation_218(PyObject *self, PyObject *arg) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_attenuation")) {
    return nullptr;
  }
  // 1-inline void Spotlight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_attenuation", "LVecBase3f");
  }
  ((*local_this).set_attenuation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_attenuation(const Spotlight self, const LVecBase3f attenuation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_attenuation_218_comment =
  "C++ Interface:\n"
  "set_attenuation(const Spotlight self, const LVecBase3f attenuation)\n"
  "\n"
  "/**\n"
  " * Sets the terms of the attenuation equation for the light.  These are, in\n"
  " * order, the constant, linear, and quadratic terms based on the distance from\n"
  " * the point to the vertex.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_attenuation_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Spotlight::get_max_distance(void) const
 */
static PyObject *Dtool_Spotlight_get_max_distance_221(PyObject *self, PyObject *) {
  Spotlight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Spotlight)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Spotlight::get_max_distance(void) const
  PN_stdfloat return_value = ((*(const Spotlight*)local_this).get_max_distance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_get_max_distance_221_comment =
  "C++ Interface:\n"
  "get_max_distance(Spotlight self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum distance at which the light has any effect, as previously\n"
  " * specified by set_max_distance.\n"
  " */";
#else
static const char *Dtool_Spotlight_get_max_distance_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Spotlight::set_max_distance(PN_stdfloat max_distance)
 */
static PyObject *Dtool_Spotlight_set_max_distance_222(PyObject *self, PyObject *arg) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.set_max_distance")) {
    return nullptr;
  }
  // 1-inline void Spotlight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_distance(const Spotlight self, float max_distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_set_max_distance_222_comment =
  "C++ Interface:\n"
  "set_max_distance(const Spotlight self, float max_distance)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the light's sphere of influence.  Beyond this distance, the\n"
  " * light may be attenuated to zero, if this is supported by the shader.\n"
  " */";
#else
static const char *Dtool_Spotlight_set_max_distance_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< Texture > Spotlight::make_spot(int pixel_width, PN_stdfloat full_radius, LColor &fg, LColor &bg)
 */
static PyObject *Dtool_Spotlight_make_spot_224(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< Texture > Spotlight::make_spot(int pixel_width, PN_stdfloat full_radius, LColor &fg, LColor &bg)
  int param0;
  float param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"pixel_width", "full_radius", "fg", "bg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ifOO:make_spot", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase4f param2_local;
    LColor *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Spotlight.make_spot", "LVecBase4f");
    }
    LVecBase4f param3_local;
    LColor *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "Spotlight.make_spot", "LVecBase4f");
    }
    PointerTo< Texture > return_value = (Spotlight::make_spot)((int)param0, (PN_stdfloat)param1, *param2_this, *param3_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Texture *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Texture, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_spot(int pixel_width, float full_radius, LVecBase4f fg, LVecBase4f bg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_make_spot_224_comment =
  "C++ Interface:\n"
  "make_spot(int pixel_width, float full_radius, LVecBase4f fg, LVecBase4f bg)\n"
  "\n"
  "/**\n"
  " * Returns a newly-generated Texture that renders a circular spot image as\n"
  " * might be cast from the spotlight.  This may be projected onto target\n"
  " * geometry (for instance, via NodePath::project_texture()) instead of\n"
  " * actually enabling the light itself, as a cheesy way to make a high-\n"
  " * resolution spot appear on the geometry.\n"
  " *\n"
  " * pixel_width specifies the height and width of the new texture in pixels,\n"
  " * full_radius is a value in the range 0..1 that indicates the relative size\n"
  " * of the fully bright center spot, and fg and bg are the colors of the\n"
  " * interior and exterior of the spot, respectively.\n"
  " */";
#else
static const char *Dtool_Spotlight_make_spot_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Spotlight::get_class_type(void)
 */
static PyObject *Dtool_Spotlight_get_class_type_225(PyObject *, PyObject *) {
  // 1-static TypeHandle Spotlight::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Spotlight::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Spotlight_get_class_type_225_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Spotlight_get_class_type_225_comment = nullptr;
#endif

static PyObject *Dtool_Spotlight_exponent_Getter(PyObject *self, void *) {
  const Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Spotlight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline PN_stdfloat Spotlight::get_exponent(void) const final
  PN_stdfloat return_value = ((*(const Spotlight*)local_this).get_exponent)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Spotlight_exponent_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.exponent")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete exponent attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_exponent(PN_stdfloat exponent)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_exponent)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_exponent(const Spotlight self, float exponent)\n");
  }
  return -1;
}

static PyObject *Dtool_Spotlight_specular_color_Getter(PyObject *self, void *) {
  const Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Spotlight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline LColor const &Spotlight::get_specular_color(void) const final
  LColor const *return_value = &(((*(const Spotlight*)local_this).get_specular_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_Spotlight_specular_color_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.specular_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete specular_color attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_specular_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_specular_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_specular_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_specular_color(const Spotlight self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_Spotlight_attenuation_Getter(PyObject *self, void *) {
  const Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Spotlight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline LVecBase3 const &Spotlight::get_attenuation(void) const final
  LVecBase3 const *return_value = &(((*(const Spotlight*)local_this).get_attenuation)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_Spotlight_attenuation_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.attenuation")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete attenuation attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_attenuation(LVecBase3 const &attenuation)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Spotlight.set_attenuation", "LVecBase3f");
    return -1;
  }
  ((*local_this).set_attenuation)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_attenuation(const Spotlight self, const LVecBase3f attenuation)\n");
  }
  return -1;
}

static PyObject *Dtool_Spotlight_max_distance_Getter(PyObject *self, void *) {
  const Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Spotlight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Spotlight::get_max_distance(void) const
  PN_stdfloat return_value = ((*(const Spotlight*)local_this).get_max_distance)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Spotlight_max_distance_Setter(PyObject *self, PyObject *arg, void *) {
  Spotlight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Spotlight, (void **)&local_this, "Spotlight.max_distance")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_distance attribute");
    return -1;
  }
  // 1-inline void Spotlight::set_max_distance(PN_stdfloat max_distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_distance(const Spotlight self, float max_distance)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * Spotlight::Spotlight(std::string const &name)
 */
static int Dtool_Init_Spotlight(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Spotlight() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-Spotlight::Spotlight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Spotlight *return_value = new Spotlight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Spotlight, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Spotlight(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Spotlight(PyObject *args, CPT(Spotlight) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Spotlight)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Spotlight::Spotlight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Spotlight *return_value = new Spotlight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_Spotlight(PyObject *args, PT(Spotlight) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Spotlight)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Spotlight::Spotlight(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Spotlight *return_value = new Spotlight(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_Spotlight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Spotlight) {
    printf("Spotlight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Spotlight *local_this = (Spotlight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Spotlight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Camera) {
    return (Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LensNode) {
    return (LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Light) {
    return (Light *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_LightLensNode) {
    return (LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(LensNode *)(Camera *)(LightLensNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Spotlight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Spotlight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Camera) {
    Camera* other_this = (Camera*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_LensNode) {
    LensNode* other_this = (LensNode*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_Light) {
    Light* other_this = (Light*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_LightLensNode) {
    LightLensNode* other_this = (LightLensNode*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Spotlight*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Spotlight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SwitchNode
 */
/**
 * Python function wrapper for:
 * inline void SwitchNode::set_visible_child(int index)
 */
static PyObject *Dtool_SwitchNode_set_visible_child_229(PyObject *self, PyObject *arg) {
  SwitchNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SwitchNode, (void **)&local_this, "SwitchNode.set_visible_child")) {
    return nullptr;
  }
  // 1-inline void SwitchNode::set_visible_child(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_visible_child)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visible_child(const SwitchNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SwitchNode_set_visible_child_229_comment =
  "C++ Interface:\n"
  "set_visible_child(const SwitchNode self, int index)\n"
  "\n"
  "/**\n"
  " * Specifies the particular child of this node, by index, that will be\n"
  " * visible.\n"
  " */";
#else
static const char *Dtool_SwitchNode_set_visible_child_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int SwitchNode::get_visible_child(void) const
 */
static PyObject *Dtool_SwitchNode_get_visible_child_230(PyObject *self, PyObject *) {
  SwitchNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SwitchNode)) {
    return nullptr;
  }
  // 1-virtual int SwitchNode::get_visible_child(void) const
  int return_value = ((*(const SwitchNode*)local_this).get_visible_child)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SwitchNode_get_visible_child_230_comment =
  "C++ Interface:\n"
  "get_visible_child(SwitchNode self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the child that should be visible.\n"
  " */";
#else
static const char *Dtool_SwitchNode_get_visible_child_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SwitchNode::get_class_type(void)
 */
static PyObject *Dtool_SwitchNode_get_class_type_232(PyObject *, PyObject *) {
  // 1-static TypeHandle SwitchNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SwitchNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SwitchNode_get_class_type_232_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SwitchNode_get_class_type_232_comment = nullptr;
#endif

static PyObject *Dtool_SwitchNode_visible_child_Getter(PyObject *self, void *) {
  const SwitchNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SwitchNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual int SwitchNode::get_visible_child(void) const
  int return_value = ((*(const SwitchNode*)local_this).get_visible_child)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_SwitchNode_visible_child_Setter(PyObject *self, PyObject *arg, void *) {
  SwitchNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SwitchNode, (void **)&local_this, "SwitchNode.visible_child")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete visible_child attribute");
    return -1;
  }
  // 1-inline void SwitchNode::set_visible_child(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_visible_child)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_visible_child(const SwitchNode self, int index)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline explicit SwitchNode::SwitchNode(std::string const &name)
 */
static int Dtool_Init_SwitchNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "SwitchNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-inline explicit SwitchNode::SwitchNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      SwitchNode *return_value = new SwitchNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SwitchNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SwitchNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SwitchNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SwitchNode) {
    printf("SwitchNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SwitchNode *local_this = (SwitchNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SwitchNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_SelectiveChildNode) {
    return (SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(SelectiveChildNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SwitchNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SwitchNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_SelectiveChildNode) {
    SelectiveChildNode* other_this = (SelectiveChildNode*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SwitchNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SwitchNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UvScrollNode
 */
/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed)
 */
static PyObject *Dtool_UvScrollNode_set_u_speed_236(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_u_speed")) {
    return nullptr;
  }
  // 1-inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_u_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_speed(const UvScrollNode self, float u_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_u_speed_236_comment =
  "C++ Interface:\n"
  "set_u_speed(const UvScrollNode self, float u_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_u_speed_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed)
 */
static PyObject *Dtool_UvScrollNode_set_v_speed_237(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_v_speed")) {
    return nullptr;
  }
  // 1-inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_v_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_speed(const UvScrollNode self, float v_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_v_speed_237_comment =
  "C++ Interface:\n"
  "set_v_speed(const UvScrollNode self, float v_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_v_speed_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed)
 */
static PyObject *Dtool_UvScrollNode_set_w_speed_238(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_w_speed")) {
    return nullptr;
  }
  // 1-inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_w_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_w_speed(const UvScrollNode self, float w_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_w_speed_238_comment =
  "C++ Interface:\n"
  "set_w_speed(const UvScrollNode self, float w_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_w_speed_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed)
 */
static PyObject *Dtool_UvScrollNode_set_r_speed_239(PyObject *self, PyObject *arg) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.set_r_speed")) {
    return nullptr;
  }
  // 1-inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_r_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r_speed(const UvScrollNode self, float r_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_set_r_speed_239_comment =
  "C++ Interface:\n"
  "set_r_speed(const UvScrollNode self, float r_speed)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_set_r_speed_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_u_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_u_speed_240(PyObject *self, PyObject *) {
  UvScrollNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UvScrollNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_u_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_u_speed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_u_speed_240_comment =
  "C++ Interface:\n"
  "get_u_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_u_speed_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_v_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_v_speed_241(PyObject *self, PyObject *) {
  UvScrollNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UvScrollNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_v_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_v_speed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_v_speed_241_comment =
  "C++ Interface:\n"
  "get_v_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_v_speed_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_w_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_w_speed_242(PyObject *self, PyObject *) {
  UvScrollNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UvScrollNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_w_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_w_speed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_w_speed_242_comment =
  "C++ Interface:\n"
  "get_w_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_w_speed_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat UvScrollNode::get_r_speed(void) const
 */
static PyObject *Dtool_UvScrollNode_get_r_speed_243(PyObject *self, PyObject *) {
  UvScrollNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UvScrollNode)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat UvScrollNode::get_r_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_r_speed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_r_speed_243_comment =
  "C++ Interface:\n"
  "get_r_speed(UvScrollNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UvScrollNode_get_r_speed_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UvScrollNode::get_class_type(void)
 */
static PyObject *Dtool_UvScrollNode_get_class_type_248(PyObject *, PyObject *) {
  // 1-static TypeHandle UvScrollNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((UvScrollNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UvScrollNode_get_class_type_248_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UvScrollNode_get_class_type_248_comment = nullptr;
#endif

static PyObject *Dtool_UvScrollNode_u_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_u_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_u_speed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_u_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.u_speed")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete u_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_u_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_u_speed(const UvScrollNode self, float u_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_UvScrollNode_v_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_v_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_v_speed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_v_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.v_speed")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete v_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_v_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_v_speed(const UvScrollNode self, float v_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_UvScrollNode_w_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_w_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_w_speed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_w_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.w_speed")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete w_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_w_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_w_speed(const UvScrollNode self, float w_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_UvScrollNode_r_speed_Getter(PyObject *self, void *) {
  const UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UvScrollNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat UvScrollNode::get_r_speed(void) const
  PN_stdfloat return_value = ((*(const UvScrollNode*)local_this).get_r_speed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_UvScrollNode_r_speed_Setter(PyObject *self, PyObject *arg, void *) {
  UvScrollNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UvScrollNode, (void **)&local_this, "UvScrollNode.r_speed")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete r_speed attribute");
    return -1;
  }
  // 1-inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_r_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_r_speed(const UvScrollNode self, float r_speed)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline explicit UvScrollNode::UvScrollNode(std::string const &name)
 * inline explicit UvScrollNode::UvScrollNode(std::string const &name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed)
 */
static int Dtool_Init_UvScrollNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-inline explicit UvScrollNode::UvScrollNode(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UvScrollNode, true, false);
        }
      }
    }
    break;
  case 5:
    {
      // 1-inline explicit UvScrollNode::UvScrollNode(std::string const &name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"name", "u_speed", "v_speed", "w_speed", "r_speed", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#ffff:UvScrollNode", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        UvScrollNode *return_value = new UvScrollNode(std::string(param0_str, param0_len), (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UvScrollNode, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UvScrollNode() takes 1 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UvScrollNode(str name)\n"
      "UvScrollNode(str name, float u_speed, float v_speed, float w_speed, float r_speed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UvScrollNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UvScrollNode) {
    printf("UvScrollNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UvScrollNode *local_this = (UvScrollNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UvScrollNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UvScrollNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UvScrollNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (UvScrollNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (UvScrollNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SceneGraphAnalyzer
 */
/**
 * Python function wrapper for:
 * inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode)
 */
static PyObject *Dtool_SceneGraphAnalyzer_set_lod_mode_254(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzer, (void **)&local_this, "SceneGraphAnalyzer.set_lod_mode")) {
    return nullptr;
  }
  // 1-inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_lod_mode)((SceneGraphAnalyzer::LodMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_mode(const SceneGraphAnalyzer self, int lod_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_set_lod_mode_254_comment =
  "C++ Interface:\n"
  "set_lod_mode(const SceneGraphAnalyzer self, int lod_mode)\n"
  "\n"
  "/**\n"
  " * Specifies the mode in which LODNodes are analyzed.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_set_lod_mode_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_lod_mode_255(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SceneGraphAnalyzer::LodMode return_value = ((*(const SceneGraphAnalyzer*)local_this).get_lod_mode)((SceneGraphAnalyzer::LodMode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_lod_mode(SceneGraphAnalyzer self, int lod_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_lod_mode_255_comment =
  "C++ Interface:\n"
  "get_lod_mode(SceneGraphAnalyzer self, int lod_mode)\n"
  "\n"
  "/**\n"
  " * Returns the mode in which LODNodes are analyzed.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_lod_mode_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphAnalyzer::clear(void)
 */
static PyObject *Dtool_SceneGraphAnalyzer_clear_256(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzer, (void **)&local_this, "SceneGraphAnalyzer.clear")) {
    return nullptr;
  }
  // 1-void SceneGraphAnalyzer::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_clear_256_comment =
  "C++ Interface:\n"
  "clear(const SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " * Resets all of the data in the analyzer in preparation for a new run.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_clear_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphAnalyzer::add_node(PandaNode *node)
 */
static PyObject *Dtool_SceneGraphAnalyzer_add_node_257(PyObject *self, PyObject *arg) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SceneGraphAnalyzer, (void **)&local_this, "SceneGraphAnalyzer.add_node")) {
    return nullptr;
  }
  // 1-void SceneGraphAnalyzer::add_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "SceneGraphAnalyzer.add_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_node(const SceneGraphAnalyzer self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_add_node_257_comment =
  "C++ Interface:\n"
  "add_node(const SceneGraphAnalyzer self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds a new node to the set of data for analysis.  Normally, this would only\n"
  " * be called once, and passed the top of the scene graph, but it's possible to\n"
  " * repeatedly pass in subgraphs to get an analysis of all the graphs together.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_add_node_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SceneGraphAnalyzer::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_write_258(PyObject *self, PyObject *args, PyObject *kwds) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-void SceneGraphAnalyzer::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "SceneGraphAnalyzer.write", false, true);
    if (param1_this != nullptr) {
      ((*(const SceneGraphAnalyzer*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(SceneGraphAnalyzer self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_write_258_comment =
  "C++ Interface:\n"
  "write(SceneGraphAnalyzer self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Describes all the data collected.\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_write_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_nodes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_nodes_259(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_nodes(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_nodes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_259_comment =
  "C++ Interface:\n"
  "get_num_nodes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_instances(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_instances_260(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_instances(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_instances)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_instances_260_comment =
  "C++ Interface:\n"
  "get_num_instances(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_instances_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_transforms(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_transforms_261(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_transforms(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_transforms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_transforms_261_comment =
  "C++ Interface:\n"
  "get_num_transforms(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_transforms_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_262(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_nodes_with_attribs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_262_comment =
  "C++ Interface:\n"
  "get_num_nodes_with_attribs(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_lod_nodes_263(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_lod_nodes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_lod_nodes_263_comment =
  "C++ Interface:\n"
  "get_num_lod_nodes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_lod_nodes_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_nodes_264(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_geom_nodes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_nodes_264_comment =
  "C++ Interface:\n"
  "get_num_geom_nodes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_nodes_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geoms(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geoms_265(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geoms(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_geoms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geoms_265_comment =
  "C++ Interface:\n"
  "get_num_geoms(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geoms_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_266(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_geom_vertex_datas)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_266_comment =
  "C++ Interface:\n"
  "get_num_geom_vertex_datas(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_267(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_geom_vertex_formats)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_267_comment =
  "C++ Interface:\n"
  "get_num_geom_vertex_formats(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SceneGraphAnalyzer::get_vertex_data_size(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_vertex_data_size_268(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline std::size_t SceneGraphAnalyzer::get_vertex_data_size(void) const
  std::size_t return_value = ((*(const SceneGraphAnalyzer*)local_this).get_vertex_data_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_vertex_data_size_268_comment =
  "C++ Interface:\n"
  "get_vertex_data_size(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_vertex_data_size_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_vertices(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_vertices_269(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_vertices(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_269_comment =
  "C++ Interface:\n"
  "get_num_vertices(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_normals(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_normals_270(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_normals(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_normals)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_normals_270_comment =
  "C++ Interface:\n"
  "get_num_normals(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_normals_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_colors(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_colors_271(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_colors(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_colors)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_colors_271_comment =
  "C++ Interface:\n"
  "get_num_colors(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_colors_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_texcoords(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_texcoords_272(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_texcoords(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_texcoords)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_texcoords_272_comment =
  "C++ Interface:\n"
  "get_num_texcoords(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_texcoords_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_tris(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_tris_273(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_tris(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_tris)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_tris_273_comment =
  "C++ Interface:\n"
  "get_num_tris(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_tris_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_lines(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_lines_274(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_lines(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_lines)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_lines_274_comment =
  "C++ Interface:\n"
  "get_num_lines(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_lines_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_points(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_points_275(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_points(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_points_275_comment =
  "C++ Interface:\n"
  "get_num_points(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_points_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_patches(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_patches_276(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_patches(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_patches)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_patches_276_comment =
  "C++ Interface:\n"
  "get_num_patches(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_patches_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_individual_tris(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_individual_tris_277(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_individual_tris(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_individual_tris)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_individual_tris_277_comment =
  "C++ Interface:\n"
  "get_num_individual_tris(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_individual_tris_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_tristrips(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_tristrips_278(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_tristrips(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_tristrips)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_tristrips_278_comment =
  "C++ Interface:\n"
  "get_num_tristrips(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_tristrips_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_279(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_triangles_in_strips)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_279_comment =
  "C++ Interface:\n"
  "get_num_triangles_in_strips(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_trifans(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_trifans_280(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_trifans(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_trifans)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_trifans_280_comment =
  "C++ Interface:\n"
  "get_num_trifans(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_trifans_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_281(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_triangles_in_fans)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_281_comment =
  "C++ Interface:\n"
  "get_num_triangles_in_fans(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_vertices_in_patches(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_282(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_vertices_in_patches(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_vertices_in_patches)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_282_comment =
  "C++ Interface:\n"
  "get_num_vertices_in_patches(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SceneGraphAnalyzer::get_texture_bytes(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_texture_bytes_283(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline std::size_t SceneGraphAnalyzer::get_texture_bytes(void) const
  std::size_t return_value = ((*(const SceneGraphAnalyzer*)local_this).get_texture_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_texture_bytes_283_comment =
  "C++ Interface:\n"
  "get_texture_bytes(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_texture_bytes_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_long_normals(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_long_normals_284(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_long_normals(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_long_normals)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_long_normals_284_comment =
  "C++ Interface:\n"
  "get_num_long_normals(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_long_normals_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SceneGraphAnalyzer::get_num_short_normals(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_num_short_normals_285(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline int SceneGraphAnalyzer::get_num_short_normals(void) const
  int return_value = ((*(const SceneGraphAnalyzer*)local_this).get_num_short_normals)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_num_short_normals_285_comment =
  "C++ Interface:\n"
  "get_num_short_normals(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_num_short_normals_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SceneGraphAnalyzer::get_total_normal_length(void) const
 */
static PyObject *Dtool_SceneGraphAnalyzer_get_total_normal_length_286(PyObject *self, PyObject *) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SceneGraphAnalyzer)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SceneGraphAnalyzer::get_total_normal_length(void) const
  PN_stdfloat return_value = ((*(const SceneGraphAnalyzer*)local_this).get_total_normal_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SceneGraphAnalyzer_get_total_normal_length_286_comment =
  "C++ Interface:\n"
  "get_total_normal_length(SceneGraphAnalyzer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SceneGraphAnalyzer_get_total_normal_length_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SceneGraphAnalyzer::SceneGraphAnalyzer(void)
 * inline SceneGraphAnalyzer::SceneGraphAnalyzer(SceneGraphAnalyzer const &) = default
 */
static int Dtool_Init_SceneGraphAnalyzer(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("SceneGraphAnalyzer() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-SceneGraphAnalyzer::SceneGraphAnalyzer(void)
      SceneGraphAnalyzer *return_value = new SceneGraphAnalyzer();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphAnalyzer, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline SceneGraphAnalyzer::SceneGraphAnalyzer(SceneGraphAnalyzer const &) = default
      SceneGraphAnalyzer const *arg_this = (SceneGraphAnalyzer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SceneGraphAnalyzer, 0, "SceneGraphAnalyzer.SceneGraphAnalyzer", true, true);
      if (arg_this != nullptr) {
        SceneGraphAnalyzer *return_value = new SceneGraphAnalyzer(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SceneGraphAnalyzer, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SceneGraphAnalyzer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SceneGraphAnalyzer()\n"
      "SceneGraphAnalyzer(const SceneGraphAnalyzer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SceneGraphAnalyzer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SceneGraphAnalyzer) {
    printf("SceneGraphAnalyzer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SceneGraphAnalyzer *local_this = (SceneGraphAnalyzer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SceneGraphAnalyzer) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SceneGraphAnalyzer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SceneGraphAnalyzer) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for LightNode (LightNode)
 */
static PyMethodDef Dtool_Methods_LightNode[] = {
  {"output", &Dtool_LightNode_output_8, METH_O, (const char *)Dtool_LightNode_output_8_comment},
  {"write", (PyCFunction) &Dtool_LightNode_write_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightNode_write_9_comment},
  {"get_class_type", &Dtool_LightNode_get_class_type_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightNode_get_class_type_10_comment},
  {"getClassType", &Dtool_LightNode_get_class_type_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightNode_get_class_type_10_comment},
  {"upcast_to_Light", &Dtool_LightNode_upcast_to_Light_3, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_Light_3_comment},
  {"upcastToLight", &Dtool_LightNode_upcast_to_Light_3, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_Light_3_comment},
  {"upcast_to_PandaNode", &Dtool_LightNode_upcast_to_PandaNode_6, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_PandaNode_6_comment},
  {"upcastToPandaNode", &Dtool_LightNode_upcast_to_PandaNode_6, METH_NOARGS, (const char *)Dtool_LightNode_upcast_to_PandaNode_6_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     LightNode
//////////////////
static PyObject *Dtool_Repr_LightNode(PyObject *self) {
  LightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LightNode
//////////////////
static PyObject *Dtool_Str_LightNode(PyObject *self) {
  LightNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LightNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LightNode,
    &Dtool_NumberMethods_LightNode,
    &Dtool_SequenceMethods_LightNode,
    &Dtool_MappingMethods_LightNode,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_LightNode,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A derivative of Light and of PandaNode.  All kinds of Light except\n"
    " * Spotlight (which must inherit from LensNode instead) inherit from this\n"
    " * class.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightNode,
    PyType_GenericAlloc,
    Dtool_new_LightNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightNode,
  Dtool_UpcastInterface_LightNode,
  Dtool_DowncastInterface_LightNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Light != nullptr);
    assert(Dtool_Ptr_Light->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Light->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_LightNode._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_Light, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_LightNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightNode);
  }
}

/**
 * Python method tables for AmbientLight (AmbientLight)
 */
static PyMethodDef Dtool_Methods_AmbientLight[] = {
  {"get_class_type", &Dtool_AmbientLight_get_class_type_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_AmbientLight_get_class_type_14_comment},
  {"getClassType", &Dtool_AmbientLight_get_class_type_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_AmbientLight_get_class_type_14_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AmbientLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AmbientLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AmbientLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AmbientLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AmbientLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AmbientLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AmbientLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AmbientLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AmbientLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AmbientLight,
    &Dtool_SequenceMethods_AmbientLight,
    &Dtool_MappingMethods_AmbientLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AmbientLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light source that seems to illuminate all points in space at once.  This\n"
    " * kind of light need not actually be part of the scene graph, since it has no\n"
    " * meaningful position.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AmbientLight,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AmbientLight,
    PyType_GenericAlloc,
    Dtool_new_AmbientLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AmbientLight,
  Dtool_UpcastInterface_AmbientLight,
  Dtool_DowncastInterface_AmbientLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AmbientLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightNode(nullptr);
    Dtool_AmbientLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightNode);
    Dtool_AmbientLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AmbientLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AmbientLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AmbientLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AmbientLight);
  }
}

/**
 * Python method tables for CallbackNode (CallbackNode)
 */
static PyMethodDef Dtool_Methods_CallbackNode[] = {
  {"set_cull_callback", &Dtool_CallbackNode_set_cull_callback_18, METH_O, (const char *)Dtool_CallbackNode_set_cull_callback_18_comment},
  {"setCullCallback", &Dtool_CallbackNode_set_cull_callback_18, METH_O, (const char *)Dtool_CallbackNode_set_cull_callback_18_comment},
  {"clear_cull_callback", &Dtool_CallbackNode_clear_cull_callback_19, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_cull_callback_19_comment},
  {"clearCullCallback", &Dtool_CallbackNode_clear_cull_callback_19, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_cull_callback_19_comment},
  {"get_cull_callback", &Dtool_CallbackNode_get_cull_callback_20, METH_NOARGS, (const char *)Dtool_CallbackNode_get_cull_callback_20_comment},
  {"getCullCallback", &Dtool_CallbackNode_get_cull_callback_20, METH_NOARGS, (const char *)Dtool_CallbackNode_get_cull_callback_20_comment},
  {"set_draw_callback", &Dtool_CallbackNode_set_draw_callback_24, METH_O, (const char *)Dtool_CallbackNode_set_draw_callback_24_comment},
  {"setDrawCallback", &Dtool_CallbackNode_set_draw_callback_24, METH_O, (const char *)Dtool_CallbackNode_set_draw_callback_24_comment},
  {"clear_draw_callback", &Dtool_CallbackNode_clear_draw_callback_25, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_draw_callback_25_comment},
  {"clearDrawCallback", &Dtool_CallbackNode_clear_draw_callback_25, METH_NOARGS, (const char *)Dtool_CallbackNode_clear_draw_callback_25_comment},
  {"get_draw_callback", &Dtool_CallbackNode_get_draw_callback_26, METH_NOARGS, (const char *)Dtool_CallbackNode_get_draw_callback_26_comment},
  {"getDrawCallback", &Dtool_CallbackNode_get_draw_callback_26, METH_NOARGS, (const char *)Dtool_CallbackNode_get_draw_callback_26_comment},
  {"get_class_type", &Dtool_CallbackNode_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackNode_get_class_type_28_comment},
  {"getClassType", &Dtool_CallbackNode_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackNode_get_class_type_28_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CallbackNode[] = {
  {(char *)"cull_callback", &Dtool_CallbackNode_cull_callback_Getter, &Dtool_CallbackNode_cull_callback_Setter, nullptr, nullptr},
  {(char *)"draw_callback", &Dtool_CallbackNode_draw_callback_Getter, &Dtool_CallbackNode_draw_callback_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CallbackNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CallbackNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CallbackNode,
    &Dtool_SequenceMethods_CallbackNode,
    &Dtool_MappingMethods_CallbackNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special node that can issue arbitrary callbacks to user code, either\n"
    " * during the cull or draw traversals.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackNode,
    nullptr, // tp_members
    Dtool_Properties_CallbackNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackNode,
    PyType_GenericAlloc,
    Dtool_new_CallbackNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackNode,
  Dtool_UpcastInterface_CallbackNode,
  Dtool_DowncastInterface_CallbackNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CallbackNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_CallbackNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_CallbackNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CallbackNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackNode);
  }
}

/**
 * Python method tables for ComputeNode (ComputeNode)
 */
static PyMethodDef Dtool_Methods_ComputeNode[] = {
  {"add_dispatch", (PyCFunction) &Dtool_ComputeNode_add_dispatch_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_add_dispatch_32_comment},
  {"addDispatch", (PyCFunction) &Dtool_ComputeNode_add_dispatch_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_add_dispatch_32_comment},
  {"get_num_dispatches", &Dtool_ComputeNode_get_num_dispatches_33, METH_NOARGS, (const char *)Dtool_ComputeNode_get_num_dispatches_33_comment},
  {"getNumDispatches", &Dtool_ComputeNode_get_num_dispatches_33, METH_NOARGS, (const char *)Dtool_ComputeNode_get_num_dispatches_33_comment},
  {"get_dispatch", &Dtool_ComputeNode_get_dispatch_34, METH_O, (const char *)Dtool_ComputeNode_get_dispatch_34_comment},
  {"getDispatch", &Dtool_ComputeNode_get_dispatch_34, METH_O, (const char *)Dtool_ComputeNode_get_dispatch_34_comment},
  {"set_dispatch", (PyCFunction) &Dtool_ComputeNode_set_dispatch_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_set_dispatch_35_comment},
  {"setDispatch", (PyCFunction) &Dtool_ComputeNode_set_dispatch_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_set_dispatch_35_comment},
  {"insert_dispatch", (PyCFunction) &Dtool_ComputeNode_insert_dispatch_36, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_insert_dispatch_36_comment},
  {"insertDispatch", (PyCFunction) &Dtool_ComputeNode_insert_dispatch_36, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ComputeNode_insert_dispatch_36_comment},
  {"remove_dispatch", &Dtool_ComputeNode_remove_dispatch_37, METH_O, (const char *)Dtool_ComputeNode_remove_dispatch_37_comment},
  {"removeDispatch", &Dtool_ComputeNode_remove_dispatch_37, METH_O, (const char *)Dtool_ComputeNode_remove_dispatch_37_comment},
  {"clear_dispatches", &Dtool_ComputeNode_clear_dispatches_38, METH_NOARGS, (const char *)Dtool_ComputeNode_clear_dispatches_38_comment},
  {"clearDispatches", &Dtool_ComputeNode_clear_dispatches_38, METH_NOARGS, (const char *)Dtool_ComputeNode_clear_dispatches_38_comment},
  {"get_class_type", &Dtool_ComputeNode_get_class_type_43, METH_NOARGS | METH_STATIC, (const char *)Dtool_ComputeNode_get_class_type_43_comment},
  {"getClassType", &Dtool_ComputeNode_get_class_type_43, METH_NOARGS | METH_STATIC, (const char *)Dtool_ComputeNode_get_class_type_43_comment},
  {"get_dispatches", (PyCFunction) &MakeSeq_ComputeNode_get_dispatches, METH_NOARGS, nullptr},
  { "getDispatches", (PyCFunction) &MakeSeq_ComputeNode_get_dispatches, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ComputeNode[] = {
  {(char *)"dispatches", &Dtool_ComputeNode_dispatches_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ComputeNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ComputeNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ComputeNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ComputeNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ComputeNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ComputeNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ComputeNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ComputeNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ComputeNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ComputeNode,
    &Dtool_SequenceMethods_ComputeNode,
    &Dtool_MappingMethods_ComputeNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ComputeNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special node, the sole purpose of which is to invoke a dispatch operation\n"
    " * on the assigned compute shader.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ComputeNode,
    nullptr, // tp_members
    Dtool_Properties_ComputeNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ComputeNode,
    PyType_GenericAlloc,
    Dtool_new_ComputeNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ComputeNode,
  Dtool_UpcastInterface_ComputeNode,
  Dtool_DowncastInterface_ComputeNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ComputeNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_ComputeNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_ComputeNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ComputeNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ComputeNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ComputeNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ComputeNode);
  }
}

/**
 * Python method tables for LightLensNode (LightLensNode)
 */
static PyMethodDef Dtool_Methods_LightLensNode[] = {
  {"has_specular_color", &Dtool_LightLensNode_has_specular_color_53, METH_NOARGS, (const char *)Dtool_LightLensNode_has_specular_color_53_comment},
  {"hasSpecularColor", &Dtool_LightLensNode_has_specular_color_53, METH_NOARGS, (const char *)Dtool_LightLensNode_has_specular_color_53_comment},
  {"is_shadow_caster", &Dtool_LightLensNode_is_shadow_caster_54, METH_NOARGS, (const char *)Dtool_LightLensNode_is_shadow_caster_54_comment},
  {"isShadowCaster", &Dtool_LightLensNode_is_shadow_caster_54, METH_NOARGS, (const char *)Dtool_LightLensNode_is_shadow_caster_54_comment},
  {"set_shadow_caster", (PyCFunction) &Dtool_LightLensNode_set_shadow_caster_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightLensNode_set_shadow_caster_55_comment},
  {"setShadowCaster", (PyCFunction) &Dtool_LightLensNode_set_shadow_caster_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightLensNode_set_shadow_caster_55_comment},
  {"get_shadow_buffer_sort", &Dtool_LightLensNode_get_shadow_buffer_sort_56, METH_NOARGS, (const char *)Dtool_LightLensNode_get_shadow_buffer_sort_56_comment},
  {"getShadowBufferSort", &Dtool_LightLensNode_get_shadow_buffer_sort_56, METH_NOARGS, (const char *)Dtool_LightLensNode_get_shadow_buffer_sort_56_comment},
  {"get_shadow_buffer_size", &Dtool_LightLensNode_get_shadow_buffer_size_57, METH_NOARGS, (const char *)Dtool_LightLensNode_get_shadow_buffer_size_57_comment},
  {"getShadowBufferSize", &Dtool_LightLensNode_get_shadow_buffer_size_57, METH_NOARGS, (const char *)Dtool_LightLensNode_get_shadow_buffer_size_57_comment},
  {"set_shadow_buffer_size", &Dtool_LightLensNode_set_shadow_buffer_size_58, METH_O, (const char *)Dtool_LightLensNode_set_shadow_buffer_size_58_comment},
  {"setShadowBufferSize", &Dtool_LightLensNode_set_shadow_buffer_size_58, METH_O, (const char *)Dtool_LightLensNode_set_shadow_buffer_size_58_comment},
  {"get_shadow_buffer", &Dtool_LightLensNode_get_shadow_buffer_59, METH_O, (const char *)Dtool_LightLensNode_get_shadow_buffer_59_comment},
  {"getShadowBuffer", &Dtool_LightLensNode_get_shadow_buffer_59, METH_O, (const char *)Dtool_LightLensNode_get_shadow_buffer_59_comment},
  {"output", &Dtool_LightLensNode_output_64, METH_O, (const char *)Dtool_LightLensNode_output_64_comment},
  {"write", (PyCFunction) &Dtool_LightLensNode_write_65, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LightLensNode_write_65_comment},
  {"get_class_type", &Dtool_LightLensNode_get_class_type_66, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightLensNode_get_class_type_66_comment},
  {"getClassType", &Dtool_LightLensNode_get_class_type_66, METH_NOARGS | METH_STATIC, (const char *)Dtool_LightLensNode_get_class_type_66_comment},
  {"upcast_to_Light", &Dtool_LightLensNode_upcast_to_Light_47, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Light_47_comment},
  {"upcastToLight", &Dtool_LightLensNode_upcast_to_Light_47, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Light_47_comment},
  {"upcast_to_Camera", &Dtool_LightLensNode_upcast_to_Camera_50, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Camera_50_comment},
  {"upcastToCamera", &Dtool_LightLensNode_upcast_to_Camera_50, METH_NOARGS, (const char *)Dtool_LightLensNode_upcast_to_Camera_50_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     LightLensNode
//////////////////
static PyObject *Dtool_Repr_LightLensNode(PyObject *self) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LightLensNode
//////////////////
static PyObject *Dtool_Str_LightLensNode(PyObject *self) {
  LightLensNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightLensNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_LightLensNode[] = {
  {(char *)"shadow_caster", &Dtool_LightLensNode_shadow_caster_Getter, nullptr, nullptr, nullptr},
  {(char *)"shadow_buffer_size", &Dtool_LightLensNode_shadow_buffer_size_Getter, &Dtool_LightLensNode_shadow_buffer_size_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LightLensNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightLensNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightLensNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightLensNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightLensNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightLensNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightLensNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightLensNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightLensNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LightLensNode,
    &Dtool_NumberMethods_LightLensNode,
    &Dtool_SequenceMethods_LightLensNode,
    &Dtool_MappingMethods_LightLensNode,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_LightLensNode,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightLensNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A derivative of Light and of Camera.  The name might be misleading: it does\n"
    " * not directly derive from LensNode, but through the Camera class.  The\n"
    " * Camera serves no purpose unless shadows are enabled.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightLensNode,
    nullptr, // tp_members
    Dtool_Properties_LightLensNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightLensNode,
    PyType_GenericAlloc,
    Dtool_new_LightLensNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightLensNode,
  Dtool_UpcastInterface_LightLensNode,
  Dtool_DowncastInterface_LightLensNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightLensNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Light != nullptr);
    assert(Dtool_Ptr_Light->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Light->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Camera != nullptr);
    assert(Dtool_Ptr_Camera->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Camera->_Dtool_ModuleClassInit(nullptr);
    Dtool_LightLensNode._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_Light, (PyTypeObject *)Dtool_Ptr_Camera);
    Dtool_LightLensNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightLensNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightLensNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightLensNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightLensNode);
  }
}

/**
 * Python method tables for DirectionalLight (DirectionalLight)
 */
static PyMethodDef Dtool_Methods_DirectionalLight[] = {
  {"set_specular_color", &Dtool_DirectionalLight_set_specular_color_69, METH_O, (const char *)Dtool_DirectionalLight_set_specular_color_69_comment},
  {"setSpecularColor", &Dtool_DirectionalLight_set_specular_color_69, METH_O, (const char *)Dtool_DirectionalLight_set_specular_color_69_comment},
  {"clear_specular_color", &Dtool_DirectionalLight_clear_specular_color_70, METH_NOARGS, (const char *)Dtool_DirectionalLight_clear_specular_color_70_comment},
  {"clearSpecularColor", &Dtool_DirectionalLight_clear_specular_color_70, METH_NOARGS, (const char *)Dtool_DirectionalLight_clear_specular_color_70_comment},
  {"get_point", &Dtool_DirectionalLight_get_point_77, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_point_77_comment},
  {"getPoint", &Dtool_DirectionalLight_get_point_77, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_point_77_comment},
  {"set_point", &Dtool_DirectionalLight_set_point_78, METH_O, (const char *)Dtool_DirectionalLight_set_point_78_comment},
  {"setPoint", &Dtool_DirectionalLight_set_point_78, METH_O, (const char *)Dtool_DirectionalLight_set_point_78_comment},
  {"get_direction", &Dtool_DirectionalLight_get_direction_83, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_direction_83_comment},
  {"getDirection", &Dtool_DirectionalLight_get_direction_83, METH_NOARGS, (const char *)Dtool_DirectionalLight_get_direction_83_comment},
  {"set_direction", &Dtool_DirectionalLight_set_direction_84, METH_O, (const char *)Dtool_DirectionalLight_set_direction_84_comment},
  {"setDirection", &Dtool_DirectionalLight_set_direction_84, METH_O, (const char *)Dtool_DirectionalLight_set_direction_84_comment},
  {"get_class_type", &Dtool_DirectionalLight_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_DirectionalLight_get_class_type_89_comment},
  {"getClassType", &Dtool_DirectionalLight_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_DirectionalLight_get_class_type_89_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DirectionalLight[] = {
  {(char *)"specular_color", &Dtool_DirectionalLight_specular_color_Getter, &Dtool_DirectionalLight_specular_color_Setter, nullptr, nullptr},
  {(char *)"point", &Dtool_DirectionalLight_point_Getter, &Dtool_DirectionalLight_point_Setter, nullptr, nullptr},
  {(char *)"direction", &Dtool_DirectionalLight_direction_Getter, &Dtool_DirectionalLight_direction_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DirectionalLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DirectionalLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DirectionalLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DirectionalLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DirectionalLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DirectionalLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DirectionalLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DirectionalLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DirectionalLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DirectionalLight,
    &Dtool_SequenceMethods_DirectionalLight,
    &Dtool_MappingMethods_DirectionalLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DirectionalLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light shining from infinitely far away in a particular direction, like\n"
    " * sunlight.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DirectionalLight,
    nullptr, // tp_members
    Dtool_Properties_DirectionalLight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DirectionalLight,
    PyType_GenericAlloc,
    Dtool_new_DirectionalLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DirectionalLight,
  Dtool_UpcastInterface_DirectionalLight,
  Dtool_DowncastInterface_DirectionalLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DirectionalLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightLensNode(nullptr);
    Dtool_DirectionalLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightLensNode);
    Dtool_DirectionalLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DirectionalLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DirectionalLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DirectionalLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DirectionalLight);
  }
}

/**
 * Python method tables for LODNode (LODNode)
 */
static PyMethodDef Dtool_Methods_LODNode[] = {
  {"make_default_lod", &Dtool_LODNode_make_default_lod_93, METH_O | METH_STATIC, (const char *)Dtool_LODNode_make_default_lod_93_comment},
  {"makeDefaultLod", &Dtool_LODNode_make_default_lod_93, METH_O | METH_STATIC, (const char *)Dtool_LODNode_make_default_lod_93_comment},
  {"add_switch", (PyCFunction) &Dtool_LODNode_add_switch_94, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_add_switch_94_comment},
  {"addSwitch", (PyCFunction) &Dtool_LODNode_add_switch_94, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_add_switch_94_comment},
  {"set_switch", (PyCFunction) &Dtool_LODNode_set_switch_95, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_set_switch_95_comment},
  {"setSwitch", (PyCFunction) &Dtool_LODNode_set_switch_95, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_set_switch_95_comment},
  {"clear_switches", &Dtool_LODNode_clear_switches_96, METH_NOARGS, (const char *)Dtool_LODNode_clear_switches_96_comment},
  {"clearSwitches", &Dtool_LODNode_clear_switches_96, METH_NOARGS, (const char *)Dtool_LODNode_clear_switches_96_comment},
  {"get_num_switches", &Dtool_LODNode_get_num_switches_97, METH_NOARGS, (const char *)Dtool_LODNode_get_num_switches_97_comment},
  {"getNumSwitches", &Dtool_LODNode_get_num_switches_97, METH_NOARGS, (const char *)Dtool_LODNode_get_num_switches_97_comment},
  {"get_in", &Dtool_LODNode_get_in_98, METH_O, (const char *)Dtool_LODNode_get_in_98_comment},
  {"getIn", &Dtool_LODNode_get_in_98, METH_O, (const char *)Dtool_LODNode_get_in_98_comment},
  {"get_out", &Dtool_LODNode_get_out_100, METH_O, (const char *)Dtool_LODNode_get_out_100_comment},
  {"getOut", &Dtool_LODNode_get_out_100, METH_O, (const char *)Dtool_LODNode_get_out_100_comment},
  {"get_lowest_switch", &Dtool_LODNode_get_lowest_switch_102, METH_NOARGS, (const char *)Dtool_LODNode_get_lowest_switch_102_comment},
  {"getLowestSwitch", &Dtool_LODNode_get_lowest_switch_102, METH_NOARGS, (const char *)Dtool_LODNode_get_lowest_switch_102_comment},
  {"get_highest_switch", &Dtool_LODNode_get_highest_switch_103, METH_NOARGS, (const char *)Dtool_LODNode_get_highest_switch_103_comment},
  {"getHighestSwitch", &Dtool_LODNode_get_highest_switch_103, METH_NOARGS, (const char *)Dtool_LODNode_get_highest_switch_103_comment},
  {"force_switch", &Dtool_LODNode_force_switch_104, METH_O, (const char *)Dtool_LODNode_force_switch_104_comment},
  {"forceSwitch", &Dtool_LODNode_force_switch_104, METH_O, (const char *)Dtool_LODNode_force_switch_104_comment},
  {"clear_force_switch", &Dtool_LODNode_clear_force_switch_105, METH_NOARGS, (const char *)Dtool_LODNode_clear_force_switch_105_comment},
  {"clearForceSwitch", &Dtool_LODNode_clear_force_switch_105, METH_NOARGS, (const char *)Dtool_LODNode_clear_force_switch_105_comment},
  {"set_lod_scale", &Dtool_LODNode_set_lod_scale_106, METH_O, (const char *)Dtool_LODNode_set_lod_scale_106_comment},
  {"setLodScale", &Dtool_LODNode_set_lod_scale_106, METH_O, (const char *)Dtool_LODNode_set_lod_scale_106_comment},
  {"get_lod_scale", &Dtool_LODNode_get_lod_scale_107, METH_NOARGS, (const char *)Dtool_LODNode_get_lod_scale_107_comment},
  {"getLodScale", &Dtool_LODNode_get_lod_scale_107, METH_NOARGS, (const char *)Dtool_LODNode_get_lod_scale_107_comment},
  {"set_center", &Dtool_LODNode_set_center_108, METH_O, (const char *)Dtool_LODNode_set_center_108_comment},
  {"setCenter", &Dtool_LODNode_set_center_108, METH_O, (const char *)Dtool_LODNode_set_center_108_comment},
  {"get_center", &Dtool_LODNode_get_center_109, METH_NOARGS, (const char *)Dtool_LODNode_get_center_109_comment},
  {"getCenter", &Dtool_LODNode_get_center_109, METH_NOARGS, (const char *)Dtool_LODNode_get_center_109_comment},
  {"show_switch", (PyCFunction) &Dtool_LODNode_show_switch_119, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_show_switch_119_comment},
  {"showSwitch", (PyCFunction) &Dtool_LODNode_show_switch_119, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LODNode_show_switch_119_comment},
  {"hide_switch", &Dtool_LODNode_hide_switch_120, METH_O, (const char *)Dtool_LODNode_hide_switch_120_comment},
  {"hideSwitch", &Dtool_LODNode_hide_switch_120, METH_O, (const char *)Dtool_LODNode_hide_switch_120_comment},
  {"show_all_switches", &Dtool_LODNode_show_all_switches_121, METH_NOARGS, (const char *)Dtool_LODNode_show_all_switches_121_comment},
  {"showAllSwitches", &Dtool_LODNode_show_all_switches_121, METH_NOARGS, (const char *)Dtool_LODNode_show_all_switches_121_comment},
  {"hide_all_switches", &Dtool_LODNode_hide_all_switches_122, METH_NOARGS, (const char *)Dtool_LODNode_hide_all_switches_122_comment},
  {"hideAllSwitches", &Dtool_LODNode_hide_all_switches_122, METH_NOARGS, (const char *)Dtool_LODNode_hide_all_switches_122_comment},
  {"is_any_shown", &Dtool_LODNode_is_any_shown_123, METH_NOARGS, (const char *)Dtool_LODNode_is_any_shown_123_comment},
  {"isAnyShown", &Dtool_LODNode_is_any_shown_123, METH_NOARGS, (const char *)Dtool_LODNode_is_any_shown_123_comment},
  {"verify_child_bounds", &Dtool_LODNode_verify_child_bounds_124, METH_NOARGS, (const char *)Dtool_LODNode_verify_child_bounds_124_comment},
  {"verifyChildBounds", &Dtool_LODNode_verify_child_bounds_124, METH_NOARGS, (const char *)Dtool_LODNode_verify_child_bounds_124_comment},
  {"get_class_type", &Dtool_LODNode_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_LODNode_get_class_type_125_comment},
  {"getClassType", &Dtool_LODNode_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_LODNode_get_class_type_125_comment},
  {"get_ins", (PyCFunction) &MakeSeq_LODNode_get_ins, METH_NOARGS, nullptr},
  { "getIns", (PyCFunction) &MakeSeq_LODNode_get_ins, METH_NOARGS, nullptr},
  {"get_outs", (PyCFunction) &MakeSeq_LODNode_get_outs, METH_NOARGS, nullptr},
  { "getOuts", (PyCFunction) &MakeSeq_LODNode_get_outs, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LODNode[] = {
  {(char *)"ins", &Dtool_LODNode_ins_Getter, nullptr, nullptr, nullptr},
  {(char *)"outs", &Dtool_LODNode_outs_Getter, nullptr, nullptr, nullptr},
  {(char *)"lowest_switch", &Dtool_LODNode_lowest_switch_Getter, nullptr, nullptr, nullptr},
  {(char *)"highest_switch", &Dtool_LODNode_highest_switch_Getter, nullptr, nullptr, nullptr},
  {(char *)"lod_scale", &Dtool_LODNode_lod_scale_Getter, &Dtool_LODNode_lod_scale_Setter, nullptr, nullptr},
  {(char *)"center", &Dtool_LODNode_center_Getter, &Dtool_LODNode_center_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LODNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LODNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LODNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LODNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LODNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LODNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LODNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LODNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LODNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LODNode,
    &Dtool_SequenceMethods_LODNode,
    &Dtool_MappingMethods_LODNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LODNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A Level-of-Detail node.  This selects only one of its children for\n"
    " * rendering, according to the distance from the camera and the table\n"
    " * indicated in the associated LOD object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LODNode,
    nullptr, // tp_members
    Dtool_Properties_LODNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LODNode,
    PyType_GenericAlloc,
    Dtool_new_LODNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LODNode,
  Dtool_UpcastInterface_LODNode,
  Dtool_DowncastInterface_LODNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LODNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_LODNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_LODNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LODNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LODNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LODNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LODNode);
  }
}

/**
 * Python method tables for FadeLODNode (FadeLODNode)
 */
static PyMethodDef Dtool_Methods_FadeLODNode[] = {
  {"set_fade_time", &Dtool_FadeLODNode_set_fade_time_129, METH_O, (const char *)Dtool_FadeLODNode_set_fade_time_129_comment},
  {"setFadeTime", &Dtool_FadeLODNode_set_fade_time_129, METH_O, (const char *)Dtool_FadeLODNode_set_fade_time_129_comment},
  {"get_fade_time", &Dtool_FadeLODNode_get_fade_time_130, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_time_130_comment},
  {"getFadeTime", &Dtool_FadeLODNode_get_fade_time_130, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_time_130_comment},
  {"set_fade_bin", (PyCFunction) &Dtool_FadeLODNode_set_fade_bin_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FadeLODNode_set_fade_bin_132_comment},
  {"setFadeBin", (PyCFunction) &Dtool_FadeLODNode_set_fade_bin_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FadeLODNode_set_fade_bin_132_comment},
  {"get_fade_bin_name", &Dtool_FadeLODNode_get_fade_bin_name_133, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_name_133_comment},
  {"getFadeBinName", &Dtool_FadeLODNode_get_fade_bin_name_133, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_name_133_comment},
  {"get_fade_bin_draw_order", &Dtool_FadeLODNode_get_fade_bin_draw_order_134, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_draw_order_134_comment},
  {"getFadeBinDrawOrder", &Dtool_FadeLODNode_get_fade_bin_draw_order_134, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_bin_draw_order_134_comment},
  {"set_fade_state_override", &Dtool_FadeLODNode_set_fade_state_override_140, METH_O, (const char *)Dtool_FadeLODNode_set_fade_state_override_140_comment},
  {"setFadeStateOverride", &Dtool_FadeLODNode_set_fade_state_override_140, METH_O, (const char *)Dtool_FadeLODNode_set_fade_state_override_140_comment},
  {"get_fade_state_override", &Dtool_FadeLODNode_get_fade_state_override_141, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_state_override_141_comment},
  {"getFadeStateOverride", &Dtool_FadeLODNode_get_fade_state_override_141, METH_NOARGS, (const char *)Dtool_FadeLODNode_get_fade_state_override_141_comment},
  {"get_class_type", &Dtool_FadeLODNode_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_FadeLODNode_get_class_type_143_comment},
  {"getClassType", &Dtool_FadeLODNode_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_FadeLODNode_get_class_type_143_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_FadeLODNode[] = {
  {(char *)"fade_time", &Dtool_FadeLODNode_fade_time_Getter, &Dtool_FadeLODNode_fade_time_Setter, nullptr, nullptr},
  {(char *)"fade_bin_name", &Dtool_FadeLODNode_fade_bin_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"fade_bin_draw_order", &Dtool_FadeLODNode_fade_bin_draw_order_Getter, nullptr, nullptr, nullptr},
  {(char *)"fade_state_override", &Dtool_FadeLODNode_fade_state_override_Getter, &Dtool_FadeLODNode_fade_state_override_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_FadeLODNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FadeLODNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FadeLODNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FadeLODNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FadeLODNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FadeLODNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FadeLODNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FadeLODNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FadeLODNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FadeLODNode,
    &Dtool_SequenceMethods_FadeLODNode,
    &Dtool_MappingMethods_FadeLODNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FadeLODNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A Level-of-Detail node with alpha based switching.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FadeLODNode,
    nullptr, // tp_members
    Dtool_Properties_FadeLODNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FadeLODNode,
    PyType_GenericAlloc,
    Dtool_new_FadeLODNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FadeLODNode,
  Dtool_UpcastInterface_FadeLODNode,
  Dtool_DowncastInterface_FadeLODNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FadeLODNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LODNode(nullptr);
    Dtool_FadeLODNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LODNode);
    Dtool_FadeLODNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FadeLODNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FadeLODNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FadeLODNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FadeLODNode);
  }
}

/**
 * Python method tables for NodeCullCallbackData (NodeCullCallbackData)
 */
static PyMethodDef Dtool_Methods_NodeCullCallbackData[] = {
  {"get_trav", &Dtool_NodeCullCallbackData_get_trav_147, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_trav_147_comment},
  {"getTrav", &Dtool_NodeCullCallbackData_get_trav_147, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_trav_147_comment},
  {"get_data", &Dtool_NodeCullCallbackData_get_data_148, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_data_148_comment},
  {"getData", &Dtool_NodeCullCallbackData_get_data_148, METH_NOARGS, (const char *)Dtool_NodeCullCallbackData_get_data_148_comment},
  {"get_class_type", &Dtool_NodeCullCallbackData_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCullCallbackData_get_class_type_149_comment},
  {"getClassType", &Dtool_NodeCullCallbackData_get_class_type_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCullCallbackData_get_class_type_149_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NodeCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodeCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NodeCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NodeCullCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NodeCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NodeCullCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NodeCullCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NodeCullCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NodeCullCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NodeCullCallbackData,
    &Dtool_SequenceMethods_NodeCullCallbackData,
    &Dtool_MappingMethods_NodeCullCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NodeCullCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This kind of CallbackData is passed to the CallbackObject added to\n"
    " * CallbackNode:set_cull_callback().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NodeCullCallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NodeCullCallbackData,
    PyType_GenericAlloc,
    Dtool_new_NodeCullCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodeCullCallbackData,
  Dtool_UpcastInterface_NodeCullCallbackData,
  Dtool_DowncastInterface_NodeCullCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NodeCullCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != nullptr);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(nullptr);
    Dtool_NodeCullCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CallbackData);
    Dtool_NodeCullCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NodeCullCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NodeCullCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodeCullCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodeCullCallbackData);
  }
}

/**
 * Python method tables for PointLight (PointLight)
 */
static PyMethodDef Dtool_Methods_PointLight[] = {
  {"set_specular_color", &Dtool_PointLight_set_specular_color_152, METH_O, (const char *)Dtool_PointLight_set_specular_color_152_comment},
  {"setSpecularColor", &Dtool_PointLight_set_specular_color_152, METH_O, (const char *)Dtool_PointLight_set_specular_color_152_comment},
  {"clear_specular_color", &Dtool_PointLight_clear_specular_color_153, METH_NOARGS, (const char *)Dtool_PointLight_clear_specular_color_153_comment},
  {"clearSpecularColor", &Dtool_PointLight_clear_specular_color_153, METH_NOARGS, (const char *)Dtool_PointLight_clear_specular_color_153_comment},
  {"set_attenuation", &Dtool_PointLight_set_attenuation_156, METH_O, (const char *)Dtool_PointLight_set_attenuation_156_comment},
  {"setAttenuation", &Dtool_PointLight_set_attenuation_156, METH_O, (const char *)Dtool_PointLight_set_attenuation_156_comment},
  {"get_max_distance", &Dtool_PointLight_get_max_distance_162, METH_NOARGS, (const char *)Dtool_PointLight_get_max_distance_162_comment},
  {"getMaxDistance", &Dtool_PointLight_get_max_distance_162, METH_NOARGS, (const char *)Dtool_PointLight_get_max_distance_162_comment},
  {"set_max_distance", &Dtool_PointLight_set_max_distance_163, METH_O, (const char *)Dtool_PointLight_set_max_distance_163_comment},
  {"setMaxDistance", &Dtool_PointLight_set_max_distance_163, METH_O, (const char *)Dtool_PointLight_set_max_distance_163_comment},
  {"get_point", &Dtool_PointLight_get_point_165, METH_NOARGS, (const char *)Dtool_PointLight_get_point_165_comment},
  {"getPoint", &Dtool_PointLight_get_point_165, METH_NOARGS, (const char *)Dtool_PointLight_get_point_165_comment},
  {"set_point", &Dtool_PointLight_set_point_166, METH_O, (const char *)Dtool_PointLight_set_point_166_comment},
  {"setPoint", &Dtool_PointLight_set_point_166, METH_O, (const char *)Dtool_PointLight_set_point_166_comment},
  {"get_class_type", &Dtool_PointLight_get_class_type_168, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointLight_get_class_type_168_comment},
  {"getClassType", &Dtool_PointLight_get_class_type_168, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointLight_get_class_type_168_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PointLight[] = {
  {(char *)"specular_color", &Dtool_PointLight_specular_color_Getter, &Dtool_PointLight_specular_color_Setter, nullptr, nullptr},
  {(char *)"attenuation", &Dtool_PointLight_attenuation_Getter, &Dtool_PointLight_attenuation_Setter, nullptr, nullptr},
  {(char *)"max_distance", &Dtool_PointLight_max_distance_Getter, &Dtool_PointLight_max_distance_Setter, nullptr, nullptr},
  {(char *)"point", &Dtool_PointLight_point_Getter, &Dtool_PointLight_point_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PointLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointLight,
    &Dtool_SequenceMethods_PointLight,
    &Dtool_MappingMethods_PointLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light originating from a single point in space, and shining in all\n"
    " * directions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointLight,
    nullptr, // tp_members
    Dtool_Properties_PointLight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointLight,
    PyType_GenericAlloc,
    Dtool_new_PointLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointLight,
  Dtool_UpcastInterface_PointLight,
  Dtool_DowncastInterface_PointLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightLensNode(nullptr);
    Dtool_PointLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightLensNode);
    Dtool_PointLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointLight);
  }
}

/**
 * Python method tables for RectangleLight (RectangleLight)
 */
static PyMethodDef Dtool_Methods_RectangleLight[] = {
  {"get_max_distance", &Dtool_RectangleLight_get_max_distance_172, METH_NOARGS, (const char *)Dtool_RectangleLight_get_max_distance_172_comment},
  {"getMaxDistance", &Dtool_RectangleLight_get_max_distance_172, METH_NOARGS, (const char *)Dtool_RectangleLight_get_max_distance_172_comment},
  {"set_max_distance", &Dtool_RectangleLight_set_max_distance_173, METH_O, (const char *)Dtool_RectangleLight_set_max_distance_173_comment},
  {"setMaxDistance", &Dtool_RectangleLight_set_max_distance_173, METH_O, (const char *)Dtool_RectangleLight_set_max_distance_173_comment},
  {"get_class_type", &Dtool_RectangleLight_get_class_type_175, METH_NOARGS | METH_STATIC, (const char *)Dtool_RectangleLight_get_class_type_175_comment},
  {"getClassType", &Dtool_RectangleLight_get_class_type_175, METH_NOARGS | METH_STATIC, (const char *)Dtool_RectangleLight_get_class_type_175_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_RectangleLight[] = {
  {(char *)"max_distance", &Dtool_RectangleLight_max_distance_Getter, &Dtool_RectangleLight_max_distance_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RectangleLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RectangleLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RectangleLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RectangleLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RectangleLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RectangleLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RectangleLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RectangleLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RectangleLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RectangleLight,
    &Dtool_SequenceMethods_RectangleLight,
    &Dtool_MappingMethods_RectangleLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RectangleLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a type of area light that is an axis aligned rectangle, pointing\n"
    " * along the Y axis in the positive direction.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RectangleLight,
    nullptr, // tp_members
    Dtool_Properties_RectangleLight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RectangleLight,
    PyType_GenericAlloc,
    Dtool_new_RectangleLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RectangleLight,
  Dtool_UpcastInterface_RectangleLight,
  Dtool_DowncastInterface_RectangleLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RectangleLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightLensNode(nullptr);
    Dtool_RectangleLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightLensNode);
    Dtool_RectangleLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RectangleLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RectangleLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RectangleLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RectangleLight);
  }
}

/**
 * Python method tables for SelectiveChildNode (SelectiveChildNode)
 */
static PyMethodDef Dtool_Methods_SelectiveChildNode[] = {
  {"get_class_type", &Dtool_SelectiveChildNode_get_class_type_179, METH_NOARGS | METH_STATIC, (const char *)Dtool_SelectiveChildNode_get_class_type_179_comment},
  {"getClassType", &Dtool_SelectiveChildNode_get_class_type_179, METH_NOARGS | METH_STATIC, (const char *)Dtool_SelectiveChildNode_get_class_type_179_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SelectiveChildNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SelectiveChildNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SelectiveChildNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SelectiveChildNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SelectiveChildNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SelectiveChildNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SelectiveChildNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SelectiveChildNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SelectiveChildNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SelectiveChildNode,
    &Dtool_SequenceMethods_SelectiveChildNode,
    &Dtool_MappingMethods_SelectiveChildNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SelectiveChildNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for nodes like LODNode and SequenceNode that select only one\n"
    " * visible child at a time.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SelectiveChildNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SelectiveChildNode,
    PyType_GenericAlloc,
    Dtool_new_SelectiveChildNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SelectiveChildNode,
  Dtool_UpcastInterface_SelectiveChildNode,
  Dtool_DowncastInterface_SelectiveChildNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SelectiveChildNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_SelectiveChildNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_SelectiveChildNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SelectiveChildNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SelectiveChildNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SelectiveChildNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SelectiveChildNode);
  }
}

/**
 * Python method tables for SequenceNode (SequenceNode)
 */
static PyMethodDef Dtool_Methods_SequenceNode[] = {
  {"get_num_frames", &Dtool_SequenceNode_get_num_frames_188, METH_NOARGS, (const char *)Dtool_SequenceNode_get_num_frames_188_comment},
  {"getNumFrames", &Dtool_SequenceNode_get_num_frames_188, METH_NOARGS, (const char *)Dtool_SequenceNode_get_num_frames_188_comment},
  {"set_frame_rate", &Dtool_SequenceNode_set_frame_rate_189, METH_O, (const char *)Dtool_SequenceNode_set_frame_rate_189_comment},
  {"setFrameRate", &Dtool_SequenceNode_set_frame_rate_189, METH_O, (const char *)Dtool_SequenceNode_set_frame_rate_189_comment},
  {"get_class_type", &Dtool_SequenceNode_get_class_type_193, METH_NOARGS | METH_STATIC, (const char *)Dtool_SequenceNode_get_class_type_193_comment},
  {"getClassType", &Dtool_SequenceNode_get_class_type_193, METH_NOARGS | METH_STATIC, (const char *)Dtool_SequenceNode_get_class_type_193_comment},
  {"upcast_to_SelectiveChildNode", &Dtool_SequenceNode_upcast_to_SelectiveChildNode_182, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_SelectiveChildNode_182_comment},
  {"upcastToSelectiveChildNode", &Dtool_SequenceNode_upcast_to_SelectiveChildNode_182, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_SelectiveChildNode_182_comment},
  {"upcast_to_AnimInterface", &Dtool_SequenceNode_upcast_to_AnimInterface_185, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_AnimInterface_185_comment},
  {"upcastToAnimInterface", &Dtool_SequenceNode_upcast_to_AnimInterface_185, METH_NOARGS, (const char *)Dtool_SequenceNode_upcast_to_AnimInterface_185_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_SequenceNode[] = {
  {(char *)"frame_rate", &Dtool_SequenceNode_frame_rate_Getter, &Dtool_SequenceNode_frame_rate_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_SequenceNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SequenceNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SequenceNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SequenceNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SequenceNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SequenceNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SequenceNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SequenceNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SequenceNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SequenceNode,
    &Dtool_SequenceMethods_SequenceNode,
    &Dtool_MappingMethods_SequenceNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SequenceNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that automatically cycles through rendering each one of its children\n"
    " * according to its frame rate.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SequenceNode,
    nullptr, // tp_members
    Dtool_Properties_SequenceNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SequenceNode,
    PyType_GenericAlloc,
    Dtool_new_SequenceNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SequenceNode,
  Dtool_UpcastInterface_SequenceNode,
  Dtool_DowncastInterface_SequenceNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SequenceNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SelectiveChildNode(nullptr);
    assert(Dtool_Ptr_AnimInterface != nullptr);
    assert(Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit(nullptr);
    Dtool_SequenceNode._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_SelectiveChildNode, (PyTypeObject *)Dtool_Ptr_AnimInterface);
    Dtool_SequenceNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SequenceNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SequenceNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SequenceNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SequenceNode);
  }
}

/**
 * Python method tables for ShaderGenerator (ShaderGenerator)
 */
static PyMethodDef Dtool_Methods_ShaderGenerator[] = {
  {"synthesize_shader", (PyCFunction) &Dtool_ShaderGenerator_synthesize_shader_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderGenerator_synthesize_shader_198_comment},
  {"synthesizeShader", (PyCFunction) &Dtool_ShaderGenerator_synthesize_shader_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderGenerator_synthesize_shader_198_comment},
  {"rehash_generated_shaders", &Dtool_ShaderGenerator_rehash_generated_shaders_199, METH_NOARGS, (const char *)Dtool_ShaderGenerator_rehash_generated_shaders_199_comment},
  {"rehashGeneratedShaders", &Dtool_ShaderGenerator_rehash_generated_shaders_199, METH_NOARGS, (const char *)Dtool_ShaderGenerator_rehash_generated_shaders_199_comment},
  {"clear_generated_shaders", &Dtool_ShaderGenerator_clear_generated_shaders_200, METH_NOARGS, (const char *)Dtool_ShaderGenerator_clear_generated_shaders_200_comment},
  {"clearGeneratedShaders", &Dtool_ShaderGenerator_clear_generated_shaders_200, METH_NOARGS, (const char *)Dtool_ShaderGenerator_clear_generated_shaders_200_comment},
  {"get_class_type", &Dtool_ShaderGenerator_get_class_type_201, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderGenerator_get_class_type_201_comment},
  {"getClassType", &Dtool_ShaderGenerator_get_class_type_201, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderGenerator_get_class_type_201_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShaderGenerator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShaderGenerator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ShaderGenerator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderGenerator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShaderGenerator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderGenerator,
    &Dtool_SequenceMethods_ShaderGenerator,
    &Dtool_MappingMethods_ShaderGenerator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShaderGenerator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The ShaderGenerator is a device that effectively replaces the classic fixed\n"
    " * function pipeline with a 'next-gen' fixed function pipeline.  The next-gen\n"
    " * fixed function pipeline supports features like normal mapping, gloss\n"
    " * mapping, cartoon lighting, and so forth.  It works by automatically\n"
    " * generating a shader from a given RenderState.\n"
    " *\n"
    " * Currently, there is one ShaderGenerator object per GraphicsStateGuardian.\n"
    " * It is our intent that in time, people will write classes that derive from\n"
    " * ShaderGenerator but which yield slightly different results.\n"
    " *\n"
    " * The ShaderGenerator owes its existence to the 'Bamboo Team' at Carnegie\n"
    " * Mellon's Entertainment Technology Center.  This is a group of students who,\n"
    " * as a semester project, decided that next-gen graphics should be accessible\n"
    " * to everyone, even if they don't know shader programming.  The group\n"
    " * consisted of:\n"
    " *\n"
    " * Aaron Lo, Programmer Heegun Lee, Programmer Erin Fernandez, Artist/Tester\n"
    " * Joe Grubb, Artist/Tester Ivan Ortega, Technical Artist/Tester\n"
    " *\n"
    " * Thanks to them!\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderGenerator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderGenerator,
    PyType_GenericAlloc,
    Dtool_new_ShaderGenerator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderGenerator,
  Dtool_UpcastInterface_ShaderGenerator,
  Dtool_DowncastInterface_ShaderGenerator,
  (CoerceFunction)Dtool_ConstCoerce_ShaderGenerator,
  (CoerceFunction)Dtool_Coerce_ShaderGenerator,
};

static void Dtool_PyModuleClassInit_ShaderGenerator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ShaderGenerator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_ShaderGenerator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShaderGenerator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderGenerator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderGenerator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderGenerator);
  }
}

/**
 * Python method tables for SphereLight (SphereLight)
 */
static PyMethodDef Dtool_Methods_SphereLight[] = {
  {"get_radius", &Dtool_SphereLight_get_radius_204, METH_NOARGS, (const char *)Dtool_SphereLight_get_radius_204_comment},
  {"getRadius", &Dtool_SphereLight_get_radius_204, METH_NOARGS, (const char *)Dtool_SphereLight_get_radius_204_comment},
  {"set_radius", &Dtool_SphereLight_set_radius_205, METH_O, (const char *)Dtool_SphereLight_set_radius_205_comment},
  {"setRadius", &Dtool_SphereLight_set_radius_205, METH_O, (const char *)Dtool_SphereLight_set_radius_205_comment},
  {"get_class_type", &Dtool_SphereLight_get_class_type_207, METH_NOARGS | METH_STATIC, (const char *)Dtool_SphereLight_get_class_type_207_comment},
  {"getClassType", &Dtool_SphereLight_get_class_type_207, METH_NOARGS | METH_STATIC, (const char *)Dtool_SphereLight_get_class_type_207_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_SphereLight[] = {
  {(char *)"radius", &Dtool_SphereLight_radius_Getter, &Dtool_SphereLight_radius_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_SphereLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SphereLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SphereLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SphereLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SphereLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SphereLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SphereLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SphereLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SphereLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SphereLight,
    &Dtool_SequenceMethods_SphereLight,
    &Dtool_MappingMethods_SphereLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SphereLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A sphere light is like a point light, except that it represents a sphere\n"
    " * with a radius, rather than being an infinitely thin point in space.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SphereLight,
    nullptr, // tp_members
    Dtool_Properties_SphereLight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SphereLight,
    PyType_GenericAlloc,
    Dtool_new_SphereLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SphereLight,
  Dtool_UpcastInterface_SphereLight,
  Dtool_DowncastInterface_SphereLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SphereLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointLight(nullptr);
    Dtool_SphereLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointLight);
    Dtool_SphereLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SphereLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SphereLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SphereLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SphereLight);
  }
}

/**
 * Python method tables for Spotlight (Spotlight)
 */
static PyMethodDef Dtool_Methods_Spotlight[] = {
  {"set_exponent", &Dtool_Spotlight_set_exponent_211, METH_O, (const char *)Dtool_Spotlight_set_exponent_211_comment},
  {"setExponent", &Dtool_Spotlight_set_exponent_211, METH_O, (const char *)Dtool_Spotlight_set_exponent_211_comment},
  {"set_specular_color", &Dtool_Spotlight_set_specular_color_214, METH_O, (const char *)Dtool_Spotlight_set_specular_color_214_comment},
  {"setSpecularColor", &Dtool_Spotlight_set_specular_color_214, METH_O, (const char *)Dtool_Spotlight_set_specular_color_214_comment},
  {"clear_specular_color", &Dtool_Spotlight_clear_specular_color_215, METH_NOARGS, (const char *)Dtool_Spotlight_clear_specular_color_215_comment},
  {"clearSpecularColor", &Dtool_Spotlight_clear_specular_color_215, METH_NOARGS, (const char *)Dtool_Spotlight_clear_specular_color_215_comment},
  {"set_attenuation", &Dtool_Spotlight_set_attenuation_218, METH_O, (const char *)Dtool_Spotlight_set_attenuation_218_comment},
  {"setAttenuation", &Dtool_Spotlight_set_attenuation_218, METH_O, (const char *)Dtool_Spotlight_set_attenuation_218_comment},
  {"get_max_distance", &Dtool_Spotlight_get_max_distance_221, METH_NOARGS, (const char *)Dtool_Spotlight_get_max_distance_221_comment},
  {"getMaxDistance", &Dtool_Spotlight_get_max_distance_221, METH_NOARGS, (const char *)Dtool_Spotlight_get_max_distance_221_comment},
  {"set_max_distance", &Dtool_Spotlight_set_max_distance_222, METH_O, (const char *)Dtool_Spotlight_set_max_distance_222_comment},
  {"setMaxDistance", &Dtool_Spotlight_set_max_distance_222, METH_O, (const char *)Dtool_Spotlight_set_max_distance_222_comment},
  {"make_spot", (PyCFunction) &Dtool_Spotlight_make_spot_224, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Spotlight_make_spot_224_comment},
  {"makeSpot", (PyCFunction) &Dtool_Spotlight_make_spot_224, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Spotlight_make_spot_224_comment},
  {"get_class_type", &Dtool_Spotlight_get_class_type_225, METH_NOARGS | METH_STATIC, (const char *)Dtool_Spotlight_get_class_type_225_comment},
  {"getClassType", &Dtool_Spotlight_get_class_type_225, METH_NOARGS | METH_STATIC, (const char *)Dtool_Spotlight_get_class_type_225_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_Spotlight[] = {
  {(char *)"exponent", &Dtool_Spotlight_exponent_Getter, &Dtool_Spotlight_exponent_Setter, nullptr, nullptr},
  {(char *)"specular_color", &Dtool_Spotlight_specular_color_Getter, &Dtool_Spotlight_specular_color_Setter, nullptr, nullptr},
  {(char *)"attenuation", &Dtool_Spotlight_attenuation_Getter, &Dtool_Spotlight_attenuation_Setter, nullptr, nullptr},
  {(char *)"max_distance", &Dtool_Spotlight_max_distance_Getter, &Dtool_Spotlight_max_distance_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Spotlight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Spotlight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Spotlight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Spotlight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Spotlight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Spotlight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Spotlight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Spotlight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Spotlight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Spotlight,
    &Dtool_SequenceMethods_Spotlight,
    &Dtool_MappingMethods_Spotlight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Spotlight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A light originating from a single point in space, and shining in a\n"
    " * particular direction, with a cone-shaped falloff.\n"
    " *\n"
    " * The Spotlight frustum is defined using a Lens, so it can have any of the\n"
    " * properties that a camera lens can have.\n"
    " *\n"
    " * Note that the class is named Spotlight instead of SpotLight, because\n"
    " * \"spotlight\" is a single English word, instead of two words.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Spotlight,
    nullptr, // tp_members
    Dtool_Properties_Spotlight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Spotlight,
    PyType_GenericAlloc,
    Dtool_new_Spotlight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Spotlight,
  Dtool_UpcastInterface_Spotlight,
  Dtool_DowncastInterface_Spotlight,
  (CoerceFunction)Dtool_ConstCoerce_Spotlight,
  (CoerceFunction)Dtool_Coerce_Spotlight,
};

static void Dtool_PyModuleClassInit_Spotlight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightLensNode(nullptr);
    Dtool_Spotlight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightLensNode);
    Dtool_Spotlight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Spotlight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Spotlight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Spotlight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Spotlight);
  }
}

/**
 * Python method tables for SwitchNode (SwitchNode)
 */
static PyMethodDef Dtool_Methods_SwitchNode[] = {
  {"set_visible_child", &Dtool_SwitchNode_set_visible_child_229, METH_O, (const char *)Dtool_SwitchNode_set_visible_child_229_comment},
  {"setVisibleChild", &Dtool_SwitchNode_set_visible_child_229, METH_O, (const char *)Dtool_SwitchNode_set_visible_child_229_comment},
  {"get_visible_child", &Dtool_SwitchNode_get_visible_child_230, METH_NOARGS, (const char *)Dtool_SwitchNode_get_visible_child_230_comment},
  {"getVisibleChild", &Dtool_SwitchNode_get_visible_child_230, METH_NOARGS, (const char *)Dtool_SwitchNode_get_visible_child_230_comment},
  {"get_class_type", &Dtool_SwitchNode_get_class_type_232, METH_NOARGS | METH_STATIC, (const char *)Dtool_SwitchNode_get_class_type_232_comment},
  {"getClassType", &Dtool_SwitchNode_get_class_type_232, METH_NOARGS | METH_STATIC, (const char *)Dtool_SwitchNode_get_class_type_232_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_SwitchNode[] = {
  {(char *)"visible_child", &Dtool_SwitchNode_visible_child_Getter, &Dtool_SwitchNode_visible_child_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_SwitchNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SwitchNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SwitchNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SwitchNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SwitchNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SwitchNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SwitchNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SwitchNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SwitchNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SwitchNode,
    &Dtool_SequenceMethods_SwitchNode,
    &Dtool_MappingMethods_SwitchNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SwitchNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node that renders only one of its children, according to the user's\n"
    " * indication.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SwitchNode,
    nullptr, // tp_members
    Dtool_Properties_SwitchNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SwitchNode,
    PyType_GenericAlloc,
    Dtool_new_SwitchNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SwitchNode,
  Dtool_UpcastInterface_SwitchNode,
  Dtool_DowncastInterface_SwitchNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SwitchNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_SelectiveChildNode(nullptr);
    Dtool_SwitchNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_SelectiveChildNode);
    Dtool_SwitchNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SwitchNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SwitchNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SwitchNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SwitchNode);
  }
}

/**
 * Python method tables for UvScrollNode (UvScrollNode)
 */
static PyMethodDef Dtool_Methods_UvScrollNode[] = {
  {"set_u_speed", &Dtool_UvScrollNode_set_u_speed_236, METH_O, (const char *)Dtool_UvScrollNode_set_u_speed_236_comment},
  {"setUSpeed", &Dtool_UvScrollNode_set_u_speed_236, METH_O, (const char *)Dtool_UvScrollNode_set_u_speed_236_comment},
  {"set_v_speed", &Dtool_UvScrollNode_set_v_speed_237, METH_O, (const char *)Dtool_UvScrollNode_set_v_speed_237_comment},
  {"setVSpeed", &Dtool_UvScrollNode_set_v_speed_237, METH_O, (const char *)Dtool_UvScrollNode_set_v_speed_237_comment},
  {"set_w_speed", &Dtool_UvScrollNode_set_w_speed_238, METH_O, (const char *)Dtool_UvScrollNode_set_w_speed_238_comment},
  {"setWSpeed", &Dtool_UvScrollNode_set_w_speed_238, METH_O, (const char *)Dtool_UvScrollNode_set_w_speed_238_comment},
  {"set_r_speed", &Dtool_UvScrollNode_set_r_speed_239, METH_O, (const char *)Dtool_UvScrollNode_set_r_speed_239_comment},
  {"setRSpeed", &Dtool_UvScrollNode_set_r_speed_239, METH_O, (const char *)Dtool_UvScrollNode_set_r_speed_239_comment},
  {"get_u_speed", &Dtool_UvScrollNode_get_u_speed_240, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_u_speed_240_comment},
  {"getUSpeed", &Dtool_UvScrollNode_get_u_speed_240, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_u_speed_240_comment},
  {"get_v_speed", &Dtool_UvScrollNode_get_v_speed_241, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_v_speed_241_comment},
  {"getVSpeed", &Dtool_UvScrollNode_get_v_speed_241, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_v_speed_241_comment},
  {"get_w_speed", &Dtool_UvScrollNode_get_w_speed_242, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_w_speed_242_comment},
  {"getWSpeed", &Dtool_UvScrollNode_get_w_speed_242, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_w_speed_242_comment},
  {"get_r_speed", &Dtool_UvScrollNode_get_r_speed_243, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_r_speed_243_comment},
  {"getRSpeed", &Dtool_UvScrollNode_get_r_speed_243, METH_NOARGS, (const char *)Dtool_UvScrollNode_get_r_speed_243_comment},
  {"get_class_type", &Dtool_UvScrollNode_get_class_type_248, METH_NOARGS | METH_STATIC, (const char *)Dtool_UvScrollNode_get_class_type_248_comment},
  {"getClassType", &Dtool_UvScrollNode_get_class_type_248, METH_NOARGS | METH_STATIC, (const char *)Dtool_UvScrollNode_get_class_type_248_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_UvScrollNode[] = {
  {(char *)"u_speed", &Dtool_UvScrollNode_u_speed_Getter, &Dtool_UvScrollNode_u_speed_Setter, nullptr, nullptr},
  {(char *)"v_speed", &Dtool_UvScrollNode_v_speed_Getter, &Dtool_UvScrollNode_v_speed_Setter, nullptr, nullptr},
  {(char *)"w_speed", &Dtool_UvScrollNode_w_speed_Getter, &Dtool_UvScrollNode_w_speed_Setter, nullptr, nullptr},
  {(char *)"r_speed", &Dtool_UvScrollNode_r_speed_Getter, &Dtool_UvScrollNode_r_speed_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_UvScrollNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UvScrollNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UvScrollNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UvScrollNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UvScrollNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UvScrollNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UvScrollNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UvScrollNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UvScrollNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UvScrollNode,
    &Dtool_SequenceMethods_UvScrollNode,
    &Dtool_MappingMethods_UvScrollNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UvScrollNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This node is placed at key points within the scene graph to animate uvs.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UvScrollNode,
    nullptr, // tp_members
    Dtool_Properties_UvScrollNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UvScrollNode,
    PyType_GenericAlloc,
    Dtool_new_UvScrollNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UvScrollNode,
  Dtool_UpcastInterface_UvScrollNode,
  Dtool_DowncastInterface_UvScrollNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UvScrollNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_UvScrollNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_UvScrollNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UvScrollNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UvScrollNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UvScrollNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UvScrollNode);
  }
}

/**
 * Python method tables for SceneGraphAnalyzer (SceneGraphAnalyzer)
 */
static PyMethodDef Dtool_Methods_SceneGraphAnalyzer[] = {
  {"set_lod_mode", &Dtool_SceneGraphAnalyzer_set_lod_mode_254, METH_O, (const char *)Dtool_SceneGraphAnalyzer_set_lod_mode_254_comment},
  {"setLodMode", &Dtool_SceneGraphAnalyzer_set_lod_mode_254, METH_O, (const char *)Dtool_SceneGraphAnalyzer_set_lod_mode_254_comment},
  {"get_lod_mode", &Dtool_SceneGraphAnalyzer_get_lod_mode_255, METH_O, (const char *)Dtool_SceneGraphAnalyzer_get_lod_mode_255_comment},
  {"getLodMode", &Dtool_SceneGraphAnalyzer_get_lod_mode_255, METH_O, (const char *)Dtool_SceneGraphAnalyzer_get_lod_mode_255_comment},
  {"clear", &Dtool_SceneGraphAnalyzer_clear_256, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_clear_256_comment},
  {"add_node", &Dtool_SceneGraphAnalyzer_add_node_257, METH_O, (const char *)Dtool_SceneGraphAnalyzer_add_node_257_comment},
  {"addNode", &Dtool_SceneGraphAnalyzer_add_node_257, METH_O, (const char *)Dtool_SceneGraphAnalyzer_add_node_257_comment},
  {"write", (PyCFunction) &Dtool_SceneGraphAnalyzer_write_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SceneGraphAnalyzer_write_258_comment},
  {"get_num_nodes", &Dtool_SceneGraphAnalyzer_get_num_nodes_259, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_259_comment},
  {"getNumNodes", &Dtool_SceneGraphAnalyzer_get_num_nodes_259, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_259_comment},
  {"get_num_instances", &Dtool_SceneGraphAnalyzer_get_num_instances_260, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_instances_260_comment},
  {"getNumInstances", &Dtool_SceneGraphAnalyzer_get_num_instances_260, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_instances_260_comment},
  {"get_num_transforms", &Dtool_SceneGraphAnalyzer_get_num_transforms_261, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_transforms_261_comment},
  {"getNumTransforms", &Dtool_SceneGraphAnalyzer_get_num_transforms_261, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_transforms_261_comment},
  {"get_num_nodes_with_attribs", &Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_262, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_262_comment},
  {"getNumNodesWithAttribs", &Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_262, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_262_comment},
  {"get_num_lod_nodes", &Dtool_SceneGraphAnalyzer_get_num_lod_nodes_263, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lod_nodes_263_comment},
  {"getNumLodNodes", &Dtool_SceneGraphAnalyzer_get_num_lod_nodes_263, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lod_nodes_263_comment},
  {"get_num_geom_nodes", &Dtool_SceneGraphAnalyzer_get_num_geom_nodes_264, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_nodes_264_comment},
  {"getNumGeomNodes", &Dtool_SceneGraphAnalyzer_get_num_geom_nodes_264, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_nodes_264_comment},
  {"get_num_geoms", &Dtool_SceneGraphAnalyzer_get_num_geoms_265, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geoms_265_comment},
  {"getNumGeoms", &Dtool_SceneGraphAnalyzer_get_num_geoms_265, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geoms_265_comment},
  {"get_num_geom_vertex_datas", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_266, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_266_comment},
  {"getNumGeomVertexDatas", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_266, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_266_comment},
  {"get_num_geom_vertex_formats", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_267, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_267_comment},
  {"getNumGeomVertexFormats", &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_267, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_267_comment},
  {"get_vertex_data_size", &Dtool_SceneGraphAnalyzer_get_vertex_data_size_268, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_vertex_data_size_268_comment},
  {"getVertexDataSize", &Dtool_SceneGraphAnalyzer_get_vertex_data_size_268, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_vertex_data_size_268_comment},
  {"get_num_vertices", &Dtool_SceneGraphAnalyzer_get_num_vertices_269, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_269_comment},
  {"getNumVertices", &Dtool_SceneGraphAnalyzer_get_num_vertices_269, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_269_comment},
  {"get_num_normals", &Dtool_SceneGraphAnalyzer_get_num_normals_270, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_normals_270_comment},
  {"getNumNormals", &Dtool_SceneGraphAnalyzer_get_num_normals_270, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_normals_270_comment},
  {"get_num_colors", &Dtool_SceneGraphAnalyzer_get_num_colors_271, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_colors_271_comment},
  {"getNumColors", &Dtool_SceneGraphAnalyzer_get_num_colors_271, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_colors_271_comment},
  {"get_num_texcoords", &Dtool_SceneGraphAnalyzer_get_num_texcoords_272, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_texcoords_272_comment},
  {"getNumTexcoords", &Dtool_SceneGraphAnalyzer_get_num_texcoords_272, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_texcoords_272_comment},
  {"get_num_tris", &Dtool_SceneGraphAnalyzer_get_num_tris_273, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tris_273_comment},
  {"getNumTris", &Dtool_SceneGraphAnalyzer_get_num_tris_273, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tris_273_comment},
  {"get_num_lines", &Dtool_SceneGraphAnalyzer_get_num_lines_274, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lines_274_comment},
  {"getNumLines", &Dtool_SceneGraphAnalyzer_get_num_lines_274, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_lines_274_comment},
  {"get_num_points", &Dtool_SceneGraphAnalyzer_get_num_points_275, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_points_275_comment},
  {"getNumPoints", &Dtool_SceneGraphAnalyzer_get_num_points_275, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_points_275_comment},
  {"get_num_patches", &Dtool_SceneGraphAnalyzer_get_num_patches_276, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_patches_276_comment},
  {"getNumPatches", &Dtool_SceneGraphAnalyzer_get_num_patches_276, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_patches_276_comment},
  {"get_num_individual_tris", &Dtool_SceneGraphAnalyzer_get_num_individual_tris_277, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_individual_tris_277_comment},
  {"getNumIndividualTris", &Dtool_SceneGraphAnalyzer_get_num_individual_tris_277, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_individual_tris_277_comment},
  {"get_num_tristrips", &Dtool_SceneGraphAnalyzer_get_num_tristrips_278, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tristrips_278_comment},
  {"getNumTristrips", &Dtool_SceneGraphAnalyzer_get_num_tristrips_278, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_tristrips_278_comment},
  {"get_num_triangles_in_strips", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_279, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_279_comment},
  {"getNumTrianglesInStrips", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_279, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_279_comment},
  {"get_num_trifans", &Dtool_SceneGraphAnalyzer_get_num_trifans_280, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_trifans_280_comment},
  {"getNumTrifans", &Dtool_SceneGraphAnalyzer_get_num_trifans_280, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_trifans_280_comment},
  {"get_num_triangles_in_fans", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_281, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_281_comment},
  {"getNumTrianglesInFans", &Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_281, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_281_comment},
  {"get_num_vertices_in_patches", &Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_282, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_282_comment},
  {"getNumVerticesInPatches", &Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_282, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_vertices_in_patches_282_comment},
  {"get_texture_bytes", &Dtool_SceneGraphAnalyzer_get_texture_bytes_283, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_texture_bytes_283_comment},
  {"getTextureBytes", &Dtool_SceneGraphAnalyzer_get_texture_bytes_283, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_texture_bytes_283_comment},
  {"get_num_long_normals", &Dtool_SceneGraphAnalyzer_get_num_long_normals_284, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_long_normals_284_comment},
  {"getNumLongNormals", &Dtool_SceneGraphAnalyzer_get_num_long_normals_284, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_long_normals_284_comment},
  {"get_num_short_normals", &Dtool_SceneGraphAnalyzer_get_num_short_normals_285, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_short_normals_285_comment},
  {"getNumShortNormals", &Dtool_SceneGraphAnalyzer_get_num_short_normals_285, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_num_short_normals_285_comment},
  {"get_total_normal_length", &Dtool_SceneGraphAnalyzer_get_total_normal_length_286, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_total_normal_length_286_comment},
  {"getTotalNormalLength", &Dtool_SceneGraphAnalyzer_get_total_normal_length_286, METH_NOARGS, (const char *)Dtool_SceneGraphAnalyzer_get_total_normal_length_286_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     SceneGraphAnalyzer
//////////////////
static PyObject *Dtool_Str_SceneGraphAnalyzer(PyObject *self) {
  SceneGraphAnalyzer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SceneGraphAnalyzer, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SceneGraphAnalyzer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_SceneGraphAnalyzer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SceneGraphAnalyzer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SceneGraphAnalyzer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SceneGraphAnalyzer,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_SceneGraphAnalyzer,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A handy class that can scrub over a scene graph and collect interesting\n"
    " * statistics on it.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SceneGraphAnalyzer,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SceneGraphAnalyzer,
    PyType_GenericAlloc,
    Dtool_new_SceneGraphAnalyzer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SceneGraphAnalyzer,
  Dtool_UpcastInterface_SceneGraphAnalyzer,
  Dtool_DowncastInterface_SceneGraphAnalyzer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SceneGraphAnalyzer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SceneGraphAnalyzer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_SceneGraphAnalyzer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum SceneGraphAnalyzer::LodMode;
    PyDict_SetItemString(dict, "LM_lowest", Dtool_WrapValue(SceneGraphAnalyzer::LM_lowest));
    PyDict_SetItemString(dict, "LMLowest", Dtool_WrapValue(SceneGraphAnalyzer::LM_lowest));
    PyDict_SetItemString(dict, "LM_highest", Dtool_WrapValue(SceneGraphAnalyzer::LM_highest));
    PyDict_SetItemString(dict, "LMHighest", Dtool_WrapValue(SceneGraphAnalyzer::LM_highest));
    PyDict_SetItemString(dict, "LM_all", Dtool_WrapValue(SceneGraphAnalyzer::LM_all));
    PyDict_SetItemString(dict, "LMAll", Dtool_WrapValue(SceneGraphAnalyzer::LM_all));
    PyDict_SetItemString(dict, "LM_none", Dtool_WrapValue(SceneGraphAnalyzer::LM_none));
    PyDict_SetItemString(dict, "LMNone", Dtool_WrapValue(SceneGraphAnalyzer::LM_none));
    if (PyType_Ready((PyTypeObject *)&Dtool_SceneGraphAnalyzer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SceneGraphAnalyzer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SceneGraphAnalyzer);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pgraphnodes_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    LightNode::init_type();
    TypeHandle handle = LightNode::get_class_type();
    Dtool_LightNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LightNode);
  }
  {
    AmbientLight::init_type();
    TypeHandle handle = AmbientLight::get_class_type();
    Dtool_AmbientLight._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AmbientLight);
  }
  {
    CallbackNode::init_type();
    TypeHandle handle = CallbackNode::get_class_type();
    Dtool_CallbackNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackNode);
  }
  {
    ComputeNode::init_type();
    TypeHandle handle = ComputeNode::get_class_type();
    Dtool_ComputeNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ComputeNode);
  }
  {
    LightLensNode::init_type();
    TypeHandle handle = LightLensNode::get_class_type();
    Dtool_LightLensNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LightLensNode);
  }
  {
    DirectionalLight::init_type();
    TypeHandle handle = DirectionalLight::get_class_type();
    Dtool_DirectionalLight._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DirectionalLight);
  }
  {
    LODNode::init_type();
    TypeHandle handle = LODNode::get_class_type();
    Dtool_LODNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LODNode);
  }
  {
    FadeLODNode::init_type();
    TypeHandle handle = FadeLODNode::get_class_type();
    Dtool_FadeLODNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FadeLODNode);
  }
  {
    NodeCullCallbackData::init_type();
    TypeHandle handle = NodeCullCallbackData::get_class_type();
    Dtool_NodeCullCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NodeCullCallbackData);
  }
  {
    PointLight::init_type();
    TypeHandle handle = PointLight::get_class_type();
    Dtool_PointLight._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PointLight);
  }
  {
    RectangleLight::init_type();
    TypeHandle handle = RectangleLight::get_class_type();
    Dtool_RectangleLight._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_RectangleLight);
  }
  {
    SelectiveChildNode::init_type();
    TypeHandle handle = SelectiveChildNode::get_class_type();
    Dtool_SelectiveChildNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SelectiveChildNode);
  }
  {
    SequenceNode::init_type();
    TypeHandle handle = SequenceNode::get_class_type();
    Dtool_SequenceNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SequenceNode);
  }
  {
    ShaderGenerator::init_type();
    TypeHandle handle = ShaderGenerator::get_class_type();
    Dtool_ShaderGenerator._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShaderGenerator);
  }
  {
    SphereLight::init_type();
    TypeHandle handle = SphereLight::get_class_type();
    Dtool_SphereLight._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SphereLight);
  }
  {
    Spotlight::init_type();
    TypeHandle handle = Spotlight::get_class_type();
    Dtool_Spotlight._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Spotlight);
  }
  {
    SwitchNode::init_type();
    TypeHandle handle = SwitchNode::get_class_type();
    Dtool_SwitchNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SwitchNode);
  }
  {
    UvScrollNode::init_type();
    TypeHandle handle = UvScrollNode::get_class_type();
    Dtool_UvScrollNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_UvScrollNode);
  }
}

void Dtool_libp3pgraphnodes_BuildInstants(PyObject *module) {
  (void) module;
  // enum LODNodeType
  PyModule_AddObject(module, "LNT_pop", Dtool_WrapValue(::LNT_pop));
  PyModule_AddObject(module, "LNTPop", Dtool_WrapValue(::LNT_pop));
  PyModule_AddObject(module, "LNT_fade", Dtool_WrapValue(::LNT_fade));
  PyModule_AddObject(module, "LNTFade", Dtool_WrapValue(::LNT_fade));
  // LightNode
  Dtool_PyModuleClassInit_LightNode(module);
  PyModule_AddObject(module, "LightNode", (PyObject *)&Dtool_LightNode);
  // AmbientLight
  Dtool_PyModuleClassInit_AmbientLight(module);
  PyModule_AddObject(module, "AmbientLight", (PyObject *)&Dtool_AmbientLight);
  // CallbackNode
  Dtool_PyModuleClassInit_CallbackNode(module);
  PyModule_AddObject(module, "CallbackNode", (PyObject *)&Dtool_CallbackNode);
  // ComputeNode
  Dtool_PyModuleClassInit_ComputeNode(module);
  PyModule_AddObject(module, "ComputeNode", (PyObject *)&Dtool_ComputeNode);
  // LightLensNode
  Dtool_PyModuleClassInit_LightLensNode(module);
  PyModule_AddObject(module, "LightLensNode", (PyObject *)&Dtool_LightLensNode);
  // DirectionalLight
  Dtool_PyModuleClassInit_DirectionalLight(module);
  PyModule_AddObject(module, "DirectionalLight", (PyObject *)&Dtool_DirectionalLight);
  // LODNode
  Dtool_PyModuleClassInit_LODNode(module);
  PyModule_AddObject(module, "LODNode", (PyObject *)&Dtool_LODNode);
  // FadeLODNode
  Dtool_PyModuleClassInit_FadeLODNode(module);
  PyModule_AddObject(module, "FadeLODNode", (PyObject *)&Dtool_FadeLODNode);
  // NodeCullCallbackData
  Dtool_PyModuleClassInit_NodeCullCallbackData(module);
  PyModule_AddObject(module, "NodeCullCallbackData", (PyObject *)&Dtool_NodeCullCallbackData);
  // PointLight
  Dtool_PyModuleClassInit_PointLight(module);
  PyModule_AddObject(module, "PointLight", (PyObject *)&Dtool_PointLight);
  // RectangleLight
  Dtool_PyModuleClassInit_RectangleLight(module);
  PyModule_AddObject(module, "RectangleLight", (PyObject *)&Dtool_RectangleLight);
  // SelectiveChildNode
  Dtool_PyModuleClassInit_SelectiveChildNode(module);
  PyModule_AddObject(module, "SelectiveChildNode", (PyObject *)&Dtool_SelectiveChildNode);
  // SequenceNode
  Dtool_PyModuleClassInit_SequenceNode(module);
  PyModule_AddObject(module, "SequenceNode", (PyObject *)&Dtool_SequenceNode);
  // ShaderGenerator
  Dtool_PyModuleClassInit_ShaderGenerator(module);
  PyModule_AddObject(module, "ShaderGenerator", (PyObject *)&Dtool_ShaderGenerator);
  // SphereLight
  Dtool_PyModuleClassInit_SphereLight(module);
  PyModule_AddObject(module, "SphereLight", (PyObject *)&Dtool_SphereLight);
  // Spotlight
  Dtool_PyModuleClassInit_Spotlight(module);
  PyModule_AddObject(module, "Spotlight", (PyObject *)&Dtool_Spotlight);
  // SwitchNode
  Dtool_PyModuleClassInit_SwitchNode(module);
  PyModule_AddObject(module, "SwitchNode", (PyObject *)&Dtool_SwitchNode);
  // UvScrollNode
  Dtool_PyModuleClassInit_UvScrollNode(module);
  PyModule_AddObject(module, "UvScrollNode", (PyObject *)&Dtool_UvScrollNode);
  // SceneGraphAnalyzer
  Dtool_PyModuleClassInit_SceneGraphAnalyzer(module);
  PyModule_AddObject(module, "SceneGraphAnalyzer", (PyObject *)&Dtool_SceneGraphAnalyzer);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3pgraphnodes_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3pgraphnodes_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613253,  /* file_identifier */
  "libp3pgraphnodes",  /* library_name */
  "Bgt0",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pgraphnodes.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  553  /* next_index */
};

Configure(_in_configure_libp3pgraphnodes);
ConfigureFn(_in_configure_libp3pgraphnodes) {
  interrogate_request_module(&_in_module_def);
}

