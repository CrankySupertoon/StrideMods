/*
 * This file was generated by:
 * built/bin/interrogate -srcdir dtool/src/prc -Idtool/src/prc -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3prc_igate.cxx -od built/pandac/input/libp3prc.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idtool/src/prc -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3prc androidLogStream.h bigEndian.h configDeclaration.h configFlags.h configPage.h configPageManager.h configVariable.h configVariableBase.h configVariableBool.h configVariableCore.h configVariableDouble.h configVariableEnum.h configVariableFilename.h configVariableInt.h configVariableInt64.h configVariableList.h configVariableManager.h configVariableSearchPath.h configVariableString.h config_prc.h encryptStream.h encryptStreamBuf.h littleEndian.h nativeNumericData.h notifyCategory.h notifyCategoryProxy.h notifySeverity.h p3prc_composite1.cxx p3prc_composite2.cxx p3prc_ext_composite.cxx pnotify.h prcKeyRegistry.h reversedNumericData.h streamReader.h streamReader_ext.h streamWrapper.h streamWriter.h streamWriter_ext.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "androidLogStream.h"
#include "bigEndian.h"
#include "configDeclaration.h"
#include "configFlags.h"
#include "configPage.h"
#include "configPageManager.h"
#include "configVariable.h"
#include "configVariableBase.h"
#include "configVariableBool.h"
#include "configVariableCore.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "configVariableInt64.h"
#include "configVariableList.h"
#include "configVariableManager.h"
#include "configVariableSearchPath.h"
#include "configVariableString.h"
#include "config_prc.h"
#include "dSearchPath.h"
#include "dtoolbase.h"
#include "encryptStream.h"
#include "encryptStreamBuf.h"
#include "filename.h"
#include "globPattern.h"
#include "littleEndian.h"
#include "nativeNumericData.h"
#include "notifyCategory.h"
#include "notifyCategoryProxy.h"
#include "notifySeverity.h"
#include "numeric_types.h"
#include "pnotify.h"
#include "prcKeyRegistry.h"
#include "reversedNumericData.h"
#include "streamReader.h"
#include "streamReader_ext.h"
#include "streamWrapper.h"
#include "streamWriter.h"
#include "streamWriter_ext.h"
#include <vector>
#include "vector_string.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ConfigFlags
 */
typedef ConfigFlags ConfigFlags_localtype;
Define_Module_Class(panda3d.core, ConfigFlags, ConfigFlags_localtype, ConfigFlags);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigFlags = &Dtool_ConfigFlags;
static void Dtool_PyModuleClassInit_ConfigFlags(PyObject *module);

/**
 * Forward declarations for top-level class ConfigPage
 */
typedef ConfigPage ConfigPage_localtype;
Define_Module_Class_Private(panda3d.core, ConfigPage, ConfigPage_localtype, ConfigPage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigPage = &Dtool_ConfigPage;
static void Dtool_PyModuleClassInit_ConfigPage(PyObject *module);

/**
 * Forward declarations for top-level class ConfigDeclaration
 */
typedef ConfigDeclaration ConfigDeclaration_localtype;
Define_Module_Class_Private(panda3d.core, ConfigDeclaration, ConfigDeclaration_localtype, ConfigDeclaration);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigDeclaration = &Dtool_ConfigDeclaration;
static void Dtool_PyModuleClassInit_ConfigDeclaration(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableCore
 */
typedef ConfigVariableCore ConfigVariableCore_localtype;
Define_Module_Class_Private(panda3d.core, ConfigVariableCore, ConfigVariableCore_localtype, ConfigVariableCore);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableCore = &Dtool_ConfigVariableCore;
static void Dtool_PyModuleClassInit_ConfigVariableCore(PyObject *module);

/**
 * Forward declarations for top-level class Notify
 */
typedef Notify Notify_localtype;
Define_Module_Class(panda3d.core, Notify, Notify_localtype, Notify);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Notify = &Dtool_Notify;
static void Dtool_PyModuleClassInit_Notify(PyObject *module);

/**
 * Forward declarations for top-level class ConfigPageManager
 */
typedef ConfigPageManager ConfigPageManager_localtype;
Define_Module_Class_Private(panda3d.core, ConfigPageManager, ConfigPageManager_localtype, ConfigPageManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigPageManager = &Dtool_ConfigPageManager;
static void Dtool_PyModuleClassInit_ConfigPageManager(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableManager
 */
typedef ConfigVariableManager ConfigVariableManager_localtype;
Define_Module_Class_Private(panda3d.core, ConfigVariableManager, ConfigVariableManager_localtype, ConfigVariableManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableManager = &Dtool_ConfigVariableManager;
static void Dtool_PyModuleClassInit_ConfigVariableManager(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableBase
 */
typedef ConfigVariableBase ConfigVariableBase_localtype;
Define_Module_Class_Private(panda3d.core, ConfigVariableBase, ConfigVariableBase_localtype, ConfigVariableBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableBase = &Dtool_ConfigVariableBase;
static void Dtool_PyModuleClassInit_ConfigVariableBase(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariable
 */
typedef ConfigVariable ConfigVariable_localtype;
Define_Module_Class(panda3d.core, ConfigVariable, ConfigVariable_localtype, ConfigVariable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariable = &Dtool_ConfigVariable;
static void Dtool_PyModuleClassInit_ConfigVariable(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableBool
 */
typedef ConfigVariableBool ConfigVariableBool_localtype;
Define_Module_Class(panda3d.core, ConfigVariableBool, ConfigVariableBool_localtype, ConfigVariableBool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableBool = &Dtool_ConfigVariableBool;
static void Dtool_PyModuleClassInit_ConfigVariableBool(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableDouble
 */
typedef ConfigVariableDouble ConfigVariableDouble_localtype;
Define_Module_Class(panda3d.core, ConfigVariableDouble, ConfigVariableDouble_localtype, ConfigVariableDouble);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableDouble = &Dtool_ConfigVariableDouble;
static void Dtool_PyModuleClassInit_ConfigVariableDouble(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableFilename
 */
typedef ConfigVariableFilename ConfigVariableFilename_localtype;
Define_Module_Class(panda3d.core, ConfigVariableFilename, ConfigVariableFilename_localtype, ConfigVariableFilename);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableFilename = &Dtool_ConfigVariableFilename;
static void Dtool_PyModuleClassInit_ConfigVariableFilename(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableInt
 */
typedef ConfigVariableInt ConfigVariableInt_localtype;
Define_Module_Class(panda3d.core, ConfigVariableInt, ConfigVariableInt_localtype, ConfigVariableInt);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableInt = &Dtool_ConfigVariableInt;
static void Dtool_PyModuleClassInit_ConfigVariableInt(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableInt64
 */
typedef ConfigVariableInt64 ConfigVariableInt64_localtype;
Define_Module_Class(panda3d.core, ConfigVariableInt64, ConfigVariableInt64_localtype, ConfigVariableInt64);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableInt64 = &Dtool_ConfigVariableInt64;
static void Dtool_PyModuleClassInit_ConfigVariableInt64(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableList
 */
typedef ConfigVariableList ConfigVariableList_localtype;
Define_Module_Class(panda3d.core, ConfigVariableList, ConfigVariableList_localtype, ConfigVariableList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableList = &Dtool_ConfigVariableList;
static void Dtool_PyModuleClassInit_ConfigVariableList(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableSearchPath
 */
typedef ConfigVariableSearchPath ConfigVariableSearchPath_localtype;
Define_Module_Class(panda3d.core, ConfigVariableSearchPath, ConfigVariableSearchPath_localtype, ConfigVariableSearchPath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableSearchPath = &Dtool_ConfigVariableSearchPath;
static void Dtool_PyModuleClassInit_ConfigVariableSearchPath(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableString
 */
typedef ConfigVariableString ConfigVariableString_localtype;
Define_Module_Class(panda3d.core, ConfigVariableString, ConfigVariableString_localtype, ConfigVariableString);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableString = &Dtool_ConfigVariableString;
static void Dtool_PyModuleClassInit_ConfigVariableString(PyObject *module);

/**
 * Forward declarations for top-level class NotifyCategory
 */
typedef NotifyCategory NotifyCategory_localtype;
Define_Module_Class(panda3d.core, NotifyCategory, NotifyCategory_localtype, NotifyCategory);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NotifyCategory = &Dtool_NotifyCategory;
static void Dtool_PyModuleClassInit_NotifyCategory(PyObject *module);

/**
 * Forward declarations for top-level class IDecryptStream
 */
typedef IDecryptStream IDecryptStream_localtype;
Define_Module_Class(panda3d.core, IDecryptStream, IDecryptStream_localtype, IDecryptStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IDecryptStream = &Dtool_IDecryptStream;
static void Dtool_PyModuleClassInit_IDecryptStream(PyObject *module);

/**
 * Forward declarations for top-level class OEncryptStream
 */
typedef OEncryptStream OEncryptStream_localtype;
Define_Module_Class(panda3d.core, OEncryptStream, OEncryptStream_localtype, OEncryptStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OEncryptStream = &Dtool_OEncryptStream;
static void Dtool_PyModuleClassInit_OEncryptStream(PyObject *module);

/**
 * Forward declarations for top-level class StreamReader
 */
typedef StreamReader StreamReader_localtype;
Define_Module_Class(panda3d.core, StreamReader, StreamReader_localtype, StreamReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamReader = &Dtool_StreamReader;
static void Dtool_PyModuleClassInit_StreamReader(PyObject *module);

/**
 * Forward declarations for top-level class StreamWriter
 */
typedef StreamWriter StreamWriter_localtype;
Define_Module_Class(panda3d.core, StreamWriter, StreamWriter_localtype, StreamWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWriter = &Dtool_StreamWriter;
static void Dtool_PyModuleClassInit_StreamWriter(PyObject *module);

/**
 * Forward declarations for top-level class StreamWrapperBase
 */
typedef StreamWrapperBase StreamWrapperBase_localtype;
Define_Module_Class(panda3d.core, StreamWrapperBase, StreamWrapperBase_localtype, StreamWrapperBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWrapperBase = &Dtool_StreamWrapperBase;
static void Dtool_PyModuleClassInit_StreamWrapperBase(PyObject *module);

/**
 * Forward declarations for top-level class IStreamWrapper
 */
typedef IStreamWrapper IStreamWrapper_localtype;
Define_Module_Class(panda3d.core, IStreamWrapper, IStreamWrapper_localtype, IStreamWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IStreamWrapper = &Dtool_IStreamWrapper;
static void Dtool_PyModuleClassInit_IStreamWrapper(PyObject *module);

/**
 * Forward declarations for top-level class OStreamWrapper
 */
typedef OStreamWrapper OStreamWrapper_localtype;
Define_Module_Class(panda3d.core, OStreamWrapper, OStreamWrapper_localtype, OStreamWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OStreamWrapper = &Dtool_OStreamWrapper;
static void Dtool_PyModuleClassInit_OStreamWrapper(PyObject *module);

/**
 * Forward declarations for top-level class StreamWrapper
 */
typedef StreamWrapper StreamWrapper_localtype;
Define_Module_Class(panda3d.core, StreamWrapper, StreamWrapper_localtype, StreamWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWrapper = &Dtool_StreamWrapper;
static void Dtool_PyModuleClassInit_StreamWrapper(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"ConfigFlags", &Dtool_ConfigFlags},
  {"ConfigPage", &Dtool_ConfigPage},
  {"ConfigDeclaration", &Dtool_ConfigDeclaration},
  {"ConfigVariableCore", &Dtool_ConfigVariableCore},
  {"Notify", &Dtool_Notify},
  {"ConfigPageManager", &Dtool_ConfigPageManager},
  {"ConfigVariableManager", &Dtool_ConfigVariableManager},
  {"ConfigVariableBase", &Dtool_ConfigVariableBase},
  {"ConfigVariable", &Dtool_ConfigVariable},
  {"ConfigVariableBool", &Dtool_ConfigVariableBool},
  {"ConfigVariableDouble", &Dtool_ConfigVariableDouble},
  {"ConfigVariableFilename", &Dtool_ConfigVariableFilename},
  {"ConfigVariableInt", &Dtool_ConfigVariableInt},
  {"ConfigVariableInt64", &Dtool_ConfigVariableInt64},
  {"ConfigVariableList", &Dtool_ConfigVariableList},
  {"ConfigVariableSearchPath", &Dtool_ConfigVariableSearchPath},
  {"ConfigVariableString", &Dtool_ConfigVariableString},
  {"NotifyCategory", &Dtool_NotifyCategory},
  {"IDecryptStream", &Dtool_IDecryptStream},
  {"OEncryptStream", &Dtool_OEncryptStream},
  {"StreamReader", &Dtool_StreamReader},
  {"StreamWriter", &Dtool_StreamWriter},
  {"StreamWrapperBase", &Dtool_StreamWrapperBase},
  {"IStreamWrapper", &Dtool_IStreamWrapper},
  {"OStreamWrapper", &Dtool_OStreamWrapper},
  {"StreamWrapper", &Dtool_StreamWrapper},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ios_base", nullptr},
#define Dtool_Ptr_std_ios_base (imports[0].type)
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[1].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[2].type)
  {"std::iostream", nullptr},
#define Dtool_Ptr_std_iostream (imports[3].type)
  {"std::basic_ios< char >", nullptr},
#define Dtool_Ptr_std_basic_ios_char (imports[4].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[5].type)
  {"DSearchPath", nullptr},
#define Dtool_Ptr_DSearchPath (imports[6].type)
  {"DSearchPath::Results", nullptr},
#define Dtool_Ptr_DSearchPath_Results (imports[7].type)
  {nullptr, nullptr},
};
#endif

// std::ios_base
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ios_base;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ios_base = &Dtool_std_ios_base;
#endif
// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// std::iostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_iostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_iostream = &Dtool_std_iostream;
#endif
// std::basic_ios< char >
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_basic_ios_char;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_basic_ios_char = &Dtool_std_basic_ios_char;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// DSearchPath
#ifndef LINK_ALL_STATIC
inline static DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced) {
  nassertr(Dtool_Ptr_DSearchPath != nullptr, nullptr);
  nassertr(Dtool_Ptr_DSearchPath->_Dtool_Coerce != nullptr, nullptr);
  return ((DSearchPath *(*)(PyObject *, DSearchPath &))Dtool_Ptr_DSearchPath->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DSearchPath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath = &Dtool_DSearchPath;
extern DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced);
#endif
// DSearchPath::Results
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DSearchPath_Results;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath_Results = &Dtool_DSearchPath_Results;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class ConfigFlags
 */
/**
 * Python function wrapper for:
 * inline ConfigFlags::ConfigFlags(void) = default
 * inline ConfigFlags::ConfigFlags(ConfigFlags const &) = default
 */
static int Dtool_Init_ConfigFlags(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ConfigFlags() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ConfigFlags::ConfigFlags(void) = default
      ConfigFlags *return_value = new ConfigFlags();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigFlags, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ConfigFlags::ConfigFlags(ConfigFlags const &) = default
      ConfigFlags const *arg_this = (ConfigFlags *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigFlags, 0, "ConfigFlags.ConfigFlags", true, true);
      if (arg_this != nullptr) {
        ConfigFlags *return_value = new ConfigFlags(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigFlags, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigFlags() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigFlags()\n"
      "ConfigFlags(const ConfigFlags param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigFlags(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigFlags) {
    printf("ConfigFlags ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigFlags *local_this = (ConfigFlags *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigFlags) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigFlags(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigPage
 */
/**
 * Python function wrapper for:
 * static ConfigPage *ConfigPage::get_default_page(void)
 */
static PyObject *Dtool_ConfigPage_get_default_page_7(PyObject *, PyObject *) {
  // 1-static ConfigPage *ConfigPage::get_default_page(void)
  ConfigPage *return_value = (ConfigPage::get_default_page)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_default_page_7_comment =
  "C++ Interface:\n"
  "get_default_page()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global \"default page\".  This is the ConfigPage\n"
  " * that lists all variables' original default values.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_default_page_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConfigPage *ConfigPage::get_local_page(void)
 */
static PyObject *Dtool_ConfigPage_get_local_page_8(PyObject *, PyObject *) {
  // 1-static ConfigPage *ConfigPage::get_local_page(void)
  ConfigPage *return_value = (ConfigPage::get_local_page)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_local_page_8_comment =
  "C++ Interface:\n"
  "get_local_page()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global \"local page\".  This is the ConfigPage that\n"
  " * lists the locally-assigned values for any variables in the world that have\n"
  " * such a local assignment.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_local_page_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigPage::get_name(void) const
 */
static PyObject *Dtool_ConfigPage_get_name_9(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigPage::get_name(void) const
  std::string const &return_value = ((*(const ConfigPage*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_name_9_comment =
  "C++ Interface:\n"
  "get_name(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the page.  If the page was loaded from a .prc file,\n"
  " * this is usually the filename.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_name_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigPage::is_special(void) const
 */
static PyObject *Dtool_ConfigPage_is_special_14(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-inline bool ConfigPage::is_special(void) const
  bool return_value = ((*(const ConfigPage*)local_this).is_special)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_is_special_14_comment =
  "C++ Interface:\n"
  "is_special(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is the special \"default\" or \"local\" page, or false if\n"
  " * it is an ordinary page, e.g.  an implicit page loaded from a prc file at\n"
  " * startup, or an explicit page created by\n"
  " * ConfigPageManager::make_explicit_page().\n"
  " */";
#else
static const char *Dtool_ConfigPage_is_special_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigPage::is_implicit(void) const
 */
static PyObject *Dtool_ConfigPage_is_implicit_15(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-inline bool ConfigPage::is_implicit(void) const
  bool return_value = ((*(const ConfigPage*)local_this).is_implicit)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_is_implicit_15_comment =
  "C++ Interface:\n"
  "is_implicit(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the page was loaded by implicitly searching the config path\n"
  " * on startup, or false if it was explicitly loaded by dynamic code after\n"
  " * initial startup.\n"
  " */";
#else
static const char *Dtool_ConfigPage_is_implicit_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::set_sort(int sort)
 */
static PyObject *Dtool_ConfigPage_set_sort_19(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.set_sort")) {
    return nullptr;
  }
  // 1-void ConfigPage::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const ConfigPage self, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_set_sort_19_comment =
  "C++ Interface:\n"
  "set_sort(const ConfigPage self, int sort)\n"
  "\n"
  "/**\n"
  " * Changes the explicit sort order of this particular ConfigPage.  Lower-\n"
  " * numbered pages supercede higher-numbered pages.  Initially, all explicitly-\n"
  " * loaded pages have sort value 0, and implicitly-loaded pages (found on disk)\n"
  " * have sort value 10; you may set an individual page higher or lower to\n"
  " * influence its priority relative to other pages.\n"
  " */";
#else
static const char *Dtool_ConfigPage_set_sort_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigPage::get_sort(void) const
 */
static PyObject *Dtool_ConfigPage_get_sort_20(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-inline int ConfigPage::get_sort(void) const
  int return_value = ((*(const ConfigPage*)local_this).get_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_sort_20_comment =
  "C++ Interface:\n"
  "get_sort(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the explicit sort order of this particular ConfigPage.  See\n"
  " * set_sort().\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_sort_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigPage::get_page_seq(void) const
 */
static PyObject *Dtool_ConfigPage_get_page_seq_23(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-inline int ConfigPage::get_page_seq(void) const
  int return_value = ((*(const ConfigPage*)local_this).get_page_seq)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_page_seq_23_comment =
  "C++ Interface:\n"
  "get_page_seq(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the sequence number of the page.\n"
  " *\n"
  " * Sequence numbers for a particular class (implicit vs.  explicit) of pages\n"
  " * are assigned as each page is loaded; each page is given a higher sequence\n"
  " * number than all the pages loaded before it.\n"
  " *\n"
  " * The implicit_load pages, which are discovered in the file system\n"
  " * automatically, have a different set of sequence numbers than the explicit\n"
  " * pages.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_page_seq_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigPage::get_trust_level(void) const
 */
static PyObject *Dtool_ConfigPage_get_trust_level_24(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-inline int ConfigPage::get_trust_level(void) const
  int return_value = ((*(const ConfigPage*)local_this).get_trust_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_trust_level_24_comment =
  "C++ Interface:\n"
  "get_trust_level(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the trust level associated with this page.  An untrusted page is\n"
  " * trust level 0; if the page was loaded from a signed .prc file, its trust\n"
  " * level is the index number of the certificate that signed it.  Generally, a\n"
  " * higher trust level value represents a greater level of trust.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_trust_level_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigPage::set_trust_level(int trust_level)
 */
static PyObject *Dtool_ConfigPage_set_trust_level_25(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.set_trust_level")) {
    return nullptr;
  }
  // 1-inline void ConfigPage::set_trust_level(int trust_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_trust_level)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_trust_level(const ConfigPage self, int trust_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_set_trust_level_25_comment =
  "C++ Interface:\n"
  "set_trust_level(const ConfigPage self, int trust_level)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the trust level on this particular page.  Note that any\n"
  " * subsequent changes to the page, or to any variable declarations on it, will\n"
  " * reset the trust level to zero.\n"
  " */";
#else
static const char *Dtool_ConfigPage_set_trust_level_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigPage::get_signature(void) const
 */
static PyObject *Dtool_ConfigPage_get_signature_26(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigPage::get_signature(void) const
  std::string const &return_value = ((*(const ConfigPage*)local_this).get_signature)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_signature_26_comment =
  "C++ Interface:\n"
  "get_signature(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the raw binary signature that was found in the prc file, if any.\n"
  " * This method is probably not terribly useful for most applications.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_signature_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::clear(void)
 */
static PyObject *Dtool_ConfigPage_clear_30(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.clear")) {
    return nullptr;
  }
  // 1-void ConfigPage::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_clear_30_comment =
  "C++ Interface:\n"
  "clear(const ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Removes all of the declarations from the page.\n"
  " */";
#else
static const char *Dtool_ConfigPage_clear_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::read_prc(std::istream &in)
 */
static PyObject *Dtool_ConfigPage_read_prc_31(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.read_prc")) {
    return nullptr;
  }
  // 1-bool ConfigPage::read_prc(std::istream &in)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "ConfigPage.read_prc", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).read_prc)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_prc(const ConfigPage self, istream in)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_read_prc_31_comment =
  "C++ Interface:\n"
  "read_prc(const ConfigPage self, istream in)\n"
  "\n"
  "/**\n"
  " * Reads the contents of a complete prc file, as returned by the indicated\n"
  " * istream, into the current page file.  Returns true on success, or false on\n"
  " * some I/O error.\n"
  " *\n"
  " * This is a low-level interface.  Normally you do not need to call it\n"
  " * directly.  See the global functions load_prc_file() and unload_prc_file(),\n"
  " * defined in panda/src/putil, for a higher-level interface.\n"
  " */";
#else
static const char *Dtool_ConfigPage_read_prc_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::read_encrypted_prc(std::istream &in, std::string const &password)
 */
static PyObject *Dtool_ConfigPage_read_encrypted_prc_32(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.read_encrypted_prc")) {
    return nullptr;
  }
  // 1-bool ConfigPage::read_encrypted_prc(std::istream &in, std::string const &password)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"in", "password", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:read_encrypted_prc", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "ConfigPage.read_encrypted_prc", false, true);
    if (param1_this != nullptr) {
      bool return_value = ((*local_this).read_encrypted_prc)(*param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_encrypted_prc(const ConfigPage self, istream in, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_read_encrypted_prc_32_comment =
  "C++ Interface:\n"
  "read_encrypted_prc(const ConfigPage self, istream in, str password)\n"
  "\n"
  "/**\n"
  " * Automatically decrypts and reads the stream, given the indicated password.\n"
  " * Note that if the password is incorrect, the result may be garbage.\n"
  " */";
#else
static const char *Dtool_ConfigPage_read_encrypted_prc_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration *ConfigPage::make_declaration(ConfigVariableCore *variable, std::string const &value)
 * ConfigDeclaration *ConfigPage::make_declaration(std::string const &variable, std::string const &value)
 */
static PyObject *Dtool_ConfigPage_make_declaration_33(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.make_declaration")) {
    return nullptr;
  }
  {
    // -2 ConfigDeclaration *ConfigPage::make_declaration(ConfigVariableCore *variable, std::string const &value)
    PyObject *param1;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    static const char *keyword_list[] = {"variable", "value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:make_declaration", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      ConfigVariableCore *param1_this = (ConfigVariableCore *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ConfigVariableCore, 1, "ConfigPage.make_declaration", false, false);
      if (param1_this != nullptr) {
        ConfigDeclaration *return_value = ((*local_this).make_declaration)(param1_this, std::string(param2_str, param2_len));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConfigDeclaration *ConfigPage::make_declaration(std::string const &variable, std::string const &value)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    static const char *keyword_list[] = {"variable", "value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:make_declaration", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      ConfigDeclaration *return_value = ((*local_this).make_declaration)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: ConfigDeclaration *ConfigPage::make_declaration(ConfigVariableCore *variable, std::string const &value)
  // No coercion possible: ConfigDeclaration *ConfigPage::make_declaration(std::string const &variable, std::string const &value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_declaration(const ConfigPage self, ConfigVariableCore variable, str value)\n"
      "make_declaration(const ConfigPage self, str variable, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_make_declaration_33_comment =
  "C++ Interface:\n"
  "make_declaration(const ConfigPage self, ConfigVariableCore variable, str value)\n"
  "make_declaration(const ConfigPage self, str variable, str value)\n"
  "\n"
  "/**\n"
  " * Adds the indicated variable/value pair as a new declaration on the page.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated variable/value pair as a new declaration on the page.\n"
  " */";
#else
static const char *Dtool_ConfigPage_make_declaration_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::delete_declaration(ConfigDeclaration *decl)
 */
static PyObject *Dtool_ConfigPage_delete_declaration_34(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.delete_declaration")) {
    return nullptr;
  }
  // 1-bool ConfigPage::delete_declaration(ConfigDeclaration *decl)
  ConfigDeclaration *arg_this = (ConfigDeclaration *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigDeclaration, 1, "ConfigPage.delete_declaration", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).delete_declaration)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_declaration(const ConfigPage self, ConfigDeclaration decl)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_delete_declaration_34_comment =
  "C++ Interface:\n"
  "delete_declaration(const ConfigPage self, ConfigDeclaration decl)\n"
  "\n"
  "/**\n"
  " * Removes the indicated declaration from the page and deletes it.  Returns\n"
  " * true if the declaration is successfully removed, false if it was not on the\n"
  " * page.\n"
  " */";
#else
static const char *Dtool_ConfigPage_delete_declaration_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t ConfigPage::get_num_declarations(void) const
 */
static PyObject *Dtool_ConfigPage_get_num_declarations_35(PyObject *self, PyObject *) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-std::size_t ConfigPage::get_num_declarations(void) const
  std::size_t return_value = ((*(const ConfigPage*)local_this).get_num_declarations)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_num_declarations_35_comment =
  "C++ Interface:\n"
  "get_num_declarations(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the number of declarations on the page.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_num_declarations_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration const *ConfigPage::get_declaration(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_get_declaration_36(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-ConfigDeclaration const *ConfigPage::get_declaration(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigDeclaration const *return_value = ((*(const ConfigPage*)local_this).get_declaration)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_declaration(ConfigPage self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_declaration_36_comment =
  "C++ Interface:\n"
  "get_declaration(ConfigPage self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth declaration on the page.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_declaration_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration *ConfigPage::modify_declaration(std::size_t n)
 */
static PyObject *Dtool_ConfigPage_modify_declaration_37(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.modify_declaration")) {
    return nullptr;
  }
  // 1-ConfigDeclaration *ConfigPage::modify_declaration(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigDeclaration *return_value = ((*local_this).modify_declaration)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_declaration(const ConfigPage self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_modify_declaration_37_comment =
  "C++ Interface:\n"
  "modify_declaration(const ConfigPage self, int n)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the nth declaration on the page.  Any\n"
  " * modifications will appear in the output, if the page is written out with\n"
  " * ConfigPage::write().\n"
  " */";
#else
static const char *Dtool_ConfigPage_modify_declaration_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string ConfigPage::get_variable_name(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_get_variable_name_38(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-std::string ConfigPage::get_variable_name(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigPage*)local_this).get_variable_name)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable_name(ConfigPage self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_variable_name_38_comment =
  "C++ Interface:\n"
  "get_variable_name(ConfigPage self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable named by the nth declaration on the page.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_variable_name_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string ConfigPage::get_string_value(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_get_string_value_39(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-std::string ConfigPage::get_string_value(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigPage*)local_this).get_string_value)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_string_value(ConfigPage self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_string_value_39_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigPage self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the value assigned by the nth declaration on the page.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_string_value_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::is_variable_used(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_is_variable_used_40(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-bool ConfigPage::is_variable_used(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigPage*)local_this).is_variable_used)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_variable_used(ConfigPage self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_is_variable_used_40_comment =
  "C++ Interface:\n"
  "is_variable_used(ConfigPage self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth active variable on the page has been used by code,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigPage_is_variable_used_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigPage_output_119(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-void ConfigPage::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigPage.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigPage*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigPage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_output_119_comment =
  "C++ Interface:\n"
  "output(ConfigPage self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigPage_output_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::output_brief_signature(std::ostream &out) const
 */
static PyObject *Dtool_ConfigPage_output_brief_signature_120(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-void ConfigPage::output_brief_signature(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigPage.output_brief_signature", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigPage*)local_this).output_brief_signature)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_brief_signature(ConfigPage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_output_brief_signature_120_comment =
  "C++ Interface:\n"
  "output_brief_signature(ConfigPage self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the first few hex digits of the signature.\n"
  " */";
#else
static const char *Dtool_ConfigPage_output_brief_signature_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigPage_write_121(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPage)) {
    return nullptr;
  }
  // 1-void ConfigPage::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigPage.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigPage*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigPage self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_write_121_comment =
  "C++ Interface:\n"
  "write(ConfigPage self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigPage_write_121_comment = nullptr;
#endif

static PyObject *Dtool_ConfigPage_name_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ConfigPage::get_name(void) const
  std::string const &return_value = ((*(const ConfigPage*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_special_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigPage::is_special(void) const
  bool return_value = ((*(const ConfigPage*)local_this).is_special)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_implicit_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigPage::is_implicit(void) const
  bool return_value = ((*(const ConfigPage*)local_this).is_implicit)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_sort_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ConfigPage::get_sort(void) const
  int return_value = ((*(const ConfigPage*)local_this).get_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigPage_sort_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.sort")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete sort attribute");
    return -1;
  }
  // 1-void ConfigPage::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_sort(const ConfigPage self, int sort)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigPage_page_seq_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ConfigPage::get_page_seq(void) const
  int return_value = ((*(const ConfigPage*)local_this).get_page_seq)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_trust_level_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ConfigPage::get_trust_level(void) const
  int return_value = ((*(const ConfigPage*)local_this).get_trust_level)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigPage_trust_level_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.trust_level")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete trust_level attribute");
    return -1;
  }
  // 1-inline void ConfigPage::set_trust_level(int trust_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_trust_level)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_trust_level(const ConfigPage self, int trust_level)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigPage_signature_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ConfigPage::get_signature(void) const
  std::string const &return_value = ((*(const ConfigPage*)local_this).get_signature)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property ConfigPage::declarations
 */
static Py_ssize_t Dtool_ConfigPage_declarations_Len(PyObject *self) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_declarations)();
}

/**
 * sequence getter for property ConfigPage::declarations
 */
static PyObject *Dtool_ConfigPage_declarations_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_declarations)()) {
    PyErr_SetString(PyExc_IndexError, "ConfigPage.declarations[] index out of range");
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // 1-ConfigDeclaration *ConfigPage::modify_declaration(std::size_t n)
    ConfigDeclaration *return_value = ((*local_this).modify_declaration)(index);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call ConfigPage.modify_declaration() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_declaration(const ConfigPage self, index)\n");
  }
}

static PyObject *Dtool_ConfigPage_declarations_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConfigPage.declarations");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConfigPage_declarations_Len;
    wrap->_getitem_func = &Dtool_ConfigPage_declarations_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_ConfigPage(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigPage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigPage) {
    printf("ConfigPage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigPage *local_this = (ConfigPage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigPage) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigPage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigPage) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigDeclaration
 */
/**
 * Python function wrapper for:
 * inline ConfigPage *ConfigDeclaration::get_page(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_page_44(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline ConfigPage *ConfigDeclaration::get_page(void) const
  ConfigPage *return_value = ((*(const ConfigDeclaration*)local_this).get_page)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_page_44_comment =
  "C++ Interface:\n"
  "get_page(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the page on which this declaration can be found.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_page_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariableCore *ConfigDeclaration::get_variable(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_variable_45(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline ConfigVariableCore *ConfigDeclaration::get_variable(void) const
  ConfigVariableCore *return_value = ((*(const ConfigDeclaration*)local_this).get_variable)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_variable_45_comment =
  "C++ Interface:\n"
  "get_variable(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the variable that this declaration names.  This variable may or may\n"
  " * not have been defined by the time the declaration is read.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_variable_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigDeclaration::get_string_value(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_string_value_97(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigDeclaration::get_string_value(void) const
  std::string const &return_value = ((*(const ConfigDeclaration*)local_this).get_string_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_string_value_97_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the value assigned to this variable.  This is the original one-line\n"
  " * text defined for the variable in the .prc file (or passed to\n"
  " * ConfigPage::make_declaration()).\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_string_value_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigDeclaration::set_string_value(std::string const &value)
 */
static PyObject *Dtool_ConfigDeclaration_set_string_value_98(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_string_value")) {
    return nullptr;
  }
  // 1-inline void ConfigDeclaration::set_string_value(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_string_value)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_string_value(const ConfigDeclaration self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_string_value_98_comment =
  "C++ Interface:\n"
  "set_string_value(const ConfigDeclaration self, str value)\n"
  "\n"
  "/**\n"
  " * Changes the value assigned to this variable.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_set_string_value_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigDeclaration::get_num_words(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_num_words_99(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigDeclaration::get_num_words(void) const
  std::size_t return_value = ((*(const ConfigDeclaration*)local_this).get_num_words)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_num_words_99_comment =
  "C++ Interface:\n"
  "get_num_words(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the number of words in the declaration's value.  A word is defined\n"
  " * as a sequence of non-whitespace characters delimited by whitespace.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_num_words_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_string_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_string_word_100(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline bool ConfigDeclaration::has_string_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigDeclaration*)local_this).has_string_word)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_string_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_string_word_100_comment =
  "C++ Interface:\n"
  "has_string_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid string value for the\n"
  " * nth word.  This is really the same thing as asking if there are at least n\n"
  " * words in the value.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_string_word_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_bool_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_bool_word_101(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline bool ConfigDeclaration::has_bool_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigDeclaration*)local_this).has_bool_word)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bool_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_bool_word_101_comment =
  "C++ Interface:\n"
  "has_bool_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid boolean value for the\n"
  " * nth word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_bool_word_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_int_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_int_word_102(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline bool ConfigDeclaration::has_int_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigDeclaration*)local_this).has_int_word)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_int_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_int_word_102_comment =
  "C++ Interface:\n"
  "has_int_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid integer value for the\n"
  " * nth word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_int_word_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_int64_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_int64_word_103(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline bool ConfigDeclaration::has_int64_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigDeclaration*)local_this).has_int64_word)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_int64_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_int64_word_103_comment =
  "C++ Interface:\n"
  "has_int64_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid int64 value for the nth\n"
  " * word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_int64_word_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_double_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_double_word_104(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline bool ConfigDeclaration::has_double_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigDeclaration*)local_this).has_double_word)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_double_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_double_word_104_comment =
  "C++ Interface:\n"
  "has_double_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid integer value for the\n"
  " * nth word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_double_word_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigDeclaration::get_string_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_string_word_105(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline std::string ConfigDeclaration::get_string_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigDeclaration*)local_this).get_string_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_string_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_string_word_105_comment =
  "C++ Interface:\n"
  "get_string_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the string value of the nth word of the declaration's value, or\n"
  " * empty string if there is no nth value.  See also has_string_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_string_word_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::get_bool_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_bool_word_106(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline bool ConfigDeclaration::get_bool_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigDeclaration*)local_this).get_bool_word)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bool_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_bool_word_106_comment =
  "C++ Interface:\n"
  "get_bool_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the boolean value of the nth word of the declaration's value, or\n"
  " * false if there is no nth value.  See also has_bool_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_bool_word_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigDeclaration::get_int_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_int_word_107(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline int ConfigDeclaration::get_int_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const ConfigDeclaration*)local_this).get_int_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_int_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_int_word_107_comment =
  "C++ Interface:\n"
  "get_int_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the integer value of the nth word of the declaration's value, or 0\n"
  " * if there is no nth value.  See also has_int_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_int_word_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigDeclaration::get_int64_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_int64_word_108(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline int64_t ConfigDeclaration::get_int64_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int64_t return_value = ((*(const ConfigDeclaration*)local_this).get_int64_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_int64_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_int64_word_108_comment =
  "C++ Interface:\n"
  "get_int64_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the int64 value of the nth word of the declaration's value, or 0 if\n"
  " * there is no nth value.  See also has_int64_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_int64_word_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigDeclaration::get_double_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_double_word_109(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline double ConfigDeclaration::get_double_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const ConfigDeclaration*)local_this).get_double_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_double_word(ConfigDeclaration self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_double_word_109_comment =
  "C++ Interface:\n"
  "get_double_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the integer value of the nth word of the declaration's value, or 0\n"
  " * if there is no nth value.  See also has_double_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_double_word_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_string_word(std::size_t n, std::string const &value)
 */
static PyObject *Dtool_ConfigDeclaration_set_string_word_110(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_string_word")) {
    return nullptr;
  }
  // 1-void ConfigDeclaration::set_string_word(std::size_t n, std::string const &value)
  Py_ssize_t param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ns#:set_string_word", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_string_word)((std::size_t)param1, std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_string_word(const ConfigDeclaration self, int n, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_string_word_110_comment =
  "C++ Interface:\n"
  "set_string_word(const ConfigDeclaration self, int n, str value)\n"
  "\n"
  "/**\n"
  " * Changes the nth word to the indicated value without affecting the other\n"
  " * words.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_set_string_word_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_bool_word(std::size_t n, bool value)
 */
static PyObject *Dtool_ConfigDeclaration_set_bool_word_111(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_bool_word")) {
    return nullptr;
  }
  // 1-void ConfigDeclaration::set_bool_word(std::size_t n, bool value)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_bool_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_bool_word)((std::size_t)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bool_word(const ConfigDeclaration self, int n, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_bool_word_111_comment =
  "C++ Interface:\n"
  "set_bool_word(const ConfigDeclaration self, int n, bool value)\n"
  "\n"
  "/**\n"
  " * Changes the nth word to the indicated value without affecting the other\n"
  " * words.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_set_bool_word_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_int_word(std::size_t n, int value)
 */
static PyObject *Dtool_ConfigDeclaration_set_int_word_112(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_int_word")) {
    return nullptr;
  }
  // 1-void ConfigDeclaration::set_int_word(std::size_t n, int value)
  Py_ssize_t param1;
  int param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ni:set_int_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_int_word)((std::size_t)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_int_word(const ConfigDeclaration self, int n, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_int_word_112_comment =
  "C++ Interface:\n"
  "set_int_word(const ConfigDeclaration self, int n, int value)\n"
  "\n"
  "/**\n"
  " * Changes the nth word to the indicated value without affecting the other\n"
  " * words.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_set_int_word_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_int64_word(std::size_t n, int64_t value)
 */
static PyObject *Dtool_ConfigDeclaration_set_int64_word_113(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_int64_word")) {
    return nullptr;
  }
  // 1-void ConfigDeclaration::set_int64_word(std::size_t n, int64_t value)
  Py_ssize_t param1;
  PY_LONG_LONG param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nL:set_int64_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_int64_word)((std::size_t)param1, (int64_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_int64_word(const ConfigDeclaration self, int n, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_int64_word_113_comment =
  "C++ Interface:\n"
  "set_int64_word(const ConfigDeclaration self, int n, long value)\n"
  "\n"
  "/**\n"
  " * Changes the nth word to the indicated value without affecting the other\n"
  " * words.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_set_int64_word_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_double_word(std::size_t n, double value)
 */
static PyObject *Dtool_ConfigDeclaration_set_double_word_114(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_double_word")) {
    return nullptr;
  }
  // 1-void ConfigDeclaration::set_double_word(std::size_t n, double value)
  Py_ssize_t param1;
  double param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:set_double_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_double_word)((std::size_t)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_double_word(const ConfigDeclaration self, int n, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_double_word_114_comment =
  "C++ Interface:\n"
  "set_double_word(const ConfigDeclaration self, int n, double value)\n"
  "\n"
  "/**\n"
  " * Changes the nth word to the indicated value without affecting the other\n"
  " * words.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_set_double_word_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Filename ConfigDeclaration::get_filename_value(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_filename_value_115(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-Filename ConfigDeclaration::get_filename_value(void) const
  Filename *return_value = new Filename(((*(const ConfigDeclaration*)local_this).get_filename_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_filename_value_115_comment =
  "C++ Interface:\n"
  "get_filename_value(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Interprets the string value as a filename and returns it, with any\n"
  " * variables expanded.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_filename_value_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigDeclaration::get_decl_seq(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_decl_seq_116(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-inline int ConfigDeclaration::get_decl_seq(void) const
  int return_value = ((*(const ConfigDeclaration*)local_this).get_decl_seq)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_decl_seq_116_comment =
  "C++ Interface:\n"
  "get_decl_seq(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the sequence number of the declaration within the page.  Sequence\n"
  " * numbers are assigned as each declaration is created; each declaration is\n"
  " * given a higher sequence number than all the declarations created in the\n"
  " * page before it.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_decl_seq_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigDeclaration_output_117(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-void ConfigDeclaration::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigDeclaration.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigDeclaration*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigDeclaration self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_output_117_comment =
  "C++ Interface:\n"
  "output(ConfigDeclaration self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_output_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigDeclaration_write_118(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigDeclaration)) {
    return nullptr;
  }
  // 1-void ConfigDeclaration::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigDeclaration.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigDeclaration*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigDeclaration self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_write_118_comment =
  "C++ Interface:\n"
  "write(ConfigDeclaration self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_write_118_comment = nullptr;
#endif

static PyObject *Dtool_ConfigDeclaration_page_Getter(PyObject *self, void *) {
  const ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConfigPage *ConfigDeclaration::get_page(void) const
  ConfigPage *return_value = ((*(const ConfigDeclaration*)local_this).get_page)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

static PyObject *Dtool_ConfigDeclaration_variable_Getter(PyObject *self, void *) {
  const ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConfigVariableCore *ConfigDeclaration::get_variable(void) const
  ConfigVariableCore *return_value = ((*(const ConfigDeclaration*)local_this).get_variable)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
}

static int Dtool_Init_ConfigDeclaration(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigDeclaration(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigDeclaration) {
    printf("ConfigDeclaration ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigDeclaration *local_this = (ConfigDeclaration *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigDeclaration) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigDeclaration(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigDeclaration) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigDeclaration*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableCore
 */
/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableCore::get_name(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_name_51(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigVariableCore::get_name(void) const
  std::string const &return_value = ((*(const ConfigVariableCore*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_name_51_comment =
  "C++ Interface:\n"
  "get_name(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_name_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::is_used(void) const
 */
static PyObject *Dtool_ConfigVariableCore_is_used_52(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableCore::is_used(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).is_used)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_is_used_52_comment =
  "C++ Interface:\n"
  "is_used(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable has been referenced by a ConfigVariable\n"
  " * somewhere in code, false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_is_used_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigFlags::ValueType ConfigVariableCore::get_value_type(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_value_type_53(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline ConfigFlags::ValueType ConfigVariableCore::get_value_type(void) const
  ConfigFlags::ValueType return_value = ((*(const ConfigVariableCore*)local_this).get_value_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_value_type_53_comment =
  "C++ Interface:\n"
  "get_value_type(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the stated type of this variable.  If the variable has not yet been\n"
  " * defined, this will be VT_undefined.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_value_type_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableCore::get_description(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_description_54(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigVariableCore::get_description(void) const
  std::string const &return_value = ((*(const ConfigVariableCore*)local_this).get_description)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_description_54_comment =
  "C++ Interface:\n"
  "get_description(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the brief description of this variable, if it has been defined.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_description_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableCore::get_flags(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_flags_55(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline int ConfigVariableCore::get_flags(void) const
  int return_value = ((*(const ConfigVariableCore*)local_this).get_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_flags_55_comment =
  "C++ Interface:\n"
  "get_flags(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the flags value as set by set_flags().  This includes the trust\n"
  " * level and some other settings.  See the individual methods is_closed(),\n"
  " * get_trust_level(), etc.  to pull out the semantic meaning of these flags\n"
  " * individually.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_flags_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::is_closed(void) const
 */
static PyObject *Dtool_ConfigVariableCore_is_closed_56(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableCore::is_closed(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).is_closed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_is_closed_56_comment =
  "C++ Interface:\n"
  "is_closed(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable is not trusted by any prc file (and hence\n"
  " * cannot be modified from its compiled-in default value), or false for the\n"
  " * normal case, in which the variable can be modified by any prc file at or\n"
  " * above its trust level (see get_trust_level()).\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_is_closed_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableCore::get_trust_level(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_trust_level_57(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline int ConfigVariableCore::get_trust_level(void) const
  int return_value = ((*(const ConfigVariableCore*)local_this).get_trust_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_trust_level_57_comment =
  "C++ Interface:\n"
  "get_trust_level(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum trust_level a prc file must demonstrate in order to\n"
  " * redefine the value for this variable.  Arguably, this should be called the\n"
  " * \"mistrust level\", since the larger the value, the more suspicious we are of\n"
  " * prc files.  This value is not used if is_closed() returns true, which\n"
  " * indicates no file may be trusted.\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_trust_level_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::is_dynamic(void) const
 */
static PyObject *Dtool_ConfigVariableCore_is_dynamic_58(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableCore::is_dynamic(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).is_dynamic)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_is_dynamic_58_comment =
  "C++ Interface:\n"
  "is_dynamic(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable was indicated as \"dynamic\" by its constructor,\n"
  " * indicating that its name was dynamically generated, possibly from a large\n"
  " * pool, and it should not be listed along with the other variables.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_is_dynamic_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_default_value_59(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_default_value(void) const
  ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_default_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_default_value_59_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the default variable specified for this variable.  If the variable\n"
  " * has not yet been defined, this will return NULL.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_default_value_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_value_type(ConfigFlags::ValueType value_type)
 */
static PyObject *Dtool_ConfigVariableCore_set_value_type_60(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_value_type")) {
    return nullptr;
  }
  // 1-void ConfigVariableCore::set_value_type(ConfigFlags::ValueType value_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_value_type)((ConfigFlags::ValueType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_type(const ConfigVariableCore self, int value_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_value_type_60_comment =
  "C++ Interface:\n"
  "set_value_type(const ConfigVariableCore self, int value_type)\n"
  "\n"
  "/**\n"
  " * Specifies the type of this variable.  See get_value_type().  It is not an\n"
  " * error to call this multiple times, but if the value changes once\n"
  " * get_declaration() has been called, a warning is printed.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_set_value_type_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_flags(int flags)
 */
static PyObject *Dtool_ConfigVariableCore_set_flags_61(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_flags")) {
    return nullptr;
  }
  // 1-void ConfigVariableCore::set_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_flags)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flags(const ConfigVariableCore self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_flags_61_comment =
  "C++ Interface:\n"
  "set_flags(const ConfigVariableCore self, int flags)\n"
  "\n"
  "/**\n"
  " * Specifies the trust level of this variable.  See get_flags().  It is not an\n"
  " * error to call this multiple times, but if the value changes once\n"
  " * get_declaration() has been called, a warning is printed.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_set_flags_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_description(std::string const &description)
 */
static PyObject *Dtool_ConfigVariableCore_set_description_62(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_description")) {
    return nullptr;
  }
  // 1-void ConfigVariableCore::set_description(std::string const &description)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_description)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_description(const ConfigVariableCore self, str description)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_description_62_comment =
  "C++ Interface:\n"
  "set_description(const ConfigVariableCore self, str description)\n"
  "\n"
  "/**\n"
  " * Specifies the one-line description of this variable.  See\n"
  " * get_description().  It is not an error to call this multiple times, but if\n"
  " * the value changes once get_declaration() has been called, a warning is\n"
  " * printed.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_set_description_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_default_value(std::string const &default_value)
 */
static PyObject *Dtool_ConfigVariableCore_set_default_value_63(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_default_value")) {
    return nullptr;
  }
  // 1-void ConfigVariableCore::set_default_value(std::string const &default_value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_default_value)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_value(const ConfigVariableCore self, str default_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_default_value_63_comment =
  "C++ Interface:\n"
  "set_default_value(const ConfigVariableCore self, str default_value)\n"
  "\n"
  "/**\n"
  " * Specifies the default value for this variable if it is not defined in any\n"
  " * prc file.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_set_default_value_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableCore::set_used(void)
 */
static PyObject *Dtool_ConfigVariableCore_set_used_64(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_used")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableCore::set_used(void)
  ((*local_this).set_used)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_used_64_comment =
  "C++ Interface:\n"
  "set_used(const ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Marks that the variable has been \"declared\" by a ConfigVariable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_set_used_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration *ConfigVariableCore::make_local_value(void)
 */
static PyObject *Dtool_ConfigVariableCore_make_local_value_65(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.make_local_value")) {
    return nullptr;
  }
  // 1-ConfigDeclaration *ConfigVariableCore::make_local_value(void)
  ConfigDeclaration *return_value = ((*local_this).make_local_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_make_local_value_65_comment =
  "C++ Interface:\n"
  "make_local_value(const ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Creates a new local value for this variable, if there is not already one\n"
  " * specified.  This will shadow any values defined in the various .prc files.\n"
  " *\n"
  " * If there is already a local value defined for this variable, simply returns\n"
  " * that one.\n"
  " *\n"
  " * Use clear_local_value() to remove the local value definition.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_make_local_value_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigVariableCore::clear_local_value(void)
 */
static PyObject *Dtool_ConfigVariableCore_clear_local_value_66(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.clear_local_value")) {
    return nullptr;
  }
  // 1-bool ConfigVariableCore::clear_local_value(void)
  bool return_value = ((*local_this).clear_local_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_clear_local_value_66_comment =
  "C++ Interface:\n"
  "clear_local_value(const ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Removes the local value defined for this variable, and allows its value to\n"
  " * be once again retrieved from the .prc files.\n"
  " *\n"
  " * Returns true if the value was successfully removed, false if it did not\n"
  " * exist in the first place.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_clear_local_value_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::has_local_value(void) const
 */
static PyObject *Dtool_ConfigVariableCore_has_local_value_67(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableCore::has_local_value(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).has_local_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_has_local_value_67_comment =
  "C++ Interface:\n"
  "has_local_value(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if this variable's value has been shadowed by a local\n"
  " * assignment (as created via make_local_value()), or false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_has_local_value_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigVariableCore::has_value(void) const
 */
static PyObject *Dtool_ConfigVariableCore_has_value_68(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-bool ConfigVariableCore::has_value(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).has_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_has_value_68_comment =
  "C++ Interface:\n"
  "has_value(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if this variable has an explicit value, either from a prc file\n"
  " * or locally set, or false if variable has its default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_has_value_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t ConfigVariableCore::get_num_declarations(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_declarations_69(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-std::size_t ConfigVariableCore::get_num_declarations(void) const
  std::size_t return_value = ((*(const ConfigVariableCore*)local_this).get_num_declarations)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_declarations_69_comment =
  "C++ Interface:\n"
  "get_num_declarations(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the number of declarations that contribute to this variable's\n"
  " * value.  If the variable has been defined, this will always be at least 1\n"
  " * (for the default value, at least).\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_num_declarations_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration const *ConfigVariableCore::get_declaration(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_declaration_70(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-ConfigDeclaration const *ConfigVariableCore::get_declaration(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_declaration)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_declaration(ConfigVariableCore self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_declaration_70_comment =
  "C++ Interface:\n"
  "get_declaration(ConfigVariableCore self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth declarations that contributes to this variable's value.\n"
  " * The declarations are arranged in order such that earlier declarations\n"
  " * shadow later declarations; thus, get_declaration(0) is always defined and\n"
  " * always returns the current value of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_declaration_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableCore::get_num_references(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_references_72(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableCore::get_num_references(void) const
  std::size_t return_value = ((*(const ConfigVariableCore*)local_this).get_num_references)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_references_72_comment =
  "C++ Interface:\n"
  "get_num_references(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the number of prc files that reference this variable.  This is not\n"
  " * exactly the same as the number of declarations; see get_reference().\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_num_references_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_reference(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_reference_73(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_reference(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_reference)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_reference(ConfigVariableCore self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_reference_73_comment =
  "C++ Interface:\n"
  "get_reference(ConfigVariableCore self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth declaration in a prc file that references this variable.\n"
  " * This is similar, but not identical to, get_declaration().  The difference\n"
  " * is that this will list *only* true references in a prc file, and will not\n"
  " * list default values or locally-assigned values; it also will list even the\n"
  " * untrusted files.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_reference_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableCore::get_num_trusted_references(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_trusted_references_75(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableCore::get_num_trusted_references(void) const
  std::size_t return_value = ((*(const ConfigVariableCore*)local_this).get_num_trusted_references)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_trusted_references_75_comment =
  "C++ Interface:\n"
  "get_num_trusted_references(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the number of trusted prc files that reference this variable.  See\n"
  " * also get_num_references().\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_num_trusted_references_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_trusted_reference(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_trusted_reference_76(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_trusted_reference(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_trusted_reference)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_trusted_reference(ConfigVariableCore self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_trusted_reference_76_comment =
  "C++ Interface:\n"
  "get_trusted_reference(ConfigVariableCore self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth declaration in a trusted prc file that references this\n"
  " * variable.  This is similar, but not identical to, get_declaration().  The\n"
  " * difference is that this will list *only* true references in a prc file, and\n"
  " * will not list default values or locally-assigned values.\n"
  " *\n"
  " * This is also similar to get_reference(), except that it only lists the\n"
  " * trusted declarations, omitting the untrusted ones.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_trusted_reference_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableCore::get_num_unique_references(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_unique_references_78(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableCore::get_num_unique_references(void) const
  std::size_t return_value = ((*(const ConfigVariableCore*)local_this).get_num_unique_references)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_unique_references_78_comment =
  "C++ Interface:\n"
  "get_num_unique_references(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the number of trusted, unique (by string value) values there exist\n"
  " * for this variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_num_unique_references_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_unique_reference(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_unique_reference_79(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_unique_reference(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_unique_reference)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unique_reference(ConfigVariableCore self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_unique_reference_79_comment =
  "C++ Interface:\n"
  "get_unique_reference(ConfigVariableCore self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth trusted, unique value for this variable.  This is similar\n"
  " * to get_trusted_reference(), except that duplicate values are removed.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_unique_reference_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableCore_output_84(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-void ConfigVariableCore::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableCore.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableCore*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableCore self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_output_84_comment =
  "C++ Interface:\n"
  "output(ConfigVariableCore self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_output_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableCore_write_85(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableCore)) {
    return nullptr;
  }
  // 1-void ConfigVariableCore::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableCore.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableCore*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableCore self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_write_85_comment =
  "C++ Interface:\n"
  "write(ConfigVariableCore self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_write_85_comment = nullptr;
#endif

/**
 * sequence length function for property ConfigVariableCore::declarations
 */
static Py_ssize_t Dtool_ConfigVariableCore_declarations_Len(PyObject *self) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_declarations)();
}

/**
 * sequence getter for property ConfigVariableCore::declarations
 */
static PyObject *Dtool_ConfigVariableCore_declarations_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_declarations)()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.declarations[] index out of range");
    return nullptr;
  }
  // 1-ConfigDeclaration const *ConfigVariableCore::get_declaration(std::size_t n) const
  ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_declaration)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_declaration(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_declarations_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConfigVariableCore.declarations");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConfigVariableCore_declarations_Len;
    wrap->_getitem_func = &Dtool_ConfigVariableCore_declarations_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_ConfigVariableCore_name_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ConfigVariableCore::get_name(void) const
  std::string const &return_value = ((*(const ConfigVariableCore*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_used_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigVariableCore::is_used(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).is_used)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_closed_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigVariableCore::is_closed(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).is_closed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_trust_level_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ConfigVariableCore::get_trust_level(void) const
  int return_value = ((*(const ConfigVariableCore*)local_this).get_trust_level)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_dynamic_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigVariableCore::is_dynamic(void) const
  bool return_value = ((*(const ConfigVariableCore*)local_this).is_dynamic)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_value_type_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConfigFlags::ValueType ConfigVariableCore::get_value_type(void) const
  ConfigFlags::ValueType return_value = ((*(const ConfigVariableCore*)local_this).get_value_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableCore_value_type_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.value_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value_type attribute");
    return -1;
  }
  // 1-void ConfigVariableCore::set_value_type(ConfigFlags::ValueType value_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_value_type)((ConfigFlags::ValueType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value_type(const ConfigVariableCore self, int value_type)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableCore_description_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ConfigVariableCore::get_description(void) const
  std::string const &return_value = ((*(const ConfigVariableCore*)local_this).get_description)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableCore_description_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.description")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete description attribute");
    return -1;
  }
  // 1-void ConfigVariableCore::set_description(std::string const &description)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_description)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_description(const ConfigVariableCore self, str description)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableCore_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_default_value(void) const
  ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_default_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
}

static int Dtool_ConfigVariableCore_default_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.default_value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete default_value attribute");
    return -1;
  }
  // 1-void ConfigVariableCore::set_default_value(std::string const &default_value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_default_value)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default_value(const ConfigVariableCore self, str default_value)\n");
  }
  return -1;
}

/**
 * sequence length function for property ConfigVariableCore::references
 */
static Py_ssize_t Dtool_ConfigVariableCore_references_Len(PyObject *self) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_references)();
}

/**
 * sequence getter for property ConfigVariableCore::references
 */
static PyObject *Dtool_ConfigVariableCore_references_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_references)()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.references[] index out of range");
    return nullptr;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_reference(std::size_t n) const
  ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_reference)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_reference(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_references_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConfigVariableCore.references");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConfigVariableCore_references_Len;
    wrap->_getitem_func = &Dtool_ConfigVariableCore_references_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property ConfigVariableCore::trusted_references
 */
static Py_ssize_t Dtool_ConfigVariableCore_trusted_references_Len(PyObject *self) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_trusted_references)();
}

/**
 * sequence getter for property ConfigVariableCore::trusted_references
 */
static PyObject *Dtool_ConfigVariableCore_trusted_references_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_trusted_references)()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.trusted_references[] index out of range");
    return nullptr;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_trusted_reference(std::size_t n) const
  ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_trusted_reference)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_trusted_reference(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_trusted_references_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConfigVariableCore.trusted_references");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConfigVariableCore_trusted_references_Len;
    wrap->_getitem_func = &Dtool_ConfigVariableCore_trusted_references_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property ConfigVariableCore::unique_references
 */
static Py_ssize_t Dtool_ConfigVariableCore_unique_references_Len(PyObject *self) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_unique_references)();
}

/**
 * sequence getter for property ConfigVariableCore::unique_references
 */
static PyObject *Dtool_ConfigVariableCore_unique_references_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_unique_references)()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.unique_references[] index out of range");
    return nullptr;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_unique_reference(std::size_t n) const
  ConfigDeclaration const *return_value = ((*(const ConfigVariableCore*)local_this).get_unique_reference)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unique_reference(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_unique_references_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConfigVariableCore.unique_references");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConfigVariableCore_unique_references_Len;
    wrap->_getitem_func = &Dtool_ConfigVariableCore_unique_references_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_ConfigVariableCore(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_declarations(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_declarations)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_declaration_70(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_references(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_references)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_reference_73(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_trusted_references(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_trusted_references)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_trusted_reference_76(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_unique_references(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_unique_references)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_unique_reference_79(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConfigVariableCore(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableCore) {
    printf("ConfigVariableCore ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableCore *local_this = (ConfigVariableCore *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableCore) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableCore(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableCore) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableCore*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Notify
 */
/**
 * Python function wrapper for:
 * void Notify::set_ostream_ptr(std::ostream *ostream_ptr, bool delete_later)
 */
static PyObject *Dtool_Notify_set_ostream_ptr_126(PyObject *self, PyObject *args, PyObject *kwds) {
  Notify *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.set_ostream_ptr")) {
    return nullptr;
  }
  // 1-void Notify::set_ostream_ptr(std::ostream *ostream_ptr, bool delete_later)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"ostream_ptr", "delete_later", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_ostream_ptr", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Notify.set_ostream_ptr", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_ostream_ptr)(param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ostream_ptr(const Notify self, ostream ostream_ptr, bool delete_later)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Notify_set_ostream_ptr_126_comment =
  "C++ Interface:\n"
  "set_ostream_ptr(const Notify self, ostream ostream_ptr, bool delete_later)\n"
  "\n"
  "/**\n"
  " * Changes the ostream that all subsequent Notify messages will be written to.\n"
  " * If the previous ostream was set with delete_later = true, this will delete\n"
  " * the previous ostream.  If ostream_ptr is NULL, this resets the default to\n"
  " * cerr.\n"
  " */";
#else
static const char *Dtool_Notify_set_ostream_ptr_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::ostream *Notify::get_ostream_ptr(void) const
 */
static PyObject *Dtool_Notify_get_ostream_ptr_127(PyObject *self, PyObject *) {
  Notify *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Notify)) {
    return nullptr;
  }
  // 1-std::ostream *Notify::get_ostream_ptr(void) const
  std::ostream *return_value = ((*(const Notify*)local_this).get_ostream_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_ostream_ptr_127_comment =
  "C++ Interface:\n"
  "get_ostream_ptr(Notify self)\n"
  "\n"
  "/**\n"
  " * Returns the system-wide ostream for all Notify messages.\n"
  " */";
#else
static const char *Dtool_Notify_get_ostream_ptr_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Notify::clear_assert_handler(void)
 */
static PyObject *Dtool_Notify_clear_assert_handler_129(PyObject *self, PyObject *) {
  Notify *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.clear_assert_handler")) {
    return nullptr;
  }
  // 1-void Notify::clear_assert_handler(void)
  ((*local_this).clear_assert_handler)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Notify_clear_assert_handler_129_comment =
  "C++ Interface:\n"
  "clear_assert_handler(const Notify self)\n"
  "\n"
  "/**\n"
  " * Removes the installed assert handler and restores default behavior of\n"
  " * nassertr() and nassertv().\n"
  " */";
#else
static const char *Dtool_Notify_clear_assert_handler_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Notify::has_assert_handler(void) const
 */
static PyObject *Dtool_Notify_has_assert_handler_130(PyObject *self, PyObject *) {
  Notify *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Notify)) {
    return nullptr;
  }
  // 1-bool Notify::has_assert_handler(void) const
  bool return_value = ((*(const Notify*)local_this).has_assert_handler)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Notify_has_assert_handler_130_comment =
  "C++ Interface:\n"
  "has_assert_handler(Notify self)\n"
  "\n"
  "/**\n"
  " * Returns true if a user assert handler has been installed, false otherwise.\n"
  " */";
#else
static const char *Dtool_Notify_has_assert_handler_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Notify::has_assert_failed(void) const
 */
static PyObject *Dtool_Notify_has_assert_failed_132(PyObject *self, PyObject *) {
  Notify *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Notify)) {
    return nullptr;
  }
  // 1-inline bool Notify::has_assert_failed(void) const
  bool return_value = ((*(const Notify*)local_this).has_assert_failed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Notify_has_assert_failed_132_comment =
  "C++ Interface:\n"
  "has_assert_failed(Notify self)\n"
  "\n"
  "/**\n"
  " * Returns true if an assertion test has failed (and not been ignored) since\n"
  " * the last call to clear_assert_failed().\n"
  " *\n"
  " * When an assertion test fails, the assert handler may decide either to\n"
  " * abort, return, or ignore the assertion.  Naturally, if it decides to abort,\n"
  " * this flag is irrelevant.  If it chooses to ignore the assertion, the flag\n"
  " * is not set.  However, if the assert handler chooses to return out of the\n"
  " * function (the normal case), it will also set this flag to indicate that an\n"
  " * assertion failure has occurred.\n"
  " *\n"
  " * This will also be the behavior in the absence of a user-defined assert\n"
  " * handler.\n"
  " */";
#else
static const char *Dtool_Notify_has_assert_failed_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Notify::get_assert_error_message(void) const
 */
static PyObject *Dtool_Notify_get_assert_error_message_133(PyObject *self, PyObject *) {
  Notify *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Notify)) {
    return nullptr;
  }
  // 1-inline std::string const &Notify::get_assert_error_message(void) const
  std::string const &return_value = ((*(const Notify*)local_this).get_assert_error_message)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_assert_error_message_133_comment =
  "C++ Interface:\n"
  "get_assert_error_message(Notify self)\n"
  "\n"
  "/**\n"
  " * Returns the error message that corresponds to the assertion that most\n"
  " * recently failed.\n"
  " */";
#else
static const char *Dtool_Notify_get_assert_error_message_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Notify::clear_assert_failed(void)
 */
static PyObject *Dtool_Notify_clear_assert_failed_134(PyObject *self, PyObject *) {
  Notify *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.clear_assert_failed")) {
    return nullptr;
  }
  // 1-inline void Notify::clear_assert_failed(void)
  ((*local_this).clear_assert_failed)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Notify_clear_assert_failed_134_comment =
  "C++ Interface:\n"
  "clear_assert_failed(const Notify self)\n"
  "\n"
  "/**\n"
  " * Resets the assert_failed flag that is set whenever an assertion test fails.\n"
  " * See has_assert_failed().\n"
  " */";
#else
static const char *Dtool_Notify_clear_assert_failed_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NotifyCategory *Notify::get_top_category(void)
 */
static PyObject *Dtool_Notify_get_top_category_135(PyObject *self, PyObject *) {
  Notify *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.get_top_category")) {
    return nullptr;
  }
  // 1-NotifyCategory *Notify::get_top_category(void)
  NotifyCategory *return_value = ((*local_this).get_top_category)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_top_category_135_comment =
  "C++ Interface:\n"
  "get_top_category(const Notify self)\n"
  "\n"
  "/**\n"
  " * Returns the topmost Category in the hierarchy.  This may be used to\n"
  " * traverse the hierarchy of available Categories.\n"
  " */";
#else
static const char *Dtool_Notify_get_top_category_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NotifyCategory *Notify::get_category(std::string const &fullname)
 * NotifyCategory *Notify::get_category(std::string const &basename, NotifyCategory *parent_category)
 * NotifyCategory *Notify::get_category(std::string const &basename, std::string const &parent_fullname)
 */
static PyObject *Dtool_Notify_get_category_136(PyObject *self, PyObject *args, PyObject *kwds) {
  Notify *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.get_category")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "fullname")) {
        // 1-NotifyCategory *Notify::get_category(std::string const &fullname)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          NotifyCategory *return_value = ((*local_this).get_category)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
        }
      }
    }
    break;
  case 2:
    {
      {
        // -2 NotifyCategory *Notify::get_category(std::string const &basename, NotifyCategory *parent_category)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        PyObject *param2;
        static const char *keyword_list[] = {"basename", "parent_category", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:get_category", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          NotifyCategory *param2_this = (NotifyCategory *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NotifyCategory, 2, "Notify.get_category", false, false);
          if (param2_this != nullptr) {
            NotifyCategory *return_value = ((*local_this).get_category)(std::string(param1_str, param1_len), param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 NotifyCategory *Notify::get_category(std::string const &basename, std::string const &parent_fullname)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        static const char *keyword_list[] = {"basename", "parent_fullname", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_category", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
          NotifyCategory *return_value = ((*local_this).get_category)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: NotifyCategory *Notify::get_category(std::string const &basename, NotifyCategory *parent_category)
      // No coercion possible: NotifyCategory *Notify::get_category(std::string const &basename, std::string const &parent_fullname)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_category() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_category(const Notify self, str fullname)\n"
      "get_category(const Notify self, str basename, NotifyCategory parent_category)\n"
      "get_category(const Notify self, str basename, str parent_fullname)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_category_136_comment =
  "C++ Interface:\n"
  "get_category(const Notify self, str fullname)\n"
  "get_category(const Notify self, str basename, NotifyCategory parent_category)\n"
  "get_category(const Notify self, str basename, str parent_fullname)\n"
  "\n"
  "/**\n"
  " * Finds or creates a new Category given the basename of the category and its\n"
  " * parent in the category hierarchy.  The parent pointer may be NULL to\n"
  " * indicate this is a top-level Category.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Finds or creates a new Category given the basename of the category and the\n"
  " * fullname of its parent.  This is another way to create a category when you\n"
  " * don't have a pointer to its parent handy, but you know the name of its\n"
  " * parent.  If the parent Category does not already exist, it will be created.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Finds or creates a new Category given the fullname of the Category.  This\n"
  " * name should be a sequence of colon-separated names of parent Categories,\n"
  " * ending in the basename of this Category, e.g.  display:glxdisplay.  This is\n"
  " * a shorthand way to define a Category when a pointer to its parent is not\n"
  " * handy.\n"
  " */";
#else
static const char *Dtool_Notify_get_category_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::ostream &Notify::out(void)
 */
static PyObject *Dtool_Notify_out_137(PyObject *, PyObject *) {
  // 1-static std::ostream &Notify::out(void)
  std::ostream *return_value = &((Notify::out)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_out_137_comment =
  "C++ Interface:\n"
  "out()\n"
  "\n"
  "/**\n"
  " * A convenient way to get the ostream that should be written to for a Notify-\n"
  " * type message.  Also see Category::out() for a message that is specific to a\n"
  " * particular Category.\n"
  " */";
#else
static const char *Dtool_Notify_out_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::ostream &Notify::null(void)
 */
static PyObject *Dtool_Notify_null_138(PyObject *, PyObject *) {
  // 1-static std::ostream &Notify::null(void)
  std::ostream *return_value = &((Notify::null)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_null_138_comment =
  "C++ Interface:\n"
  "null()\n"
  "\n"
  "/**\n"
  " * A convenient way to get an ostream that doesn't do anything.  Returned by\n"
  " * Category::out() when a particular Category and/or Severity is disabled.\n"
  " */";
#else
static const char *Dtool_Notify_null_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void Notify::write_string(std::string const &str)
 */
static PyObject *Dtool_Notify_write_string_139(PyObject *, PyObject *arg) {
  // 1-static void Notify::write_string(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (Notify::write_string)(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_string(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Notify_write_string_139_comment =
  "C++ Interface:\n"
  "write_string(str str)\n"
  "\n"
  "/**\n"
  " * A convenient way for scripting languages, which may know nothing about\n"
  " * ostreams, to write to Notify.  This writes a single string, followed by an\n"
  " * implicit newline, to the Notify output stream.\n"
  " */";
#else
static const char *Dtool_Notify_write_string_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Notify *Notify::ptr(void)
 */
static PyObject *Dtool_Notify_ptr_140(PyObject *, PyObject *) {
  // 1-static Notify *Notify::ptr(void)
  Notify *return_value = (Notify::ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Notify, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_ptr_140_comment =
  "C++ Interface:\n"
  "ptr()\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the global Notify object.  There is only one of\n"
  " * these in the world.\n"
  " */";
#else
static const char *Dtool_Notify_ptr_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Notify::Notify(void)
 * inline Notify::Notify(Notify const &) = default
 */
static int Dtool_Init_Notify(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Notify() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-Notify::Notify(void)
      Notify *return_value = new Notify();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Notify, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Notify::Notify(Notify const &) = default
      Notify const *arg_this = (Notify *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Notify, 0, "Notify.Notify", true, true);
      if (arg_this != nullptr) {
        Notify *return_value = new Notify(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Notify, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Notify() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Notify()\n"
      "Notify(const Notify param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Notify(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Notify) {
    printf("Notify ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Notify *local_this = (Notify *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Notify) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Notify(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Notify) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigPageManager
 */
/**
 * Python function wrapper for:
 * inline bool ConfigPageManager::loaded_implicit_pages(void) const
 */
static PyObject *Dtool_ConfigPageManager_loaded_implicit_pages_142(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline bool ConfigPageManager::loaded_implicit_pages(void) const
  bool return_value = ((*(const ConfigPageManager*)local_this).loaded_implicit_pages)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_loaded_implicit_pages_142_comment =
  "C++ Interface:\n"
  "loaded_implicit_pages(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns true if the implicit *.prc files have already been loaded, false\n"
  " * otherwise.  Normally this will only be false briefly before startup.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_loaded_implicit_pages_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigPageManager::load_implicit_pages(void)
 */
static PyObject *Dtool_ConfigPageManager_load_implicit_pages_143(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.load_implicit_pages")) {
    return nullptr;
  }
  // 1-inline void ConfigPageManager::load_implicit_pages(void)
  ((*local_this).load_implicit_pages)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_load_implicit_pages_143_comment =
  "C++ Interface:\n"
  "load_implicit_pages(const ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Searches the PRC_DIR and/or PRC_PATH directories for *.prc files and loads\n"
  " * them in as pages.  This is normally called automatically at startup time,\n"
  " * when the first variable's value is referenced.  See also\n"
  " * reload_implicit_pages().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_load_implicit_pages_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPageManager::reload_implicit_pages(void)
 */
static PyObject *Dtool_ConfigPageManager_reload_implicit_pages_144(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.reload_implicit_pages")) {
    return nullptr;
  }
  // 1-void ConfigPageManager::reload_implicit_pages(void)
  ((*local_this).reload_implicit_pages)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_reload_implicit_pages_144_comment =
  "C++ Interface:\n"
  "reload_implicit_pages(const ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Searches the PRC_DIR and/or PRC_PATH directories for *.prc files and loads\n"
  " * them in as pages.\n"
  " *\n"
  " * This may be called after startup, to force the system to re-read all of the\n"
  " * implicit prc files.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_reload_implicit_pages_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath &ConfigPageManager::get_search_path(void)
 */
static PyObject *Dtool_ConfigPageManager_get_search_path_145(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.get_search_path")) {
    return nullptr;
  }
  // 1-inline DSearchPath &ConfigPageManager::get_search_path(void)
  DSearchPath *return_value = &(((*local_this).get_search_path)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_search_path_145_comment =
  "C++ Interface:\n"
  "get_search_path(const ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the search path used to locate implicit .prc files.  This is\n"
  " * determined by the PRC_DIR and PRC_PATH environment variables.  The object\n"
  " * returned by this method may be modified to change the path at runtime, and\n"
  " * then reload_implicit_pages() called.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_search_path_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_prc_patterns(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_prc_patterns_146(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_prc_patterns(void) const
  std::size_t return_value = ((*(const ConfigPageManager*)local_this).get_num_prc_patterns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_prc_patterns_146_comment =
  "C++ Interface:\n"
  "get_num_prc_patterns(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of patterns, like \"*.prc\", that are compiled in that\n"
  " * will be searched for as default config filenames.  Normally there is only\n"
  " * one pattern, and it is \"*.prc\", but others may be specified with the\n"
  " * PRC_FILENAME variable in Config.pp.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_prc_patterns_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigPageManager::get_prc_pattern(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_prc_pattern_147(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::string ConfigPageManager::get_prc_pattern(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigPageManager*)local_this).get_prc_pattern)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prc_pattern(ConfigPageManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_prc_pattern_147_comment =
  "C++ Interface:\n"
  "get_prc_pattern(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth filename pattern that will be considered a match as a valid\n"
  " * config file.  See get_num_prc_patterns().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_prc_pattern_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_prc_encrypted_patterns(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_148(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_prc_encrypted_patterns(void) const
  std::size_t return_value = ((*(const ConfigPageManager*)local_this).get_num_prc_encrypted_patterns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_148_comment =
  "C++ Interface:\n"
  "get_num_prc_encrypted_patterns(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of patterns, like \"*.pre\", that are compiled in that\n"
  " * will be searched for as special config files that are understood to be\n"
  " * encrypted.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigPageManager::get_prc_encrypted_pattern(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_prc_encrypted_pattern_149(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::string ConfigPageManager::get_prc_encrypted_pattern(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigPageManager*)local_this).get_prc_encrypted_pattern)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prc_encrypted_pattern(ConfigPageManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_prc_encrypted_pattern_149_comment =
  "C++ Interface:\n"
  "get_prc_encrypted_pattern(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth filename pattern that will be considered a match as a valid\n"
  " * encrypted config file.  See get_num_prc_encrypted_patterns().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_prc_encrypted_pattern_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_prc_executable_patterns(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_prc_executable_patterns_150(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_prc_executable_patterns(void) const
  std::size_t return_value = ((*(const ConfigPageManager*)local_this).get_num_prc_executable_patterns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_prc_executable_patterns_150_comment =
  "C++ Interface:\n"
  "get_num_prc_executable_patterns(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of patterns, like \"*.exe\", that are compiled in that\n"
  " * will be searched for as special config files that are to be executed as a\n"
  " * program, and their output taken to be input.  This is normally empty.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_prc_executable_patterns_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigPageManager::get_prc_executable_pattern(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_prc_executable_pattern_151(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::string ConfigPageManager::get_prc_executable_pattern(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigPageManager*)local_this).get_prc_executable_pattern)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prc_executable_pattern(ConfigPageManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_prc_executable_pattern_151_comment =
  "C++ Interface:\n"
  "get_prc_executable_pattern(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth filename pattern that will be considered a match as a valid\n"
  " * executable-style config file.  See get_num_prc_executable_patterns().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_prc_executable_pattern_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigPage *ConfigPageManager::make_explicit_page(std::string const &name)
 */
static PyObject *Dtool_ConfigPageManager_make_explicit_page_152(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.make_explicit_page")) {
    return nullptr;
  }
  // 1-ConfigPage *ConfigPageManager::make_explicit_page(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ConfigPage *return_value = ((*local_this).make_explicit_page)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_explicit_page(const ConfigPageManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_make_explicit_page_152_comment =
  "C++ Interface:\n"
  "make_explicit_page(const ConfigPageManager self, str name)\n"
  "\n"
  "/**\n"
  " * Creates and returns a new, empty ConfigPage.  This page will be stacked on\n"
  " * top of any pages that were created before; it may shadow variable\n"
  " * declarations that are defined in previous pages.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_make_explicit_page_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPageManager::delete_explicit_page(ConfigPage *page)
 */
static PyObject *Dtool_ConfigPageManager_delete_explicit_page_153(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.delete_explicit_page")) {
    return nullptr;
  }
  // 1-bool ConfigPageManager::delete_explicit_page(ConfigPage *page)
  ConfigPage *arg_this = (ConfigPage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigPage, 1, "ConfigPageManager.delete_explicit_page", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).delete_explicit_page)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_explicit_page(const ConfigPageManager self, ConfigPage page)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_delete_explicit_page_153_comment =
  "C++ Interface:\n"
  "delete_explicit_page(const ConfigPageManager self, ConfigPage page)\n"
  "\n"
  "/**\n"
  " * Removes a previously-constructed ConfigPage from the set of active pages,\n"
  " * and deletes it.  The ConfigPage object is no longer valid after this call.\n"
  " * Returns true if the page is successfully deleted, or false if it was\n"
  " * unknown (which should never happen if the page was legitimately\n"
  " * constructed).\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_delete_explicit_page_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_implicit_pages(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_implicit_pages_154(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_implicit_pages(void) const
  std::size_t return_value = ((*(const ConfigPageManager*)local_this).get_num_implicit_pages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_implicit_pages_154_comment =
  "C++ Interface:\n"
  "get_num_implicit_pages(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of implicitly-loaded ConfigPages in the world.\n"
  " * These represent files that were automatically discovered on the disk as\n"
  " * .prc files.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_implicit_pages_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigPage *ConfigPageManager::get_implicit_page(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_implicit_page_155(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline ConfigPage *ConfigPageManager::get_implicit_page(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigPage *return_value = ((*(const ConfigPageManager*)local_this).get_implicit_page)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_implicit_page(ConfigPageManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_implicit_page_155_comment =
  "C++ Interface:\n"
  "get_implicit_page(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth implicit ConfigPage in the world.  See\n"
  " * get_num_implicit_pages().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_implicit_page_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_explicit_pages(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_explicit_pages_156(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_explicit_pages(void) const
  std::size_t return_value = ((*(const ConfigPageManager*)local_this).get_num_explicit_pages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_explicit_pages_156_comment =
  "C++ Interface:\n"
  "get_num_explicit_pages(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of explicitly-loaded ConfigPages in the world.\n"
  " * These represent pages that were loaded dynamically at runtime by explicit\n"
  " * calls to ConfigPageManager::make_explicit_page().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_explicit_pages_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigPage *ConfigPageManager::get_explicit_page(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_explicit_page_157(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-inline ConfigPage *ConfigPageManager::get_explicit_page(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigPage *return_value = ((*(const ConfigPageManager*)local_this).get_explicit_page)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_explicit_page(ConfigPageManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_explicit_page_157_comment =
  "C++ Interface:\n"
  "get_explicit_page(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth explicit ConfigPage in the world.  See\n"
  " * get_num_explicit_pages().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_explicit_page_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPageManager::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigPageManager_output_158(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-void ConfigPageManager::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigPageManager.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigPageManager*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigPageManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_output_158_comment =
  "C++ Interface:\n"
  "output(ConfigPageManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_output_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigPageManager::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigPageManager_write_159(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigPageManager)) {
    return nullptr;
  }
  // 1-void ConfigPageManager::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigPageManager.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigPageManager*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigPageManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_write_159_comment =
  "C++ Interface:\n"
  "write(ConfigPageManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_write_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConfigPageManager *ConfigPageManager::get_global_ptr(void)
 */
static PyObject *Dtool_ConfigPageManager_get_global_ptr_160(PyObject *, PyObject *) {
  // 1-static ConfigPageManager *ConfigPageManager::get_global_ptr(void)
  ConfigPageManager *return_value = (ConfigPageManager::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPageManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_global_ptr_160_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_global_ptr_160_comment = nullptr;
#endif

static int Dtool_Init_ConfigPageManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigPageManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigPageManager) {
    printf("ConfigPageManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigPageManager *local_this = (ConfigPageManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigPageManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigPageManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigPageManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigPageManager*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableManager
 */
/**
 * Python function wrapper for:
 * ConfigVariableCore *ConfigVariableManager::make_variable(std::string const &name)
 */
static PyObject *Dtool_ConfigVariableManager_make_variable_162(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableManager, (void **)&local_this, "ConfigVariableManager.make_variable")) {
    return nullptr;
  }
  // 1-ConfigVariableCore *ConfigVariableManager::make_variable(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ConfigVariableCore *return_value = ((*local_this).make_variable)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_variable(const ConfigVariableManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_make_variable_162_comment =
  "C++ Interface:\n"
  "make_variable(const ConfigVariableManager self, str name)\n"
  "\n"
  "/**\n"
  " * Creates and returns a new, undefined ConfigVariableCore with the indicated\n"
  " * name; or if a variable with this name has already been created, returns\n"
  " * that one instead.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_make_variable_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigVariableCore *ConfigVariableManager::make_variable_template(std::string const &pattern, ConfigFlags::ValueType type, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static PyObject *Dtool_ConfigVariableManager_make_variable_template_163(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableManager, (void **)&local_this, "ConfigVariableManager.make_variable_template")) {
    return nullptr;
  }
  // 1-ConfigVariableCore *ConfigVariableManager::make_variable_template(std::string const &pattern, ConfigFlags::ValueType type, std::string const &default_value, std::string const &description = string(), int flags = 0)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  const char *param4_str = "";
  Py_ssize_t param4_len = 0;
  int param5 = 0;
  static const char *keyword_list[] = {"pattern", "type", "default_value", "description", "flags", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#is#|s#i:make_variable_template", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3_str, &param3_len, &param4_str, &param4_len, &param5)) {
    ConfigVariableCore *return_value = ((*local_this).make_variable_template)(std::string(param1_str, param1_len), (ConfigFlags::ValueType)param2, std::string(param3_str, param3_len), std::string(param4_str, param4_len), (int)param5);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_variable_template(const ConfigVariableManager self, str pattern, int type, str default_value, str description, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_make_variable_template_163_comment =
  "C++ Interface:\n"
  "make_variable_template(const ConfigVariableManager self, str pattern, int type, str default_value, str description, int flags)\n"
  "\n"
  "/**\n"
  " * Defines a variable \"template\" to match against dynamically-defined\n"
  " * variables that may or may not be created in the future.\n"
  " *\n"
  " * The template consists of a glob pattern, e.g.  \"notify-level-*\", which will\n"
  " * be tested against any config variable passed to a future call to\n"
  " * make_variable().  If the pattern matches, the returned ConfigVariableCore\n"
  " * is copied to define the new variable, instead of creating a default, empty\n"
  " * one.\n"
  " *\n"
  " * This is useful to pre-specify default values for a family of variables that\n"
  " * all have similar properties, and all may not be created at the same time.\n"
  " * It is especially useful to avoid cluttering up the list of available\n"
  " * variables with user-declared variables that have not been defined yet by\n"
  " * the application (e.g.  \"egg-object-type-*\").\n"
  " *\n"
  " * This method basically pre-defines all variables that match the specified\n"
  " * glob pattern.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_make_variable_template_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableManager::get_num_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_get_num_variables_164(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableManager::get_num_variables(void) const
  std::size_t return_value = ((*(const ConfigVariableManager*)local_this).get_num_variables)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_num_variables_164_comment =
  "C++ Interface:\n"
  "get_num_variables(ConfigVariableManager self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of active ConfigVariableCores in the world.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_get_num_variables_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariableCore *ConfigVariableManager::get_variable(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableManager_get_variable_165(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-inline ConfigVariableCore *ConfigVariableManager::get_variable(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConfigVariableCore *return_value = ((*(const ConfigVariableManager*)local_this).get_variable)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable(ConfigVariableManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_variable_165_comment =
  "C++ Interface:\n"
  "get_variable(ConfigVariableManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth active ConfigVariableCore in the world.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_get_variable_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string ConfigVariableManager::get_variable_name(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableManager_get_variable_name_167(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-std::string ConfigVariableManager::get_variable_name(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigVariableManager*)local_this).get_variable_name)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable_name(ConfigVariableManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_variable_name_167_comment =
  "C++ Interface:\n"
  "get_variable_name(ConfigVariableManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth active ConfigVariable in the list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_get_variable_name_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConfigVariableManager::is_variable_used(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableManager_is_variable_used_168(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-bool ConfigVariableManager::is_variable_used(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigVariableManager*)local_this).is_variable_used)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_variable_used(ConfigVariableManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_is_variable_used_168_comment =
  "C++ Interface:\n"
  "is_variable_used(ConfigVariableManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth active ConfigVariable in the list has been used by\n"
  " * code, false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_is_variable_used_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableManager_output_170(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-void ConfigVariableManager::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableManager.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableManager*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_output_170_comment =
  "C++ Interface:\n"
  "output(ConfigVariableManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_output_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableManager_write_171(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-void ConfigVariableManager::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableManager.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableManager*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_write_171_comment =
  "C++ Interface:\n"
  "write(ConfigVariableManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_write_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::write_prc_variables(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableManager_write_prc_variables_172(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-void ConfigVariableManager::write_prc_variables(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableManager.write_prc_variables", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableManager*)local_this).write_prc_variables)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_prc_variables(ConfigVariableManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_write_prc_variables_172_comment =
  "C++ Interface:\n"
  "write_prc_variables(ConfigVariableManager self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes all of the prc-set config variables, as they appear in a prc file\n"
  " * somewhere, one per line, very concisely.  This lists the dominant value in\n"
  " * the prc file; it does not list shadowed values, and it does not list\n"
  " * locally-set values.\n"
  " *\n"
  " * This is mainly intended for generating a hash of the input config file\n"
  " * state.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_write_prc_variables_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::list_unused_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_list_unused_variables_173(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-void ConfigVariableManager::list_unused_variables(void) const
  ((*(const ConfigVariableManager*)local_this).list_unused_variables)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_list_unused_variables_173_comment =
  "C++ Interface:\n"
  "list_unused_variables(ConfigVariableManager self)\n"
  "\n"
  "/**\n"
  " * Writes a list of all the variables that have been defined in a prc file\n"
  " * without having been declared somewhere in code.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_list_unused_variables_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::list_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_list_variables_174(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-void ConfigVariableManager::list_variables(void) const
  ((*(const ConfigVariableManager*)local_this).list_variables)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_list_variables_174_comment =
  "C++ Interface:\n"
  "list_variables(ConfigVariableManager self)\n"
  "\n"
  "/**\n"
  " * Writes a list of all the variables that have been declared somewhere in\n"
  " * code, along with a brief description.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_list_variables_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::list_dynamic_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_list_dynamic_variables_175(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableManager)) {
    return nullptr;
  }
  // 1-void ConfigVariableManager::list_dynamic_variables(void) const
  ((*(const ConfigVariableManager*)local_this).list_dynamic_variables)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_list_dynamic_variables_175_comment =
  "C++ Interface:\n"
  "list_dynamic_variables(ConfigVariableManager self)\n"
  "\n"
  "/**\n"
  " * Writes a list of all the \"dynamic\" variables that have been declared\n"
  " * somewhere in code, along with a brief description.  This is a (usually\n"
  " * large) list of config variables that are declared with a generated variable\n"
  " * name.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_list_dynamic_variables_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConfigVariableManager *ConfigVariableManager::get_global_ptr(void)
 */
static PyObject *Dtool_ConfigVariableManager_get_global_ptr_176(PyObject *, PyObject *) {
  // 1-static ConfigVariableManager *ConfigVariableManager::get_global_ptr(void)
  ConfigVariableManager *return_value = (ConfigVariableManager::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_global_ptr_176_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_get_global_ptr_176_comment = nullptr;
#endif

/**
 * sequence length function for property ConfigVariableManager::variables
 */
static Py_ssize_t Dtool_ConfigVariableManager_variables_Len(PyObject *self) {
  ConfigVariableManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_variables)();
}

/**
 * sequence getter for property ConfigVariableManager::variables
 */
static PyObject *Dtool_ConfigVariableManager_variables_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_variables)()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableManager.variables[] index out of range");
    return nullptr;
  }
  // 1-inline ConfigVariableCore *ConfigVariableManager::get_variable(std::size_t n) const
  ConfigVariableCore *return_value = ((*(const ConfigVariableManager*)local_this).get_variable)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable(ConfigVariableManager self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableManager_variables_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConfigVariableManager.variables");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConfigVariableManager_variables_Len;
    wrap->_getitem_func = &Dtool_ConfigVariableManager_variables_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_ConfigVariableManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableManager_get_variables(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_variables)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableManager_get_variable_165(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConfigVariableManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableManager) {
    printf("ConfigVariableManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableManager *local_this = (ConfigVariableManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableBase
 */
/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableBase::get_name(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_name_178(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigVariableBase::get_name(void) const
  std::string const &return_value = ((*(const ConfigVariableBase*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_name_178_comment =
  "C++ Interface:\n"
  "get_name(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_name_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_value_type_179(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
  ConfigFlags::ValueType return_value = ((*(const ConfigVariableBase*)local_this).get_value_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_value_type_179_comment =
  "C++ Interface:\n"
  "get_value_type(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the stated type of this variable.  This should be VT_list, unless a\n"
  " * later variable declaration has changed it.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_value_type_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableBase::get_description(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_description_180(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigVariableBase::get_description(void) const
  std::string const &return_value = ((*(const ConfigVariableBase*)local_this).get_description)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_description_180_comment =
  "C++ Interface:\n"
  "get_description(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the brief description of this variable, if it has been defined.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_description_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableBase::get_flags(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_flags_181(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline int ConfigVariableBase::get_flags(void) const
  int return_value = ((*(const ConfigVariableBase*)local_this).get_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_flags_181_comment =
  "C++ Interface:\n"
  "get_flags(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the flags value as set by set_flags().  This includes the trust\n"
  " * level and some other settings.  See the individual methods is_closed(),\n"
  " * get_trust_level(), etc.  to pull out the semantic meaning of these flags\n"
  " * individually.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_flags_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::is_closed(void) const
 */
static PyObject *Dtool_ConfigVariableBase_is_closed_182(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBase::is_closed(void) const
  bool return_value = ((*(const ConfigVariableBase*)local_this).is_closed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_is_closed_182_comment =
  "C++ Interface:\n"
  "is_closed(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable is not trusted by any prc file (and hence\n"
  " * cannot be modified from its compiled-in default value), or false for the\n"
  " * normal case, in which the variable can be modified by any prc file at or\n"
  " * above its trust level (see get_trust_level()).\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_is_closed_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableBase::get_trust_level(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_trust_level_183(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline int ConfigVariableBase::get_trust_level(void) const
  int return_value = ((*(const ConfigVariableBase*)local_this).get_trust_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_trust_level_183_comment =
  "C++ Interface:\n"
  "get_trust_level(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum trust_level a prc file must demonstrate in order to\n"
  " * redefine the value for this variable.  Arguably, this should be called the\n"
  " * \"mistrust level\", since the larger the value, the more suspicious we are of\n"
  " * prc files.  This value is not used if is_closed() returns true, which\n"
  " * indicates no file may be trusted.\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_trust_level_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::is_dynamic(void) const
 */
static PyObject *Dtool_ConfigVariableBase_is_dynamic_184(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBase::is_dynamic(void) const
  bool return_value = ((*(const ConfigVariableBase*)local_this).is_dynamic)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_is_dynamic_184_comment =
  "C++ Interface:\n"
  "is_dynamic(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable was indicated as \"dynamic\" by its constructor,\n"
  " * indicating that its name was dynamically generated, possibly from a large\n"
  " * pool, and it should not be listed along with the other variables.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_is_dynamic_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::clear_local_value(void)
 */
static PyObject *Dtool_ConfigVariableBase_clear_local_value_191(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBase, (void **)&local_this, "ConfigVariableBase.clear_local_value")) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBase::clear_local_value(void)
  bool return_value = ((*local_this).clear_local_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_clear_local_value_191_comment =
  "C++ Interface:\n"
  "clear_local_value(const ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Removes the local value defined for this variable, and allows its value to\n"
  " * be once again retrieved from the .prc files.\n"
  " *\n"
  " * Returns true if the value was successfully removed, false if it did not\n"
  " * exist in the first place.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_clear_local_value_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::has_local_value(void) const
 */
static PyObject *Dtool_ConfigVariableBase_has_local_value_192(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBase::has_local_value(void) const
  bool return_value = ((*(const ConfigVariableBase*)local_this).has_local_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_has_local_value_192_comment =
  "C++ Interface:\n"
  "has_local_value(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this variable's value has been shadowed by a local\n"
  " * assignment (as created via make_local_value()), or false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_has_local_value_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::has_value(void) const
 */
static PyObject *Dtool_ConfigVariableBase_has_value_193(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBase::has_value(void) const
  bool return_value = ((*(const ConfigVariableBase*)local_this).has_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_has_value_193_comment =
  "C++ Interface:\n"
  "has_value(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this variable has an explicit value, either from a prc file\n"
  " * or locally set, or false if variable has its default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_has_value_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBase::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableBase_output_194(PyObject *self, PyObject *arg) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline void ConfigVariableBase::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableBase*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_output_194_comment =
  "C++ Interface:\n"
  "output(ConfigVariableBase self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_output_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBase::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableBase_write_195(PyObject *self, PyObject *arg) {
  ConfigVariableBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBase)) {
    return nullptr;
  }
  // 1-inline void ConfigVariableBase::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableBase.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableBase*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_write_195_comment =
  "C++ Interface:\n"
  "write(ConfigVariableBase self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_write_195_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableBase_name_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ConfigVariableBase::get_name(void) const
  std::string const &return_value = ((*(const ConfigVariableBase*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_value_type_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
  ConfigFlags::ValueType return_value = ((*(const ConfigVariableBase*)local_this).get_value_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_description_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ConfigVariableBase::get_description(void) const
  std::string const &return_value = ((*(const ConfigVariableBase*)local_this).get_description)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_closed_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigVariableBase::is_closed(void) const
  bool return_value = ((*(const ConfigVariableBase*)local_this).is_closed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_trust_level_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ConfigVariableBase::get_trust_level(void) const
  int return_value = ((*(const ConfigVariableBase*)local_this).get_trust_level)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_dynamic_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigVariableBase::is_dynamic(void) const
  bool return_value = ((*(const ConfigVariableBase*)local_this).is_dynamic)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ConfigVariableBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableBase) {
    printf("ConfigVariableBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableBase *local_this = (ConfigVariableBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableBase*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariable
 */
/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariable::get_string_value(void) const
 */
static PyObject *Dtool_ConfigVariable_get_string_value_199(PyObject *self, PyObject *) {
  ConfigVariable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariable)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigVariable::get_string_value(void) const
  std::string const &return_value = ((*(const ConfigVariable*)local_this).get_string_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_get_string_value_199_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigVariable self)\n"
  "\n"
  "/**\n"
  " * Returns the toplevel value of the variable, formatted as a string.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_get_string_value_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariable::set_string_value(std::string const &value)
 */
static PyObject *Dtool_ConfigVariable_set_string_value_200(PyObject *self, PyObject *arg) {
  ConfigVariable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariable, (void **)&local_this, "ConfigVariable.set_string_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariable::set_string_value(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_string_value)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_string_value(const ConfigVariable self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_set_string_value_200_comment =
  "C++ Interface:\n"
  "set_string_value(const ConfigVariable self, str value)\n"
  "\n"
  "/**\n"
  " * Changes the value assigned to this variable.  This creates a local value\n"
  " * that shadows any values defined in the .prc files, until\n"
  " * clear_local_value() is called.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_set_string_value_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariable::clear_value(void)
 */
static PyObject *Dtool_ConfigVariable_clear_value_201(PyObject *self, PyObject *) {
  ConfigVariable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariable, (void **)&local_this, "ConfigVariable.clear_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariable::clear_value(void)
  ((*local_this).clear_value)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_clear_value_201_comment =
  "C++ Interface:\n"
  "clear_value(const ConfigVariable self)\n"
  "\n"
  "/**\n"
  " * Removes the value assigned to this variable, and lets its original value\n"
  " * (as read from the prc files) show through.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_clear_value_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariable::get_num_words(void) const
 */
static PyObject *Dtool_ConfigVariable_get_num_words_202(PyObject *self, PyObject *) {
  ConfigVariable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariable)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariable::get_num_words(void) const
  std::size_t return_value = ((*(const ConfigVariable*)local_this).get_num_words)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_get_num_words_202_comment =
  "C++ Interface:\n"
  "get_num_words(ConfigVariable self)\n"
  "\n"
  "/**\n"
  " * Returns the number of words in the variable's value.  A word is defined as\n"
  " * a sequence of non-whitespace characters delimited by whitespace.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_get_num_words_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariable::ConfigVariable(ConfigVariable const &) = default
 * inline explicit ConfigVariable::ConfigVariable(std::string const &name)
 */
static int Dtool_Init_ConfigVariable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariable() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConfigVariable::ConfigVariable(ConfigVariable const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      ConfigVariable const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariable);
      if (param0_this != nullptr) {
        ConfigVariable *return_value = new ConfigVariable(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariable, true, false);
      }
    }
  }

  {
    // -2 inline explicit ConfigVariable::ConfigVariable(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariable", (char **)keyword_list, &param0_str, &param0_len)) {
      ConfigVariable *return_value = new ConfigVariable(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariable, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline ConfigVariable::ConfigVariable(ConfigVariable const &) = default
  // No coercion possible: inline explicit ConfigVariable::ConfigVariable(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariable(const ConfigVariable param0)\n"
      "ConfigVariable(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariable) {
    printf("ConfigVariable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariable *local_this = (ConfigVariable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariable*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableBool
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableBool::operator =(bool value)
 */
static PyObject *Dtool_ConfigVariableBool_operator_205(PyObject *self, PyObject *arg) {
  ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.assign")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableBool::operator =(bool value)
  ((*local_this).operator =)((PyObject_IsTrue(arg) != 0));
  ConfigVariableBool *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableBool, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableBool self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_operator_205_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableBool self, bool value)\n";
#else
static const char *Dtool_ConfigVariableBool_operator_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBool::set_value(bool value)
 */
static PyObject *Dtool_ConfigVariableBool_set_value_209(PyObject *self, PyObject *arg) {
  ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.set_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableBool::set_value(bool value)
  ((*local_this).set_value)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableBool self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_set_value_209_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableBool self, bool value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_set_value_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBool::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableBool_get_value_210(PyObject *self, PyObject *) {
  ConfigVariableBool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBool)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBool::get_value(void) const
  bool return_value = ((*(const ConfigVariableBool*)local_this).get_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_get_value_210_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableBool self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_get_value_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBool::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableBool_get_default_value_211(PyObject *self, PyObject *) {
  ConfigVariableBool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBool)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBool::get_default_value(void) const
  bool return_value = ((*(const ConfigVariableBool*)local_this).get_default_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_get_default_value_211_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableBool self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_get_default_value_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBool::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableBool_get_word_214(PyObject *self, PyObject *arg) {
  ConfigVariableBool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableBool)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableBool::get_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const ConfigVariableBool*)local_this).get_word)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableBool self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_get_word_214_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableBool self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_get_word_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBool::set_word(std::size_t n, bool value)
 */
static PyObject *Dtool_ConfigVariableBool_set_word_215(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.set_word")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableBool::set_word(std::size_t n, bool value)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_word)((std::size_t)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableBool self, int n, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_set_word_215_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableBool self, int n, bool value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_set_word_215_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableBool_value_Getter(PyObject *self, void *) {
  const ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigVariableBool::get_value(void) const
  bool return_value = ((*(const ConfigVariableBool*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableBool_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableBool::set_value(bool value)
  ((*local_this).set_value)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableBool self, bool value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableBool_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool ConfigVariableBool::get_default_value(void) const
  bool return_value = ((*(const ConfigVariableBool*)local_this).get_default_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableBool::ConfigVariableBool(ConfigVariableBool const &) = default
 * inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
 * inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableBool(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(ConfigVariableBool const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ConfigVariableBool const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariableBool);
          if (param0_this != nullptr) {
            ConfigVariableBool *return_value = new ConfigVariableBool(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
          }
        }
      }

      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableBool", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableBool::ConfigVariableBool(ConfigVariableBool const &) = default
      // No coercion possible: inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableBool", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O|s#i:ConfigVariableBool", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableBool() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableBool(const ConfigVariableBool param0)\n"
      "ConfigVariableBool(str name)\n"
      "ConfigVariableBool(str name, str default_value, str description, int flags)\n"
      "ConfigVariableBool(str name, bool default_value, str description, int flags)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableBool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableBool) {
    printf("ConfigVariableBool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableBool *local_this = (ConfigVariableBool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableBool) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableBool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBool) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableBool*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableBool*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableBool*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableDouble
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableDouble::operator =(double value)
 */
static PyObject *Dtool_ConfigVariableDouble_operator_219(PyObject *self, PyObject *arg) {
  ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.assign")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableDouble::operator =(double value)
  if (PyNumber_Check(arg)) {
    ((*local_this).operator =)(PyFloat_AsDouble(arg));
    ConfigVariableDouble *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableDouble, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableDouble self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_operator_219_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableDouble self, double value)\n";
#else
static const char *Dtool_ConfigVariableDouble_operator_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableDouble::set_value(double value)
 */
static PyObject *Dtool_ConfigVariableDouble_set_value_223(PyObject *self, PyObject *arg) {
  ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.set_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableDouble::set_value(double value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_value)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableDouble self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_set_value_223_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableDouble self, double value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_set_value_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigVariableDouble::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableDouble_get_value_224(PyObject *self, PyObject *) {
  ConfigVariableDouble *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableDouble)) {
    return nullptr;
  }
  // 1-inline double ConfigVariableDouble::get_value(void) const
  double return_value = ((*(const ConfigVariableDouble*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_get_value_224_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableDouble self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_get_value_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigVariableDouble::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableDouble_get_default_value_225(PyObject *self, PyObject *) {
  ConfigVariableDouble *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableDouble)) {
    return nullptr;
  }
  // 1-inline double ConfigVariableDouble::get_default_value(void) const
  double return_value = ((*(const ConfigVariableDouble*)local_this).get_default_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_get_default_value_225_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableDouble self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_get_default_value_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigVariableDouble::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableDouble_get_word_229(PyObject *self, PyObject *arg) {
  ConfigVariableDouble *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableDouble)) {
    return nullptr;
  }
  // 1-inline double ConfigVariableDouble::get_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const ConfigVariableDouble*)local_this).get_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableDouble self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_get_word_229_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableDouble self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_get_word_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableDouble::set_word(std::size_t n, double value)
 */
static PyObject *Dtool_ConfigVariableDouble_set_word_230(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.set_word")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableDouble::set_word(std::size_t n, double value)
  Py_ssize_t param1;
  double param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_word)((std::size_t)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableDouble self, int n, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_set_word_230_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableDouble self, int n, double value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_set_word_230_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableDouble_value_Getter(PyObject *self, void *) {
  const ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ConfigVariableDouble::get_value(void) const
  double return_value = ((*(const ConfigVariableDouble*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableDouble_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableDouble::set_value(double value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_value)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableDouble self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableDouble_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ConfigVariableDouble::get_default_value(void) const
  double return_value = ((*(const ConfigVariableDouble*)local_this).get_default_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableDouble::ConfigVariableDouble(ConfigVariableDouble const &) = default
 * inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
 * inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableDouble(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(ConfigVariableDouble const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ConfigVariableDouble const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariableDouble);
          if (param0_this != nullptr) {
            ConfigVariableDouble *return_value = new ConfigVariableDouble(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
          }
        }
      }

      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableDouble", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableDouble::ConfigVariableDouble(ConfigVariableDouble const &) = default
      // No coercion possible: inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableDouble", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        double param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d|s#i:ConfigVariableDouble", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), (double)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableDouble() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableDouble(const ConfigVariableDouble param0)\n"
      "ConfigVariableDouble(str name)\n"
      "ConfigVariableDouble(str name, str default_value, str description, int flags)\n"
      "ConfigVariableDouble(str name, double default_value, str description, int flags)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableDouble(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableDouble) {
    printf("ConfigVariableDouble ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableDouble *local_this = (ConfigVariableDouble *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableDouble) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableDouble(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableDouble) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableDouble*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableDouble*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableDouble*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableFilename
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableFilename::operator =(Filename const &value)
 */
static PyObject *Dtool_ConfigVariableFilename_operator_234(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.assign")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableFilename::operator =(Filename const &value)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableFilename.assign", "Filename");
  }
  ((*local_this).operator =)(*arg_this);
  ConfigVariableFilename *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableFilename, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableFilename self, const Filename value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_operator_234_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableFilename self, const Filename value)\n";
#else
static const char *Dtool_ConfigVariableFilename_operator_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline char const *ConfigVariableFilename::c_str(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_c_str_236(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline char const *ConfigVariableFilename::c_str(void) const
  char const *return_value = ((*(const ConfigVariableFilename*)local_this).c_str)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_c_str_236_comment =
  "C++ Interface:\n"
  "c_str(ConfigVariableFilename self)\n"
  "\n"
  "// These methods help the ConfigVariableFilename act like a Filename object.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_c_str_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableFilename::empty(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_empty_237(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableFilename::empty(void) const
  bool return_value = ((*(const ConfigVariableFilename*)local_this).empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_empty_237_comment =
  "C++ Interface:\n"
  "empty(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_empty_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableFilename::length(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_length_238(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableFilename::length(void) const
  std::size_t return_value = ((*(const ConfigVariableFilename*)local_this).length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_length_238_comment =
  "C++ Interface:\n"
  "length(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_length_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_fullpath(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_fullpath_240(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableFilename::get_fullpath(void) const
  std::string return_value = ((*(const ConfigVariableFilename*)local_this).get_fullpath)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_fullpath_240_comment =
  "C++ Interface:\n"
  "get_fullpath(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the entire filename: directory, basename, extension.  This is the\n"
  " * same thing returned by the string typecast operator, so this function is a\n"
  " * little redundant.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_fullpath_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_dirname(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_dirname_241(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableFilename::get_dirname(void) const
  std::string return_value = ((*(const ConfigVariableFilename*)local_this).get_dirname)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_dirname_241_comment =
  "C++ Interface:\n"
  "get_dirname(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the directory part of the filename.  This is everything in the\n"
  " * filename up to, but not including the rightmost slash.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_dirname_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_basename(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_basename_242(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableFilename::get_basename(void) const
  std::string return_value = ((*(const ConfigVariableFilename*)local_this).get_basename)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_basename_242_comment =
  "C++ Interface:\n"
  "get_basename(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename.  This is everything in the\n"
  " * filename after the rightmost slash, including any extensions.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_basename_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_fullpath_wo_extension(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_fullpath_wo_extension_243(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableFilename::get_fullpath_wo_extension(void) const
  std::string return_value = ((*(const ConfigVariableFilename*)local_this).get_fullpath_wo_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_fullpath_wo_extension_243_comment =
  "C++ Interface:\n"
  "get_fullpath_wo_extension(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the full filename--directory and basename parts--except for the\n"
  " * extension.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_fullpath_wo_extension_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_basename_wo_extension(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_basename_wo_extension_244(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableFilename::get_basename_wo_extension(void) const
  std::string return_value = ((*(const ConfigVariableFilename*)local_this).get_basename_wo_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_basename_wo_extension_244_comment =
  "C++ Interface:\n"
  "get_basename_wo_extension(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename, without the file extension.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_basename_wo_extension_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_extension(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_extension_245(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableFilename::get_extension(void) const
  std::string return_value = ((*(const ConfigVariableFilename*)local_this).get_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_extension_245_comment =
  "C++ Interface:\n"
  "get_extension(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the file extension.  This is everything after the rightmost dot, if\n"
  " * there is one, or the empty string if there is not.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_extension_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableFilename::set_value(Filename const &value)
 */
static PyObject *Dtool_ConfigVariableFilename_set_value_249(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.set_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableFilename::set_value(Filename const &value)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableFilename.set_value", "Filename");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableFilename self, const Filename value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_set_value_249_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableFilename self, const Filename value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_set_value_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableFilename::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_value_250(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline Filename ConfigVariableFilename::get_value(void) const
  Filename *return_value = new Filename(((*(const ConfigVariableFilename*)local_this).get_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_value_250_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_value_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableFilename::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_default_value_251(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline Filename ConfigVariableFilename::get_default_value(void) const
  Filename *return_value = new Filename(((*(const ConfigVariableFilename*)local_this).get_default_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_default_value_251_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_default_value_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableFilename::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_word_255(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline Filename ConfigVariableFilename::get_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    Filename *return_value = new Filename(((*(const ConfigVariableFilename*)local_this).get_word)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableFilename self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_word_255_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableFilename self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_word_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableFilename::set_word(std::size_t n, Filename const &value)
 */
static PyObject *Dtool_ConfigVariableFilename_set_word_256(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.set_word")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableFilename::set_word(std::size_t n, Filename const &value)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ConfigVariableFilename.set_word", "Filename");
    }
    ((*local_this).set_word)((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableFilename self, int n, const Filename value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_set_word_256_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableFilename self, int n, const Filename value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_set_word_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline operator Filename const &(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_operator_typecast_235(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableFilename)) {
    return nullptr;
  }
  // 1-inline operator Filename const &(void) const
  Filename const *return_value = &((Filename const &)*(const ConfigVariableFilename*)local_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_operator_typecast_235_comment =
  "C++ Interface:\n"
  "operator_typecast(ConfigVariableFilename self)\n";
#else
static const char *Dtool_ConfigVariableFilename_operator_typecast_235_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableFilename_value_Getter(PyObject *self, void *) {
  const ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename ConfigVariableFilename::get_value(void) const
  Filename *return_value = new Filename(((*(const ConfigVariableFilename*)local_this).get_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

static int Dtool_ConfigVariableFilename_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableFilename::set_value(Filename const &value)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableFilename.set_value", "Filename");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableFilename self, const Filename value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableFilename_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename ConfigVariableFilename::get_default_value(void) const
  Filename *return_value = new Filename(((*(const ConfigVariableFilename*)local_this).get_default_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableFilename::ConfigVariableFilename(ConfigVariableFilename const &) = default
 * inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
 * inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name, Filename const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableFilename(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableFilename::ConfigVariableFilename(ConfigVariableFilename const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ConfigVariableFilename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariableFilename);
          if (param0_this != nullptr) {
            ConfigVariableFilename *return_value = new ConfigVariableFilename(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableFilename, true, false);
          }
        }
      }

      {
        // -2 inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableFilename", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableFilename, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableFilename::ConfigVariableFilename(ConfigVariableFilename const &) = default
      // No coercion possible: inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name, Filename const &default_value, std::string const &description = string(), int flags = 0)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O|s#i:ConfigVariableFilename", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "ConfigVariableFilename.ConfigVariableFilename", "Filename");
          return -1;
        }
        ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableFilename, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableFilename() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableFilename(const ConfigVariableFilename param0)\n"
      "ConfigVariableFilename(str name)\n"
      "ConfigVariableFilename(str name, const Filename default_value, str description, int flags)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableFilename(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableFilename) {
    printf("ConfigVariableFilename ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableFilename *local_this = (ConfigVariableFilename *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableFilename) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  // inline operator Filename const &(void) const
  if (requested_type == Dtool_Ptr_Filename) {
    return (void *)(&((Filename const &)*local_this));
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableFilename(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableFilename) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableFilename*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableFilename*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableFilename*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableInt
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableInt::operator =(int value)
 */
static PyObject *Dtool_ConfigVariableInt_operator_260(PyObject *self, PyObject *arg) {
  ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.assign")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableInt::operator =(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).operator =)((int)arg_val);
    ConfigVariableInt *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableInt, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableInt self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_operator_260_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableInt self, int value)\n";
#else
static const char *Dtool_ConfigVariableInt_operator_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt::set_value(int value)
 */
static PyObject *Dtool_ConfigVariableInt_set_value_264(PyObject *self, PyObject *arg) {
  ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.set_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableInt::set_value(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_value)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_set_value_264_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableInt self, int value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_set_value_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableInt::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt_get_value_265(PyObject *self, PyObject *) {
  ConfigVariableInt *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableInt)) {
    return nullptr;
  }
  // 1-inline int ConfigVariableInt::get_value(void) const
  int return_value = ((*(const ConfigVariableInt*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_get_value_265_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableInt self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_get_value_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableInt::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt_get_default_value_266(PyObject *self, PyObject *) {
  ConfigVariableInt *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableInt)) {
    return nullptr;
  }
  // 1-inline int ConfigVariableInt::get_default_value(void) const
  int return_value = ((*(const ConfigVariableInt*)local_this).get_default_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_get_default_value_266_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableInt self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_get_default_value_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableInt::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableInt_get_word_269(PyObject *self, PyObject *arg) {
  ConfigVariableInt *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableInt)) {
    return nullptr;
  }
  // 1-inline int ConfigVariableInt::get_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const ConfigVariableInt*)local_this).get_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableInt self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_get_word_269_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableInt self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_get_word_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt::set_word(std::size_t n, int value)
 */
static PyObject *Dtool_ConfigVariableInt_set_word_270(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.set_word")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableInt::set_word(std::size_t n, int value)
  Py_ssize_t param1;
  int param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ni:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_word)((std::size_t)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableInt self, int n, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_set_word_270_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableInt self, int n, int value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_set_word_270_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableInt_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ConfigVariableInt::get_value(void) const
  int return_value = ((*(const ConfigVariableInt*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableInt_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableInt::set_value(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_value)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableInt_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ConfigVariableInt::get_default_value(void) const
  int return_value = ((*(const ConfigVariableInt*)local_this).get_default_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableInt::ConfigVariableInt(ConfigVariableInt const &) = default
 * inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
 * inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableInt(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(ConfigVariableInt const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ConfigVariableInt const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariableInt);
          if (param0_this != nullptr) {
            ConfigVariableInt *return_value = new ConfigVariableInt(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
          }
        }
      }

      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableInt", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt::ConfigVariableInt(ConfigVariableInt const &) = default
      // No coercion possible: inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableInt", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        int param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i|s#i:ConfigVariableInt", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), (int)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableInt() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableInt(const ConfigVariableInt param0)\n"
      "ConfigVariableInt(str name)\n"
      "ConfigVariableInt(str name, str default_value, str description, int flags)\n"
      "ConfigVariableInt(str name, int default_value, str description, int flags)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableInt(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableInt) {
    printf("ConfigVariableInt ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableInt *local_this = (ConfigVariableInt *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableInt) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableInt(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableInt) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableInt*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableInt*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableInt*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableInt64
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableInt64::operator =(int64_t value)
 */
static PyObject *Dtool_ConfigVariableInt64_operator_274(PyObject *self, PyObject *arg) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.assign")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableInt64::operator =(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:assign", &param1)) {
    ((*local_this).operator =)((int64_t)param1);
    ConfigVariableInt64 *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableInt64, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableInt64 self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_operator_274_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableInt64 self, long value)\n";
#else
static const char *Dtool_ConfigVariableInt64_operator_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt64::set_value(int64_t value)
 */
static PyObject *Dtool_ConfigVariableInt64_set_value_278(PyObject *self, PyObject *arg) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.set_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableInt64::set_value(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:set_value", &param1)) {
    ((*local_this).set_value)((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt64 self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_set_value_278_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableInt64 self, long value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_set_value_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigVariableInt64::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt64_get_value_279(PyObject *self, PyObject *) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableInt64)) {
    return nullptr;
  }
  // 1-inline int64_t ConfigVariableInt64::get_value(void) const
  int64_t return_value = ((*(const ConfigVariableInt64*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_get_value_279_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableInt64 self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_get_value_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigVariableInt64::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt64_get_default_value_280(PyObject *self, PyObject *) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableInt64)) {
    return nullptr;
  }
  // 1-inline int64_t ConfigVariableInt64::get_default_value(void) const
  int64_t return_value = ((*(const ConfigVariableInt64*)local_this).get_default_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_get_default_value_280_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableInt64 self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_get_default_value_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigVariableInt64::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableInt64_get_word_285(PyObject *self, PyObject *arg) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableInt64)) {
    return nullptr;
  }
  // 1-inline int64_t ConfigVariableInt64::get_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int64_t return_value = ((*(const ConfigVariableInt64*)local_this).get_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableInt64 self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_get_word_285_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableInt64 self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_get_word_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt64::set_word(std::size_t n, int64_t value)
 */
static PyObject *Dtool_ConfigVariableInt64_set_word_286(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.set_word")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableInt64::set_word(std::size_t n, int64_t value)
  Py_ssize_t param1;
  PY_LONG_LONG param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nL:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_word)((std::size_t)param1, (int64_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableInt64 self, int n, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_set_word_286_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableInt64 self, int n, long value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_set_word_286_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableInt64_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int64_t ConfigVariableInt64::get_value(void) const
  int64_t return_value = ((*(const ConfigVariableInt64*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableInt64_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableInt64::set_value(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:set_value", &param1)) {
    ((*local_this).set_value)((int64_t)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt64 self, long value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableInt64_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int64_t ConfigVariableInt64::get_default_value(void) const
  int64_t return_value = ((*(const ConfigVariableInt64*)local_this).get_default_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableInt64::ConfigVariableInt64(ConfigVariableInt64 const &) = default
 * inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
 * inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableInt64(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(ConfigVariableInt64 const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ConfigVariableInt64 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariableInt64);
          if (param0_this != nullptr) {
            ConfigVariableInt64 *return_value = new ConfigVariableInt64(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
          }
        }
      }

      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableInt64", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt64::ConfigVariableInt64(ConfigVariableInt64 const &) = default
      // No coercion possible: inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableInt64", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PY_LONG_LONG param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#L|s#i:ConfigVariableInt64", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), (int64_t)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableInt64() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableInt64(const ConfigVariableInt64 param0)\n"
      "ConfigVariableInt64(str name)\n"
      "ConfigVariableInt64(str name, str default_value, str description, int flags)\n"
      "ConfigVariableInt64(str name, long default_value, str description, int flags)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableInt64(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableInt64) {
    printf("ConfigVariableInt64 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableInt64 *local_this = (ConfigVariableInt64 *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableInt64) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableInt64(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableInt64) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableInt64*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableInt64*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableInt64*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableList
 */
/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableList::get_num_values(void) const
 */
static PyObject *Dtool_ConfigVariableList_get_num_values_291(PyObject *self, PyObject *) {
  ConfigVariableList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableList)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableList::get_num_values(void) const
  std::size_t return_value = ((*(const ConfigVariableList*)local_this).get_num_values)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_num_values_291_comment =
  "C++ Interface:\n"
  "get_num_values(ConfigVariableList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of values in the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_num_values_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableList::get_string_value(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableList_get_string_value_292(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableList)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableList::get_string_value(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigVariableList*)local_this).get_string_value)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_string_value(ConfigVariableList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_string_value_292_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigVariableList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth value of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_string_value_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableList::get_num_unique_values(void) const
 */
static PyObject *Dtool_ConfigVariableList_get_num_unique_values_293(PyObject *self, PyObject *) {
  ConfigVariableList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableList)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableList::get_num_unique_values(void) const
  std::size_t return_value = ((*(const ConfigVariableList*)local_this).get_num_unique_values)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_num_unique_values_293_comment =
  "C++ Interface:\n"
  "get_num_unique_values(ConfigVariableList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of unique values in the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_num_unique_values_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableList::get_unique_value(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableList_get_unique_value_294(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableList)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableList::get_unique_value(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigVariableList*)local_this).get_unique_value)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unique_value(ConfigVariableList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_unique_value_294_comment =
  "C++ Interface:\n"
  "get_unique_value(ConfigVariableList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth unique value of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_unique_value_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableList::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableList_output_297(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableList)) {
    return nullptr;
  }
  // 1-void ConfigVariableList::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableList.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableList*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableList self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_output_297_comment =
  "C++ Interface:\n"
  "output(ConfigVariableList self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_output_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableList::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableList_write_298(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableList)) {
    return nullptr;
  }
  // 1-void ConfigVariableList::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableList.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableList*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableList self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_write_298_comment =
  "C++ Interface:\n"
  "write(ConfigVariableList self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_write_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariableList::ConfigVariableList(ConfigVariableList const &) = default
 * inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableList(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description = string(), int flags = 0)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    const char *param1_str = "";
    Py_ssize_t param1_len = 0;
    int param2 = 0;
    static const char *keyword_list[] = {"name", "description", "flags", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#i:ConfigVariableList", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
      ConfigVariableList *return_value = new ConfigVariableList(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableList, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConfigVariableList::ConfigVariableList(ConfigVariableList const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      ConfigVariableList const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariableList);
      if (param0_this != nullptr) {
        ConfigVariableList *return_value = new ConfigVariableList(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableList, true, false);
      }
    }
  }

  // No coercion possible: inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description = string(), int flags = 0)
  // No coercion possible: inline ConfigVariableList::ConfigVariableList(ConfigVariableList const &) = default
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableList(str name, str description, int flags)\n"
      "ConfigVariableList(const ConfigVariableList param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableList) {
    printf("ConfigVariableList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableList *local_this = (ConfigVariableList *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableList) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableList) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableList*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableList*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableSearchPath
 */
/**
 * Python function wrapper for:
 * inline DSearchPath ConfigVariableSearchPath::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_value_303(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline DSearchPath ConfigVariableSearchPath::get_value(void) const
  DSearchPath *return_value = new DSearchPath(((*(const ConfigVariableSearchPath*)local_this).get_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_value_303_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_value_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_default_value_304(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
  DSearchPath const *return_value = &(((*(const ConfigVariableSearchPath*)local_this).get_default_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_default_value_304_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_default_value_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableSearchPath::clear_local_value(void)
 */
static PyObject *Dtool_ConfigVariableSearchPath_clear_local_value_309(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.clear_local_value")) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableSearchPath::clear_local_value(void)
  bool return_value = ((*local_this).clear_local_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_clear_local_value_309_comment =
  "C++ Interface:\n"
  "clear_local_value(const ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Removes all the directories locally added to the search list, and restores\n"
  " * it to its original form.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_clear_local_value_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::clear(void)
 */
static PyObject *Dtool_ConfigVariableSearchPath_clear_310(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.clear")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableSearchPath::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_clear_310_comment =
  "C++ Interface:\n"
  "clear(const ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Removes all the directories locally added to the search list, and restores\n"
  " * it to its original form.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_clear_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::append_directory(Filename const &directory)
 */
static PyObject *Dtool_ConfigVariableSearchPath_append_directory_311(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.append_directory")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableSearchPath::append_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.append_directory", "Filename");
  }
  ((*local_this).append_directory)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_directory(const ConfigVariableSearchPath self, const Filename directory)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_append_directory_311_comment =
  "C++ Interface:\n"
  "append_directory(const ConfigVariableSearchPath self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Adds a new directory to the end of the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_append_directory_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::prepend_directory(Filename const &directory)
 */
static PyObject *Dtool_ConfigVariableSearchPath_prepend_directory_312(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.prepend_directory")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableSearchPath::prepend_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.prepend_directory", "Filename");
  }
  ((*local_this).prepend_directory)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_directory(const ConfigVariableSearchPath self, const Filename directory)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_prepend_directory_312_comment =
  "C++ Interface:\n"
  "prepend_directory(const ConfigVariableSearchPath self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Adds a new directory to the front of the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_prepend_directory_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::append_path(DSearchPath const &path)
 * inline void ConfigVariableSearchPath::append_path(std::string const &path, std::string const &separator = string())
 */
static PyObject *Dtool_ConfigVariableSearchPath_append_path_313(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.append_path")) {
    return nullptr;
  }
  {
    // -2 inline void ConfigVariableSearchPath::append_path(std::string const &path, std::string const &separator = string())
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"path", "separator", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:append_path", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      ((*local_this).append_path)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void ConfigVariableSearchPath::append_path(std::string const &path, std::string const &separator = string())
  {
    // -2 inline void ConfigVariableSearchPath::append_path(DSearchPath const &path)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "path")) {
      DSearchPath param1_local;
      DSearchPath const *param1_this = Dtool_Coerce_DSearchPath(param1, param1_local);
      if ((param1_this != nullptr)) {
        ((*local_this).append_path)(*param1_this);
        return Dtool_Return_None();
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_path(const ConfigVariableSearchPath self, str path, str separator)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_append_path_313_comment =
  "C++ Interface:\n"
  "append_path(const ConfigVariableSearchPath self, str path, str separator)\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the end of the\n"
  " * search list.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the end of the\n"
  " * search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_append_path_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::prepend_path(DSearchPath const &path)
 */
static PyObject *Dtool_ConfigVariableSearchPath_prepend_path_314(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.prepend_path")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableSearchPath::prepend_path(DSearchPath const &path)
  DSearchPath arg_local;
  DSearchPath const *arg_this = Dtool_Coerce_DSearchPath(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.prepend_path", "DSearchPath");
  }
  ((*local_this).prepend_path)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_path(const ConfigVariableSearchPath self, const DSearchPath path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_prepend_path_314_comment =
  "C++ Interface:\n"
  "prepend_path(const ConfigVariableSearchPath self, const DSearchPath path)\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the beginning of\n"
  " * the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_prepend_path_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableSearchPath::is_empty(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_is_empty_315(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableSearchPath::is_empty(void) const
  bool return_value = ((*(const ConfigVariableSearchPath*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_is_empty_315_comment =
  "C++ Interface:\n"
  "is_empty(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Returns true if the search list is empty, false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_is_empty_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableSearchPath::get_num_directories(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_num_directories_316(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableSearchPath::get_num_directories(void) const
  std::size_t return_value = ((*(const ConfigVariableSearchPath*)local_this).get_num_directories)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_num_directories_316_comment =
  "C++ Interface:\n"
  "get_num_directories(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Returns the number of directories on the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_num_directories_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableSearchPath::get_directory(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_directory_317(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline Filename ConfigVariableSearchPath::get_directory(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    Filename *return_value = new Filename(((*(const ConfigVariableSearchPath*)local_this).get_directory)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(ConfigVariableSearchPath self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_directory_317_comment =
  "C++ Interface:\n"
  "get_directory(ConfigVariableSearchPath self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth directory on the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_directory_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableSearchPath::find_file(Filename const &filename) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_find_file_320(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline Filename ConfigVariableSearchPath::find_file(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.find_file", "Filename");
  }
  Filename *return_value = new Filename(((*(const ConfigVariableSearchPath*)local_this).find_file)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_file(ConfigVariableSearchPath self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_find_file_320_comment =
  "C++ Interface:\n"
  "find_file(ConfigVariableSearchPath self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Returns the full matching pathname of the first match if found, or\n"
  " * the empty string if not found.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_find_file_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath::Results ConfigVariableSearchPath::find_all_files(Filename const &filename) const
 * inline std::size_t ConfigVariableSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_find_all_files_321(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "filename")) {
        // 1-inline DSearchPath::Results ConfigVariableSearchPath::find_all_files(Filename const &filename) const
        Filename arg_local;
        Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.find_all_files", "Filename");
        }
        DSearchPath::Results *return_value = new DSearchPath::Results(((*(const ConfigVariableSearchPath*)local_this).find_all_files)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath_Results, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t ConfigVariableSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"filename", "results", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:find_all_files", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ConfigVariableSearchPath.find_all_files", "Filename");
        }
        DSearchPath::Results *param2_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DSearchPath_Results, 2, "ConfigVariableSearchPath.find_all_files", false, true);
        if (param2_this != nullptr) {
          std::size_t return_value = ((*(const ConfigVariableSearchPath*)local_this).find_all_files)(*param1_this, *param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_files() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_files(ConfigVariableSearchPath self, const Filename filename)\n"
      "find_all_files(ConfigVariableSearchPath self, const Filename filename, Results results)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_find_all_files_321_comment =
  "C++ Interface:\n"
  "find_all_files(ConfigVariableSearchPath self, const Filename filename)\n"
  "find_all_files(ConfigVariableSearchPath self, const Filename filename, Results results)\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Fills up the results list with *all* of the matching filenames\n"
  " * found, if any.  Returns the number of matches found.\n"
  " *\n"
  " * It is the responsibility of the the caller to clear the results list first;\n"
  " * otherwise, the newly-found files will be appended to the list.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant of find_all_files() returns the new Results object, instead of\n"
  " * filling on in on the parameter list.  This is a little more convenient to\n"
  " * call from Python.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_find_all_files_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::output(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_output_322(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline void ConfigVariableSearchPath::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableSearchPath.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableSearchPath*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableSearchPath self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_output_322_comment =
  "C++ Interface:\n"
  "output(ConfigVariableSearchPath self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_output_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::write(std::ostream &out) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_write_323(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline void ConfigVariableSearchPath::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConfigVariableSearchPath.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ConfigVariableSearchPath*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableSearchPath self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_write_323_comment =
  "C++ Interface:\n"
  "write(ConfigVariableSearchPath self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_write_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline operator DSearchPath (void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_operator_typecast_DSearchPath_302(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableSearchPath)) {
    return nullptr;
  }
  // 1-inline operator DSearchPath (void) const
  DSearchPath *return_value = new DSearchPath((DSearchPath)*(const ConfigVariableSearchPath*)local_this);
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_operator_typecast_DSearchPath_302_comment =
  "C++ Interface:\n"
  "operator_typecast_DSearchPath(ConfigVariableSearchPath self)\n";
#else
static const char *Dtool_ConfigVariableSearchPath_operator_typecast_DSearchPath_302_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableSearchPath_value_Getter(PyObject *self, void *) {
  const ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DSearchPath ConfigVariableSearchPath::get_value(void) const
  DSearchPath *return_value = new DSearchPath(((*(const ConfigVariableSearchPath*)local_this).get_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, true, false);
}

static PyObject *Dtool_ConfigVariableSearchPath_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
  DSearchPath const *return_value = &(((*(const ConfigVariableSearchPath*)local_this).get_default_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, true);
}

/**
 * sequence length function for property ConfigVariableSearchPath::directories
 */
static Py_ssize_t Dtool_ConfigVariableSearchPath_directories_Len(PyObject *self) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_directories)();
}

/**
 * sequence getter for property ConfigVariableSearchPath::directories
 */
static PyObject *Dtool_ConfigVariableSearchPath_directories_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_directories)()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableSearchPath.directories[] index out of range");
    return nullptr;
  }
  // 1-inline Filename ConfigVariableSearchPath::get_directory(std::size_t n) const
  Filename *return_value = new Filename(((*(const ConfigVariableSearchPath*)local_this).get_directory)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(ConfigVariableSearchPath self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableSearchPath_directories_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConfigVariableSearchPath.directories");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConfigVariableSearchPath_directories_Len;
    wrap->_getitem_func = &Dtool_ConfigVariableSearchPath_directories_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
 */
static int Dtool_Init_ConfigVariableSearchPath(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"name", "description", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
      }
    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Os#|i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          DSearchPath const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_DSearchPath);
          if (param1_this != nullptr) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#|i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        int param2;
        static const char *keyword_list[] = {"name", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Os#|i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          DSearchPath param1_local;
          DSearchPath const *param1_this = Dtool_Coerce_DSearchPath(param1, param1_local);
          if ((param1_this != nullptr)) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
      // No coercion possible: inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableSearchPath() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableSearchPath(str name)\n"
      "ConfigVariableSearchPath(str name, str description)\n"
      "ConfigVariableSearchPath(str name, const DSearchPath default_value, str description, int flags)\n"
      "ConfigVariableSearchPath(str name, str default_value, str description, int flags)\n"
      "ConfigVariableSearchPath(str name, str description, int flags)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableSearchPath_get_directories(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_directories)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableSearchPath_get_directory_317(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConfigVariableSearchPath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableSearchPath) {
    printf("ConfigVariableSearchPath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableSearchPath *local_this = (ConfigVariableSearchPath *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableSearchPath) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableSearchPath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableSearchPath) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableSearchPath*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableSearchPath*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConfigVariableString
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableString::operator =(std::string const &value)
 */
static PyObject *Dtool_ConfigVariableString_operator_326(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.assign")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableString::operator =(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).operator =)(std::string(param1_str, param1_len));
    ConfigVariableString *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableString, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableString self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_operator_326_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableString self, str value)\n";
#else
static const char *Dtool_ConfigVariableString_operator_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline char const *ConfigVariableString::c_str(void) const
 */
static PyObject *Dtool_ConfigVariableString_c_str_328(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableString)) {
    return nullptr;
  }
  // 1-inline char const *ConfigVariableString::c_str(void) const
  char const *return_value = ((*(const ConfigVariableString*)local_this).c_str)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_c_str_328_comment =
  "C++ Interface:\n"
  "c_str(ConfigVariableString self)\n"
  "\n"
  "// These methods help the ConfigVariableString act like a C++ string object.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_c_str_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableString::empty(void) const
 */
static PyObject *Dtool_ConfigVariableString_empty_329(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableString)) {
    return nullptr;
  }
  // 1-inline bool ConfigVariableString::empty(void) const
  bool return_value = ((*(const ConfigVariableString*)local_this).empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_empty_329_comment =
  "C++ Interface:\n"
  "empty(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_empty_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableString::length(void) const
 */
static PyObject *Dtool_ConfigVariableString_length_330(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableString)) {
    return nullptr;
  }
  // 1-inline std::size_t ConfigVariableString::length(void) const
  std::size_t return_value = ((*(const ConfigVariableString*)local_this).length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_length_330_comment =
  "C++ Interface:\n"
  "length(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_length_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableString::set_value(std::string const &value)
 */
static PyObject *Dtool_ConfigVariableString_set_value_335(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.set_value")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableString::set_value(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_value)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableString self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_set_value_335_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableString self, str value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_set_value_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableString::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableString_get_value_336(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableString)) {
    return nullptr;
  }
  // 1-inline std::string const &ConfigVariableString::get_value(void) const
  std::string const &return_value = ((*(const ConfigVariableString*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_get_value_336_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_get_value_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableString::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableString_get_default_value_337(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableString)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableString::get_default_value(void) const
  std::string return_value = ((*(const ConfigVariableString*)local_this).get_default_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_get_default_value_337_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_get_default_value_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableString::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableString_get_word_340(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConfigVariableString)) {
    return nullptr;
  }
  // 1-inline std::string ConfigVariableString::get_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const ConfigVariableString*)local_this).get_word)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableString self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_get_word_340_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableString self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_get_word_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableString::set_word(std::size_t n, std::string const &value)
 */
static PyObject *Dtool_ConfigVariableString_set_word_341(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.set_word")) {
    return nullptr;
  }
  // 1-inline void ConfigVariableString::set_word(std::size_t n, std::string const &value)
  Py_ssize_t param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ns#:set_word", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_word)((std::size_t)param1, std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableString self, int n, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_set_word_341_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableString self, int n, str value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_set_word_341_comment = nullptr;
#endif

static PyObject *Dtool_ConfigVariableString_value_Getter(PyObject *self, void *) {
  const ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ConfigVariableString::get_value(void) const
  std::string const &return_value = ((*(const ConfigVariableString*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableString_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableString::set_value(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_value)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableString self, str value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableString_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string ConfigVariableString::get_default_value(void) const
  std::string return_value = ((*(const ConfigVariableString*)local_this).get_default_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableString::ConfigVariableString(ConfigVariableString const &) = default
 * inline ConfigVariableString::ConfigVariableString(std::string const &name)
 * inline ConfigVariableString::ConfigVariableString(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableString(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableString::ConfigVariableString(ConfigVariableString const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ConfigVariableString const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ConfigVariableString);
          if (param0_this != nullptr) {
            ConfigVariableString *return_value = new ConfigVariableString(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableString, true, false);
          }
        }
      }

      {
        // -2 inline ConfigVariableString::ConfigVariableString(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableString", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableString, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableString::ConfigVariableString(ConfigVariableString const &) = default
      // No coercion possible: inline ConfigVariableString::ConfigVariableString(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-inline ConfigVariableString::ConfigVariableString(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      static const char *keyword_list[] = {"name", "default_value", "description", "flags", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableString", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
        ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableString, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableString() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableString(const ConfigVariableString param0)\n"
      "ConfigVariableString(str name)\n"
      "ConfigVariableString(str name, str default_value, str description, int flags)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableString(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConfigVariableString) {
    printf("ConfigVariableString ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConfigVariableString *local_this = (ConfigVariableString *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConfigVariableString) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConfigVariableString(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConfigVariableString) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableString*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableString*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableString*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NotifyCategory
 */
/**
 * Python function wrapper for:
 * inline std::string NotifyCategory::get_fullname(void) const
 */
static PyObject *Dtool_NotifyCategory_get_fullname_349(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::string NotifyCategory::get_fullname(void) const
  std::string return_value = ((*(const NotifyCategory*)local_this).get_fullname)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_fullname_349_comment =
  "C++ Interface:\n"
  "get_fullname(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_fullname_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string NotifyCategory::get_basename(void) const
 */
static PyObject *Dtool_NotifyCategory_get_basename_350(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::string NotifyCategory::get_basename(void) const
  std::string return_value = ((*(const NotifyCategory*)local_this).get_basename)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_basename_350_comment =
  "C++ Interface:\n"
  "get_basename(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_basename_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NotifySeverity NotifyCategory::get_severity(void) const
 */
static PyObject *Dtool_NotifyCategory_get_severity_351(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline NotifySeverity NotifyCategory::get_severity(void) const
  NotifySeverity return_value = ((*(const NotifyCategory*)local_this).get_severity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_severity_351_comment =
  "C++ Interface:\n"
  "get_severity(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_severity_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NotifyCategory::set_severity(NotifySeverity severity)
 */
static PyObject *Dtool_NotifyCategory_set_severity_352(PyObject *self, PyObject *arg) {
  NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NotifyCategory, (void **)&local_this, "NotifyCategory.set_severity")) {
    return nullptr;
  }
  // 1-inline void NotifyCategory::set_severity(NotifySeverity severity)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_severity)((NotifySeverity)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_severity(const NotifyCategory self, int severity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_set_severity_352_comment =
  "C++ Interface:\n"
  "set_severity(const NotifyCategory self, int severity)\n"
  "\n"
  "/**\n"
  " * Sets the severity level of messages that will be reported from this\n"
  " * Category.  This allows any message of this severity level or higher.\n"
  " */";
#else
static const char *Dtool_NotifyCategory_set_severity_352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_on(NotifySeverity severity) const
 */
static PyObject *Dtool_NotifyCategory_is_on_356(PyObject *self, PyObject *arg) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline bool NotifyCategory::is_on(NotifySeverity severity) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const NotifyCategory*)local_this).is_on)((NotifySeverity)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_on(NotifyCategory self, int severity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_on_356_comment =
  "C++ Interface:\n"
  "is_on(NotifyCategory self, int severity)\n"
  "\n"
  "/**\n"
  " * Returns true if messages of the indicated severity level ought to be\n"
  " * reported for this Category.\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_on_356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_spam(void) const
 */
static PyObject *Dtool_NotifyCategory_is_spam_357(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline bool NotifyCategory::is_spam(void) const
  bool return_value = ((*(const NotifyCategory*)local_this).is_spam)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_spam_357_comment =
  "C++ Interface:\n"
  "is_spam(NotifyCategory self)\n"
  "\n"
  "// When NOTIFY_DEBUG is not defined, the categories will never be set to\n"
  "// \"spam\" or \"debug\" severities, and these methods are redefined to be\n"
  "// static to make it more obvious to the compiler.  However, we still want\n"
  "// to present a consistent interface to our scripting language, so during\n"
  "// the interrogate pass (that is, when CPPPARSER is defined), we still\n"
  "// pretend they're nonstatic.\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_spam).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_spam_357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_debug(void) const
 */
static PyObject *Dtool_NotifyCategory_is_debug_358(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline bool NotifyCategory::is_debug(void) const
  bool return_value = ((*(const NotifyCategory*)local_this).is_debug)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_debug_358_comment =
  "C++ Interface:\n"
  "is_debug(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_debug).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_debug_358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_info(void) const
 */
static PyObject *Dtool_NotifyCategory_is_info_359(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline bool NotifyCategory::is_info(void) const
  bool return_value = ((*(const NotifyCategory*)local_this).is_info)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_info_359_comment =
  "C++ Interface:\n"
  "is_info(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_info).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_info_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_warning(void) const
 */
static PyObject *Dtool_NotifyCategory_is_warning_360(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline bool NotifyCategory::is_warning(void) const
  bool return_value = ((*(const NotifyCategory*)local_this).is_warning)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_warning_360_comment =
  "C++ Interface:\n"
  "is_warning(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_warning).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_warning_360_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_error(void) const
 */
static PyObject *Dtool_NotifyCategory_is_error_361(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline bool NotifyCategory::is_error(void) const
  bool return_value = ((*(const NotifyCategory*)local_this).is_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_error_361_comment =
  "C++ Interface:\n"
  "is_error(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_error).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_error_361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_fatal(void) const
 */
static PyObject *Dtool_NotifyCategory_is_fatal_362(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline bool NotifyCategory::is_fatal(void) const
  bool return_value = ((*(const NotifyCategory*)local_this).is_fatal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_fatal_362_comment =
  "C++ Interface:\n"
  "is_fatal(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_fatal).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_fatal_362_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::ostream &NotifyCategory::out(NotifySeverity severity, bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_out_363(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-std::ostream &NotifyCategory::out(NotifySeverity severity, bool prefix = true) const
  int param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"severity", "prefix", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:out", (char **)keyword_list, &param1, &param2)) {
    std::ostream *return_value = &(((*(const NotifyCategory*)local_this).out)((NotifySeverity)param1, (PyObject_IsTrue(param2) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "out(NotifyCategory self, int severity, bool prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_out_363_comment =
  "C++ Interface:\n"
  "out(NotifyCategory self, int severity, bool prefix)\n"
  "\n"
  "/**\n"
  " * Begins a new message to this Category at the indicated severity level.  If\n"
  " * the indicated severity level is enabled, this writes a prefixing string to\n"
  " * the Notify::out() stream and returns that.  If the severity level is\n"
  " * disabled, this returns Notify::null().\n"
  " */";
#else
static const char *Dtool_NotifyCategory_out_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::ostream &NotifyCategory::spam(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_spam_364(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::ostream &NotifyCategory::spam(bool prefix = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "prefix")) {
    std::ostream *return_value = &(((*(const NotifyCategory*)local_this).spam)((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "spam(NotifyCategory self, bool prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_spam_364_comment =
  "C++ Interface:\n"
  "spam(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_spam).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_spam_364_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::ostream &NotifyCategory::debug(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_debug_365(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::ostream &NotifyCategory::debug(bool prefix = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "prefix")) {
    std::ostream *return_value = &(((*(const NotifyCategory*)local_this).debug)((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "debug(NotifyCategory self, bool prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_debug_365_comment =
  "C++ Interface:\n"
  "debug(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_debug).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_debug_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::ostream &NotifyCategory::info(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_info_366(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::ostream &NotifyCategory::info(bool prefix = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "prefix")) {
    std::ostream *return_value = &(((*(const NotifyCategory*)local_this).info)((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "info(NotifyCategory self, bool prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_info_366_comment =
  "C++ Interface:\n"
  "info(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_info).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_info_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::ostream &NotifyCategory::warning(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_warning_367(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::ostream &NotifyCategory::warning(bool prefix = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "prefix")) {
    std::ostream *return_value = &(((*(const NotifyCategory*)local_this).warning)((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "warning(NotifyCategory self, bool prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_warning_367_comment =
  "C++ Interface:\n"
  "warning(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_warning).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_warning_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::ostream &NotifyCategory::error(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_error_368(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::ostream &NotifyCategory::error(bool prefix = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "prefix")) {
    std::ostream *return_value = &(((*(const NotifyCategory*)local_this).error)((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "error(NotifyCategory self, bool prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_error_368_comment =
  "C++ Interface:\n"
  "error(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_error).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_error_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::ostream &NotifyCategory::fatal(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_fatal_369(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-inline std::ostream &NotifyCategory::fatal(bool prefix = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "prefix")) {
    std::ostream *return_value = &(((*(const NotifyCategory*)local_this).fatal)((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fatal(NotifyCategory self, bool prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_fatal_369_comment =
  "C++ Interface:\n"
  "fatal(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_fatal).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_fatal_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t NotifyCategory::get_num_children(void) const
 */
static PyObject *Dtool_NotifyCategory_get_num_children_370(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-std::size_t NotifyCategory::get_num_children(void) const
  std::size_t return_value = ((*(const NotifyCategory*)local_this).get_num_children)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_num_children_370_comment =
  "C++ Interface:\n"
  "get_num_children(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * Returns the number of child Categories of this particular Category.\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_num_children_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NotifyCategory *NotifyCategory::get_child(std::size_t i) const
 */
static PyObject *Dtool_NotifyCategory_get_child_371(PyObject *self, PyObject *arg) {
  NotifyCategory *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NotifyCategory)) {
    return nullptr;
  }
  // 1-NotifyCategory *NotifyCategory::get_child(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    NotifyCategory *return_value = ((*(const NotifyCategory*)local_this).get_child)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(NotifyCategory self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_child_371_comment =
  "C++ Interface:\n"
  "get_child(NotifyCategory self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the nth child Category of this particular Category.\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_child_371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void NotifyCategory::set_server_delta(long int delta)
 */
static PyObject *Dtool_NotifyCategory_set_server_delta_375(PyObject *, PyObject *arg) {
  // 1-static void NotifyCategory::set_server_delta(long int delta)
  if (PyLongOrInt_Check(arg)) {
    (NotifyCategory::set_server_delta)(PyLongOrInt_AS_LONG(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server_delta(int delta)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_set_server_delta_375_comment =
  "C++ Interface:\n"
  "set_server_delta(int delta)\n"
  "\n"
  "/**\n"
  " * Sets a global delta (in seconds) between the local time and the server's\n"
  " * time, for the purpose of synchronizing the time stamps in the log messages\n"
  " * of the client with that of a known server.\n"
  " */";
#else
static const char *Dtool_NotifyCategory_set_server_delta_375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigFlags *NotifyCategory::upcast_to_ConfigFlags(void)
 */
static PyObject *Dtool_NotifyCategory_upcast_to_ConfigFlags_347(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NotifyCategory, (void **)&local_this, "NotifyCategory.upcast_to_ConfigFlags")) {
    return nullptr;
  }
  // 1-ConfigFlags *NotifyCategory::upcast_to_ConfigFlags(void)
  ConfigFlags *return_value = (ConfigFlags *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigFlags, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_upcast_to_ConfigFlags_347_comment =
  "C++ Interface:\n"
  "upcast_to_ConfigFlags(const NotifyCategory self)\n"
  "\n"
  "upcast from NotifyCategory to ConfigFlags";
#else
static const char *Dtool_NotifyCategory_upcast_to_ConfigFlags_347_comment = nullptr;
#endif

static PyObject *Dtool_NotifyCategory_fullname_Getter(PyObject *self, void *) {
  const NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string NotifyCategory::get_fullname(void) const
  std::string return_value = ((*(const NotifyCategory*)local_this).get_fullname)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_NotifyCategory_basename_Getter(PyObject *self, void *) {
  const NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string NotifyCategory::get_basename(void) const
  std::string return_value = ((*(const NotifyCategory*)local_this).get_basename)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_NotifyCategory_severity_Getter(PyObject *self, void *) {
  const NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NotifySeverity NotifyCategory::get_severity(void) const
  NotifySeverity return_value = ((*(const NotifyCategory*)local_this).get_severity)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_NotifyCategory_severity_Setter(PyObject *self, PyObject *arg, void *) {
  NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NotifyCategory, (void **)&local_this, "NotifyCategory.severity")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete severity attribute");
    return -1;
  }
  // 1-inline void NotifyCategory::set_severity(NotifySeverity severity)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_severity)((NotifySeverity)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_severity(const NotifyCategory self, int severity)\n");
  }
  return -1;
}

/**
 * sequence length function for property NotifyCategory::children
 */
static Py_ssize_t Dtool_NotifyCategory_children_Len(PyObject *self) {
  NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_children)();
}

/**
 * sequence getter for property NotifyCategory::children
 */
static PyObject *Dtool_NotifyCategory_children_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_children)()) {
    PyErr_SetString(PyExc_IndexError, "NotifyCategory.children[] index out of range");
    return nullptr;
  }
  // 1-NotifyCategory *NotifyCategory::get_child(std::size_t i) const
  NotifyCategory *return_value = ((*(const NotifyCategory*)local_this).get_child)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(NotifyCategory self, index)\n");
  }
}

static PyObject *Dtool_NotifyCategory_children_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "NotifyCategory.children");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_NotifyCategory_children_Len;
    wrap->_getitem_func = &Dtool_NotifyCategory_children_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline NotifyCategory::NotifyCategory(NotifyCategory const &) = default
 */
static int Dtool_Init_NotifyCategory(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NotifyCategory() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline NotifyCategory::NotifyCategory(NotifyCategory const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    NotifyCategory const *param0_this = (NotifyCategory *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NotifyCategory, 0, "NotifyCategory.NotifyCategory", true, true);
    if (param0_this != nullptr) {
      NotifyCategory *return_value = new NotifyCategory(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NotifyCategory, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NotifyCategory(const NotifyCategory param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NotifyCategory_get_children(PyObject *self, PyObject *) {
  NotifyCategory *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_children)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NotifyCategory_get_child_371(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NotifyCategory(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NotifyCategory) {
    printf("NotifyCategory ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NotifyCategory *local_this = (NotifyCategory *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NotifyCategory) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NotifyCategory(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NotifyCategory) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (NotifyCategory*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IDecryptStream
 */
/**
 * Python function wrapper for:
 * inline IDecryptStream &IDecryptStream::open(std::istream *source, bool owns_source, std::string const &password)
 */
static PyObject *Dtool_IDecryptStream_open_381(PyObject *self, PyObject *args, PyObject *kwds) {
  IDecryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecryptStream, (void **)&local_this, "IDecryptStream.open")) {
    return nullptr;
  }
  // 1-inline IDecryptStream &IDecryptStream::open(std::istream *source, bool owns_source, std::string const &password)
  PyObject *param1;
  PyObject *param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"source", "owns_source", "password", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:open", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "IDecryptStream.open", false, true);
    if (param1_this != nullptr) {
      IDecryptStream *return_value = &(((*local_this).open)(param1_this, (PyObject_IsTrue(param2) != 0), std::string(param3_str, param3_len)));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecryptStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const IDecryptStream self, istream source, bool owns_source, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_open_381_comment =
  "C++ Interface:\n"
  "open(const IDecryptStream self, istream source, bool owns_source, str password)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IDecryptStream_open_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline IDecryptStream &IDecryptStream::close(void)
 */
static PyObject *Dtool_IDecryptStream_close_382(PyObject *self, PyObject *) {
  IDecryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecryptStream, (void **)&local_this, "IDecryptStream.close")) {
    return nullptr;
  }
  // 1-inline IDecryptStream &IDecryptStream::close(void)
  IDecryptStream *return_value = &(((*local_this).close)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecryptStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_close_382_comment =
  "C++ Interface:\n"
  "close(const IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Resets the EncryptStream to empty, but does not actually close the source\n"
  " * istream unless owns_source was true.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_close_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &IDecryptStream::get_algorithm(void) const
 */
static PyObject *Dtool_IDecryptStream_get_algorithm_383(PyObject *self, PyObject *) {
  IDecryptStream *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IDecryptStream)) {
    return nullptr;
  }
  // 1-inline std::string const &IDecryptStream::get_algorithm(void) const
  std::string const &return_value = ((*(const IDecryptStream*)local_this).get_algorithm)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_get_algorithm_383_comment =
  "C++ Interface:\n"
  "get_algorithm(IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption algorithm that was read from the stream.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_get_algorithm_383_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int IDecryptStream::get_key_length(void) const
 */
static PyObject *Dtool_IDecryptStream_get_key_length_384(PyObject *self, PyObject *) {
  IDecryptStream *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IDecryptStream)) {
    return nullptr;
  }
  // 1-inline int IDecryptStream::get_key_length(void) const
  int return_value = ((*(const IDecryptStream*)local_this).get_key_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_get_key_length_384_comment =
  "C++ Interface:\n"
  "get_key_length(IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption key length, in bits, that was read from the stream.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_get_key_length_384_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int IDecryptStream::get_iteration_count(void) const
 */
static PyObject *Dtool_IDecryptStream_get_iteration_count_385(PyObject *self, PyObject *) {
  IDecryptStream *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IDecryptStream)) {
    return nullptr;
  }
  // 1-inline int IDecryptStream::get_iteration_count(void) const
  int return_value = ((*(const IDecryptStream*)local_this).get_iteration_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_get_iteration_count_385_comment =
  "C++ Interface:\n"
  "get_iteration_count(IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Returns the value that was was read from the stream.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_get_iteration_count_385_comment = nullptr;
#endif

static PyObject *Dtool_IDecryptStream_algorithm_Getter(PyObject *self, void *) {
  const IDecryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &IDecryptStream::get_algorithm(void) const
  std::string const &return_value = ((*(const IDecryptStream*)local_this).get_algorithm)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_IDecryptStream_key_length_Getter(PyObject *self, void *) {
  const IDecryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int IDecryptStream::get_key_length(void) const
  int return_value = ((*(const IDecryptStream*)local_this).get_key_length)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_IDecryptStream_iteration_count_Getter(PyObject *self, void *) {
  const IDecryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int IDecryptStream::get_iteration_count(void) const
  int return_value = ((*(const IDecryptStream*)local_this).get_iteration_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline IDecryptStream::IDecryptStream(void)
 * inline explicit IDecryptStream::IDecryptStream(std::istream *source, bool owns_source, std::string const &password)
 */
static int Dtool_Init_IDecryptStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline IDecryptStream::IDecryptStream(void)
      IDecryptStream *return_value = new IDecryptStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecryptStream, true, false);
    }
    break;
  case 3:
    {
      // 1-inline explicit IDecryptStream::IDecryptStream(std::istream *source, bool owns_source, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      const char *param2_str = nullptr;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"source", "owns_source", "password", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:IDecryptStream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
        std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "IDecryptStream.IDecryptStream", false, true);
        if (param0_this != nullptr) {
          IDecryptStream *return_value = new IDecryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecryptStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IDecryptStream() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IDecryptStream()\n"
      "IDecryptStream(istream source, bool owns_source, str password)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_IDecryptStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IDecryptStream) {
    printf("IDecryptStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IDecryptStream *local_this = (IDecryptStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IDecryptStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IDecryptStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IDecryptStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (IDecryptStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OEncryptStream
 */
/**
 * Python function wrapper for:
 * inline OEncryptStream &OEncryptStream::open(std::ostream *dest, bool owns_dest, std::string const &password)
 */
static PyObject *Dtool_OEncryptStream_open_393(PyObject *self, PyObject *args, PyObject *kwds) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.open")) {
    return nullptr;
  }
  // 1-inline OEncryptStream &OEncryptStream::open(std::ostream *dest, bool owns_dest, std::string const &password)
  PyObject *param1;
  PyObject *param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"dest", "owns_dest", "password", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:open", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OEncryptStream.open", false, true);
    if (param1_this != nullptr) {
      OEncryptStream *return_value = &(((*local_this).open)(param1_this, (PyObject_IsTrue(param2) != 0), std::string(param3_str, param3_len)));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OEncryptStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OEncryptStream self, ostream dest, bool owns_dest, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_open_393_comment =
  "C++ Interface:\n"
  "open(const OEncryptStream self, ostream dest, bool owns_dest, str password)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OEncryptStream_open_393_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OEncryptStream &OEncryptStream::close(void)
 */
static PyObject *Dtool_OEncryptStream_close_394(PyObject *self, PyObject *) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.close")) {
    return nullptr;
  }
  // 1-inline OEncryptStream &OEncryptStream::close(void)
  OEncryptStream *return_value = &(((*local_this).close)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OEncryptStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_close_394_comment =
  "C++ Interface:\n"
  "close(const OEncryptStream self)\n"
  "\n"
  "/**\n"
  " * Resets the EncryptStream to empty, but does not actually close the dest\n"
  " * ostream unless owns_dest was true.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_close_394_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OEncryptStream::set_algorithm(std::string const &algorithm)
 */
static PyObject *Dtool_OEncryptStream_set_algorithm_395(PyObject *self, PyObject *arg) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.set_algorithm")) {
    return nullptr;
  }
  // 1-inline void OEncryptStream::set_algorithm(std::string const &algorithm)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_algorithm)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_algorithm(const OEncryptStream self, str algorithm)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_set_algorithm_395_comment =
  "C++ Interface:\n"
  "set_algorithm(const OEncryptStream self, str algorithm)\n"
  "\n"
  "/**\n"
  " * Specifies the encryption algorithm that should be used for future calls to\n"
  " * open().  The default is whatever is specified by the encryption-algorithm\n"
  " * config variable.  The complete set of available algorithms is defined by\n"
  " * the current version of OpenSSL.\n"
  " *\n"
  " * If an invalid algorithm is specified, there is no immediate error return\n"
  " * code, but open() will fail.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_set_algorithm_395_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OEncryptStream::set_key_length(int key_length)
 */
static PyObject *Dtool_OEncryptStream_set_key_length_396(PyObject *self, PyObject *arg) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.set_key_length")) {
    return nullptr;
  }
  // 1-inline void OEncryptStream::set_key_length(int key_length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_key_length)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_key_length(const OEncryptStream self, int key_length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_set_key_length_396_comment =
  "C++ Interface:\n"
  "set_key_length(const OEncryptStream self, int key_length)\n"
  "\n"
  "/**\n"
  " * Specifies the length of the key, in bits, that should be used to encrypt\n"
  " * the stream in future calls to open().  The default is whatever is specified\n"
  " * by the encryption-key-length config variable.\n"
  " *\n"
  " * If an invalid key_length for the chosen algorithm is specified, there is no\n"
  " * immediate error return code, but open() will fail.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_set_key_length_396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OEncryptStream::set_iteration_count(int iteration_count)
 */
static PyObject *Dtool_OEncryptStream_set_iteration_count_397(PyObject *self, PyObject *arg) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.set_iteration_count")) {
    return nullptr;
  }
  // 1-inline void OEncryptStream::set_iteration_count(int iteration_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_iteration_count)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_iteration_count(const OEncryptStream self, int iteration_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_set_iteration_count_397_comment =
  "C++ Interface:\n"
  "set_iteration_count(const OEncryptStream self, int iteration_count)\n"
  "\n"
  "/**\n"
  " * Specifies the number of times to repeatedly hash the key before writing it\n"
  " * to the stream in future calls to open().  Its purpose is to make it\n"
  " * computationally more expensive for an attacker to search the key space\n"
  " * exhaustively.  This should be a multiple of 1,000 and should not exceed\n"
  " * about 65 million; the value 0 indicates just one application of the hashing\n"
  " * algorithm.\n"
  " *\n"
  " * The default is whatever is specified by the encryption-iteration-count\n"
  " * config variable.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_set_iteration_count_397_comment = nullptr;
#endif

static PyObject *Dtool_OEncryptStream_algorithm_Getter(PyObject *self, void *) {
  const OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OEncryptStream, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &OEncryptStream::get_algorithm(void) const
  std::string const &return_value = ((*(const OEncryptStream*)local_this).get_algorithm)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OEncryptStream_algorithm_Setter(PyObject *self, PyObject *arg, void *) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.algorithm")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete algorithm attribute");
    return -1;
  }
  // 1-inline void OEncryptStream::set_algorithm(std::string const &algorithm)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_algorithm)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_algorithm(const OEncryptStream self, str algorithm)\n");
  }
  return -1;
}

static PyObject *Dtool_OEncryptStream_key_length_Getter(PyObject *self, void *) {
  const OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OEncryptStream, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int OEncryptStream::get_key_length(void) const
  int return_value = ((*(const OEncryptStream*)local_this).get_key_length)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OEncryptStream_key_length_Setter(PyObject *self, PyObject *arg, void *) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.key_length")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete key_length attribute");
    return -1;
  }
  // 1-inline void OEncryptStream::set_key_length(int key_length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_key_length)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_key_length(const OEncryptStream self, int key_length)\n");
  }
  return -1;
}

static PyObject *Dtool_OEncryptStream_iteration_count_Getter(PyObject *self, void *) {
  const OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OEncryptStream, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int OEncryptStream::get_iteration_count(void) const
  int return_value = ((*(const OEncryptStream*)local_this).get_iteration_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OEncryptStream_iteration_count_Setter(PyObject *self, PyObject *arg, void *) {
  OEncryptStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.iteration_count")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete iteration_count attribute");
    return -1;
  }
  // 1-inline void OEncryptStream::set_iteration_count(int iteration_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_iteration_count)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_iteration_count(const OEncryptStream self, int iteration_count)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline OEncryptStream::OEncryptStream(void)
 * inline explicit OEncryptStream::OEncryptStream(std::ostream *dest, bool owns_dest, std::string const &password)
 */
static int Dtool_Init_OEncryptStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OEncryptStream::OEncryptStream(void)
      OEncryptStream *return_value = new OEncryptStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OEncryptStream, true, false);
    }
    break;
  case 3:
    {
      // 1-inline explicit OEncryptStream::OEncryptStream(std::ostream *dest, bool owns_dest, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      const char *param2_str = nullptr;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"dest", "owns_dest", "password", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:OEncryptStream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
        std::ostream *param0_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_ostream, 0, "OEncryptStream.OEncryptStream", false, true);
        if (param0_this != nullptr) {
          OEncryptStream *return_value = new OEncryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OEncryptStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OEncryptStream() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OEncryptStream()\n"
      "OEncryptStream(ostream dest, bool owns_dest, str password)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OEncryptStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OEncryptStream) {
    printf("OEncryptStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OEncryptStream *local_this = (OEncryptStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OEncryptStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OEncryptStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OEncryptStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (OEncryptStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StreamReader
 */
/**
 * Python function wrapper for:
 * Rejected Remap [inline void StreamReader::operator =(StreamReader &&from) noexcept]
 * inline void StreamReader::operator =(StreamReader const &copy)
 */
static PyObject *Dtool_StreamReader_operator_407(PyObject *self, PyObject *arg) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.assign")) {
    return nullptr;
  }
  // 1-inline void StreamReader::operator =(StreamReader const &copy)
  StreamReader const *arg_this = (StreamReader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StreamReader, 1, "StreamReader.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    StreamReader *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamReader, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StreamReader self, const StreamReader copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_operator_407_comment =
  "C++ Interface:\n"
  "assign(const StreamReader self, const StreamReader copy)\n";
#else
static const char *Dtool_StreamReader_operator_407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::istream *StreamReader::get_istream(void) const
 */
static PyObject *Dtool_StreamReader_get_istream_409(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_StreamReader)) {
    return nullptr;
  }
  // 1-inline std::istream *StreamReader::get_istream(void) const
  std::istream *return_value = ((*(const StreamReader*)local_this).get_istream)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_istream_409_comment =
  "C++ Interface:\n"
  "get_istream(StreamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the stream in use.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_istream_409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool StreamReader::get_bool(void)
 */
static PyObject *Dtool_StreamReader_get_bool_412(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_bool")) {
    return nullptr;
  }
  // 1-inline bool StreamReader::get_bool(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).get_bool)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_bool_412_comment =
  "C++ Interface:\n"
  "get_bool(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a boolean value.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_bool_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int8_t StreamReader::get_int8(void)
 */
static PyObject *Dtool_StreamReader_get_int8_413(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int8")) {
    return nullptr;
  }
  // 1-inline int8_t StreamReader::get_int8(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int8_t return_value = ((*local_this).get_int8)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int8_413_comment =
  "C++ Interface:\n"
  "get_int8(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 8-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int8_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint8_t StreamReader::get_uint8(void)
 */
static PyObject *Dtool_StreamReader_get_uint8_414(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint8")) {
    return nullptr;
  }
  // 1-inline uint8_t StreamReader::get_uint8(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint8_t return_value = ((*local_this).get_uint8)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint8_414_comment =
  "C++ Interface:\n"
  "get_uint8(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 8-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint8_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int16_t StreamReader::get_int16(void)
 */
static PyObject *Dtool_StreamReader_get_int16_415(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int16")) {
    return nullptr;
  }
  // 1-inline int16_t StreamReader::get_int16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int16_t return_value = ((*local_this).get_int16)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int16_415_comment =
  "C++ Interface:\n"
  "get_int16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int16_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int32_t StreamReader::get_int32(void)
 */
static PyObject *Dtool_StreamReader_get_int32_416(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int32")) {
    return nullptr;
  }
  // 1-inline int32_t StreamReader::get_int32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int32_t return_value = ((*local_this).get_int32)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int32_416_comment =
  "C++ Interface:\n"
  "get_int32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int32_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t StreamReader::get_int64(void)
 */
static PyObject *Dtool_StreamReader_get_int64_417(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int64")) {
    return nullptr;
  }
  // 1-inline int64_t StreamReader::get_int64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int64_t return_value = ((*local_this).get_int64)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int64_417_comment =
  "C++ Interface:\n"
  "get_int64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int64_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t StreamReader::get_uint16(void)
 */
static PyObject *Dtool_StreamReader_get_uint16_418(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint16")) {
    return nullptr;
  }
  // 1-inline uint16_t StreamReader::get_uint16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint16_t return_value = ((*local_this).get_uint16)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint16_418_comment =
  "C++ Interface:\n"
  "get_uint16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint16_418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t StreamReader::get_uint32(void)
 */
static PyObject *Dtool_StreamReader_get_uint32_419(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint32")) {
    return nullptr;
  }
  // 1-inline uint32_t StreamReader::get_uint32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint32_t return_value = ((*local_this).get_uint32)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint32_419_comment =
  "C++ Interface:\n"
  "get_uint32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint32_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t StreamReader::get_uint64(void)
 */
static PyObject *Dtool_StreamReader_get_uint64_420(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint64")) {
    return nullptr;
  }
  // 1-inline uint64_t StreamReader::get_uint64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint64_t return_value = ((*local_this).get_uint64)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint64_420_comment =
  "C++ Interface:\n"
  "get_uint64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint64_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float StreamReader::get_float32(void)
 */
static PyObject *Dtool_StreamReader_get_float32_421(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_float32")) {
    return nullptr;
  }
  // 1-inline float StreamReader::get_float32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  float return_value = ((*local_this).get_float32)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_float32_421_comment =
  "C++ Interface:\n"
  "get_float32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit single-precision floating-point number.  Since this kind\n"
  " * of float is not necessarily portable across different architectures,\n"
  " * special care is required.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_float32_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 StreamReader::get_float64(void)
 */
static PyObject *Dtool_StreamReader_get_float64_422(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_float64")) {
    return nullptr;
  }
  // 1-inline PN_float64 StreamReader::get_float64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PN_float64 return_value = ((*local_this).get_float64)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_float64_422_comment =
  "C++ Interface:\n"
  "get_float64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit floating-point number.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_float64_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int16_t StreamReader::get_be_int16(void)
 */
static PyObject *Dtool_StreamReader_get_be_int16_423(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_int16")) {
    return nullptr;
  }
  // 1-inline int16_t StreamReader::get_be_int16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int16_t return_value = ((*local_this).get_be_int16)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_int16_423_comment =
  "C++ Interface:\n"
  "get_be_int16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed big-endian 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_int16_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int32_t StreamReader::get_be_int32(void)
 */
static PyObject *Dtool_StreamReader_get_be_int32_424(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_int32")) {
    return nullptr;
  }
  // 1-inline int32_t StreamReader::get_be_int32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int32_t return_value = ((*local_this).get_be_int32)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_int32_424_comment =
  "C++ Interface:\n"
  "get_be_int32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed big-endian 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_int32_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t StreamReader::get_be_int64(void)
 */
static PyObject *Dtool_StreamReader_get_be_int64_425(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_int64")) {
    return nullptr;
  }
  // 1-inline int64_t StreamReader::get_be_int64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int64_t return_value = ((*local_this).get_be_int64)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_int64_425_comment =
  "C++ Interface:\n"
  "get_be_int64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed big-endian 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_int64_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t StreamReader::get_be_uint16(void)
 */
static PyObject *Dtool_StreamReader_get_be_uint16_426(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_uint16")) {
    return nullptr;
  }
  // 1-inline uint16_t StreamReader::get_be_uint16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint16_t return_value = ((*local_this).get_be_uint16)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_uint16_426_comment =
  "C++ Interface:\n"
  "get_be_uint16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned big-endian 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_uint16_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t StreamReader::get_be_uint32(void)
 */
static PyObject *Dtool_StreamReader_get_be_uint32_427(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_uint32")) {
    return nullptr;
  }
  // 1-inline uint32_t StreamReader::get_be_uint32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint32_t return_value = ((*local_this).get_be_uint32)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_uint32_427_comment =
  "C++ Interface:\n"
  "get_be_uint32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned big-endian 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_uint32_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t StreamReader::get_be_uint64(void)
 */
static PyObject *Dtool_StreamReader_get_be_uint64_428(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_uint64")) {
    return nullptr;
  }
  // 1-inline uint64_t StreamReader::get_be_uint64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint64_t return_value = ((*local_this).get_be_uint64)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_uint64_428_comment =
  "C++ Interface:\n"
  "get_be_uint64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned big-endian 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_uint64_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float StreamReader::get_be_float32(void)
 */
static PyObject *Dtool_StreamReader_get_be_float32_429(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_float32")) {
    return nullptr;
  }
  // 1-inline float StreamReader::get_be_float32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  float return_value = ((*local_this).get_be_float32)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_float32_429_comment =
  "C++ Interface:\n"
  "get_be_float32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit single-precision big-endian floating-point number.  Since\n"
  " * this kind of float is not necessarily portable across different\n"
  " * architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_float32_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 StreamReader::get_be_float64(void)
 */
static PyObject *Dtool_StreamReader_get_be_float64_430(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_float64")) {
    return nullptr;
  }
  // 1-inline PN_float64 StreamReader::get_be_float64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PN_float64 return_value = ((*local_this).get_be_float64)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_float64_430_comment =
  "C++ Interface:\n"
  "get_be_float64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit big-endian floating-point number.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_float64_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_string(void)
 */
static PyObject *Dtool_StreamReader_get_string_431(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_string")) {
    return nullptr;
  }
  // 1-std::string StreamReader::get_string(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::string return_value = ((*local_this).get_string)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_string_431_comment =
  "C++ Interface:\n"
  "get_string(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_string_431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_string32(void)
 */
static PyObject *Dtool_StreamReader_get_string32_432(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_string32")) {
    return nullptr;
  }
  // 1-std::string StreamReader::get_string32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::string return_value = ((*local_this).get_string32)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_string32_432_comment =
  "C++ Interface:\n"
  "get_string32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string with a 32-bit length field.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_string32_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_z_string(void)
 */
static PyObject *Dtool_StreamReader_get_z_string_433(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_z_string")) {
    return nullptr;
  }
  // 1-std::string StreamReader::get_z_string(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::string return_value = ((*local_this).get_z_string)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_z_string_433_comment =
  "C++ Interface:\n"
  "get_z_string(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string, as a NULL-terminated string.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_z_string_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_fixed_string(std::size_t size)
 */
static PyObject *Dtool_StreamReader_get_fixed_string_434(PyObject *self, PyObject *arg) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_fixed_string")) {
    return nullptr;
  }
  // 1-std::string StreamReader::get_fixed_string(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::string return_value = ((*local_this).get_fixed_string)(arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_fixed_string(const StreamReader self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_fixed_string_434_comment =
  "C++ Interface:\n"
  "get_fixed_string(const StreamReader self, int size)\n"
  "\n"
  "/**\n"
  " * Extracts a fixed-length string.  However, if a zero byte occurs within the\n"
  " * string, it marks the end of the string.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_fixed_string_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StreamReader::skip_bytes(std::size_t size)
 */
static PyObject *Dtool_StreamReader_skip_bytes_435(PyObject *self, PyObject *arg) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.skip_bytes")) {
    return nullptr;
  }
  // 1-void StreamReader::skip_bytes(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).skip_bytes)(arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "skip_bytes(const StreamReader self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_skip_bytes_435_comment =
  "C++ Interface:\n"
  "skip_bytes(const StreamReader self, int size)\n"
  "\n"
  "/**\n"
  " * Skips over the indicated number of bytes in the stream.\n"
  " */";
#else
static const char *Dtool_StreamReader_skip_bytes_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *StreamReader::extract_bytes(std::size_t size)
 */
static PyObject *Dtool_StreamReader_extract_bytes_436(PyObject *self, PyObject *arg) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.extract_bytes")) {
    return nullptr;
  }
  // 1-PyObject *StreamReader::extract_bytes(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PyObject *return_value = invoke_extension(local_this).extract_bytes(arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_bytes(const StreamReader self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_extract_bytes_436_comment =
  "C++ Interface:\n"
  "extract_bytes(const StreamReader self, int size)\n"
  "\n"
  "/**\n"
  " * Extracts the indicated number of bytes in the stream into the given\n"
  " * character buffer.  Assumes that the buffer is big enough to hold the\n"
  " * requested number of bytes.  Returns the number of bytes that were\n"
  " * successfully written.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Extracts the indicated number of bytes in the stream and returns them as a\n"
  " * string.  Returns empty string at end-of-file.\n"
  " */";
#else
static const char *Dtool_StreamReader_extract_bytes_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *StreamReader::readline(void)
 */
static PyObject *Dtool_StreamReader_readline_437(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.readline")) {
    return nullptr;
  }
  // 1-PyObject *StreamReader::readline(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PyObject *return_value = invoke_extension(local_this).readline();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_readline_437_comment =
  "C++ Interface:\n"
  "readline(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Assumes the stream represents a text file, and extracts one line up to and\n"
  " * including the trailing newline character.  Returns empty string when the\n"
  " * end of file is reached.\n"
  " *\n"
  " * The interface here is intentionally designed to be similar to that for\n"
  " * Python's File.readline() function.\n"
  " */";
#else
static const char *Dtool_StreamReader_readline_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *StreamReader::readlines(void)
 */
static PyObject *Dtool_StreamReader_readlines_438(PyObject *self, PyObject *) {
  StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.readlines")) {
    return nullptr;
  }
  // 1-PyObject *StreamReader::readlines(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PyObject *return_value = invoke_extension(local_this).readlines();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_readlines_438_comment =
  "C++ Interface:\n"
  "readlines(const StreamReader self)\n";
#else
static const char *Dtool_StreamReader_readlines_438_comment = nullptr;
#endif

static PyObject *Dtool_StreamReader_istream_Getter(PyObject *self, void *) {
  const StreamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamReader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::istream *IStreamWrapper::get_istream(void) const
  std::istream *return_value = ((*(const StreamReader*)local_this).get_istream)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
}

/**
 * Python function wrapper for:
 * Rejected Remap [inline StreamReader::StreamReader(StreamReader &&from) noexcept]
 * inline StreamReader::StreamReader(StreamReader const &copy)
 * inline explicit StreamReader::StreamReader(std::istream *in, bool owns_stream)
 */
static int Dtool_Init_StreamReader(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline StreamReader::StreamReader(StreamReader const &copy)
        StreamReader const *arg_this = (StreamReader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StreamReader, 0, "StreamReader.StreamReader", true, true);
        if (arg_this != nullptr) {
          StreamReader *return_value = new StreamReader(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamReader, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline explicit StreamReader::StreamReader(std::istream *in, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"in", "owns_stream", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:StreamReader", (char **)keyword_list, &param0, &param1)) {
        std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "StreamReader.StreamReader", false, true);
        if (param0_this != nullptr) {
          StreamReader *return_value = new StreamReader(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamReader, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StreamReader() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StreamReader(const StreamReader copy)\n"
      "StreamReader(istream in, bool owns_stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StreamReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StreamReader) {
    printf("StreamReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StreamReader *local_this = (StreamReader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StreamReader) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StreamReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StreamReader) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StreamWriter
 */
/**
 * Python function wrapper for:
 * Rejected Remap [inline void StreamWriter::operator =(StreamWriter &&from) noexcept]
 * inline void StreamWriter::operator =(StreamWriter const &copy)
 */
static PyObject *Dtool_StreamWriter_operator_441(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.assign")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::operator =(StreamWriter const &copy)
  StreamWriter const *arg_this = (StreamWriter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StreamWriter, 1, "StreamWriter.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    StreamWriter *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWriter, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StreamWriter self, const StreamWriter copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_operator_441_comment =
  "C++ Interface:\n"
  "assign(const StreamWriter self, const StreamWriter copy)\n";
#else
static const char *Dtool_StreamWriter_operator_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::ostream *StreamWriter::get_ostream(void) const
 */
static PyObject *Dtool_StreamWriter_get_ostream_443(PyObject *self, PyObject *) {
  StreamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_StreamWriter)) {
    return nullptr;
  }
  // 1-inline std::ostream *StreamWriter::get_ostream(void) const
  std::ostream *return_value = ((*(const StreamWriter*)local_this).get_ostream)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_get_ostream_443_comment =
  "C++ Interface:\n"
  "get_ostream(StreamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the stream in use.\n"
  " */";
#else
static const char *Dtool_StreamWriter_get_ostream_443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_bool(bool value)
 */
static PyObject *Dtool_StreamWriter_add_bool_446(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_bool")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_bool(bool value)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).add_bool)((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_bool(const StreamWriter self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_bool_446_comment =
  "C++ Interface:\n"
  "add_bool(const StreamWriter self, bool value)\n"
  "\n"
  "/**\n"
  " * Adds a boolean value to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_bool_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int8(int8_t value)
 */
static PyObject *Dtool_StreamWriter_add_int8_447(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int8")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_int8(int8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < SCHAR_MIN || param1 > SCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed byte",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_int8)((int8_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int8(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int8_447_comment =
  "C++ Interface:\n"
  "add_int8(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 8-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int8_447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint8(uint8_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint8_448(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint8")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_uint8(uint8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_uint8)((uint8_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint8(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint8_448_comment =
  "C++ Interface:\n"
  "add_uint8(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 8-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint8_448_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int16(int16_t value)
 */
static PyObject *Dtool_StreamWriter_add_int16_449(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int16")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_int16)((int16_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int16(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int16_449_comment =
  "C++ Interface:\n"
  "add_int16(const StreamWriter self, int value)\n"
  "\n"
  "// The default numeric packing is little-endian.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int16_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int32(int32_t value)
 */
static PyObject *Dtool_StreamWriter_add_int32_450(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int32")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_int32)((int32_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int32(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int32_450_comment =
  "C++ Interface:\n"
  "add_int32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int32_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int64(int64_t value)
 */
static PyObject *Dtool_StreamWriter_add_int64_451(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int64")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_int64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_int64)((int64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int64(const StreamWriter self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int64_451_comment =
  "C++ Interface:\n"
  "add_int64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int64_451_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint16(uint16_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint16_452(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint16")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_uint16)((uint16_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint16(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint16_452_comment =
  "C++ Interface:\n"
  "add_uint16(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint16_452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint32(uint32_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint32_453(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint32")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_uint32)((uint32_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint32(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint32_453_comment =
  "C++ Interface:\n"
  "add_uint32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint32_453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint64(uint64_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint64_454(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint64")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_uint64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_uint64)((uint64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint64(const StreamWriter self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint64_454_comment =
  "C++ Interface:\n"
  "add_uint64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint64_454_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_float32(float value)
 */
static PyObject *Dtool_StreamWriter_add_float32_455(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_float32")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_float32(float value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_float32)((float)PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float32(const StreamWriter self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_float32_455_comment =
  "C++ Interface:\n"
  "add_float32(const StreamWriter self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision floating-point number to the stream.  Since\n"
  " * this kind of float is not necessarily portable across different\n"
  " * architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_float32_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_float64(PN_float64 value)
 */
static PyObject *Dtool_StreamWriter_add_float64_456(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_float64")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_float64)(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float64(const StreamWriter self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_float64_456_comment =
  "C++ Interface:\n"
  "add_float64(const StreamWriter self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit floating-point number to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_float64_456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_int16(int16_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_int16_457(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_int16")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_int16)((int16_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int16(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_int16_457_comment =
  "C++ Interface:\n"
  "add_be_int16(const StreamWriter self, int value)\n"
  "\n"
  "// These functions pack numbers big-endian, in case that's desired.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_int16_457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_int32(int32_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_int32_458(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_int32")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_int32)((int32_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int32(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_int32_458_comment =
  "C++ Interface:\n"
  "add_be_int32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_int32_458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_int64(int64_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_int64_459(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_int64")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_be_int64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_int64)((int64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int64(const StreamWriter self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_int64_459_comment =
  "C++ Interface:\n"
  "add_be_int64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_int64_459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_uint16(uint16_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_uint16_460(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_uint16")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_uint16)((uint16_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint16(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_uint16_460_comment =
  "C++ Interface:\n"
  "add_be_uint16(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_uint16_460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_uint32(uint32_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_uint32_461(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_uint32")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_uint32)((uint32_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint32(const StreamWriter self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_uint32_461_comment =
  "C++ Interface:\n"
  "add_be_uint32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_uint32_461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_uint64(uint64_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_uint64_462(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_uint64")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_be_uint64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_uint64)((uint64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint64(const StreamWriter self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_uint64_462_comment =
  "C++ Interface:\n"
  "add_be_uint64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_uint64_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_float32(float value)
 */
static PyObject *Dtool_StreamWriter_add_be_float32_463(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_float32")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_float32(float value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_float32)((float)PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float32(const StreamWriter self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_float32_463_comment =
  "C++ Interface:\n"
  "add_be_float32(const StreamWriter self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision big-endian floating-point number to the\n"
  " * stream.  Since this kind of float is not necessarily portable across\n"
  " * different architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_float32_463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_float64(PN_float64 value)
 */
static PyObject *Dtool_StreamWriter_add_be_float64_464(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_float64")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_be_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_be_float64)(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float64(const StreamWriter self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_float64_464_comment =
  "C++ Interface:\n"
  "add_be_float64(const StreamWriter self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit big-endian floating-point number to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_float64_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_string(std::string const &str)
 */
static PyObject *Dtool_StreamWriter_add_string_465(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_string")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_string(std::string const &str)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_string)(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string(const StreamWriter self, str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_string_465_comment =
  "C++ Interface:\n"
  "add_string(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the stream.  This actually adds a count\n"
  " * followed by n bytes.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_string_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_string32(std::string const &str)
 */
static PyObject *Dtool_StreamWriter_add_string32_466(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_string32")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_string32(std::string const &str)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_string32)(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string32(const StreamWriter self, str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_string32_466_comment =
  "C++ Interface:\n"
  "add_string32(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the stream, using a 32-bit length field.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_string32_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_z_string(std::string str)
 */
static PyObject *Dtool_StreamWriter_add_z_string_467(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_z_string")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_z_string(std::string str)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_z_string)(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z_string(const StreamWriter self, str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_z_string_467_comment =
  "C++ Interface:\n"
  "add_z_string(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the stream, as a NULL-terminated string.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_z_string_467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_fixed_string(std::string const &str, std::size_t size)
 */
static PyObject *Dtool_StreamWriter_add_fixed_string_468(PyObject *self, PyObject *args, PyObject *kwds) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_fixed_string")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::add_fixed_string(std::string const &str, std::size_t size)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"str", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#n:add_fixed_string", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).add_fixed_string)(std::string(param1_str, param1_len), (std::size_t)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_fixed_string(const StreamWriter self, str str, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_fixed_string_468_comment =
  "C++ Interface:\n"
  "add_fixed_string(const StreamWriter self, str str, int size)\n"
  "\n"
  "/**\n"
  " * Adds a fixed-length string to the stream.  If the string given is less than\n"
  " * the requested size, this will pad the string out with zeroes; if it is\n"
  " * greater than the requested size, this will silently truncate the string.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_fixed_string_468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StreamWriter::pad_bytes(std::size_t size)
 */
static PyObject *Dtool_StreamWriter_pad_bytes_469(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.pad_bytes")) {
    return nullptr;
  }
  // 1-void StreamWriter::pad_bytes(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).pad_bytes)(arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pad_bytes(const StreamWriter self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_pad_bytes_469_comment =
  "C++ Interface:\n"
  "pad_bytes(const StreamWriter self, int size)\n"
  "\n"
  "/**\n"
  " * Adds the indicated number of zero bytes to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_pad_bytes_469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StreamWriter::append_data(PyObject *data)
 */
static PyObject *Dtool_StreamWriter_append_data_470(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.append_data")) {
    return nullptr;
  }
  // 1-void StreamWriter::append_data(PyObject *data)
  invoke_extension(local_this).append_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_data(const StreamWriter self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_append_data_470_comment =
  "C++ Interface:\n"
  "append_data(const StreamWriter self, object data)\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the streamWriter.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_append_data_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::flush(void)
 */
static PyObject *Dtool_StreamWriter_flush_471(PyObject *self, PyObject *) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.flush")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).flush)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_flush_471_comment =
  "C++ Interface:\n"
  "flush(const StreamWriter self)\n"
  "\n"
  "/**\n"
  " * Calls flush() on the underlying stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_flush_471_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::write(std::string const &str)
 */
static PyObject *Dtool_StreamWriter_write_472(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.write")) {
    return nullptr;
  }
  // 1-inline void StreamWriter::write(std::string const &str)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).write)(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(const StreamWriter self, str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_write_472_comment =
  "C++ Interface:\n"
  "write(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * A synonym of append_data().  This is useful when assigning the StreamWriter\n"
  " * to sys.stderr and/or sys.stdout in Python.\n"
  " */";
#else
static const char *Dtool_StreamWriter_write_472_comment = nullptr;
#endif

static PyObject *Dtool_StreamWriter_ostream_Getter(PyObject *self, void *) {
  const StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWriter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::ostream *OStreamWrapper::get_ostream(void) const
  std::ostream *return_value = ((*(const StreamWriter*)local_this).get_ostream)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

static PyObject *Dtool_StreamWriter_softspace_Getter(PyObject *self, void *) {
  const StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWriter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int StreamWriter::get_softspace(void) const
  int return_value = ((const StreamWriter*)local_this)->softspace;
  return Dtool_WrapValue(return_value);
}

static int Dtool_StreamWriter_softspace_Setter(PyObject *self, PyObject *arg, void *) {
  StreamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.softspace")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete softspace attribute");
    return -1;
  }
  // 1-void StreamWriter::set_softspace(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->softspace = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_softspace(const StreamWriter self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * Rejected Remap [inline StreamWriter::StreamWriter(StreamWriter &&from) noexcept]
 * inline StreamWriter::StreamWriter(StreamWriter const &copy)
 * inline explicit StreamWriter::StreamWriter(std::ostream *out, bool owns_stream)
 */
static int Dtool_Init_StreamWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline StreamWriter::StreamWriter(StreamWriter const &copy)
        StreamWriter const *arg_this = (StreamWriter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StreamWriter, 0, "StreamWriter.StreamWriter", true, true);
        if (arg_this != nullptr) {
          StreamWriter *return_value = new StreamWriter(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWriter, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline explicit StreamWriter::StreamWriter(std::ostream *out, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"out", "owns_stream", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:StreamWriter", (char **)keyword_list, &param0, &param1)) {
        std::ostream *param0_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_ostream, 0, "StreamWriter.StreamWriter", false, true);
        if (param0_this != nullptr) {
          StreamWriter *return_value = new StreamWriter(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWriter, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StreamWriter() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StreamWriter(const StreamWriter copy)\n"
      "StreamWriter(ostream out, bool owns_stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StreamWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StreamWriter) {
    printf("StreamWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StreamWriter *local_this = (StreamWriter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StreamWriter) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StreamWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StreamWriter) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StreamWrapperBase
 */
/**
 * Python function wrapper for:
 * inline void StreamWrapperBase::acquire(void)
 */
static PyObject *Dtool_StreamWrapperBase_acquire_477(PyObject *self, PyObject *) {
  StreamWrapperBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapperBase, (void **)&local_this, "StreamWrapperBase.acquire")) {
    return nullptr;
  }
  // 1-inline void StreamWrapperBase::acquire(void)
  ((*local_this).acquire)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapperBase_acquire_477_comment =
  "C++ Interface:\n"
  "acquire(const StreamWrapperBase self)\n"
  "\n"
  "/**\n"
  " * Acquires the internal lock.\n"
  " *\n"
  " * User code should call this to take temporary possession of the stream and\n"
  " * perform direct I/O operations on it, for instance to make several\n"
  " * sequential atomic reads.  You may not call any of the StreamWrapper methods\n"
  " * while the lock is held, other than release().\n"
  " *\n"
  " * Use with extreme caution!  This is a very low-level, non-recursive lock.\n"
  " * You must call acquire() only once, and you must later call release()\n"
  " * exactly once.  Failing to do so may result in a hard deadlock with no\n"
  " * available debugging features.\n"
  " */";
#else
static const char *Dtool_StreamWrapperBase_acquire_477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWrapperBase::release(void)
 */
static PyObject *Dtool_StreamWrapperBase_release_478(PyObject *self, PyObject *) {
  StreamWrapperBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapperBase, (void **)&local_this, "StreamWrapperBase.release")) {
    return nullptr;
  }
  // 1-inline void StreamWrapperBase::release(void)
  ((*local_this).release)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapperBase_release_478_comment =
  "C++ Interface:\n"
  "release(const StreamWrapperBase self)\n"
  "\n"
  "/**\n"
  " * Releases the internal lock.  Must be called exactly once following a call\n"
  " * to acquire().  See the cautions with acquire().\n"
  " */";
#else
static const char *Dtool_StreamWrapperBase_release_478_comment = nullptr;
#endif

static int Dtool_Init_StreamWrapperBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_StreamWrapperBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StreamWrapperBase) {
    printf("StreamWrapperBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StreamWrapperBase *local_this = (StreamWrapperBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StreamWrapperBase) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StreamWrapperBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StreamWrapperBase) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IStreamWrapper
 */
/**
 * Python function wrapper for:
 * inline std::istream *IStreamWrapper::get_istream(void) const
 */
static PyObject *Dtool_IStreamWrapper_get_istream_484(PyObject *self, PyObject *) {
  IStreamWrapper *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IStreamWrapper)) {
    return nullptr;
  }
  // 1-inline std::istream *IStreamWrapper::get_istream(void) const
  std::istream *return_value = ((*(const IStreamWrapper*)local_this).get_istream)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IStreamWrapper_get_istream_484_comment =
  "C++ Interface:\n"
  "get_istream(IStreamWrapper self)\n"
  "\n"
  "/**\n"
  " * Returns the istream this object is wrapping.\n"
  " */";
#else
static const char *Dtool_IStreamWrapper_get_istream_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * StreamWrapperBase *IStreamWrapper::upcast_to_StreamWrapperBase(void)
 */
static PyObject *Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_481(PyObject *self, PyObject *) {
  IStreamWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IStreamWrapper, (void **)&local_this, "IStreamWrapper.upcast_to_StreamWrapperBase")) {
    return nullptr;
  }
  // 1-StreamWrapperBase *IStreamWrapper::upcast_to_StreamWrapperBase(void)
  StreamWrapperBase *return_value = (StreamWrapperBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWrapperBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_481_comment =
  "C++ Interface:\n"
  "upcast_to_StreamWrapperBase(const IStreamWrapper self)\n"
  "\n"
  "upcast from IStreamWrapper to StreamWrapperBase";
#else
static const char *Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_481_comment = nullptr;
#endif

static PyObject *Dtool_IStreamWrapper_istream_Getter(PyObject *self, void *) {
  const IStreamWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IStreamWrapper, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::istream *IStreamWrapper::get_istream(void) const
  std::istream *return_value = ((*(const IStreamWrapper*)local_this).get_istream)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
}

/**
 * Python function wrapper for:
 * inline explicit IStreamWrapper::IStreamWrapper(std::istream &stream)
 */
static int Dtool_Init_IStreamWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "IStreamWrapper() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "stream")) {
    // 1-inline explicit IStreamWrapper::IStreamWrapper(std::istream &stream)
    std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 0, "IStreamWrapper.IStreamWrapper", false, true);
    if (arg_this != nullptr) {
      IStreamWrapper *return_value = new IStreamWrapper(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IStreamWrapper, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IStreamWrapper(istream stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_IStreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IStreamWrapper) {
    printf("IStreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IStreamWrapper *local_this = (IStreamWrapper *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IStreamWrapper) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_StreamWrapperBase) {
    return (StreamWrapperBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IStreamWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IStreamWrapper) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OStreamWrapper
 */
/**
 * Python function wrapper for:
 * inline std::ostream *OStreamWrapper::get_ostream(void) const
 */
static PyObject *Dtool_OStreamWrapper_get_ostream_489(PyObject *self, PyObject *) {
  OStreamWrapper *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OStreamWrapper)) {
    return nullptr;
  }
  // 1-inline std::ostream *OStreamWrapper::get_ostream(void) const
  std::ostream *return_value = ((*(const OStreamWrapper*)local_this).get_ostream)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OStreamWrapper_get_ostream_489_comment =
  "C++ Interface:\n"
  "get_ostream(OStreamWrapper self)\n"
  "\n"
  "/**\n"
  " * Returns the ostream this object is wrapping.\n"
  " */";
#else
static const char *Dtool_OStreamWrapper_get_ostream_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * StreamWrapperBase *OStreamWrapper::upcast_to_StreamWrapperBase(void)
 */
static PyObject *Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_486(PyObject *self, PyObject *) {
  OStreamWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OStreamWrapper, (void **)&local_this, "OStreamWrapper.upcast_to_StreamWrapperBase")) {
    return nullptr;
  }
  // 1-StreamWrapperBase *OStreamWrapper::upcast_to_StreamWrapperBase(void)
  StreamWrapperBase *return_value = (StreamWrapperBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWrapperBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_486_comment =
  "C++ Interface:\n"
  "upcast_to_StreamWrapperBase(const OStreamWrapper self)\n"
  "\n"
  "upcast from OStreamWrapper to StreamWrapperBase";
#else
static const char *Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_486_comment = nullptr;
#endif

static PyObject *Dtool_OStreamWrapper_ostream_Getter(PyObject *self, void *) {
  const OStreamWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OStreamWrapper, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::ostream *OStreamWrapper::get_ostream(void) const
  std::ostream *return_value = ((*(const OStreamWrapper*)local_this).get_ostream)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

/**
 * Python function wrapper for:
 * inline explicit OStreamWrapper::OStreamWrapper(std::ostream &stream)
 */
static int Dtool_Init_OStreamWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OStreamWrapper() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "stream")) {
    // 1-inline explicit OStreamWrapper::OStreamWrapper(std::ostream &stream)
    std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "OStreamWrapper.OStreamWrapper", false, true);
    if (arg_this != nullptr) {
      OStreamWrapper *return_value = new OStreamWrapper(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OStreamWrapper, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OStreamWrapper(ostream stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OStreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OStreamWrapper) {
    printf("OStreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OStreamWrapper *local_this = (OStreamWrapper *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OStreamWrapper) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_StreamWrapperBase) {
    return (StreamWrapperBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OStreamWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OStreamWrapper) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StreamWrapper
 */
/**
 * Python function wrapper for:
 * inline std::iostream *StreamWrapper::get_iostream(void) const
 */
static PyObject *Dtool_StreamWrapper_get_iostream_497(PyObject *self, PyObject *) {
  StreamWrapper *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_StreamWrapper)) {
    return nullptr;
  }
  // 1-inline std::iostream *StreamWrapper::get_iostream(void) const
  std::iostream *return_value = ((*(const StreamWrapper*)local_this).get_iostream)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_iostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapper_get_iostream_497_comment =
  "C++ Interface:\n"
  "get_iostream(StreamWrapper self)\n"
  "\n"
  "/**\n"
  " * Returns the iostream this object is wrapping.\n"
  " */";
#else
static const char *Dtool_StreamWrapper_get_iostream_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * IStreamWrapper *StreamWrapper::upcast_to_IStreamWrapper(void)
 */
static PyObject *Dtool_StreamWrapper_upcast_to_IStreamWrapper_491(PyObject *self, PyObject *) {
  StreamWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapper, (void **)&local_this, "StreamWrapper.upcast_to_IStreamWrapper")) {
    return nullptr;
  }
  // 1-IStreamWrapper *StreamWrapper::upcast_to_IStreamWrapper(void)
  IStreamWrapper *return_value = (IStreamWrapper *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IStreamWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapper_upcast_to_IStreamWrapper_491_comment =
  "C++ Interface:\n"
  "upcast_to_IStreamWrapper(const StreamWrapper self)\n"
  "\n"
  "upcast from StreamWrapper to IStreamWrapper";
#else
static const char *Dtool_StreamWrapper_upcast_to_IStreamWrapper_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OStreamWrapper *StreamWrapper::upcast_to_OStreamWrapper(void)
 */
static PyObject *Dtool_StreamWrapper_upcast_to_OStreamWrapper_493(PyObject *self, PyObject *) {
  StreamWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapper, (void **)&local_this, "StreamWrapper.upcast_to_OStreamWrapper")) {
    return nullptr;
  }
  // 1-OStreamWrapper *StreamWrapper::upcast_to_OStreamWrapper(void)
  OStreamWrapper *return_value = (OStreamWrapper *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OStreamWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapper_upcast_to_OStreamWrapper_493_comment =
  "C++ Interface:\n"
  "upcast_to_OStreamWrapper(const StreamWrapper self)\n"
  "\n"
  "upcast from StreamWrapper to OStreamWrapper";
#else
static const char *Dtool_StreamWrapper_upcast_to_OStreamWrapper_493_comment = nullptr;
#endif

static PyObject *Dtool_StreamWrapper_iostream_Getter(PyObject *self, void *) {
  const StreamWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWrapper, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::iostream *StreamWrapper::get_iostream(void) const
  std::iostream *return_value = ((*(const StreamWrapper*)local_this).get_iostream)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_iostream, false, false);
}

/**
 * Python function wrapper for:
 * inline explicit StreamWrapper::StreamWrapper(std::iostream &stream)
 */
static int Dtool_Init_StreamWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "StreamWrapper() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "stream")) {
    // 1-inline explicit StreamWrapper::StreamWrapper(std::iostream &stream)
    std::iostream *arg_this = (std::iostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_iostream, 0, "StreamWrapper.StreamWrapper", false, true);
    if (arg_this != nullptr) {
      StreamWrapper *return_value = new StreamWrapper(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWrapper, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StreamWrapper(iostream stream)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StreamWrapper) {
    printf("StreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StreamWrapper *local_this = (StreamWrapper *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StreamWrapper) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_IStreamWrapper) {
    return (IStreamWrapper *) local_this;
  }
  if (requested_type == Dtool_Ptr_OStreamWrapper) {
    return (OStreamWrapper *) local_this;
  }
  if (requested_type == Dtool_Ptr_StreamWrapperBase) {
    return (StreamWrapperBase *)(IStreamWrapper *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StreamWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StreamWrapper) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_IStreamWrapper) {
    IStreamWrapper* other_this = (IStreamWrapper*)from_this;
    return (StreamWrapper*)other_this;
  }
  if (from_type == Dtool_Ptr_OStreamWrapper) {
    OStreamWrapper* other_this = (OStreamWrapper*)from_this;
    return (StreamWrapper*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for ConfigFlags (ConfigFlags)
 */
static PyMethodDef Dtool_Methods_ConfigFlags[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ConfigFlags = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigFlags = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigFlags",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigFlags,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigFlags,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is the base class of both ConfigVariable and ConfigVariableCore.\n"
    " * It exists only to provide a convenient name scoping for some enumerated\n"
    " * values common to both classes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigFlags,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigFlags,
    PyType_GenericAlloc,
    Dtool_new_ConfigFlags,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigFlags,
  Dtool_UpcastInterface_ConfigFlags,
  Dtool_DowncastInterface_ConfigFlags,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigFlags(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConfigFlags._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(33);
    Dtool_ConfigFlags._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ConfigFlags::ValueType;
    PyDict_SetItemString(dict, "VT_undefined", Dtool_WrapValue(ConfigFlags::VT_undefined));
    PyDict_SetItemString(dict, "VTUndefined", Dtool_WrapValue(ConfigFlags::VT_undefined));
    PyDict_SetItemString(dict, "VT_list", Dtool_WrapValue(ConfigFlags::VT_list));
    PyDict_SetItemString(dict, "VTList", Dtool_WrapValue(ConfigFlags::VT_list));
    PyDict_SetItemString(dict, "VT_string", Dtool_WrapValue(ConfigFlags::VT_string));
    PyDict_SetItemString(dict, "VTString", Dtool_WrapValue(ConfigFlags::VT_string));
    PyDict_SetItemString(dict, "VT_filename", Dtool_WrapValue(ConfigFlags::VT_filename));
    PyDict_SetItemString(dict, "VTFilename", Dtool_WrapValue(ConfigFlags::VT_filename));
    PyDict_SetItemString(dict, "VT_bool", Dtool_WrapValue(ConfigFlags::VT_bool));
    PyDict_SetItemString(dict, "VTBool", Dtool_WrapValue(ConfigFlags::VT_bool));
    PyDict_SetItemString(dict, "VT_int", Dtool_WrapValue(ConfigFlags::VT_int));
    PyDict_SetItemString(dict, "VTInt", Dtool_WrapValue(ConfigFlags::VT_int));
    PyDict_SetItemString(dict, "VT_double", Dtool_WrapValue(ConfigFlags::VT_double));
    PyDict_SetItemString(dict, "VTDouble", Dtool_WrapValue(ConfigFlags::VT_double));
    PyDict_SetItemString(dict, "VT_enum", Dtool_WrapValue(ConfigFlags::VT_enum));
    PyDict_SetItemString(dict, "VTEnum", Dtool_WrapValue(ConfigFlags::VT_enum));
    PyDict_SetItemString(dict, "VT_search_path", Dtool_WrapValue(ConfigFlags::VT_search_path));
    PyDict_SetItemString(dict, "VTSearchPath", Dtool_WrapValue(ConfigFlags::VT_search_path));
    PyDict_SetItemString(dict, "VT_int64", Dtool_WrapValue(ConfigFlags::VT_int64));
    PyDict_SetItemString(dict, "VTInt64", Dtool_WrapValue(ConfigFlags::VT_int64));
    PyDict_SetItemString(dict, "VT_color", Dtool_WrapValue(ConfigFlags::VT_color));
    PyDict_SetItemString(dict, "VTColor", Dtool_WrapValue(ConfigFlags::VT_color));
    // enum ConfigFlags::VariableFlags;
    PyDict_SetItemString(dict, "F_trust_level_mask", Dtool_WrapValue(ConfigFlags::F_trust_level_mask));
    PyDict_SetItemString(dict, "FTrustLevelMask", Dtool_WrapValue(ConfigFlags::F_trust_level_mask));
    PyDict_SetItemString(dict, "F_open", Dtool_WrapValue(ConfigFlags::F_open));
    PyDict_SetItemString(dict, "FOpen", Dtool_WrapValue(ConfigFlags::F_open));
    PyDict_SetItemString(dict, "F_closed", Dtool_WrapValue(ConfigFlags::F_closed));
    PyDict_SetItemString(dict, "FClosed", Dtool_WrapValue(ConfigFlags::F_closed));
    PyDict_SetItemString(dict, "F_dynamic", Dtool_WrapValue(ConfigFlags::F_dynamic));
    PyDict_SetItemString(dict, "FDynamic", Dtool_WrapValue(ConfigFlags::F_dynamic));
    PyDict_SetItemString(dict, "F_dconfig", Dtool_WrapValue(ConfigFlags::F_dconfig));
    PyDict_SetItemString(dict, "FDconfig", Dtool_WrapValue(ConfigFlags::F_dconfig));
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigFlags) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigFlags)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigFlags);
  }
}

/**
 * Python method tables for ConfigPage (ConfigPage)
 */
static PyMethodDef Dtool_Methods_ConfigPage[] = {
  {"get_default_page", &Dtool_ConfigPage_get_default_page_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_default_page_7_comment},
  {"getDefaultPage", &Dtool_ConfigPage_get_default_page_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_default_page_7_comment},
  {"get_local_page", &Dtool_ConfigPage_get_local_page_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_local_page_8_comment},
  {"getLocalPage", &Dtool_ConfigPage_get_local_page_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_local_page_8_comment},
  {"get_name", &Dtool_ConfigPage_get_name_9, METH_NOARGS, (const char *)Dtool_ConfigPage_get_name_9_comment},
  {"getName", &Dtool_ConfigPage_get_name_9, METH_NOARGS, (const char *)Dtool_ConfigPage_get_name_9_comment},
  {"is_special", &Dtool_ConfigPage_is_special_14, METH_NOARGS, (const char *)Dtool_ConfigPage_is_special_14_comment},
  {"isSpecial", &Dtool_ConfigPage_is_special_14, METH_NOARGS, (const char *)Dtool_ConfigPage_is_special_14_comment},
  {"is_implicit", &Dtool_ConfigPage_is_implicit_15, METH_NOARGS, (const char *)Dtool_ConfigPage_is_implicit_15_comment},
  {"isImplicit", &Dtool_ConfigPage_is_implicit_15, METH_NOARGS, (const char *)Dtool_ConfigPage_is_implicit_15_comment},
  {"set_sort", &Dtool_ConfigPage_set_sort_19, METH_O, (const char *)Dtool_ConfigPage_set_sort_19_comment},
  {"setSort", &Dtool_ConfigPage_set_sort_19, METH_O, (const char *)Dtool_ConfigPage_set_sort_19_comment},
  {"get_sort", &Dtool_ConfigPage_get_sort_20, METH_NOARGS, (const char *)Dtool_ConfigPage_get_sort_20_comment},
  {"getSort", &Dtool_ConfigPage_get_sort_20, METH_NOARGS, (const char *)Dtool_ConfigPage_get_sort_20_comment},
  {"get_page_seq", &Dtool_ConfigPage_get_page_seq_23, METH_NOARGS, (const char *)Dtool_ConfigPage_get_page_seq_23_comment},
  {"getPageSeq", &Dtool_ConfigPage_get_page_seq_23, METH_NOARGS, (const char *)Dtool_ConfigPage_get_page_seq_23_comment},
  {"get_trust_level", &Dtool_ConfigPage_get_trust_level_24, METH_NOARGS, (const char *)Dtool_ConfigPage_get_trust_level_24_comment},
  {"getTrustLevel", &Dtool_ConfigPage_get_trust_level_24, METH_NOARGS, (const char *)Dtool_ConfigPage_get_trust_level_24_comment},
  {"set_trust_level", &Dtool_ConfigPage_set_trust_level_25, METH_O, (const char *)Dtool_ConfigPage_set_trust_level_25_comment},
  {"setTrustLevel", &Dtool_ConfigPage_set_trust_level_25, METH_O, (const char *)Dtool_ConfigPage_set_trust_level_25_comment},
  {"get_signature", &Dtool_ConfigPage_get_signature_26, METH_NOARGS, (const char *)Dtool_ConfigPage_get_signature_26_comment},
  {"getSignature", &Dtool_ConfigPage_get_signature_26, METH_NOARGS, (const char *)Dtool_ConfigPage_get_signature_26_comment},
  {"clear", &Dtool_ConfigPage_clear_30, METH_NOARGS, (const char *)Dtool_ConfigPage_clear_30_comment},
  {"read_prc", &Dtool_ConfigPage_read_prc_31, METH_O, (const char *)Dtool_ConfigPage_read_prc_31_comment},
  {"readPrc", &Dtool_ConfigPage_read_prc_31, METH_O, (const char *)Dtool_ConfigPage_read_prc_31_comment},
  {"read_encrypted_prc", (PyCFunction) &Dtool_ConfigPage_read_encrypted_prc_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_read_encrypted_prc_32_comment},
  {"readEncryptedPrc", (PyCFunction) &Dtool_ConfigPage_read_encrypted_prc_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_read_encrypted_prc_32_comment},
  {"make_declaration", (PyCFunction) &Dtool_ConfigPage_make_declaration_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_make_declaration_33_comment},
  {"makeDeclaration", (PyCFunction) &Dtool_ConfigPage_make_declaration_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_make_declaration_33_comment},
  {"delete_declaration", &Dtool_ConfigPage_delete_declaration_34, METH_O, (const char *)Dtool_ConfigPage_delete_declaration_34_comment},
  {"deleteDeclaration", &Dtool_ConfigPage_delete_declaration_34, METH_O, (const char *)Dtool_ConfigPage_delete_declaration_34_comment},
  {"get_num_declarations", &Dtool_ConfigPage_get_num_declarations_35, METH_NOARGS, (const char *)Dtool_ConfigPage_get_num_declarations_35_comment},
  {"getNumDeclarations", &Dtool_ConfigPage_get_num_declarations_35, METH_NOARGS, (const char *)Dtool_ConfigPage_get_num_declarations_35_comment},
  {"get_declaration", &Dtool_ConfigPage_get_declaration_36, METH_O, (const char *)Dtool_ConfigPage_get_declaration_36_comment},
  {"getDeclaration", &Dtool_ConfigPage_get_declaration_36, METH_O, (const char *)Dtool_ConfigPage_get_declaration_36_comment},
  {"modify_declaration", &Dtool_ConfigPage_modify_declaration_37, METH_O, (const char *)Dtool_ConfigPage_modify_declaration_37_comment},
  {"modifyDeclaration", &Dtool_ConfigPage_modify_declaration_37, METH_O, (const char *)Dtool_ConfigPage_modify_declaration_37_comment},
  {"get_variable_name", &Dtool_ConfigPage_get_variable_name_38, METH_O, (const char *)Dtool_ConfigPage_get_variable_name_38_comment},
  {"getVariableName", &Dtool_ConfigPage_get_variable_name_38, METH_O, (const char *)Dtool_ConfigPage_get_variable_name_38_comment},
  {"get_string_value", &Dtool_ConfigPage_get_string_value_39, METH_O, (const char *)Dtool_ConfigPage_get_string_value_39_comment},
  {"getStringValue", &Dtool_ConfigPage_get_string_value_39, METH_O, (const char *)Dtool_ConfigPage_get_string_value_39_comment},
  {"is_variable_used", &Dtool_ConfigPage_is_variable_used_40, METH_O, (const char *)Dtool_ConfigPage_is_variable_used_40_comment},
  {"isVariableUsed", &Dtool_ConfigPage_is_variable_used_40, METH_O, (const char *)Dtool_ConfigPage_is_variable_used_40_comment},
  {"output", &Dtool_ConfigPage_output_119, METH_O, (const char *)Dtool_ConfigPage_output_119_comment},
  {"output_brief_signature", &Dtool_ConfigPage_output_brief_signature_120, METH_O, (const char *)Dtool_ConfigPage_output_brief_signature_120_comment},
  {"outputBriefSignature", &Dtool_ConfigPage_output_brief_signature_120, METH_O, (const char *)Dtool_ConfigPage_output_brief_signature_120_comment},
  {"write", &Dtool_ConfigPage_write_121, METH_O, (const char *)Dtool_ConfigPage_write_121_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConfigPage
//////////////////
static PyObject *Dtool_Repr_ConfigPage(PyObject *self) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigPage
//////////////////
static PyObject *Dtool_Str_ConfigPage(PyObject *self) {
  ConfigPage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigPage[] = {
  {(char *)"name", &Dtool_ConfigPage_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"special", &Dtool_ConfigPage_special_Getter, nullptr, nullptr, nullptr},
  {(char *)"implicit", &Dtool_ConfigPage_implicit_Getter, nullptr, nullptr, nullptr},
  {(char *)"sort", &Dtool_ConfigPage_sort_Getter, &Dtool_ConfigPage_sort_Setter, nullptr, nullptr},
  {(char *)"page_seq", &Dtool_ConfigPage_page_seq_Getter, nullptr, nullptr, nullptr},
  {(char *)"trust_level", &Dtool_ConfigPage_trust_level_Getter, &Dtool_ConfigPage_trust_level_Setter, nullptr, nullptr},
  {(char *)"signature", &Dtool_ConfigPage_signature_Getter, nullptr, nullptr, nullptr},
  {(char *)"declarations", &Dtool_ConfigPage_declarations_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigPage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigPage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigPage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigPage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigPage,
    &Dtool_NumberMethods_ConfigPage,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigPage,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A page of ConfigDeclarations that may be loaded or unloaded.  Typically\n"
    " * this represents a single .prc file that is read from disk at runtime, but\n"
    " * it may also represent a list of declarations built up by application code\n"
    " * and explicitly loaded.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigPage,
    nullptr, // tp_members
    Dtool_Properties_ConfigPage,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigPage,
    PyType_GenericAlloc,
    Dtool_new_ConfigPage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigPage,
  Dtool_UpcastInterface_ConfigPage,
  Dtool_DowncastInterface_ConfigPage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigPage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConfigPage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigPage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigPage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigPage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigPage);
  }
}

/**
 * Python method tables for ConfigDeclaration (ConfigDeclaration)
 */
static PyMethodDef Dtool_Methods_ConfigDeclaration[] = {
  {"get_page", &Dtool_ConfigDeclaration_get_page_44, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_page_44_comment},
  {"getPage", &Dtool_ConfigDeclaration_get_page_44, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_page_44_comment},
  {"get_variable", &Dtool_ConfigDeclaration_get_variable_45, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_variable_45_comment},
  {"getVariable", &Dtool_ConfigDeclaration_get_variable_45, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_variable_45_comment},
  {"get_string_value", &Dtool_ConfigDeclaration_get_string_value_97, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_string_value_97_comment},
  {"getStringValue", &Dtool_ConfigDeclaration_get_string_value_97, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_string_value_97_comment},
  {"set_string_value", &Dtool_ConfigDeclaration_set_string_value_98, METH_O, (const char *)Dtool_ConfigDeclaration_set_string_value_98_comment},
  {"setStringValue", &Dtool_ConfigDeclaration_set_string_value_98, METH_O, (const char *)Dtool_ConfigDeclaration_set_string_value_98_comment},
  {"get_num_words", &Dtool_ConfigDeclaration_get_num_words_99, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_num_words_99_comment},
  {"getNumWords", &Dtool_ConfigDeclaration_get_num_words_99, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_num_words_99_comment},
  {"has_string_word", &Dtool_ConfigDeclaration_has_string_word_100, METH_O, (const char *)Dtool_ConfigDeclaration_has_string_word_100_comment},
  {"hasStringWord", &Dtool_ConfigDeclaration_has_string_word_100, METH_O, (const char *)Dtool_ConfigDeclaration_has_string_word_100_comment},
  {"has_bool_word", &Dtool_ConfigDeclaration_has_bool_word_101, METH_O, (const char *)Dtool_ConfigDeclaration_has_bool_word_101_comment},
  {"hasBoolWord", &Dtool_ConfigDeclaration_has_bool_word_101, METH_O, (const char *)Dtool_ConfigDeclaration_has_bool_word_101_comment},
  {"has_int_word", &Dtool_ConfigDeclaration_has_int_word_102, METH_O, (const char *)Dtool_ConfigDeclaration_has_int_word_102_comment},
  {"hasIntWord", &Dtool_ConfigDeclaration_has_int_word_102, METH_O, (const char *)Dtool_ConfigDeclaration_has_int_word_102_comment},
  {"has_int64_word", &Dtool_ConfigDeclaration_has_int64_word_103, METH_O, (const char *)Dtool_ConfigDeclaration_has_int64_word_103_comment},
  {"hasInt64Word", &Dtool_ConfigDeclaration_has_int64_word_103, METH_O, (const char *)Dtool_ConfigDeclaration_has_int64_word_103_comment},
  {"has_double_word", &Dtool_ConfigDeclaration_has_double_word_104, METH_O, (const char *)Dtool_ConfigDeclaration_has_double_word_104_comment},
  {"hasDoubleWord", &Dtool_ConfigDeclaration_has_double_word_104, METH_O, (const char *)Dtool_ConfigDeclaration_has_double_word_104_comment},
  {"get_string_word", &Dtool_ConfigDeclaration_get_string_word_105, METH_O, (const char *)Dtool_ConfigDeclaration_get_string_word_105_comment},
  {"getStringWord", &Dtool_ConfigDeclaration_get_string_word_105, METH_O, (const char *)Dtool_ConfigDeclaration_get_string_word_105_comment},
  {"get_bool_word", &Dtool_ConfigDeclaration_get_bool_word_106, METH_O, (const char *)Dtool_ConfigDeclaration_get_bool_word_106_comment},
  {"getBoolWord", &Dtool_ConfigDeclaration_get_bool_word_106, METH_O, (const char *)Dtool_ConfigDeclaration_get_bool_word_106_comment},
  {"get_int_word", &Dtool_ConfigDeclaration_get_int_word_107, METH_O, (const char *)Dtool_ConfigDeclaration_get_int_word_107_comment},
  {"getIntWord", &Dtool_ConfigDeclaration_get_int_word_107, METH_O, (const char *)Dtool_ConfigDeclaration_get_int_word_107_comment},
  {"get_int64_word", &Dtool_ConfigDeclaration_get_int64_word_108, METH_O, (const char *)Dtool_ConfigDeclaration_get_int64_word_108_comment},
  {"getInt64Word", &Dtool_ConfigDeclaration_get_int64_word_108, METH_O, (const char *)Dtool_ConfigDeclaration_get_int64_word_108_comment},
  {"get_double_word", &Dtool_ConfigDeclaration_get_double_word_109, METH_O, (const char *)Dtool_ConfigDeclaration_get_double_word_109_comment},
  {"getDoubleWord", &Dtool_ConfigDeclaration_get_double_word_109, METH_O, (const char *)Dtool_ConfigDeclaration_get_double_word_109_comment},
  {"set_string_word", (PyCFunction) &Dtool_ConfigDeclaration_set_string_word_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_string_word_110_comment},
  {"setStringWord", (PyCFunction) &Dtool_ConfigDeclaration_set_string_word_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_string_word_110_comment},
  {"set_bool_word", (PyCFunction) &Dtool_ConfigDeclaration_set_bool_word_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_bool_word_111_comment},
  {"setBoolWord", (PyCFunction) &Dtool_ConfigDeclaration_set_bool_word_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_bool_word_111_comment},
  {"set_int_word", (PyCFunction) &Dtool_ConfigDeclaration_set_int_word_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int_word_112_comment},
  {"setIntWord", (PyCFunction) &Dtool_ConfigDeclaration_set_int_word_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int_word_112_comment},
  {"set_int64_word", (PyCFunction) &Dtool_ConfigDeclaration_set_int64_word_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int64_word_113_comment},
  {"setInt64Word", (PyCFunction) &Dtool_ConfigDeclaration_set_int64_word_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int64_word_113_comment},
  {"set_double_word", (PyCFunction) &Dtool_ConfigDeclaration_set_double_word_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_double_word_114_comment},
  {"setDoubleWord", (PyCFunction) &Dtool_ConfigDeclaration_set_double_word_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_double_word_114_comment},
  {"get_filename_value", &Dtool_ConfigDeclaration_get_filename_value_115, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_filename_value_115_comment},
  {"getFilenameValue", &Dtool_ConfigDeclaration_get_filename_value_115, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_filename_value_115_comment},
  {"get_decl_seq", &Dtool_ConfigDeclaration_get_decl_seq_116, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_decl_seq_116_comment},
  {"getDeclSeq", &Dtool_ConfigDeclaration_get_decl_seq_116, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_decl_seq_116_comment},
  {"output", &Dtool_ConfigDeclaration_output_117, METH_O, (const char *)Dtool_ConfigDeclaration_output_117_comment},
  {"write", &Dtool_ConfigDeclaration_write_118, METH_O, (const char *)Dtool_ConfigDeclaration_write_118_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConfigDeclaration
//////////////////
static PyObject *Dtool_Repr_ConfigDeclaration(PyObject *self) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigDeclaration
//////////////////
static PyObject *Dtool_Str_ConfigDeclaration(PyObject *self) {
  ConfigDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigDeclaration[] = {
  {(char *)"page", &Dtool_ConfigDeclaration_page_Getter, nullptr, nullptr, nullptr},
  {(char *)"variable", &Dtool_ConfigDeclaration_variable_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigDeclaration = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigDeclaration = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigDeclaration = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigDeclaration = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigDeclaration = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigDeclaration = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigDeclaration",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigDeclaration,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigDeclaration,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigDeclaration,
    &Dtool_NumberMethods_ConfigDeclaration,
    &Dtool_SequenceMethods_ConfigDeclaration,
    &Dtool_MappingMethods_ConfigDeclaration,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigDeclaration,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigDeclaration,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single declaration of a config variable, typically defined as one line in\n"
    " * a .prc file, e.g.  \"show-frame-rate-meter 1\".  This is really just a\n"
    " * pairing of a string name (actually, a ConfigVariableCore pointer) to a\n"
    " * string value.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigDeclaration,
    nullptr, // tp_members
    Dtool_Properties_ConfigDeclaration,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigDeclaration,
    PyType_GenericAlloc,
    Dtool_new_ConfigDeclaration,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigDeclaration,
  Dtool_UpcastInterface_ConfigDeclaration,
  Dtool_DowncastInterface_ConfigDeclaration,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigDeclaration(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(nullptr);
    Dtool_ConfigDeclaration._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    Dtool_ConfigDeclaration._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigDeclaration._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigDeclaration) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigDeclaration)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigDeclaration);
  }
}

/**
 * Python method tables for ConfigVariableCore (ConfigVariableCore)
 */
static PyMethodDef Dtool_Methods_ConfigVariableCore[] = {
  {"get_name", &Dtool_ConfigVariableCore_get_name_51, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_name_51_comment},
  {"getName", &Dtool_ConfigVariableCore_get_name_51, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_name_51_comment},
  {"is_used", &Dtool_ConfigVariableCore_is_used_52, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_used_52_comment},
  {"isUsed", &Dtool_ConfigVariableCore_is_used_52, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_used_52_comment},
  {"get_value_type", &Dtool_ConfigVariableCore_get_value_type_53, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_value_type_53_comment},
  {"getValueType", &Dtool_ConfigVariableCore_get_value_type_53, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_value_type_53_comment},
  {"get_description", &Dtool_ConfigVariableCore_get_description_54, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_description_54_comment},
  {"getDescription", &Dtool_ConfigVariableCore_get_description_54, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_description_54_comment},
  {"get_flags", &Dtool_ConfigVariableCore_get_flags_55, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_flags_55_comment},
  {"getFlags", &Dtool_ConfigVariableCore_get_flags_55, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_flags_55_comment},
  {"is_closed", &Dtool_ConfigVariableCore_is_closed_56, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_closed_56_comment},
  {"isClosed", &Dtool_ConfigVariableCore_is_closed_56, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_closed_56_comment},
  {"get_trust_level", &Dtool_ConfigVariableCore_get_trust_level_57, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_trust_level_57_comment},
  {"getTrustLevel", &Dtool_ConfigVariableCore_get_trust_level_57, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_trust_level_57_comment},
  {"is_dynamic", &Dtool_ConfigVariableCore_is_dynamic_58, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_dynamic_58_comment},
  {"isDynamic", &Dtool_ConfigVariableCore_is_dynamic_58, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_dynamic_58_comment},
  {"get_default_value", &Dtool_ConfigVariableCore_get_default_value_59, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_default_value_59_comment},
  {"getDefaultValue", &Dtool_ConfigVariableCore_get_default_value_59, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_default_value_59_comment},
  {"set_value_type", &Dtool_ConfigVariableCore_set_value_type_60, METH_O, (const char *)Dtool_ConfigVariableCore_set_value_type_60_comment},
  {"setValueType", &Dtool_ConfigVariableCore_set_value_type_60, METH_O, (const char *)Dtool_ConfigVariableCore_set_value_type_60_comment},
  {"set_flags", &Dtool_ConfigVariableCore_set_flags_61, METH_O, (const char *)Dtool_ConfigVariableCore_set_flags_61_comment},
  {"setFlags", &Dtool_ConfigVariableCore_set_flags_61, METH_O, (const char *)Dtool_ConfigVariableCore_set_flags_61_comment},
  {"set_description", &Dtool_ConfigVariableCore_set_description_62, METH_O, (const char *)Dtool_ConfigVariableCore_set_description_62_comment},
  {"setDescription", &Dtool_ConfigVariableCore_set_description_62, METH_O, (const char *)Dtool_ConfigVariableCore_set_description_62_comment},
  {"set_default_value", &Dtool_ConfigVariableCore_set_default_value_63, METH_O, (const char *)Dtool_ConfigVariableCore_set_default_value_63_comment},
  {"setDefaultValue", &Dtool_ConfigVariableCore_set_default_value_63, METH_O, (const char *)Dtool_ConfigVariableCore_set_default_value_63_comment},
  {"set_used", &Dtool_ConfigVariableCore_set_used_64, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_set_used_64_comment},
  {"setUsed", &Dtool_ConfigVariableCore_set_used_64, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_set_used_64_comment},
  {"make_local_value", &Dtool_ConfigVariableCore_make_local_value_65, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_make_local_value_65_comment},
  {"makeLocalValue", &Dtool_ConfigVariableCore_make_local_value_65, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_make_local_value_65_comment},
  {"clear_local_value", &Dtool_ConfigVariableCore_clear_local_value_66, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_clear_local_value_66_comment},
  {"clearLocalValue", &Dtool_ConfigVariableCore_clear_local_value_66, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_clear_local_value_66_comment},
  {"has_local_value", &Dtool_ConfigVariableCore_has_local_value_67, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_local_value_67_comment},
  {"hasLocalValue", &Dtool_ConfigVariableCore_has_local_value_67, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_local_value_67_comment},
  {"has_value", &Dtool_ConfigVariableCore_has_value_68, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_value_68_comment},
  {"hasValue", &Dtool_ConfigVariableCore_has_value_68, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_value_68_comment},
  {"get_num_declarations", &Dtool_ConfigVariableCore_get_num_declarations_69, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_declarations_69_comment},
  {"getNumDeclarations", &Dtool_ConfigVariableCore_get_num_declarations_69, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_declarations_69_comment},
  {"get_declaration", &Dtool_ConfigVariableCore_get_declaration_70, METH_O, (const char *)Dtool_ConfigVariableCore_get_declaration_70_comment},
  {"getDeclaration", &Dtool_ConfigVariableCore_get_declaration_70, METH_O, (const char *)Dtool_ConfigVariableCore_get_declaration_70_comment},
  {"get_num_references", &Dtool_ConfigVariableCore_get_num_references_72, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_references_72_comment},
  {"getNumReferences", &Dtool_ConfigVariableCore_get_num_references_72, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_references_72_comment},
  {"get_reference", &Dtool_ConfigVariableCore_get_reference_73, METH_O, (const char *)Dtool_ConfigVariableCore_get_reference_73_comment},
  {"getReference", &Dtool_ConfigVariableCore_get_reference_73, METH_O, (const char *)Dtool_ConfigVariableCore_get_reference_73_comment},
  {"get_num_trusted_references", &Dtool_ConfigVariableCore_get_num_trusted_references_75, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_trusted_references_75_comment},
  {"getNumTrustedReferences", &Dtool_ConfigVariableCore_get_num_trusted_references_75, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_trusted_references_75_comment},
  {"get_trusted_reference", &Dtool_ConfigVariableCore_get_trusted_reference_76, METH_O, (const char *)Dtool_ConfigVariableCore_get_trusted_reference_76_comment},
  {"getTrustedReference", &Dtool_ConfigVariableCore_get_trusted_reference_76, METH_O, (const char *)Dtool_ConfigVariableCore_get_trusted_reference_76_comment},
  {"get_num_unique_references", &Dtool_ConfigVariableCore_get_num_unique_references_78, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_unique_references_78_comment},
  {"getNumUniqueReferences", &Dtool_ConfigVariableCore_get_num_unique_references_78, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_unique_references_78_comment},
  {"get_unique_reference", &Dtool_ConfigVariableCore_get_unique_reference_79, METH_O, (const char *)Dtool_ConfigVariableCore_get_unique_reference_79_comment},
  {"getUniqueReference", &Dtool_ConfigVariableCore_get_unique_reference_79, METH_O, (const char *)Dtool_ConfigVariableCore_get_unique_reference_79_comment},
  {"output", &Dtool_ConfigVariableCore_output_84, METH_O, (const char *)Dtool_ConfigVariableCore_output_84_comment},
  {"write", &Dtool_ConfigVariableCore_write_85, METH_O, (const char *)Dtool_ConfigVariableCore_write_85_comment},
  {"get_declarations", (PyCFunction) &MakeSeq_ConfigVariableCore_get_declarations, METH_NOARGS, nullptr},
  { "getDeclarations", (PyCFunction) &MakeSeq_ConfigVariableCore_get_declarations, METH_NOARGS, nullptr},
  {"get_references", (PyCFunction) &MakeSeq_ConfigVariableCore_get_references, METH_NOARGS, nullptr},
  { "getReferences", (PyCFunction) &MakeSeq_ConfigVariableCore_get_references, METH_NOARGS, nullptr},
  {"get_trusted_references", (PyCFunction) &MakeSeq_ConfigVariableCore_get_trusted_references, METH_NOARGS, nullptr},
  { "getTrustedReferences", (PyCFunction) &MakeSeq_ConfigVariableCore_get_trusted_references, METH_NOARGS, nullptr},
  {"get_unique_references", (PyCFunction) &MakeSeq_ConfigVariableCore_get_unique_references, METH_NOARGS, nullptr},
  { "getUniqueReferences", (PyCFunction) &MakeSeq_ConfigVariableCore_get_unique_references, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConfigVariableCore
//////////////////
static PyObject *Dtool_Repr_ConfigVariableCore(PyObject *self) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableCore
//////////////////
static PyObject *Dtool_Str_ConfigVariableCore(PyObject *self) {
  ConfigVariableCore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableCore[] = {
  {(char *)"declarations", &Dtool_ConfigVariableCore_declarations_Getter, nullptr, nullptr, nullptr},
  {(char *)"name", &Dtool_ConfigVariableCore_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"used", &Dtool_ConfigVariableCore_used_Getter, nullptr, nullptr, nullptr},
  {(char *)"closed", &Dtool_ConfigVariableCore_closed_Getter, nullptr, nullptr, nullptr},
  {(char *)"trust_level", &Dtool_ConfigVariableCore_trust_level_Getter, nullptr, nullptr, nullptr},
  {(char *)"dynamic", &Dtool_ConfigVariableCore_dynamic_Getter, nullptr, nullptr, nullptr},
  {(char *)"value_type", &Dtool_ConfigVariableCore_value_type_Getter, &Dtool_ConfigVariableCore_value_type_Setter, nullptr, nullptr},
  {(char *)"description", &Dtool_ConfigVariableCore_description_Getter, &Dtool_ConfigVariableCore_description_Setter, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableCore_default_value_Getter, &Dtool_ConfigVariableCore_default_value_Setter, nullptr, nullptr},
  {(char *)"references", &Dtool_ConfigVariableCore_references_Getter, nullptr, nullptr, nullptr},
  {(char *)"trusted_references", &Dtool_ConfigVariableCore_trusted_references_Getter, nullptr, nullptr, nullptr},
  {(char *)"unique_references", &Dtool_ConfigVariableCore_unique_references_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableCore = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableCore = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableCore = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableCore = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableCore = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableCore = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableCore",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableCore,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableCore,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableCore,
    &Dtool_NumberMethods_ConfigVariableCore,
    &Dtool_SequenceMethods_ConfigVariableCore,
    &Dtool_MappingMethods_ConfigVariableCore,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigVariableCore,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableCore,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The internal definition of a ConfigVariable.  This object is shared between\n"
    " * all instances of a ConfigVariable that use the same variable name.\n"
    " *\n"
    " * You cannot create a ConfigVariableCore instance directly; instead, use the\n"
    " * make() method, which may return a shared instance.  Once created, these\n"
    " * objects are never destructed.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableCore,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableCore,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableCore,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableCore,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableCore,
  Dtool_UpcastInterface_ConfigVariableCore,
  Dtool_DowncastInterface_ConfigVariableCore,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableCore(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(nullptr);
    Dtool_ConfigVariableCore._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    Dtool_ConfigVariableCore._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableCore._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableCore) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableCore)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableCore);
  }
}

/**
 * Python method tables for Notify (Notify)
 */
static PyMethodDef Dtool_Methods_Notify[] = {
  {"set_ostream_ptr", (PyCFunction) &Dtool_Notify_set_ostream_ptr_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_set_ostream_ptr_126_comment},
  {"setOstreamPtr", (PyCFunction) &Dtool_Notify_set_ostream_ptr_126, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_set_ostream_ptr_126_comment},
  {"get_ostream_ptr", &Dtool_Notify_get_ostream_ptr_127, METH_NOARGS, (const char *)Dtool_Notify_get_ostream_ptr_127_comment},
  {"getOstreamPtr", &Dtool_Notify_get_ostream_ptr_127, METH_NOARGS, (const char *)Dtool_Notify_get_ostream_ptr_127_comment},
  {"clear_assert_handler", &Dtool_Notify_clear_assert_handler_129, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_handler_129_comment},
  {"clearAssertHandler", &Dtool_Notify_clear_assert_handler_129, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_handler_129_comment},
  {"has_assert_handler", &Dtool_Notify_has_assert_handler_130, METH_NOARGS, (const char *)Dtool_Notify_has_assert_handler_130_comment},
  {"hasAssertHandler", &Dtool_Notify_has_assert_handler_130, METH_NOARGS, (const char *)Dtool_Notify_has_assert_handler_130_comment},
  {"has_assert_failed", &Dtool_Notify_has_assert_failed_132, METH_NOARGS, (const char *)Dtool_Notify_has_assert_failed_132_comment},
  {"hasAssertFailed", &Dtool_Notify_has_assert_failed_132, METH_NOARGS, (const char *)Dtool_Notify_has_assert_failed_132_comment},
  {"get_assert_error_message", &Dtool_Notify_get_assert_error_message_133, METH_NOARGS, (const char *)Dtool_Notify_get_assert_error_message_133_comment},
  {"getAssertErrorMessage", &Dtool_Notify_get_assert_error_message_133, METH_NOARGS, (const char *)Dtool_Notify_get_assert_error_message_133_comment},
  {"clear_assert_failed", &Dtool_Notify_clear_assert_failed_134, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_failed_134_comment},
  {"clearAssertFailed", &Dtool_Notify_clear_assert_failed_134, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_failed_134_comment},
  {"get_top_category", &Dtool_Notify_get_top_category_135, METH_NOARGS, (const char *)Dtool_Notify_get_top_category_135_comment},
  {"getTopCategory", &Dtool_Notify_get_top_category_135, METH_NOARGS, (const char *)Dtool_Notify_get_top_category_135_comment},
  {"get_category", (PyCFunction) &Dtool_Notify_get_category_136, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_get_category_136_comment},
  {"getCategory", (PyCFunction) &Dtool_Notify_get_category_136, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_get_category_136_comment},
  {"out", &Dtool_Notify_out_137, METH_NOARGS | METH_STATIC, (const char *)Dtool_Notify_out_137_comment},
  {"null", &Dtool_Notify_null_138, METH_NOARGS | METH_STATIC, (const char *)Dtool_Notify_null_138_comment},
  {"write_string", &Dtool_Notify_write_string_139, METH_O | METH_STATIC, (const char *)Dtool_Notify_write_string_139_comment},
  {"writeString", &Dtool_Notify_write_string_139, METH_O | METH_STATIC, (const char *)Dtool_Notify_write_string_139_comment},
  {"ptr", &Dtool_Notify_ptr_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_Notify_ptr_140_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Notify = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Notify = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Notify",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Notify,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Notify,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An object that handles general error reporting to the user.  It contains a\n"
    " * pointer to an ostream, initially cerr, which can be reset at will to point\n"
    " * to different output devices, according to the needs of the application.\n"
    " * All output generated within Panda should vector through the Notify ostream.\n"
    " *\n"
    " * This also includes a collection of Categories and Severities, which may be\n"
    " * independently enabled or disabled, so that error messages may be squelched\n"
    " * or respected according to the wishes of the user.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Notify,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Notify,
    PyType_GenericAlloc,
    Dtool_new_Notify,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Notify,
  Dtool_UpcastInterface_Notify,
  Dtool_DowncastInterface_Notify,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Notify(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Notify._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Notify._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Notify) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Notify)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Notify);
  }
}

/**
 * Python method tables for ConfigPageManager (ConfigPageManager)
 */
static PyMethodDef Dtool_Methods_ConfigPageManager[] = {
  {"loaded_implicit_pages", &Dtool_ConfigPageManager_loaded_implicit_pages_142, METH_NOARGS, (const char *)Dtool_ConfigPageManager_loaded_implicit_pages_142_comment},
  {"loadedImplicitPages", &Dtool_ConfigPageManager_loaded_implicit_pages_142, METH_NOARGS, (const char *)Dtool_ConfigPageManager_loaded_implicit_pages_142_comment},
  {"load_implicit_pages", &Dtool_ConfigPageManager_load_implicit_pages_143, METH_NOARGS, (const char *)Dtool_ConfigPageManager_load_implicit_pages_143_comment},
  {"loadImplicitPages", &Dtool_ConfigPageManager_load_implicit_pages_143, METH_NOARGS, (const char *)Dtool_ConfigPageManager_load_implicit_pages_143_comment},
  {"reload_implicit_pages", &Dtool_ConfigPageManager_reload_implicit_pages_144, METH_NOARGS, (const char *)Dtool_ConfigPageManager_reload_implicit_pages_144_comment},
  {"reloadImplicitPages", &Dtool_ConfigPageManager_reload_implicit_pages_144, METH_NOARGS, (const char *)Dtool_ConfigPageManager_reload_implicit_pages_144_comment},
  {"get_search_path", &Dtool_ConfigPageManager_get_search_path_145, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_search_path_145_comment},
  {"getSearchPath", &Dtool_ConfigPageManager_get_search_path_145, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_search_path_145_comment},
  {"get_num_prc_patterns", &Dtool_ConfigPageManager_get_num_prc_patterns_146, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_patterns_146_comment},
  {"getNumPrcPatterns", &Dtool_ConfigPageManager_get_num_prc_patterns_146, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_patterns_146_comment},
  {"get_prc_pattern", &Dtool_ConfigPageManager_get_prc_pattern_147, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_pattern_147_comment},
  {"getPrcPattern", &Dtool_ConfigPageManager_get_prc_pattern_147, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_pattern_147_comment},
  {"get_num_prc_encrypted_patterns", &Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_148, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_148_comment},
  {"getNumPrcEncryptedPatterns", &Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_148, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_148_comment},
  {"get_prc_encrypted_pattern", &Dtool_ConfigPageManager_get_prc_encrypted_pattern_149, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_encrypted_pattern_149_comment},
  {"getPrcEncryptedPattern", &Dtool_ConfigPageManager_get_prc_encrypted_pattern_149, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_encrypted_pattern_149_comment},
  {"get_num_prc_executable_patterns", &Dtool_ConfigPageManager_get_num_prc_executable_patterns_150, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_executable_patterns_150_comment},
  {"getNumPrcExecutablePatterns", &Dtool_ConfigPageManager_get_num_prc_executable_patterns_150, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_executable_patterns_150_comment},
  {"get_prc_executable_pattern", &Dtool_ConfigPageManager_get_prc_executable_pattern_151, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_executable_pattern_151_comment},
  {"getPrcExecutablePattern", &Dtool_ConfigPageManager_get_prc_executable_pattern_151, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_executable_pattern_151_comment},
  {"make_explicit_page", &Dtool_ConfigPageManager_make_explicit_page_152, METH_O, (const char *)Dtool_ConfigPageManager_make_explicit_page_152_comment},
  {"makeExplicitPage", &Dtool_ConfigPageManager_make_explicit_page_152, METH_O, (const char *)Dtool_ConfigPageManager_make_explicit_page_152_comment},
  {"delete_explicit_page", &Dtool_ConfigPageManager_delete_explicit_page_153, METH_O, (const char *)Dtool_ConfigPageManager_delete_explicit_page_153_comment},
  {"deleteExplicitPage", &Dtool_ConfigPageManager_delete_explicit_page_153, METH_O, (const char *)Dtool_ConfigPageManager_delete_explicit_page_153_comment},
  {"get_num_implicit_pages", &Dtool_ConfigPageManager_get_num_implicit_pages_154, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_implicit_pages_154_comment},
  {"getNumImplicitPages", &Dtool_ConfigPageManager_get_num_implicit_pages_154, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_implicit_pages_154_comment},
  {"get_implicit_page", &Dtool_ConfigPageManager_get_implicit_page_155, METH_O, (const char *)Dtool_ConfigPageManager_get_implicit_page_155_comment},
  {"getImplicitPage", &Dtool_ConfigPageManager_get_implicit_page_155, METH_O, (const char *)Dtool_ConfigPageManager_get_implicit_page_155_comment},
  {"get_num_explicit_pages", &Dtool_ConfigPageManager_get_num_explicit_pages_156, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_explicit_pages_156_comment},
  {"getNumExplicitPages", &Dtool_ConfigPageManager_get_num_explicit_pages_156, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_explicit_pages_156_comment},
  {"get_explicit_page", &Dtool_ConfigPageManager_get_explicit_page_157, METH_O, (const char *)Dtool_ConfigPageManager_get_explicit_page_157_comment},
  {"getExplicitPage", &Dtool_ConfigPageManager_get_explicit_page_157, METH_O, (const char *)Dtool_ConfigPageManager_get_explicit_page_157_comment},
  {"output", &Dtool_ConfigPageManager_output_158, METH_O, (const char *)Dtool_ConfigPageManager_output_158_comment},
  {"write", &Dtool_ConfigPageManager_write_159, METH_O, (const char *)Dtool_ConfigPageManager_write_159_comment},
  {"get_global_ptr", &Dtool_ConfigPageManager_get_global_ptr_160, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPageManager_get_global_ptr_160_comment},
  {"getGlobalPtr", &Dtool_ConfigPageManager_get_global_ptr_160, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPageManager_get_global_ptr_160_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConfigPageManager
//////////////////
static PyObject *Dtool_Repr_ConfigPageManager(PyObject *self) {
  ConfigPageManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigPageManager
//////////////////
static PyObject *Dtool_Str_ConfigPageManager(PyObject *self) {
  ConfigPageManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConfigPageManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigPageManager = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigPageManager = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigPageManager = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigPageManager = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigPageManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigPageManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigPageManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigPageManager,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigPageManager,
    &Dtool_NumberMethods_ConfigPageManager,
    &Dtool_SequenceMethods_ConfigPageManager,
    &Dtool_MappingMethods_ConfigPageManager,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigPageManager,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigPageManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A global object that maintains the set of ConfigPages everywhere in the\n"
    " * world, and keeps them in sorted order.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigPageManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigPageManager,
    PyType_GenericAlloc,
    Dtool_new_ConfigPageManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigPageManager,
  Dtool_UpcastInterface_ConfigPageManager,
  Dtool_DowncastInterface_ConfigPageManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigPageManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(nullptr);
    Dtool_ConfigPageManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    Dtool_ConfigPageManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigPageManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigPageManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigPageManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigPageManager);
  }
}

/**
 * Python method tables for ConfigVariableManager (ConfigVariableManager)
 */
static PyMethodDef Dtool_Methods_ConfigVariableManager[] = {
  {"make_variable", &Dtool_ConfigVariableManager_make_variable_162, METH_O, (const char *)Dtool_ConfigVariableManager_make_variable_162_comment},
  {"makeVariable", &Dtool_ConfigVariableManager_make_variable_162, METH_O, (const char *)Dtool_ConfigVariableManager_make_variable_162_comment},
  {"make_variable_template", (PyCFunction) &Dtool_ConfigVariableManager_make_variable_template_163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableManager_make_variable_template_163_comment},
  {"makeVariableTemplate", (PyCFunction) &Dtool_ConfigVariableManager_make_variable_template_163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableManager_make_variable_template_163_comment},
  {"get_num_variables", &Dtool_ConfigVariableManager_get_num_variables_164, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_get_num_variables_164_comment},
  {"getNumVariables", &Dtool_ConfigVariableManager_get_num_variables_164, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_get_num_variables_164_comment},
  {"get_variable", &Dtool_ConfigVariableManager_get_variable_165, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_165_comment},
  {"getVariable", &Dtool_ConfigVariableManager_get_variable_165, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_165_comment},
  {"get_variable_name", &Dtool_ConfigVariableManager_get_variable_name_167, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_name_167_comment},
  {"getVariableName", &Dtool_ConfigVariableManager_get_variable_name_167, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_name_167_comment},
  {"is_variable_used", &Dtool_ConfigVariableManager_is_variable_used_168, METH_O, (const char *)Dtool_ConfigVariableManager_is_variable_used_168_comment},
  {"isVariableUsed", &Dtool_ConfigVariableManager_is_variable_used_168, METH_O, (const char *)Dtool_ConfigVariableManager_is_variable_used_168_comment},
  {"output", &Dtool_ConfigVariableManager_output_170, METH_O, (const char *)Dtool_ConfigVariableManager_output_170_comment},
  {"write", &Dtool_ConfigVariableManager_write_171, METH_O, (const char *)Dtool_ConfigVariableManager_write_171_comment},
  {"write_prc_variables", &Dtool_ConfigVariableManager_write_prc_variables_172, METH_O, (const char *)Dtool_ConfigVariableManager_write_prc_variables_172_comment},
  {"writePrcVariables", &Dtool_ConfigVariableManager_write_prc_variables_172, METH_O, (const char *)Dtool_ConfigVariableManager_write_prc_variables_172_comment},
  {"list_unused_variables", &Dtool_ConfigVariableManager_list_unused_variables_173, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_unused_variables_173_comment},
  {"listUnusedVariables", &Dtool_ConfigVariableManager_list_unused_variables_173, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_unused_variables_173_comment},
  {"list_variables", &Dtool_ConfigVariableManager_list_variables_174, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_variables_174_comment},
  {"listVariables", &Dtool_ConfigVariableManager_list_variables_174, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_variables_174_comment},
  {"list_dynamic_variables", &Dtool_ConfigVariableManager_list_dynamic_variables_175, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_dynamic_variables_175_comment},
  {"listDynamicVariables", &Dtool_ConfigVariableManager_list_dynamic_variables_175, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_dynamic_variables_175_comment},
  {"get_global_ptr", &Dtool_ConfigVariableManager_get_global_ptr_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigVariableManager_get_global_ptr_176_comment},
  {"getGlobalPtr", &Dtool_ConfigVariableManager_get_global_ptr_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigVariableManager_get_global_ptr_176_comment},
  {"get_variables", (PyCFunction) &MakeSeq_ConfigVariableManager_get_variables, METH_NOARGS, nullptr},
  { "getVariables", (PyCFunction) &MakeSeq_ConfigVariableManager_get_variables, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConfigVariableManager
//////////////////
static PyObject *Dtool_Repr_ConfigVariableManager(PyObject *self) {
  ConfigVariableManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableManager
//////////////////
static PyObject *Dtool_Str_ConfigVariableManager(PyObject *self) {
  ConfigVariableManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableManager[] = {
  {(char *)"variables", &Dtool_ConfigVariableManager_variables_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableManager,
    &Dtool_NumberMethods_ConfigVariableManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigVariableManager,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A global object that maintains the set of ConfigVariables (actually,\n"
    " * ConfigVariableCores) everywhere in the world, and keeps them in sorted\n"
    " * order.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableManager,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableManager,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableManager,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableManager,
  Dtool_UpcastInterface_ConfigVariableManager,
  Dtool_DowncastInterface_ConfigVariableManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConfigVariableManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableManager);
  }
}

/**
 * Python method tables for ConfigVariableBase (ConfigVariableBase)
 */
static PyMethodDef Dtool_Methods_ConfigVariableBase[] = {
  {"get_name", &Dtool_ConfigVariableBase_get_name_178, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_name_178_comment},
  {"getName", &Dtool_ConfigVariableBase_get_name_178, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_name_178_comment},
  {"get_value_type", &Dtool_ConfigVariableBase_get_value_type_179, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_value_type_179_comment},
  {"getValueType", &Dtool_ConfigVariableBase_get_value_type_179, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_value_type_179_comment},
  {"get_description", &Dtool_ConfigVariableBase_get_description_180, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_description_180_comment},
  {"getDescription", &Dtool_ConfigVariableBase_get_description_180, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_description_180_comment},
  {"get_flags", &Dtool_ConfigVariableBase_get_flags_181, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_flags_181_comment},
  {"getFlags", &Dtool_ConfigVariableBase_get_flags_181, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_flags_181_comment},
  {"is_closed", &Dtool_ConfigVariableBase_is_closed_182, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_closed_182_comment},
  {"isClosed", &Dtool_ConfigVariableBase_is_closed_182, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_closed_182_comment},
  {"get_trust_level", &Dtool_ConfigVariableBase_get_trust_level_183, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_trust_level_183_comment},
  {"getTrustLevel", &Dtool_ConfigVariableBase_get_trust_level_183, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_trust_level_183_comment},
  {"is_dynamic", &Dtool_ConfigVariableBase_is_dynamic_184, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_dynamic_184_comment},
  {"isDynamic", &Dtool_ConfigVariableBase_is_dynamic_184, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_dynamic_184_comment},
  {"clear_local_value", &Dtool_ConfigVariableBase_clear_local_value_191, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_clear_local_value_191_comment},
  {"clearLocalValue", &Dtool_ConfigVariableBase_clear_local_value_191, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_clear_local_value_191_comment},
  {"has_local_value", &Dtool_ConfigVariableBase_has_local_value_192, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_local_value_192_comment},
  {"hasLocalValue", &Dtool_ConfigVariableBase_has_local_value_192, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_local_value_192_comment},
  {"has_value", &Dtool_ConfigVariableBase_has_value_193, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_value_193_comment},
  {"hasValue", &Dtool_ConfigVariableBase_has_value_193, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_value_193_comment},
  {"output", &Dtool_ConfigVariableBase_output_194, METH_O, (const char *)Dtool_ConfigVariableBase_output_194_comment},
  {"write", &Dtool_ConfigVariableBase_write_195, METH_O, (const char *)Dtool_ConfigVariableBase_write_195_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConfigVariableBase
//////////////////
static PyObject *Dtool_Repr_ConfigVariableBase(PyObject *self) {
  ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableBase
//////////////////
static PyObject *Dtool_Str_ConfigVariableBase(PyObject *self) {
  ConfigVariableBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableBase[] = {
  {(char *)"name", &Dtool_ConfigVariableBase_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"value_type", &Dtool_ConfigVariableBase_value_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"description", &Dtool_ConfigVariableBase_description_Getter, nullptr, nullptr, nullptr},
  {(char *)"closed", &Dtool_ConfigVariableBase_closed_Getter, nullptr, nullptr, nullptr},
  {(char *)"trust_level", &Dtool_ConfigVariableBase_trust_level_Getter, nullptr, nullptr, nullptr},
  {(char *)"dynamic", &Dtool_ConfigVariableBase_dynamic_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableBase = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableBase = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableBase = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableBase = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableBase,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableBase,
    &Dtool_NumberMethods_ConfigVariableBase,
    &Dtool_SequenceMethods_ConfigVariableBase,
    &Dtool_MappingMethods_ConfigVariableBase,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigVariableBase,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is the base class for both ConfigVariableList and ConfigVariable\n"
    " * (and hence for all of the ConfigVariableBool, ConfigVaribleString, etc.\n"
    " * classes).  It collects together the common interface for all generic\n"
    " * ConfigVariables.\n"
    " *\n"
    " * Mostly, this class serves as a thin wrapper around ConfigVariableCore\n"
    " * and/or ConfigDeclaration, more or less duplicating the interface presented\n"
    " * there.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableBase,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableBase,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableBase,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableBase,
  Dtool_UpcastInterface_ConfigVariableBase,
  Dtool_DowncastInterface_ConfigVariableBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(nullptr);
    Dtool_ConfigVariableBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    Dtool_ConfigVariableBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableBase);
  }
}

/**
 * Python method tables for ConfigVariable (ConfigVariable)
 */
static PyMethodDef Dtool_Methods_ConfigVariable[] = {
  {"get_string_value", &Dtool_ConfigVariable_get_string_value_199, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_string_value_199_comment},
  {"getStringValue", &Dtool_ConfigVariable_get_string_value_199, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_string_value_199_comment},
  {"set_string_value", &Dtool_ConfigVariable_set_string_value_200, METH_O, (const char *)Dtool_ConfigVariable_set_string_value_200_comment},
  {"setStringValue", &Dtool_ConfigVariable_set_string_value_200, METH_O, (const char *)Dtool_ConfigVariable_set_string_value_200_comment},
  {"clear_value", &Dtool_ConfigVariable_clear_value_201, METH_NOARGS, (const char *)Dtool_ConfigVariable_clear_value_201_comment},
  {"clearValue", &Dtool_ConfigVariable_clear_value_201, METH_NOARGS, (const char *)Dtool_ConfigVariable_clear_value_201_comment},
  {"get_num_words", &Dtool_ConfigVariable_get_num_words_202, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_num_words_202_comment},
  {"getNumWords", &Dtool_ConfigVariable_get_num_words_202, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_num_words_202_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigVariable,
    &Dtool_SequenceMethods_ConfigVariable,
    &Dtool_MappingMethods_ConfigVariable,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a generic, untyped ConfigVariable.  It is also the base class for\n"
    " * the typed ConfigVariables, and contains all of the code common to\n"
    " * ConfigVariables of all types (except ConfigVariableList, which is a bit of\n"
    " * a special case).\n"
    " *\n"
    " * Mostly, this class serves as a thin wrapper around ConfigVariableCore\n"
    " * and/or ConfigDeclaration, more or less duplicating the interface presented\n"
    " * there.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariable,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariable,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariable,
  Dtool_UpcastInterface_ConfigVariable,
  Dtool_DowncastInterface_ConfigVariable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariableBase(nullptr);
    Dtool_ConfigVariable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariableBase);
    Dtool_ConfigVariable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariable);
  }
}

/**
 * Python method tables for ConfigVariableBool (ConfigVariableBool)
 */
static PyMethodDef Dtool_Methods_ConfigVariableBool[] = {
  {"assign", &Dtool_ConfigVariableBool_operator_205, METH_O, (const char *)Dtool_ConfigVariableBool_operator_205_comment},
  {"set_value", &Dtool_ConfigVariableBool_set_value_209, METH_O, (const char *)Dtool_ConfigVariableBool_set_value_209_comment},
  {"setValue", &Dtool_ConfigVariableBool_set_value_209, METH_O, (const char *)Dtool_ConfigVariableBool_set_value_209_comment},
  {"get_value", &Dtool_ConfigVariableBool_get_value_210, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_value_210_comment},
  {"getValue", &Dtool_ConfigVariableBool_get_value_210, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_value_210_comment},
  {"get_default_value", &Dtool_ConfigVariableBool_get_default_value_211, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_default_value_211_comment},
  {"getDefaultValue", &Dtool_ConfigVariableBool_get_default_value_211, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_default_value_211_comment},
  {"get_word", &Dtool_ConfigVariableBool_get_word_214, METH_O, (const char *)Dtool_ConfigVariableBool_get_word_214_comment},
  {"getWord", &Dtool_ConfigVariableBool_get_word_214, METH_O, (const char *)Dtool_ConfigVariableBool_get_word_214_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableBool_set_word_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableBool_set_word_215_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableBool_set_word_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableBool_set_word_215_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableBool slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_ConfigVariableBool_operator_typecast_bool_206_nb_bool(PyObject *self) {
  ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableBool slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableBool_operator_208_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableBool index out of range");
    return nullptr;
  }
  // 1-inline bool ConfigVariableBool::operator [](std::size_t n) const
  bool return_value = ((*(const ConfigVariableBool*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableBool self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableBool slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableBool_size_207_sq_length(PyObject *self) {
  ConfigVariableBool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableBool[] = {
  {(char *)"value", &Dtool_ConfigVariableBool_value_Getter, &Dtool_ConfigVariableBool_value_Setter, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableBool_default_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableBool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_ConfigVariableBool_operator_typecast_bool_206_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableBool = {
  &Dtool_ConfigVariableBool_size_207_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConfigVariableBool_operator_208_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableBool = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableBool = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableBool = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableBool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableBool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableBool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableBool,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigVariableBool,
    &Dtool_SequenceMethods_ConfigVariableBool,
    &Dtool_MappingMethods_ConfigVariableBool,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableBool,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a boolean type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableBool,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableBool,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableBool,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableBool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableBool,
  Dtool_UpcastInterface_ConfigVariableBool,
  Dtool_DowncastInterface_ConfigVariableBool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableBool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(nullptr);
    Dtool_ConfigVariableBool._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    Dtool_ConfigVariableBool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableBool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableBool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableBool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableBool);
  }
}

/**
 * Python method tables for ConfigVariableDouble (ConfigVariableDouble)
 */
static PyMethodDef Dtool_Methods_ConfigVariableDouble[] = {
  {"assign", &Dtool_ConfigVariableDouble_operator_219, METH_O, (const char *)Dtool_ConfigVariableDouble_operator_219_comment},
  {"set_value", &Dtool_ConfigVariableDouble_set_value_223, METH_O, (const char *)Dtool_ConfigVariableDouble_set_value_223_comment},
  {"setValue", &Dtool_ConfigVariableDouble_set_value_223, METH_O, (const char *)Dtool_ConfigVariableDouble_set_value_223_comment},
  {"get_value", &Dtool_ConfigVariableDouble_get_value_224, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_value_224_comment},
  {"getValue", &Dtool_ConfigVariableDouble_get_value_224, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_value_224_comment},
  {"get_default_value", &Dtool_ConfigVariableDouble_get_default_value_225, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_default_value_225_comment},
  {"getDefaultValue", &Dtool_ConfigVariableDouble_get_default_value_225, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_default_value_225_comment},
  {"get_word", &Dtool_ConfigVariableDouble_get_word_229, METH_O, (const char *)Dtool_ConfigVariableDouble_get_word_229_comment},
  {"getWord", &Dtool_ConfigVariableDouble_get_word_229, METH_O, (const char *)Dtool_ConfigVariableDouble_get_word_229_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableDouble_set_word_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableDouble_set_word_230_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableDouble_set_word_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableDouble_set_word_230_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableDouble slot nb_float -> operator typecast double
//////////////////
static PyObject *Dtool_ConfigVariableDouble_operator_typecast_double_220_nb_float(PyObject *self) {
  ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline operator double (void) const
  double return_value = (double)*(const ConfigVariableDouble*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast_double(ConfigVariableDouble self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableDouble slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableDouble_operator_222_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableDouble index out of range");
    return nullptr;
  }
  // 1-inline double ConfigVariableDouble::operator [](std::size_t n) const
  double return_value = ((*(const ConfigVariableDouble*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableDouble self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableDouble slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableDouble_size_221_sq_length(PyObject *self) {
  ConfigVariableDouble *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableDouble[] = {
  {(char *)"value", &Dtool_ConfigVariableDouble_value_Getter, &Dtool_ConfigVariableDouble_value_Setter, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableDouble_default_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableDouble = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  &Dtool_ConfigVariableDouble_operator_typecast_double_220_nb_float,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableDouble = {
  &Dtool_ConfigVariableDouble_size_221_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConfigVariableDouble_operator_222_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableDouble = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableDouble = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableDouble = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableDouble = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableDouble",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableDouble,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableDouble,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigVariableDouble,
    &Dtool_SequenceMethods_ConfigVariableDouble,
    &Dtool_MappingMethods_ConfigVariableDouble,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableDouble,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a floating-\n"
    " * point type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableDouble,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableDouble,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableDouble,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableDouble,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableDouble,
  Dtool_UpcastInterface_ConfigVariableDouble,
  Dtool_DowncastInterface_ConfigVariableDouble,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableDouble(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(nullptr);
    Dtool_ConfigVariableDouble._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    Dtool_ConfigVariableDouble._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableDouble._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableDouble) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableDouble)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableDouble);
  }
}

/**
 * Python method tables for ConfigVariableFilename (ConfigVariableFilename)
 */
static PyMethodDef Dtool_Methods_ConfigVariableFilename[] = {
  {"assign", &Dtool_ConfigVariableFilename_operator_234, METH_O, (const char *)Dtool_ConfigVariableFilename_operator_234_comment},
  {"c_str", &Dtool_ConfigVariableFilename_c_str_236, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_c_str_236_comment},
  {"cStr", &Dtool_ConfigVariableFilename_c_str_236, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_c_str_236_comment},
  {"empty", &Dtool_ConfigVariableFilename_empty_237, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_empty_237_comment},
  {"length", &Dtool_ConfigVariableFilename_length_238, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_length_238_comment},
  {"get_fullpath", &Dtool_ConfigVariableFilename_get_fullpath_240, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_240_comment},
  {"getFullpath", &Dtool_ConfigVariableFilename_get_fullpath_240, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_240_comment},
  {"get_dirname", &Dtool_ConfigVariableFilename_get_dirname_241, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_dirname_241_comment},
  {"getDirname", &Dtool_ConfigVariableFilename_get_dirname_241, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_dirname_241_comment},
  {"get_basename", &Dtool_ConfigVariableFilename_get_basename_242, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_242_comment},
  {"getBasename", &Dtool_ConfigVariableFilename_get_basename_242, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_242_comment},
  {"get_fullpath_wo_extension", &Dtool_ConfigVariableFilename_get_fullpath_wo_extension_243, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_wo_extension_243_comment},
  {"getFullpathWoExtension", &Dtool_ConfigVariableFilename_get_fullpath_wo_extension_243, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_wo_extension_243_comment},
  {"get_basename_wo_extension", &Dtool_ConfigVariableFilename_get_basename_wo_extension_244, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_wo_extension_244_comment},
  {"getBasenameWoExtension", &Dtool_ConfigVariableFilename_get_basename_wo_extension_244, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_wo_extension_244_comment},
  {"get_extension", &Dtool_ConfigVariableFilename_get_extension_245, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_extension_245_comment},
  {"getExtension", &Dtool_ConfigVariableFilename_get_extension_245, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_extension_245_comment},
  {"set_value", &Dtool_ConfigVariableFilename_set_value_249, METH_O, (const char *)Dtool_ConfigVariableFilename_set_value_249_comment},
  {"setValue", &Dtool_ConfigVariableFilename_set_value_249, METH_O, (const char *)Dtool_ConfigVariableFilename_set_value_249_comment},
  {"get_value", &Dtool_ConfigVariableFilename_get_value_250, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_value_250_comment},
  {"getValue", &Dtool_ConfigVariableFilename_get_value_250, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_value_250_comment},
  {"get_default_value", &Dtool_ConfigVariableFilename_get_default_value_251, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_default_value_251_comment},
  {"getDefaultValue", &Dtool_ConfigVariableFilename_get_default_value_251, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_default_value_251_comment},
  {"get_word", &Dtool_ConfigVariableFilename_get_word_255, METH_O, (const char *)Dtool_ConfigVariableFilename_get_word_255_comment},
  {"getWord", &Dtool_ConfigVariableFilename_get_word_255, METH_O, (const char *)Dtool_ConfigVariableFilename_get_word_255_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableFilename_set_word_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableFilename_set_word_256_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableFilename_set_word_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableFilename_set_word_256_comment},
  {"operator_typecast", &Dtool_ConfigVariableFilename_operator_typecast_235, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_operator_typecast_235_comment},
  {"operatorTypecast", &Dtool_ConfigVariableFilename_operator_typecast_235, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_operator_typecast_235_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableFilename slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableFilename_operator_239_mp_subscript(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return nullptr;
  }
  // 1-inline char ConfigVariableFilename::operator [](std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    char return_value = ((*(const ConfigVariableFilename*)local_this).operator [])(arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableFilename self, int n)\n");
  }
  return nullptr;
}

//////////////////
//  A rich comparison function
//     ConfigVariableFilename
//////////////////
static PyObject *Dtool_RichCompare_ConfigVariableFilename(PyObject *self, PyObject *arg, int op) {
  ConfigVariableFilename *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ConfigVariableFilename::operator ==(Filename const &other) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ConfigVariableFilename*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ConfigVariableFilename::operator !=(Filename const &other) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ConfigVariableFilename*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ConfigVariableFilename::operator <(Filename const &other) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ConfigVariableFilename*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ConfigVariableFilename[] = {
  {(char *)"value", &Dtool_ConfigVariableFilename_value_Getter, &Dtool_ConfigVariableFilename_value_Setter, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableFilename_default_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableFilename = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableFilename = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableFilename = {
  nullptr,
  &Dtool_ConfigVariableFilename_operator_239_mp_subscript,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableFilename = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableFilename = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableFilename = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableFilename",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableFilename,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableFilename,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigVariableFilename,
    &Dtool_SequenceMethods_ConfigVariableFilename,
    &Dtool_MappingMethods_ConfigVariableFilename,
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableFilename,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a Filename\n"
    " * type.  It is almost the same thing as ConfigVariableString, except it\n"
    " * handles an implicit Filename::expand_from() operation so that the user may\n"
    " * put OS-specific filenames, or filenames based on environment variables, in\n"
    " * the prc file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_ConfigVariableFilename,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableFilename,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableFilename,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableFilename,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableFilename,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableFilename,
  Dtool_UpcastInterface_ConfigVariableFilename,
  Dtool_DowncastInterface_ConfigVariableFilename,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableFilename(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(nullptr);
    Dtool_ConfigVariableFilename._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    Dtool_ConfigVariableFilename._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableFilename._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableFilename) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableFilename)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableFilename);
  }
}

/**
 * Python method tables for ConfigVariableInt (ConfigVariableInt)
 */
static PyMethodDef Dtool_Methods_ConfigVariableInt[] = {
  {"assign", &Dtool_ConfigVariableInt_operator_260, METH_O, (const char *)Dtool_ConfigVariableInt_operator_260_comment},
  {"set_value", &Dtool_ConfigVariableInt_set_value_264, METH_O, (const char *)Dtool_ConfigVariableInt_set_value_264_comment},
  {"setValue", &Dtool_ConfigVariableInt_set_value_264, METH_O, (const char *)Dtool_ConfigVariableInt_set_value_264_comment},
  {"get_value", &Dtool_ConfigVariableInt_get_value_265, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_value_265_comment},
  {"getValue", &Dtool_ConfigVariableInt_get_value_265, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_value_265_comment},
  {"get_default_value", &Dtool_ConfigVariableInt_get_default_value_266, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_default_value_266_comment},
  {"getDefaultValue", &Dtool_ConfigVariableInt_get_default_value_266, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_default_value_266_comment},
  {"get_word", &Dtool_ConfigVariableInt_get_word_269, METH_O, (const char *)Dtool_ConfigVariableInt_get_word_269_comment},
  {"getWord", &Dtool_ConfigVariableInt_get_word_269, METH_O, (const char *)Dtool_ConfigVariableInt_get_word_269_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableInt_set_word_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt_set_word_270_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableInt_set_word_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt_set_word_270_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt slot nb_int -> operator typecast int
//////////////////
static PyObject *Dtool_ConfigVariableInt_operator_typecast_int_261_nb_int(PyObject *self) {
  ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline operator int (void) const
  int return_value = (int)*(const ConfigVariableInt*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast_int(ConfigVariableInt self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableInt_operator_263_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableInt index out of range");
    return nullptr;
  }
  // 1-inline int ConfigVariableInt::operator [](std::size_t n) const
  int return_value = ((*(const ConfigVariableInt*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableInt self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableInt_size_262_sq_length(PyObject *self) {
  ConfigVariableInt *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableInt[] = {
  {(char *)"value", &Dtool_ConfigVariableInt_value_Getter, &Dtool_ConfigVariableInt_value_Setter, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableInt_default_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableInt = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  &Dtool_ConfigVariableInt_operator_typecast_int_261_nb_int,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableInt = {
  &Dtool_ConfigVariableInt_size_262_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConfigVariableInt_operator_263_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableInt = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableInt = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableInt = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableInt = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableInt",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableInt,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableInt,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigVariableInt,
    &Dtool_SequenceMethods_ConfigVariableInt,
    &Dtool_MappingMethods_ConfigVariableInt,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableInt,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as an integer\n"
    " * type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableInt,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableInt,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableInt,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableInt,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableInt,
  Dtool_UpcastInterface_ConfigVariableInt,
  Dtool_DowncastInterface_ConfigVariableInt,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableInt(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(nullptr);
    Dtool_ConfigVariableInt._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    Dtool_ConfigVariableInt._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableInt._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableInt) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableInt)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableInt);
  }
}

/**
 * Python method tables for ConfigVariableInt64 (ConfigVariableInt64)
 */
static PyMethodDef Dtool_Methods_ConfigVariableInt64[] = {
  {"assign", &Dtool_ConfigVariableInt64_operator_274, METH_O, (const char *)Dtool_ConfigVariableInt64_operator_274_comment},
  {"set_value", &Dtool_ConfigVariableInt64_set_value_278, METH_O, (const char *)Dtool_ConfigVariableInt64_set_value_278_comment},
  {"setValue", &Dtool_ConfigVariableInt64_set_value_278, METH_O, (const char *)Dtool_ConfigVariableInt64_set_value_278_comment},
  {"get_value", &Dtool_ConfigVariableInt64_get_value_279, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_value_279_comment},
  {"getValue", &Dtool_ConfigVariableInt64_get_value_279, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_value_279_comment},
  {"get_default_value", &Dtool_ConfigVariableInt64_get_default_value_280, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_default_value_280_comment},
  {"getDefaultValue", &Dtool_ConfigVariableInt64_get_default_value_280, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_default_value_280_comment},
  {"get_word", &Dtool_ConfigVariableInt64_get_word_285, METH_O, (const char *)Dtool_ConfigVariableInt64_get_word_285_comment},
  {"getWord", &Dtool_ConfigVariableInt64_get_word_285, METH_O, (const char *)Dtool_ConfigVariableInt64_get_word_285_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableInt64_set_word_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt64_set_word_286_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableInt64_set_word_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt64_set_word_286_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt64 slot nb_int -> operator typecast int64_t
//////////////////
static PyObject *Dtool_ConfigVariableInt64_operator_typecast_int64_t_275_nb_int(PyObject *self) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline operator int64_t (void) const
  int64_t return_value = (int64_t)*(const ConfigVariableInt64*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast_int64_t(ConfigVariableInt64 self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt64 slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableInt64_operator_277_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableInt64 index out of range");
    return nullptr;
  }
  // 1-inline int64_t ConfigVariableInt64::operator [](std::size_t n) const
  int64_t return_value = ((*(const ConfigVariableInt64*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableInt64 self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt64 slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableInt64_size_276_sq_length(PyObject *self) {
  ConfigVariableInt64 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableInt64[] = {
  {(char *)"value", &Dtool_ConfigVariableInt64_value_Getter, &Dtool_ConfigVariableInt64_value_Setter, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableInt64_default_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableInt64 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  &Dtool_ConfigVariableInt64_operator_typecast_int64_t_275_nb_int,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableInt64 = {
  &Dtool_ConfigVariableInt64_size_276_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConfigVariableInt64_operator_277_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableInt64 = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableInt64 = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableInt64 = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableInt64 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableInt64",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableInt64,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableInt64,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigVariableInt64,
    &Dtool_SequenceMethods_ConfigVariableInt64,
    &Dtool_MappingMethods_ConfigVariableInt64,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableInt64,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a 64-bit\n"
    " * integer type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableInt64,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableInt64,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableInt64,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableInt64,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableInt64,
  Dtool_UpcastInterface_ConfigVariableInt64,
  Dtool_DowncastInterface_ConfigVariableInt64,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableInt64(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(nullptr);
    Dtool_ConfigVariableInt64._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    Dtool_ConfigVariableInt64._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableInt64._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableInt64) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableInt64)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableInt64);
  }
}

/**
 * Python method tables for ConfigVariableList (ConfigVariableList)
 */
static PyMethodDef Dtool_Methods_ConfigVariableList[] = {
  {"get_num_values", &Dtool_ConfigVariableList_get_num_values_291, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_values_291_comment},
  {"getNumValues", &Dtool_ConfigVariableList_get_num_values_291, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_values_291_comment},
  {"get_string_value", &Dtool_ConfigVariableList_get_string_value_292, METH_O, (const char *)Dtool_ConfigVariableList_get_string_value_292_comment},
  {"getStringValue", &Dtool_ConfigVariableList_get_string_value_292, METH_O, (const char *)Dtool_ConfigVariableList_get_string_value_292_comment},
  {"get_num_unique_values", &Dtool_ConfigVariableList_get_num_unique_values_293, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_unique_values_293_comment},
  {"getNumUniqueValues", &Dtool_ConfigVariableList_get_num_unique_values_293, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_unique_values_293_comment},
  {"get_unique_value", &Dtool_ConfigVariableList_get_unique_value_294, METH_O, (const char *)Dtool_ConfigVariableList_get_unique_value_294_comment},
  {"getUniqueValue", &Dtool_ConfigVariableList_get_unique_value_294, METH_O, (const char *)Dtool_ConfigVariableList_get_unique_value_294_comment},
  {"output", &Dtool_ConfigVariableList_output_297, METH_O, (const char *)Dtool_ConfigVariableList_output_297_comment},
  {"write", &Dtool_ConfigVariableList_write_298, METH_O, (const char *)Dtool_ConfigVariableList_write_298_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableList slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableList_operator_296_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableList index out of range");
    return nullptr;
  }
  // 1-inline std::string ConfigVariableList::operator [](std::size_t n) const
  std::string return_value = ((*(const ConfigVariableList*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableList self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableList slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableList_size_295_sq_length(PyObject *self) {
  ConfigVariableList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     ConfigVariableList
//////////////////
static PyObject *Dtool_Repr_ConfigVariableList(PyObject *self) {
  ConfigVariableList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableList
//////////////////
static PyObject *Dtool_Str_ConfigVariableList(PyObject *self) {
  ConfigVariableList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConfigVariableList = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableList = {
  &Dtool_ConfigVariableList_size_295_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConfigVariableList_operator_296_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableList = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableList = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableList = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableList = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableList",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableList,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableList,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableList,
    &Dtool_NumberMethods_ConfigVariableList,
    &Dtool_SequenceMethods_ConfigVariableList,
    &Dtool_MappingMethods_ConfigVariableList,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigVariableList,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableList,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is similar to ConfigVariable, but it reports its value as a list\n"
    " * of strings.  In this special case, all of the declarations of the variable\n"
    " * are returned as the elements of this list, in order.\n"
    " *\n"
    " * Note that this is different from a normal ConfigVariableString, which just\n"
    " * returns its topmost value, which can optionally be treated as a number of\n"
    " * discrete words by dividing it at the spaces.\n"
    " *\n"
    " * A ConfigVariableList cannot be modified locally.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableList,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableList,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableList,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableList,
  Dtool_UpcastInterface_ConfigVariableList,
  Dtool_DowncastInterface_ConfigVariableList,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariableBase(nullptr);
    Dtool_ConfigVariableList._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariableBase);
    Dtool_ConfigVariableList._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableList);
  }
}

/**
 * Python method tables for ConfigVariableSearchPath (ConfigVariableSearchPath)
 */
static PyMethodDef Dtool_Methods_ConfigVariableSearchPath[] = {
  {"get_value", &Dtool_ConfigVariableSearchPath_get_value_303, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_value_303_comment},
  {"getValue", &Dtool_ConfigVariableSearchPath_get_value_303, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_value_303_comment},
  {"get_default_value", &Dtool_ConfigVariableSearchPath_get_default_value_304, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_default_value_304_comment},
  {"getDefaultValue", &Dtool_ConfigVariableSearchPath_get_default_value_304, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_default_value_304_comment},
  {"clear_local_value", &Dtool_ConfigVariableSearchPath_clear_local_value_309, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_clear_local_value_309_comment},
  {"clearLocalValue", &Dtool_ConfigVariableSearchPath_clear_local_value_309, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_clear_local_value_309_comment},
  {"clear", &Dtool_ConfigVariableSearchPath_clear_310, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_clear_310_comment},
  {"append_directory", &Dtool_ConfigVariableSearchPath_append_directory_311, METH_O, (const char *)Dtool_ConfigVariableSearchPath_append_directory_311_comment},
  {"appendDirectory", &Dtool_ConfigVariableSearchPath_append_directory_311, METH_O, (const char *)Dtool_ConfigVariableSearchPath_append_directory_311_comment},
  {"prepend_directory", &Dtool_ConfigVariableSearchPath_prepend_directory_312, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_directory_312_comment},
  {"prependDirectory", &Dtool_ConfigVariableSearchPath_prepend_directory_312, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_directory_312_comment},
  {"append_path", (PyCFunction) &Dtool_ConfigVariableSearchPath_append_path_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_append_path_313_comment},
  {"appendPath", (PyCFunction) &Dtool_ConfigVariableSearchPath_append_path_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_append_path_313_comment},
  {"prepend_path", &Dtool_ConfigVariableSearchPath_prepend_path_314, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_path_314_comment},
  {"prependPath", &Dtool_ConfigVariableSearchPath_prepend_path_314, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_path_314_comment},
  {"is_empty", &Dtool_ConfigVariableSearchPath_is_empty_315, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_is_empty_315_comment},
  {"isEmpty", &Dtool_ConfigVariableSearchPath_is_empty_315, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_is_empty_315_comment},
  {"get_num_directories", &Dtool_ConfigVariableSearchPath_get_num_directories_316, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_num_directories_316_comment},
  {"getNumDirectories", &Dtool_ConfigVariableSearchPath_get_num_directories_316, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_num_directories_316_comment},
  {"get_directory", &Dtool_ConfigVariableSearchPath_get_directory_317, METH_O, (const char *)Dtool_ConfigVariableSearchPath_get_directory_317_comment},
  {"getDirectory", &Dtool_ConfigVariableSearchPath_get_directory_317, METH_O, (const char *)Dtool_ConfigVariableSearchPath_get_directory_317_comment},
  {"find_file", &Dtool_ConfigVariableSearchPath_find_file_320, METH_O, (const char *)Dtool_ConfigVariableSearchPath_find_file_320_comment},
  {"findFile", &Dtool_ConfigVariableSearchPath_find_file_320, METH_O, (const char *)Dtool_ConfigVariableSearchPath_find_file_320_comment},
  {"find_all_files", (PyCFunction) &Dtool_ConfigVariableSearchPath_find_all_files_321, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_find_all_files_321_comment},
  {"findAllFiles", (PyCFunction) &Dtool_ConfigVariableSearchPath_find_all_files_321, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_find_all_files_321_comment},
  {"output", &Dtool_ConfigVariableSearchPath_output_322, METH_O, (const char *)Dtool_ConfigVariableSearchPath_output_322_comment},
  {"write", &Dtool_ConfigVariableSearchPath_write_323, METH_O, (const char *)Dtool_ConfigVariableSearchPath_write_323_comment},
  {"operator_typecast_DSearchPath", &Dtool_ConfigVariableSearchPath_operator_typecast_DSearchPath_302, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_operator_typecast_DSearchPath_302_comment},
  {"operatorTypecastDSearchPath", &Dtool_ConfigVariableSearchPath_operator_typecast_DSearchPath_302, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_operator_typecast_DSearchPath_302_comment},
  {"get_directories", (PyCFunction) &MakeSeq_ConfigVariableSearchPath_get_directories, METH_NOARGS, nullptr},
  { "getDirectories", (PyCFunction) &MakeSeq_ConfigVariableSearchPath_get_directories, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConfigVariableSearchPath
//////////////////
static PyObject *Dtool_Repr_ConfigVariableSearchPath(PyObject *self) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableSearchPath
//////////////////
static PyObject *Dtool_Str_ConfigVariableSearchPath(PyObject *self) {
  ConfigVariableSearchPath *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableSearchPath[] = {
  {(char *)"value", &Dtool_ConfigVariableSearchPath_value_Getter, nullptr, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableSearchPath_default_value_Getter, nullptr, nullptr, nullptr},
  {(char *)"directories", &Dtool_ConfigVariableSearchPath_directories_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableSearchPath = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableSearchPath = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableSearchPath = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableSearchPath = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableSearchPath = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableSearchPath = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableSearchPath",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableSearchPath,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableSearchPath,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableSearchPath,
    &Dtool_NumberMethods_ConfigVariableSearchPath,
    &Dtool_SequenceMethods_ConfigVariableSearchPath,
    &Dtool_MappingMethods_ConfigVariableSearchPath,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ConfigVariableSearchPath,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableSearchPath,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is similar to a ConfigVariableList, but it returns its list as a\n"
    " * DSearchPath, as a list of directories.\n"
    " *\n"
    " * You may locally append directories to the end of the search path with the\n"
    " * methods here, or prepend them to the beginning.  Use these methods to make\n"
    " * adjustments to the path; do not attempt to directly modify the const\n"
    " * DSearchPath object returned by get_value().\n"
    " *\n"
    " * Unlike other ConfigVariable types, local changes (made by calling\n"
    " * append_directory() and prepend_directory()) are specific to this particular\n"
    " * instance of the ConfigVariableSearchPath.  A separate instance of the same\n"
    " * variable, created by using the same name to the constructor, will not\n"
    " * reflect the local changes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableSearchPath,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableSearchPath,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableSearchPath,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableSearchPath,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableSearchPath,
  Dtool_UpcastInterface_ConfigVariableSearchPath,
  Dtool_DowncastInterface_ConfigVariableSearchPath,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableSearchPath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariableBase(nullptr);
    Dtool_ConfigVariableSearchPath._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariableBase);
    Dtool_ConfigVariableSearchPath._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableSearchPath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableSearchPath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableSearchPath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableSearchPath);
  }
}

/**
 * Python method tables for ConfigVariableString (ConfigVariableString)
 */
static PyMethodDef Dtool_Methods_ConfigVariableString[] = {
  {"assign", &Dtool_ConfigVariableString_operator_326, METH_O, (const char *)Dtool_ConfigVariableString_operator_326_comment},
  {"c_str", &Dtool_ConfigVariableString_c_str_328, METH_NOARGS, (const char *)Dtool_ConfigVariableString_c_str_328_comment},
  {"cStr", &Dtool_ConfigVariableString_c_str_328, METH_NOARGS, (const char *)Dtool_ConfigVariableString_c_str_328_comment},
  {"empty", &Dtool_ConfigVariableString_empty_329, METH_NOARGS, (const char *)Dtool_ConfigVariableString_empty_329_comment},
  {"length", &Dtool_ConfigVariableString_length_330, METH_NOARGS, (const char *)Dtool_ConfigVariableString_length_330_comment},
  {"set_value", &Dtool_ConfigVariableString_set_value_335, METH_O, (const char *)Dtool_ConfigVariableString_set_value_335_comment},
  {"setValue", &Dtool_ConfigVariableString_set_value_335, METH_O, (const char *)Dtool_ConfigVariableString_set_value_335_comment},
  {"get_value", &Dtool_ConfigVariableString_get_value_336, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_value_336_comment},
  {"getValue", &Dtool_ConfigVariableString_get_value_336, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_value_336_comment},
  {"get_default_value", &Dtool_ConfigVariableString_get_default_value_337, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_default_value_337_comment},
  {"getDefaultValue", &Dtool_ConfigVariableString_get_default_value_337, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_default_value_337_comment},
  {"get_word", &Dtool_ConfigVariableString_get_word_340, METH_O, (const char *)Dtool_ConfigVariableString_get_word_340_comment},
  {"getWord", &Dtool_ConfigVariableString_get_word_340, METH_O, (const char *)Dtool_ConfigVariableString_get_word_340_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableString_set_word_341, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableString_set_word_341_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableString_set_word_341, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableString_set_word_341_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableString slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableString_operator_331_mp_subscript(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return nullptr;
  }
  // 1-inline char ConfigVariableString::operator [](std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    char return_value = ((*(const ConfigVariableString*)local_this).operator [])(arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableString self, int n)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableString slot tp_str -> operator typecast
//////////////////
static PyObject *Dtool_ConfigVariableString_operator_typecast_327_tp_str(PyObject *self) {
  ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline operator std::string const &(void) const
  std::string const &return_value = (std::string const &)*(const ConfigVariableString*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast(ConfigVariableString self)\n");
  }
  return nullptr;
}

//////////////////
//  A rich comparison function
//     ConfigVariableString
//////////////////
static PyObject *Dtool_RichCompare_ConfigVariableString(PyObject *self, PyObject *arg, int op) {
  ConfigVariableString *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ConfigVariableString::operator ==(std::string const &other) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const ConfigVariableString*)local_this).operator ==)(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ConfigVariableString::operator !=(std::string const &other) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const ConfigVariableString*)local_this).operator !=)(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ConfigVariableString::operator <(std::string const &other) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const ConfigVariableString*)local_this).operator <)(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ConfigVariableString[] = {
  {(char *)"value", &Dtool_ConfigVariableString_value_Getter, &Dtool_ConfigVariableString_value_Setter, nullptr, nullptr},
  {(char *)"default_value", &Dtool_ConfigVariableString_default_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableString = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableString = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableString = {
  nullptr,
  &Dtool_ConfigVariableString_operator_331_mp_subscript,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableString = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConfigVariableString = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConfigVariableString = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConfigVariableString",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableString,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConfigVariableString,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_ConfigVariableString,
    &Dtool_SequenceMethods_ConfigVariableString,
    &Dtool_MappingMethods_ConfigVariableString,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_ConfigVariableString_operator_typecast_327_tp_str,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConfigVariableString,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a string type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_ConfigVariableString,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConfigVariableString,
    nullptr, // tp_members
    Dtool_Properties_ConfigVariableString,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableString,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableString,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableString,
  Dtool_UpcastInterface_ConfigVariableString,
  Dtool_DowncastInterface_ConfigVariableString,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConfigVariableString(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(nullptr);
    Dtool_ConfigVariableString._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    Dtool_ConfigVariableString._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableString._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableString) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableString)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableString);
  }
}

/**
 * Python method tables for NotifyCategory (NotifyCategory)
 */
static PyMethodDef Dtool_Methods_NotifyCategory[] = {
  {"get_fullname", &Dtool_NotifyCategory_get_fullname_349, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_fullname_349_comment},
  {"getFullname", &Dtool_NotifyCategory_get_fullname_349, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_fullname_349_comment},
  {"get_basename", &Dtool_NotifyCategory_get_basename_350, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_basename_350_comment},
  {"getBasename", &Dtool_NotifyCategory_get_basename_350, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_basename_350_comment},
  {"get_severity", &Dtool_NotifyCategory_get_severity_351, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_severity_351_comment},
  {"getSeverity", &Dtool_NotifyCategory_get_severity_351, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_severity_351_comment},
  {"set_severity", &Dtool_NotifyCategory_set_severity_352, METH_O, (const char *)Dtool_NotifyCategory_set_severity_352_comment},
  {"setSeverity", &Dtool_NotifyCategory_set_severity_352, METH_O, (const char *)Dtool_NotifyCategory_set_severity_352_comment},
  {"is_on", &Dtool_NotifyCategory_is_on_356, METH_O, (const char *)Dtool_NotifyCategory_is_on_356_comment},
  {"isOn", &Dtool_NotifyCategory_is_on_356, METH_O, (const char *)Dtool_NotifyCategory_is_on_356_comment},
  {"is_spam", &Dtool_NotifyCategory_is_spam_357, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_spam_357_comment},
  {"isSpam", &Dtool_NotifyCategory_is_spam_357, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_spam_357_comment},
  {"is_debug", &Dtool_NotifyCategory_is_debug_358, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_debug_358_comment},
  {"isDebug", &Dtool_NotifyCategory_is_debug_358, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_debug_358_comment},
  {"is_info", &Dtool_NotifyCategory_is_info_359, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_info_359_comment},
  {"isInfo", &Dtool_NotifyCategory_is_info_359, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_info_359_comment},
  {"is_warning", &Dtool_NotifyCategory_is_warning_360, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_warning_360_comment},
  {"isWarning", &Dtool_NotifyCategory_is_warning_360, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_warning_360_comment},
  {"is_error", &Dtool_NotifyCategory_is_error_361, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_error_361_comment},
  {"isError", &Dtool_NotifyCategory_is_error_361, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_error_361_comment},
  {"is_fatal", &Dtool_NotifyCategory_is_fatal_362, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_fatal_362_comment},
  {"isFatal", &Dtool_NotifyCategory_is_fatal_362, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_fatal_362_comment},
  {"out", (PyCFunction) &Dtool_NotifyCategory_out_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_out_363_comment},
  {"spam", (PyCFunction) &Dtool_NotifyCategory_spam_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_spam_364_comment},
  {"debug", (PyCFunction) &Dtool_NotifyCategory_debug_365, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_debug_365_comment},
  {"info", (PyCFunction) &Dtool_NotifyCategory_info_366, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_info_366_comment},
  {"warning", (PyCFunction) &Dtool_NotifyCategory_warning_367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_warning_367_comment},
  {"error", (PyCFunction) &Dtool_NotifyCategory_error_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_error_368_comment},
  {"fatal", (PyCFunction) &Dtool_NotifyCategory_fatal_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_fatal_369_comment},
  {"get_num_children", &Dtool_NotifyCategory_get_num_children_370, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_num_children_370_comment},
  {"getNumChildren", &Dtool_NotifyCategory_get_num_children_370, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_num_children_370_comment},
  {"get_child", &Dtool_NotifyCategory_get_child_371, METH_O, (const char *)Dtool_NotifyCategory_get_child_371_comment},
  {"getChild", &Dtool_NotifyCategory_get_child_371, METH_O, (const char *)Dtool_NotifyCategory_get_child_371_comment},
  {"set_server_delta", &Dtool_NotifyCategory_set_server_delta_375, METH_O | METH_STATIC, (const char *)Dtool_NotifyCategory_set_server_delta_375_comment},
  {"setServerDelta", &Dtool_NotifyCategory_set_server_delta_375, METH_O | METH_STATIC, (const char *)Dtool_NotifyCategory_set_server_delta_375_comment},
  {"upcast_to_ConfigFlags", &Dtool_NotifyCategory_upcast_to_ConfigFlags_347, METH_NOARGS, (const char *)Dtool_NotifyCategory_upcast_to_ConfigFlags_347_comment},
  {"upcastToConfigFlags", &Dtool_NotifyCategory_upcast_to_ConfigFlags_347, METH_NOARGS, (const char *)Dtool_NotifyCategory_upcast_to_ConfigFlags_347_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_children", (PyCFunction) &MakeSeq_NotifyCategory_get_children, METH_NOARGS, nullptr},
  { "getChildren", (PyCFunction) &MakeSeq_NotifyCategory_get_children, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_NotifyCategory[] = {
  {(char *)"fullname", &Dtool_NotifyCategory_fullname_Getter, nullptr, nullptr, nullptr},
  {(char *)"basename", &Dtool_NotifyCategory_basename_Getter, nullptr, nullptr, nullptr},
  {(char *)"severity", &Dtool_NotifyCategory_severity_Getter, &Dtool_NotifyCategory_severity_Setter, nullptr, nullptr},
  {(char *)"children", &Dtool_NotifyCategory_children_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_NotifyCategory = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NotifyCategory = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NotifyCategory = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NotifyCategory = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NotifyCategory = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NotifyCategory = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NotifyCategory",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NotifyCategory,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NotifyCategory,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NotifyCategory,
    &Dtool_SequenceMethods_NotifyCategory,
    &Dtool_MappingMethods_NotifyCategory,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NotifyCategory,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A particular category of error messages.  Typically there will be one of\n"
    " * these per package, so that we can turn on or off error messages at least at\n"
    " * a package level; further nested categories can be created within a package\n"
    " * if a finer grain of control is required.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NotifyCategory,
    nullptr, // tp_members
    Dtool_Properties_NotifyCategory,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NotifyCategory,
    PyType_GenericAlloc,
    Dtool_new_NotifyCategory,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NotifyCategory,
  Dtool_UpcastInterface_NotifyCategory,
  Dtool_DowncastInterface_NotifyCategory,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NotifyCategory(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(nullptr);
    Dtool_NotifyCategory._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    Dtool_NotifyCategory._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NotifyCategory._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NotifyCategory) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NotifyCategory)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NotifyCategory);
  }
}

/**
 * Python method tables for IDecryptStream (IDecryptStream)
 */
static PyMethodDef Dtool_Methods_IDecryptStream[] = {
  {"open", (PyCFunction) &Dtool_IDecryptStream_open_381, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IDecryptStream_open_381_comment},
  {"close", &Dtool_IDecryptStream_close_382, METH_NOARGS, (const char *)Dtool_IDecryptStream_close_382_comment},
  {"get_algorithm", &Dtool_IDecryptStream_get_algorithm_383, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_algorithm_383_comment},
  {"getAlgorithm", &Dtool_IDecryptStream_get_algorithm_383, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_algorithm_383_comment},
  {"get_key_length", &Dtool_IDecryptStream_get_key_length_384, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_key_length_384_comment},
  {"getKeyLength", &Dtool_IDecryptStream_get_key_length_384, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_key_length_384_comment},
  {"get_iteration_count", &Dtool_IDecryptStream_get_iteration_count_385, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_iteration_count_385_comment},
  {"getIterationCount", &Dtool_IDecryptStream_get_iteration_count_385, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_iteration_count_385_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_IDecryptStream[] = {
  {(char *)"algorithm", &Dtool_IDecryptStream_algorithm_Getter, nullptr, nullptr, nullptr},
  {(char *)"key_length", &Dtool_IDecryptStream_key_length_Getter, nullptr, nullptr, nullptr},
  {(char *)"iteration_count", &Dtool_IDecryptStream_iteration_count_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_IDecryptStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IDecryptStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_IDecryptStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_IDecryptStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_IDecryptStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_IDecryptStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.IDecryptStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IDecryptStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_IDecryptStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IDecryptStream,
    &Dtool_SequenceMethods_IDecryptStream,
    &Dtool_MappingMethods_IDecryptStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_IDecryptStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses OpenSSL to decrypt the input from another\n"
    " * source stream on-the-fly.\n"
    " *\n"
    " * Attach an IDecryptStream to an existing istream that provides encrypted\n"
    " * data, as generated by an OEncryptStream, and read the corresponding\n"
    " * unencrypted data from the IDecryptStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IDecryptStream,
    nullptr, // tp_members
    Dtool_Properties_IDecryptStream,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IDecryptStream,
    PyType_GenericAlloc,
    Dtool_new_IDecryptStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IDecryptStream,
  Dtool_UpcastInterface_IDecryptStream,
  Dtool_DowncastInterface_IDecryptStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IDecryptStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_istream != nullptr);
    assert(Dtool_Ptr_std_istream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_istream->_Dtool_ModuleClassInit(nullptr);
    Dtool_IDecryptStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_istream);
    Dtool_IDecryptStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IDecryptStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IDecryptStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IDecryptStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IDecryptStream);
  }
}

/**
 * Python method tables for OEncryptStream (OEncryptStream)
 */
static PyMethodDef Dtool_Methods_OEncryptStream[] = {
  {"open", (PyCFunction) &Dtool_OEncryptStream_open_393, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OEncryptStream_open_393_comment},
  {"close", &Dtool_OEncryptStream_close_394, METH_NOARGS, (const char *)Dtool_OEncryptStream_close_394_comment},
  {"set_algorithm", &Dtool_OEncryptStream_set_algorithm_395, METH_O, (const char *)Dtool_OEncryptStream_set_algorithm_395_comment},
  {"setAlgorithm", &Dtool_OEncryptStream_set_algorithm_395, METH_O, (const char *)Dtool_OEncryptStream_set_algorithm_395_comment},
  {"set_key_length", &Dtool_OEncryptStream_set_key_length_396, METH_O, (const char *)Dtool_OEncryptStream_set_key_length_396_comment},
  {"setKeyLength", &Dtool_OEncryptStream_set_key_length_396, METH_O, (const char *)Dtool_OEncryptStream_set_key_length_396_comment},
  {"set_iteration_count", &Dtool_OEncryptStream_set_iteration_count_397, METH_O, (const char *)Dtool_OEncryptStream_set_iteration_count_397_comment},
  {"setIterationCount", &Dtool_OEncryptStream_set_iteration_count_397, METH_O, (const char *)Dtool_OEncryptStream_set_iteration_count_397_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_OEncryptStream[] = {
  {(char *)"algorithm", &Dtool_OEncryptStream_algorithm_Getter, &Dtool_OEncryptStream_algorithm_Setter, nullptr, nullptr},
  {(char *)"key_length", &Dtool_OEncryptStream_key_length_Getter, &Dtool_OEncryptStream_key_length_Setter, nullptr, nullptr},
  {(char *)"iteration_count", &Dtool_OEncryptStream_iteration_count_Getter, &Dtool_OEncryptStream_iteration_count_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_OEncryptStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OEncryptStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OEncryptStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OEncryptStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OEncryptStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OEncryptStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OEncryptStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OEncryptStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OEncryptStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OEncryptStream,
    &Dtool_SequenceMethods_OEncryptStream,
    &Dtool_MappingMethods_OEncryptStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OEncryptStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses OpenSSL to encrypt data to another\n"
    " * destination stream on-the-fly.\n"
    " *\n"
    " * Attach an OEncryptStream to an existing ostream that will accept encrypted\n"
    " * data, and write your unencrypted source data to the OEncryptStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OEncryptStream,
    nullptr, // tp_members
    Dtool_Properties_OEncryptStream,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OEncryptStream,
    PyType_GenericAlloc,
    Dtool_new_OEncryptStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OEncryptStream,
  Dtool_UpcastInterface_OEncryptStream,
  Dtool_DowncastInterface_OEncryptStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OEncryptStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_ostream != nullptr);
    assert(Dtool_Ptr_std_ostream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_ostream->_Dtool_ModuleClassInit(nullptr);
    Dtool_OEncryptStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_ostream);
    Dtool_OEncryptStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OEncryptStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OEncryptStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OEncryptStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OEncryptStream);
  }
}

/**
 * Python method tables for StreamReader (StreamReader)
 */
static PyMethodDef Dtool_Methods_StreamReader[] = {
  {"assign", &Dtool_StreamReader_operator_407, METH_O, (const char *)Dtool_StreamReader_operator_407_comment},
  {"get_istream", &Dtool_StreamReader_get_istream_409, METH_NOARGS, (const char *)Dtool_StreamReader_get_istream_409_comment},
  {"getIstream", &Dtool_StreamReader_get_istream_409, METH_NOARGS, (const char *)Dtool_StreamReader_get_istream_409_comment},
  {"get_bool", &Dtool_StreamReader_get_bool_412, METH_NOARGS, (const char *)Dtool_StreamReader_get_bool_412_comment},
  {"getBool", &Dtool_StreamReader_get_bool_412, METH_NOARGS, (const char *)Dtool_StreamReader_get_bool_412_comment},
  {"get_int8", &Dtool_StreamReader_get_int8_413, METH_NOARGS, (const char *)Dtool_StreamReader_get_int8_413_comment},
  {"getInt8", &Dtool_StreamReader_get_int8_413, METH_NOARGS, (const char *)Dtool_StreamReader_get_int8_413_comment},
  {"get_uint8", &Dtool_StreamReader_get_uint8_414, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint8_414_comment},
  {"getUint8", &Dtool_StreamReader_get_uint8_414, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint8_414_comment},
  {"get_int16", &Dtool_StreamReader_get_int16_415, METH_NOARGS, (const char *)Dtool_StreamReader_get_int16_415_comment},
  {"getInt16", &Dtool_StreamReader_get_int16_415, METH_NOARGS, (const char *)Dtool_StreamReader_get_int16_415_comment},
  {"get_int32", &Dtool_StreamReader_get_int32_416, METH_NOARGS, (const char *)Dtool_StreamReader_get_int32_416_comment},
  {"getInt32", &Dtool_StreamReader_get_int32_416, METH_NOARGS, (const char *)Dtool_StreamReader_get_int32_416_comment},
  {"get_int64", &Dtool_StreamReader_get_int64_417, METH_NOARGS, (const char *)Dtool_StreamReader_get_int64_417_comment},
  {"getInt64", &Dtool_StreamReader_get_int64_417, METH_NOARGS, (const char *)Dtool_StreamReader_get_int64_417_comment},
  {"get_uint16", &Dtool_StreamReader_get_uint16_418, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint16_418_comment},
  {"getUint16", &Dtool_StreamReader_get_uint16_418, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint16_418_comment},
  {"get_uint32", &Dtool_StreamReader_get_uint32_419, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint32_419_comment},
  {"getUint32", &Dtool_StreamReader_get_uint32_419, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint32_419_comment},
  {"get_uint64", &Dtool_StreamReader_get_uint64_420, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint64_420_comment},
  {"getUint64", &Dtool_StreamReader_get_uint64_420, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint64_420_comment},
  {"get_float32", &Dtool_StreamReader_get_float32_421, METH_NOARGS, (const char *)Dtool_StreamReader_get_float32_421_comment},
  {"getFloat32", &Dtool_StreamReader_get_float32_421, METH_NOARGS, (const char *)Dtool_StreamReader_get_float32_421_comment},
  {"get_float64", &Dtool_StreamReader_get_float64_422, METH_NOARGS, (const char *)Dtool_StreamReader_get_float64_422_comment},
  {"getFloat64", &Dtool_StreamReader_get_float64_422, METH_NOARGS, (const char *)Dtool_StreamReader_get_float64_422_comment},
  {"get_be_int16", &Dtool_StreamReader_get_be_int16_423, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int16_423_comment},
  {"getBeInt16", &Dtool_StreamReader_get_be_int16_423, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int16_423_comment},
  {"get_be_int32", &Dtool_StreamReader_get_be_int32_424, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int32_424_comment},
  {"getBeInt32", &Dtool_StreamReader_get_be_int32_424, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int32_424_comment},
  {"get_be_int64", &Dtool_StreamReader_get_be_int64_425, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int64_425_comment},
  {"getBeInt64", &Dtool_StreamReader_get_be_int64_425, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int64_425_comment},
  {"get_be_uint16", &Dtool_StreamReader_get_be_uint16_426, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint16_426_comment},
  {"getBeUint16", &Dtool_StreamReader_get_be_uint16_426, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint16_426_comment},
  {"get_be_uint32", &Dtool_StreamReader_get_be_uint32_427, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint32_427_comment},
  {"getBeUint32", &Dtool_StreamReader_get_be_uint32_427, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint32_427_comment},
  {"get_be_uint64", &Dtool_StreamReader_get_be_uint64_428, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint64_428_comment},
  {"getBeUint64", &Dtool_StreamReader_get_be_uint64_428, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint64_428_comment},
  {"get_be_float32", &Dtool_StreamReader_get_be_float32_429, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float32_429_comment},
  {"getBeFloat32", &Dtool_StreamReader_get_be_float32_429, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float32_429_comment},
  {"get_be_float64", &Dtool_StreamReader_get_be_float64_430, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float64_430_comment},
  {"getBeFloat64", &Dtool_StreamReader_get_be_float64_430, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float64_430_comment},
  {"get_string", &Dtool_StreamReader_get_string_431, METH_NOARGS, (const char *)Dtool_StreamReader_get_string_431_comment},
  {"getString", &Dtool_StreamReader_get_string_431, METH_NOARGS, (const char *)Dtool_StreamReader_get_string_431_comment},
  {"get_string32", &Dtool_StreamReader_get_string32_432, METH_NOARGS, (const char *)Dtool_StreamReader_get_string32_432_comment},
  {"getString32", &Dtool_StreamReader_get_string32_432, METH_NOARGS, (const char *)Dtool_StreamReader_get_string32_432_comment},
  {"get_z_string", &Dtool_StreamReader_get_z_string_433, METH_NOARGS, (const char *)Dtool_StreamReader_get_z_string_433_comment},
  {"getZString", &Dtool_StreamReader_get_z_string_433, METH_NOARGS, (const char *)Dtool_StreamReader_get_z_string_433_comment},
  {"get_fixed_string", &Dtool_StreamReader_get_fixed_string_434, METH_O, (const char *)Dtool_StreamReader_get_fixed_string_434_comment},
  {"getFixedString", &Dtool_StreamReader_get_fixed_string_434, METH_O, (const char *)Dtool_StreamReader_get_fixed_string_434_comment},
  {"skip_bytes", &Dtool_StreamReader_skip_bytes_435, METH_O, (const char *)Dtool_StreamReader_skip_bytes_435_comment},
  {"skipBytes", &Dtool_StreamReader_skip_bytes_435, METH_O, (const char *)Dtool_StreamReader_skip_bytes_435_comment},
  {"extract_bytes", &Dtool_StreamReader_extract_bytes_436, METH_O, (const char *)Dtool_StreamReader_extract_bytes_436_comment},
  {"extractBytes", &Dtool_StreamReader_extract_bytes_436, METH_O, (const char *)Dtool_StreamReader_extract_bytes_436_comment},
  {"readline", &Dtool_StreamReader_readline_437, METH_NOARGS, (const char *)Dtool_StreamReader_readline_437_comment},
  {"readlines", &Dtool_StreamReader_readlines_438, METH_NOARGS, (const char *)Dtool_StreamReader_readlines_438_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_StreamReader[] = {
  {(char *)"istream", &Dtool_StreamReader_istream_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_StreamReader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_StreamReader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StreamReader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamReader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StreamReader,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to read sequential binary data directly from an istream.  Its\n"
    " * interface is similar to DatagramIterator by design; see also StreamWriter.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StreamReader,
    nullptr, // tp_members
    Dtool_Properties_StreamReader,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StreamReader,
    PyType_GenericAlloc,
    Dtool_new_StreamReader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamReader,
  Dtool_UpcastInterface_StreamReader,
  Dtool_DowncastInterface_StreamReader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StreamReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StreamReader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StreamReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamReader);
  }
}

/**
 * Python method tables for StreamWriter (StreamWriter)
 */
static PyMethodDef Dtool_Methods_StreamWriter[] = {
  {"assign", &Dtool_StreamWriter_operator_441, METH_O, (const char *)Dtool_StreamWriter_operator_441_comment},
  {"get_ostream", &Dtool_StreamWriter_get_ostream_443, METH_NOARGS, (const char *)Dtool_StreamWriter_get_ostream_443_comment},
  {"getOstream", &Dtool_StreamWriter_get_ostream_443, METH_NOARGS, (const char *)Dtool_StreamWriter_get_ostream_443_comment},
  {"add_bool", &Dtool_StreamWriter_add_bool_446, METH_O, (const char *)Dtool_StreamWriter_add_bool_446_comment},
  {"addBool", &Dtool_StreamWriter_add_bool_446, METH_O, (const char *)Dtool_StreamWriter_add_bool_446_comment},
  {"add_int8", &Dtool_StreamWriter_add_int8_447, METH_O, (const char *)Dtool_StreamWriter_add_int8_447_comment},
  {"addInt8", &Dtool_StreamWriter_add_int8_447, METH_O, (const char *)Dtool_StreamWriter_add_int8_447_comment},
  {"add_uint8", &Dtool_StreamWriter_add_uint8_448, METH_O, (const char *)Dtool_StreamWriter_add_uint8_448_comment},
  {"addUint8", &Dtool_StreamWriter_add_uint8_448, METH_O, (const char *)Dtool_StreamWriter_add_uint8_448_comment},
  {"add_int16", &Dtool_StreamWriter_add_int16_449, METH_O, (const char *)Dtool_StreamWriter_add_int16_449_comment},
  {"addInt16", &Dtool_StreamWriter_add_int16_449, METH_O, (const char *)Dtool_StreamWriter_add_int16_449_comment},
  {"add_int32", &Dtool_StreamWriter_add_int32_450, METH_O, (const char *)Dtool_StreamWriter_add_int32_450_comment},
  {"addInt32", &Dtool_StreamWriter_add_int32_450, METH_O, (const char *)Dtool_StreamWriter_add_int32_450_comment},
  {"add_int64", &Dtool_StreamWriter_add_int64_451, METH_O, (const char *)Dtool_StreamWriter_add_int64_451_comment},
  {"addInt64", &Dtool_StreamWriter_add_int64_451, METH_O, (const char *)Dtool_StreamWriter_add_int64_451_comment},
  {"add_uint16", &Dtool_StreamWriter_add_uint16_452, METH_O, (const char *)Dtool_StreamWriter_add_uint16_452_comment},
  {"addUint16", &Dtool_StreamWriter_add_uint16_452, METH_O, (const char *)Dtool_StreamWriter_add_uint16_452_comment},
  {"add_uint32", &Dtool_StreamWriter_add_uint32_453, METH_O, (const char *)Dtool_StreamWriter_add_uint32_453_comment},
  {"addUint32", &Dtool_StreamWriter_add_uint32_453, METH_O, (const char *)Dtool_StreamWriter_add_uint32_453_comment},
  {"add_uint64", &Dtool_StreamWriter_add_uint64_454, METH_O, (const char *)Dtool_StreamWriter_add_uint64_454_comment},
  {"addUint64", &Dtool_StreamWriter_add_uint64_454, METH_O, (const char *)Dtool_StreamWriter_add_uint64_454_comment},
  {"add_float32", &Dtool_StreamWriter_add_float32_455, METH_O, (const char *)Dtool_StreamWriter_add_float32_455_comment},
  {"addFloat32", &Dtool_StreamWriter_add_float32_455, METH_O, (const char *)Dtool_StreamWriter_add_float32_455_comment},
  {"add_float64", &Dtool_StreamWriter_add_float64_456, METH_O, (const char *)Dtool_StreamWriter_add_float64_456_comment},
  {"addFloat64", &Dtool_StreamWriter_add_float64_456, METH_O, (const char *)Dtool_StreamWriter_add_float64_456_comment},
  {"add_be_int16", &Dtool_StreamWriter_add_be_int16_457, METH_O, (const char *)Dtool_StreamWriter_add_be_int16_457_comment},
  {"addBeInt16", &Dtool_StreamWriter_add_be_int16_457, METH_O, (const char *)Dtool_StreamWriter_add_be_int16_457_comment},
  {"add_be_int32", &Dtool_StreamWriter_add_be_int32_458, METH_O, (const char *)Dtool_StreamWriter_add_be_int32_458_comment},
  {"addBeInt32", &Dtool_StreamWriter_add_be_int32_458, METH_O, (const char *)Dtool_StreamWriter_add_be_int32_458_comment},
  {"add_be_int64", &Dtool_StreamWriter_add_be_int64_459, METH_O, (const char *)Dtool_StreamWriter_add_be_int64_459_comment},
  {"addBeInt64", &Dtool_StreamWriter_add_be_int64_459, METH_O, (const char *)Dtool_StreamWriter_add_be_int64_459_comment},
  {"add_be_uint16", &Dtool_StreamWriter_add_be_uint16_460, METH_O, (const char *)Dtool_StreamWriter_add_be_uint16_460_comment},
  {"addBeUint16", &Dtool_StreamWriter_add_be_uint16_460, METH_O, (const char *)Dtool_StreamWriter_add_be_uint16_460_comment},
  {"add_be_uint32", &Dtool_StreamWriter_add_be_uint32_461, METH_O, (const char *)Dtool_StreamWriter_add_be_uint32_461_comment},
  {"addBeUint32", &Dtool_StreamWriter_add_be_uint32_461, METH_O, (const char *)Dtool_StreamWriter_add_be_uint32_461_comment},
  {"add_be_uint64", &Dtool_StreamWriter_add_be_uint64_462, METH_O, (const char *)Dtool_StreamWriter_add_be_uint64_462_comment},
  {"addBeUint64", &Dtool_StreamWriter_add_be_uint64_462, METH_O, (const char *)Dtool_StreamWriter_add_be_uint64_462_comment},
  {"add_be_float32", &Dtool_StreamWriter_add_be_float32_463, METH_O, (const char *)Dtool_StreamWriter_add_be_float32_463_comment},
  {"addBeFloat32", &Dtool_StreamWriter_add_be_float32_463, METH_O, (const char *)Dtool_StreamWriter_add_be_float32_463_comment},
  {"add_be_float64", &Dtool_StreamWriter_add_be_float64_464, METH_O, (const char *)Dtool_StreamWriter_add_be_float64_464_comment},
  {"addBeFloat64", &Dtool_StreamWriter_add_be_float64_464, METH_O, (const char *)Dtool_StreamWriter_add_be_float64_464_comment},
  {"add_string", &Dtool_StreamWriter_add_string_465, METH_O, (const char *)Dtool_StreamWriter_add_string_465_comment},
  {"addString", &Dtool_StreamWriter_add_string_465, METH_O, (const char *)Dtool_StreamWriter_add_string_465_comment},
  {"add_string32", &Dtool_StreamWriter_add_string32_466, METH_O, (const char *)Dtool_StreamWriter_add_string32_466_comment},
  {"addString32", &Dtool_StreamWriter_add_string32_466, METH_O, (const char *)Dtool_StreamWriter_add_string32_466_comment},
  {"add_z_string", &Dtool_StreamWriter_add_z_string_467, METH_O, (const char *)Dtool_StreamWriter_add_z_string_467_comment},
  {"addZString", &Dtool_StreamWriter_add_z_string_467, METH_O, (const char *)Dtool_StreamWriter_add_z_string_467_comment},
  {"add_fixed_string", (PyCFunction) &Dtool_StreamWriter_add_fixed_string_468, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StreamWriter_add_fixed_string_468_comment},
  {"addFixedString", (PyCFunction) &Dtool_StreamWriter_add_fixed_string_468, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StreamWriter_add_fixed_string_468_comment},
  {"pad_bytes", &Dtool_StreamWriter_pad_bytes_469, METH_O, (const char *)Dtool_StreamWriter_pad_bytes_469_comment},
  {"padBytes", &Dtool_StreamWriter_pad_bytes_469, METH_O, (const char *)Dtool_StreamWriter_pad_bytes_469_comment},
  {"append_data", &Dtool_StreamWriter_append_data_470, METH_O, (const char *)Dtool_StreamWriter_append_data_470_comment},
  {"appendData", &Dtool_StreamWriter_append_data_470, METH_O, (const char *)Dtool_StreamWriter_append_data_470_comment},
  {"flush", &Dtool_StreamWriter_flush_471, METH_NOARGS, (const char *)Dtool_StreamWriter_flush_471_comment},
  {"write", &Dtool_StreamWriter_write_472, METH_O, (const char *)Dtool_StreamWriter_write_472_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_StreamWriter[] = {
  {(char *)"ostream", &Dtool_StreamWriter_ostream_Getter, nullptr, nullptr, nullptr},
  {(char *)"softspace", &Dtool_StreamWriter_softspace_Getter, &Dtool_StreamWriter_softspace_Setter, (char *)
    "// Python 2 needs this for printing to work correctly.",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_StreamWriter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_StreamWriter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StreamWriter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamWriter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StreamWriter,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A StreamWriter object is used to write sequential binary data directly to\n"
    " * an ostream.  Its interface is very similar to Datagram by design; it's\n"
    " * primarily intended as a convenience to eliminate the overhead of writing\n"
    " * bytes to a Datagram and then writing the Datagram to a stream.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StreamWriter,
    nullptr, // tp_members
    Dtool_Properties_StreamWriter,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StreamWriter,
    PyType_GenericAlloc,
    Dtool_new_StreamWriter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamWriter,
  Dtool_UpcastInterface_StreamWriter,
  Dtool_DowncastInterface_StreamWriter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StreamWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StreamWriter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StreamWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamWriter);
  }
}

/**
 * Python method tables for StreamWrapperBase (StreamWrapperBase)
 */
static PyMethodDef Dtool_Methods_StreamWrapperBase[] = {
  {"acquire", &Dtool_StreamWrapperBase_acquire_477, METH_NOARGS, (const char *)Dtool_StreamWrapperBase_acquire_477_comment},
  {"release", &Dtool_StreamWrapperBase_release_478, METH_NOARGS, (const char *)Dtool_StreamWrapperBase_release_478_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_StreamWrapperBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_StreamWrapperBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StreamWrapperBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamWrapperBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StreamWrapperBase,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for both IStreamWrapper and OStreamWrapper, this provides\n"
    " * the common locking interface.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StreamWrapperBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StreamWrapperBase,
    PyType_GenericAlloc,
    Dtool_new_StreamWrapperBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamWrapperBase,
  Dtool_UpcastInterface_StreamWrapperBase,
  Dtool_DowncastInterface_StreamWrapperBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StreamWrapperBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StreamWrapperBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StreamWrapperBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamWrapperBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamWrapperBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamWrapperBase);
  }
}

/**
 * Python method tables for IStreamWrapper (IStreamWrapper)
 */
static PyMethodDef Dtool_Methods_IStreamWrapper[] = {
  {"get_istream", &Dtool_IStreamWrapper_get_istream_484, METH_NOARGS, (const char *)Dtool_IStreamWrapper_get_istream_484_comment},
  {"getIstream", &Dtool_IStreamWrapper_get_istream_484, METH_NOARGS, (const char *)Dtool_IStreamWrapper_get_istream_484_comment},
  {"upcast_to_StreamWrapperBase", &Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_481, METH_NOARGS, (const char *)Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_481_comment},
  {"upcastToStreamWrapperBase", &Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_481, METH_NOARGS, (const char *)Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_481_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_IStreamWrapper[] = {
  {(char *)"istream", &Dtool_IStreamWrapper_istream_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_IStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_IStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_IStreamWrapper = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_IStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_IStreamWrapper = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.IStreamWrapper",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IStreamWrapper,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_IStreamWrapper,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IStreamWrapper,
    &Dtool_SequenceMethods_IStreamWrapper,
    &Dtool_MappingMethods_IStreamWrapper,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_IStreamWrapper,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a locking wrapper around an arbitrary istream pointer.\n"
    " * A thread may use this class to perform an atomic seek/read/gcount\n"
    " * operation.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IStreamWrapper,
    nullptr, // tp_members
    Dtool_Properties_IStreamWrapper,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IStreamWrapper,
    PyType_GenericAlloc,
    Dtool_new_IStreamWrapper,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IStreamWrapper,
  Dtool_UpcastInterface_IStreamWrapper,
  Dtool_DowncastInterface_IStreamWrapper,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IStreamWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_StreamWrapperBase(nullptr);
    Dtool_IStreamWrapper._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_StreamWrapperBase);
    Dtool_IStreamWrapper._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IStreamWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IStreamWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IStreamWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IStreamWrapper);
  }
}

/**
 * Python method tables for OStreamWrapper (OStreamWrapper)
 */
static PyMethodDef Dtool_Methods_OStreamWrapper[] = {
  {"get_ostream", &Dtool_OStreamWrapper_get_ostream_489, METH_NOARGS, (const char *)Dtool_OStreamWrapper_get_ostream_489_comment},
  {"getOstream", &Dtool_OStreamWrapper_get_ostream_489, METH_NOARGS, (const char *)Dtool_OStreamWrapper_get_ostream_489_comment},
  {"upcast_to_StreamWrapperBase", &Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_486, METH_NOARGS, (const char *)Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_486_comment},
  {"upcastToStreamWrapperBase", &Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_486, METH_NOARGS, (const char *)Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_486_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_OStreamWrapper[] = {
  {(char *)"ostream", &Dtool_OStreamWrapper_ostream_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_OStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OStreamWrapper = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OStreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OStreamWrapper = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OStreamWrapper",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OStreamWrapper,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OStreamWrapper,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OStreamWrapper,
    &Dtool_SequenceMethods_OStreamWrapper,
    &Dtool_MappingMethods_OStreamWrapper,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OStreamWrapper,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a locking wrapper around an arbitrary ostream pointer.\n"
    " * A thread may use this class to perform an atomic seek/write operation.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OStreamWrapper,
    nullptr, // tp_members
    Dtool_Properties_OStreamWrapper,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OStreamWrapper,
    PyType_GenericAlloc,
    Dtool_new_OStreamWrapper,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OStreamWrapper,
  Dtool_UpcastInterface_OStreamWrapper,
  Dtool_DowncastInterface_OStreamWrapper,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OStreamWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_StreamWrapperBase(nullptr);
    Dtool_OStreamWrapper._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_StreamWrapperBase);
    Dtool_OStreamWrapper._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OStreamWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OStreamWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OStreamWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OStreamWrapper);
  }
}

/**
 * Python method tables for StreamWrapper (StreamWrapper)
 */
static PyMethodDef Dtool_Methods_StreamWrapper[] = {
  {"get_iostream", &Dtool_StreamWrapper_get_iostream_497, METH_NOARGS, (const char *)Dtool_StreamWrapper_get_iostream_497_comment},
  {"getIostream", &Dtool_StreamWrapper_get_iostream_497, METH_NOARGS, (const char *)Dtool_StreamWrapper_get_iostream_497_comment},
  {"upcast_to_IStreamWrapper", &Dtool_StreamWrapper_upcast_to_IStreamWrapper_491, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_IStreamWrapper_491_comment},
  {"upcastToIStreamWrapper", &Dtool_StreamWrapper_upcast_to_IStreamWrapper_491, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_IStreamWrapper_491_comment},
  {"upcast_to_OStreamWrapper", &Dtool_StreamWrapper_upcast_to_OStreamWrapper_493, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_OStreamWrapper_493_comment},
  {"upcastToOStreamWrapper", &Dtool_StreamWrapper_upcast_to_OStreamWrapper_493, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_OStreamWrapper_493_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_StreamWrapper[] = {
  {(char *)"iostream", &Dtool_StreamWrapper_iostream_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_StreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_StreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_StreamWrapper = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_StreamWrapper = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_StreamWrapper = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StreamWrapper",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamWrapper,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_StreamWrapper,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StreamWrapper,
    &Dtool_SequenceMethods_StreamWrapper,
    &Dtool_MappingMethods_StreamWrapper,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_StreamWrapper,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a locking wrapper around a combination ostream/istream\n"
    " * pointer.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StreamWrapper,
    nullptr, // tp_members
    Dtool_Properties_StreamWrapper,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StreamWrapper,
    PyType_GenericAlloc,
    Dtool_new_StreamWrapper,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamWrapper,
  Dtool_UpcastInterface_StreamWrapper,
  Dtool_DowncastInterface_StreamWrapper,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StreamWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_IStreamWrapper(nullptr);
    Dtool_PyModuleClassInit_OStreamWrapper(nullptr);
    Dtool_StreamWrapper._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_IStreamWrapper, (PyTypeObject *)&Dtool_OStreamWrapper);
    Dtool_StreamWrapper._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StreamWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamWrapper);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3prc_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3prc_BuildInstants(PyObject *module) {
  (void) module;
  // enum NotifySeverity
  PyModule_AddObject(module, "NS_unspecified", Dtool_WrapValue(::NS_unspecified));
  PyModule_AddObject(module, "NSUnspecified", Dtool_WrapValue(::NS_unspecified));
  PyModule_AddObject(module, "NS_spam", Dtool_WrapValue(::NS_spam));
  PyModule_AddObject(module, "NSSpam", Dtool_WrapValue(::NS_spam));
  PyModule_AddObject(module, "NS_debug", Dtool_WrapValue(::NS_debug));
  PyModule_AddObject(module, "NSDebug", Dtool_WrapValue(::NS_debug));
  PyModule_AddObject(module, "NS_info", Dtool_WrapValue(::NS_info));
  PyModule_AddObject(module, "NSInfo", Dtool_WrapValue(::NS_info));
  PyModule_AddObject(module, "NS_warning", Dtool_WrapValue(::NS_warning));
  PyModule_AddObject(module, "NSWarning", Dtool_WrapValue(::NS_warning));
  PyModule_AddObject(module, "NS_error", Dtool_WrapValue(::NS_error));
  PyModule_AddObject(module, "NSError", Dtool_WrapValue(::NS_error));
  PyModule_AddObject(module, "NS_fatal", Dtool_WrapValue(::NS_fatal));
  PyModule_AddObject(module, "NSFatal", Dtool_WrapValue(::NS_fatal));
  // ConfigFlags
  Dtool_PyModuleClassInit_ConfigFlags(module);
  PyModule_AddObject(module, "ConfigFlags", (PyObject *)&Dtool_ConfigFlags);
  // ConfigPage
  Dtool_PyModuleClassInit_ConfigPage(module);
  PyModule_AddObject(module, "ConfigPage", (PyObject *)&Dtool_ConfigPage);
  // ConfigDeclaration
  Dtool_PyModuleClassInit_ConfigDeclaration(module);
  PyModule_AddObject(module, "ConfigDeclaration", (PyObject *)&Dtool_ConfigDeclaration);
  // ConfigVariableCore
  Dtool_PyModuleClassInit_ConfigVariableCore(module);
  PyModule_AddObject(module, "ConfigVariableCore", (PyObject *)&Dtool_ConfigVariableCore);
  // Notify
  Dtool_PyModuleClassInit_Notify(module);
  PyModule_AddObject(module, "Notify", (PyObject *)&Dtool_Notify);
  // ConfigPageManager
  Dtool_PyModuleClassInit_ConfigPageManager(module);
  PyModule_AddObject(module, "ConfigPageManager", (PyObject *)&Dtool_ConfigPageManager);
  // ConfigVariableManager
  Dtool_PyModuleClassInit_ConfigVariableManager(module);
  PyModule_AddObject(module, "ConfigVariableManager", (PyObject *)&Dtool_ConfigVariableManager);
  // ConfigVariableBase
  Dtool_PyModuleClassInit_ConfigVariableBase(module);
  PyModule_AddObject(module, "ConfigVariableBase", (PyObject *)&Dtool_ConfigVariableBase);
  // ConfigVariable
  Dtool_PyModuleClassInit_ConfigVariable(module);
  PyModule_AddObject(module, "ConfigVariable", (PyObject *)&Dtool_ConfigVariable);
  // ConfigVariableBool
  Dtool_PyModuleClassInit_ConfigVariableBool(module);
  PyModule_AddObject(module, "ConfigVariableBool", (PyObject *)&Dtool_ConfigVariableBool);
  // ConfigVariableDouble
  Dtool_PyModuleClassInit_ConfigVariableDouble(module);
  PyModule_AddObject(module, "ConfigVariableDouble", (PyObject *)&Dtool_ConfigVariableDouble);
  // ConfigVariableFilename
  Dtool_PyModuleClassInit_ConfigVariableFilename(module);
  PyModule_AddObject(module, "ConfigVariableFilename", (PyObject *)&Dtool_ConfigVariableFilename);
  // ConfigVariableInt
  Dtool_PyModuleClassInit_ConfigVariableInt(module);
  PyModule_AddObject(module, "ConfigVariableInt", (PyObject *)&Dtool_ConfigVariableInt);
  // ConfigVariableInt64
  Dtool_PyModuleClassInit_ConfigVariableInt64(module);
  PyModule_AddObject(module, "ConfigVariableInt64", (PyObject *)&Dtool_ConfigVariableInt64);
  // ConfigVariableList
  Dtool_PyModuleClassInit_ConfigVariableList(module);
  PyModule_AddObject(module, "ConfigVariableList", (PyObject *)&Dtool_ConfigVariableList);
  // ConfigVariableSearchPath
  Dtool_PyModuleClassInit_ConfigVariableSearchPath(module);
  PyModule_AddObject(module, "ConfigVariableSearchPath", (PyObject *)&Dtool_ConfigVariableSearchPath);
  // ConfigVariableString
  Dtool_PyModuleClassInit_ConfigVariableString(module);
  PyModule_AddObject(module, "ConfigVariableString", (PyObject *)&Dtool_ConfigVariableString);
  // NotifyCategory
  Dtool_PyModuleClassInit_NotifyCategory(module);
  PyModule_AddObject(module, "NotifyCategory", (PyObject *)&Dtool_NotifyCategory);
  // IDecryptStream
  Dtool_PyModuleClassInit_IDecryptStream(module);
  PyModule_AddObject(module, "IDecryptStream", (PyObject *)&Dtool_IDecryptStream);
  // OEncryptStream
  Dtool_PyModuleClassInit_OEncryptStream(module);
  PyModule_AddObject(module, "OEncryptStream", (PyObject *)&Dtool_OEncryptStream);
  // StreamReader
  Dtool_PyModuleClassInit_StreamReader(module);
  PyModule_AddObject(module, "StreamReader", (PyObject *)&Dtool_StreamReader);
  // StreamWriter
  Dtool_PyModuleClassInit_StreamWriter(module);
  PyModule_AddObject(module, "StreamWriter", (PyObject *)&Dtool_StreamWriter);
  // StreamWrapperBase
  Dtool_PyModuleClassInit_StreamWrapperBase(module);
  PyModule_AddObject(module, "StreamWrapperBase", (PyObject *)&Dtool_StreamWrapperBase);
  // IStreamWrapper
  Dtool_PyModuleClassInit_IStreamWrapper(module);
  PyModule_AddObject(module, "IStreamWrapper", (PyObject *)&Dtool_IStreamWrapper);
  // OStreamWrapper
  Dtool_PyModuleClassInit_OStreamWrapper(module);
  PyModule_AddObject(module, "OStreamWrapper", (PyObject *)&Dtool_OStreamWrapper);
  // StreamWrapper
  Dtool_PyModuleClassInit_StreamWrapper(module);
  PyModule_AddObject(module, "StreamWrapper", (PyObject *)&Dtool_StreamWrapper);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3prc_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3prc_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612452,  /* file_identifier */
  "libp3prc",  /* library_name */
  "Flsb",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3prc.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  988  /* next_index */
};

Configure(_in_configure_libp3prc);
ConfigureFn(_in_configure_libp3prc) {
  interrogate_request_module(&_in_module_def);
}

