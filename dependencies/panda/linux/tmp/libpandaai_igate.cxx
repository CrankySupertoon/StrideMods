/*
 * This file was generated by:
 * built/bin/interrogate -srcdir contrib/src/ai -Icontrib/src/ai -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libpandaai_igate.cxx -od built/pandac/input/libpandaai.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Icontrib/src/ai -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.ai -library libpandaai aiBehaviors.h aiCharacter.h aiGlobals.h aiNode.h aiPathFinder.h aiWorld.h arrival.h config_ai.h evade.h flee.h flock.h meshNode.h obstacleAvoidance.h p3ai_composite1.cxx pathFind.h pathFollow.h pursue.h seek.h wander.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "aiBehaviors.h"
#include "aiCharacter.h"
#include "aiGlobals.h"
#include "aiNode.h"
#include "aiPathFinder.h"
#include "aiWorld.h"
#include "arrival.h"
#include "boundingSphere.h"
#include "cmath.h"
#include "config_ai.h"
#include "evade.h"
#include "flee.h"
#include "flock.h"
#include "lineSegs.h"
#include "meshNode.h"
#include "obstacleAvoidance.h"
#include "pathFind.h"
#include "pathFollow.h"
#include "pursue.h"
#include "seek.h"
#include "wander.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AICharacter
 */
typedef AICharacter AICharacter_localtype;
Define_Module_ClassRef(panda3d.ai, AICharacter, AICharacter_localtype, AICharacter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AICharacter = &Dtool_AICharacter;
static void Dtool_PyModuleClassInit_AICharacter(PyObject *module);

/**
 * Forward declarations for top-level class AIBehaviors
 */
typedef AIBehaviors AIBehaviors_localtype;
Define_Module_Class(panda3d.ai, AIBehaviors, AIBehaviors_localtype, AIBehaviors);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AIBehaviors = &Dtool_AIBehaviors;
static void Dtool_PyModuleClassInit_AIBehaviors(PyObject *module);

/**
 * Forward declarations for top-level class AINode
 */
typedef AINode AINode_localtype;
Define_Module_Class(panda3d.ai, AINode, AINode_localtype, AINode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AINode = &Dtool_AINode;
static void Dtool_PyModuleClassInit_AINode(PyObject *module);

/**
 * Forward declarations for top-level class Flock
 */
typedef Flock Flock_localtype;
Define_Module_Class(panda3d.ai, Flock, Flock_localtype, Flock);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Flock = &Dtool_Flock;
static void Dtool_PyModuleClassInit_Flock(PyObject *module);

/**
 * Forward declarations for top-level class AIWorld
 */
typedef AIWorld AIWorld_localtype;
Define_Module_Class(panda3d.ai, AIWorld, AIWorld_localtype, AIWorld);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AIWorld = &Dtool_AIWorld;
static void Dtool_PyModuleClassInit_AIWorld(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"AICharacter", &Dtool_AICharacter},
  {"AIBehaviors", &Dtool_AIBehaviors},
  {"AINode", &Dtool_AINode},
  {"Flock", &Dtool_Flock},
  {"AIWorld", &Dtool_AIWorld},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[0].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[1].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[2].type)
  {nullptr, nullptr},
};
#endif

// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class AICharacter
 */
/**
 * Python function wrapper for:
 * double AICharacter::get_mass(void)
 */
static PyObject *Dtool_AICharacter_get_mass_3(PyObject *self, PyObject *) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_mass")) {
    return nullptr;
  }
  // 1-double AICharacter::get_mass(void)
  double return_value = ((*local_this).get_mass)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_mass_3_comment =
  "C++ Interface:\n"
  "get_mass(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_mass_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_mass(double m)
 */
static PyObject *Dtool_AICharacter_set_mass_4(PyObject *self, PyObject *arg) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_mass")) {
    return nullptr;
  }
  // 1-void AICharacter::set_mass(double m)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_mass)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass(const AICharacter self, double m)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_mass_4_comment =
  "C++ Interface:\n"
  "set_mass(const AICharacter self, double m)\n";
#else
static const char *Dtool_AICharacter_set_mass_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase3 AICharacter::get_velocity(void)
 */
static PyObject *Dtool_AICharacter_get_velocity_5(PyObject *self, PyObject *) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_velocity")) {
    return nullptr;
  }
  // 1-LVecBase3 AICharacter::get_velocity(void)
  LVecBase3 *return_value = new LVecBase3(((*local_this).get_velocity)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_velocity_5_comment =
  "C++ Interface:\n"
  "get_velocity(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_velocity_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double AICharacter::get_max_force(void)
 */
static PyObject *Dtool_AICharacter_get_max_force_6(PyObject *self, PyObject *) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_max_force")) {
    return nullptr;
  }
  // 1-double AICharacter::get_max_force(void)
  double return_value = ((*local_this).get_max_force)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_max_force_6_comment =
  "C++ Interface:\n"
  "get_max_force(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_max_force_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_max_force(double max_force)
 */
static PyObject *Dtool_AICharacter_set_max_force_7(PyObject *self, PyObject *arg) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_max_force")) {
    return nullptr;
  }
  // 1-void AICharacter::set_max_force(double max_force)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_force)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_force(const AICharacter self, double max_force)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_max_force_7_comment =
  "C++ Interface:\n"
  "set_max_force(const AICharacter self, double max_force)\n";
#else
static const char *Dtool_AICharacter_set_max_force_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath AICharacter::get_node_path(void)
 */
static PyObject *Dtool_AICharacter_get_node_path_8(PyObject *self, PyObject *) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_node_path")) {
    return nullptr;
  }
  // 1-NodePath AICharacter::get_node_path(void)
  NodePath *return_value = new NodePath(((*local_this).get_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_node_path_8_comment =
  "C++ Interface:\n"
  "get_node_path(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_node_path_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_node_path(NodePath np)
 */
static PyObject *Dtool_AICharacter_set_node_path_9(PyObject *self, PyObject *arg) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_node_path")) {
    return nullptr;
  }
  // 1-void AICharacter::set_node_path(NodePath np)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AICharacter.set_node_path", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_node_path)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_node_path(const AICharacter self, NodePath np)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_node_path_9_comment =
  "C++ Interface:\n"
  "set_node_path(const AICharacter self, NodePath np)\n";
#else
static const char *Dtool_AICharacter_set_node_path_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AIBehaviors *AICharacter::get_ai_behaviors(void)
 */
static PyObject *Dtool_AICharacter_get_ai_behaviors_10(PyObject *self, PyObject *) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.get_ai_behaviors")) {
    return nullptr;
  }
  // 1-AIBehaviors *AICharacter::get_ai_behaviors(void)
  AIBehaviors *return_value = ((*local_this).get_ai_behaviors)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AIBehaviors, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_get_ai_behaviors_10_comment =
  "C++ Interface:\n"
  "get_ai_behaviors(const AICharacter self)\n";
#else
static const char *Dtool_AICharacter_get_ai_behaviors_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AICharacter::set_pf_guide(bool pf_guide)
 */
static PyObject *Dtool_AICharacter_set_pf_guide_11(PyObject *self, PyObject *arg) {
  AICharacter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AICharacter, (void **)&local_this, "AICharacter.set_pf_guide")) {
    return nullptr;
  }
  // 1-void AICharacter::set_pf_guide(bool pf_guide)
  ((*local_this).set_pf_guide)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pf_guide(const AICharacter self, bool pf_guide)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AICharacter_set_pf_guide_11_comment =
  "C++ Interface:\n"
  "set_pf_guide(const AICharacter self, bool pf_guide)\n"
  "\n"
  "// This function is used to enable or disable the guides for path finding.";
#else
static const char *Dtool_AICharacter_set_pf_guide_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AICharacter::AICharacter(AICharacter const &) = default
 * explicit AICharacter::AICharacter(std::string model_name, NodePath model_np, double mass, double movt_force, double max_force)
 */
static int Dtool_Init_AICharacter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline AICharacter::AICharacter(AICharacter const &) = default
      AICharacter const *arg_this = (AICharacter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AICharacter, 0, "AICharacter.AICharacter", true, true);
      if (arg_this != nullptr) {
        AICharacter *return_value = new AICharacter(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AICharacter, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-explicit AICharacter::AICharacter(std::string model_name, NodePath model_np, double mass, double movt_force, double max_force)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      double param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"model_name", "model_np", "mass", "movt_force", "max_force", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oddd:AICharacter", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "AICharacter.AICharacter", true, true);
        if (param1_this != nullptr) {
          AICharacter *return_value = new AICharacter(std::string(param0_str, param0_len), *param1_this, (double)param2, (double)param3, (double)param4);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AICharacter, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AICharacter() takes 1 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AICharacter(const AICharacter param0)\n"
      "AICharacter(str model_name, NodePath model_np, double mass, double movt_force, double max_force)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AICharacter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AICharacter) {
    printf("AICharacter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AICharacter *local_this = (AICharacter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AICharacter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AICharacter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AICharacter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AICharacter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AIBehaviors
 */
/**
 * Python function wrapper for:
 * void AIBehaviors::seek(LVecBase3 pos, float seek_wt = 1.0)
 * void AIBehaviors::seek(NodePath target_object, float seek_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_seek_15(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.seek")) {
    return nullptr;
  }
  {
    // -2 void AIBehaviors::seek(LVecBase3 pos, float seek_wt = 1.0)
    PyObject *param1;
    float param2 = 1.0;
    static const char *keyword_list[] = {"pos", "seek_wt", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:seek", (char **)keyword_list, &param1, &param2)) {
      LVecBase3 *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
      if (param1_this != nullptr) {
        ((*local_this).seek)(*param1_this, (float)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::seek(NodePath target_object, float seek_wt = 1.0)
    PyObject *param1;
    float param2 = 1.0;
    static const char *keyword_list[] = {"target_object", "seek_wt", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:seek", (char **)keyword_list, &param1, &param2)) {
      NodePath *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
      if (param1_this != nullptr) {
        ((*local_this).seek)(*param1_this, (float)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::seek(LVecBase3 pos, float seek_wt = 1.0)
    PyObject *param1;
    float param2 = 1.0;
    static const char *keyword_list[] = {"pos", "seek_wt", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:seek", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f param1_local;
      LVecBase3 *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
      if ((param1_this != nullptr)) {
        ((*local_this).seek)(*param1_this, (float)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void AIBehaviors::seek(NodePath target_object, float seek_wt = 1.0)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seek(const AIBehaviors self, LVecBase3f pos, float seek_wt)\n"
      "seek(const AIBehaviors self, NodePath target_object, float seek_wt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_seek_15_comment =
  "C++ Interface:\n"
  "seek(const AIBehaviors self, LVecBase3f pos, float seek_wt)\n"
  "seek(const AIBehaviors self, NodePath target_object, float seek_wt)\n"
  "\n"
  "/**\n"
  " * This function activates seek and makes an object of the Seek class.  This\n"
  " * is the function we want the user to call for seek to be done.  This\n"
  " * function is overloaded to accept a NodePath or an LVecBase3.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_seek_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::flee(LVecBase3 pos, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
 * void AIBehaviors::flee(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_flee_16(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.flee")) {
    return nullptr;
  }
  {
    // -2 void AIBehaviors::flee(LVecBase3 pos, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
    PyObject *param1;
    double param2 = 10.0;
    double param3 = 10.0;
    float param4 = 1.0;
    static const char *keyword_list[] = {"pos", "panic_distance", "relax_distance", "flee_wt", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:flee", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3 *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
      if (param1_this != nullptr) {
        ((*local_this).flee)(*param1_this, (double)param2, (double)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::flee(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
    PyObject *param1;
    double param2 = 10.0;
    double param3 = 10.0;
    float param4 = 1.0;
    static const char *keyword_list[] = {"target_object", "panic_distance", "relax_distance", "flee_wt", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:flee", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      NodePath *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
      if (param1_this != nullptr) {
        ((*local_this).flee)(*param1_this, (double)param2, (double)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::flee(LVecBase3 pos, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
    PyObject *param1;
    double param2 = 10.0;
    double param3 = 10.0;
    float param4 = 1.0;
    static const char *keyword_list[] = {"pos", "panic_distance", "relax_distance", "flee_wt", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:flee", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LVecBase3f param1_local;
      LVecBase3 *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
      if ((param1_this != nullptr)) {
        ((*local_this).flee)(*param1_this, (double)param2, (double)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void AIBehaviors::flee(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flee(const AIBehaviors self, LVecBase3f pos, double panic_distance, double relax_distance, float flee_wt)\n"
      "flee(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float flee_wt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_flee_16_comment =
  "C++ Interface:\n"
  "flee(const AIBehaviors self, LVecBase3f pos, double panic_distance, double relax_distance, float flee_wt)\n"
  "flee(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float flee_wt)\n"
  "\n"
  "/**\n"
  " * This function activates flee_activate and creates an object of the Flee\n"
  " * class.  This function is overloaded to accept a NodePath or an LVecBase3.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_flee_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::pursue(NodePath target_object, float pursue_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_pursue_17(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.pursue")) {
    return nullptr;
  }
  // 1-void AIBehaviors::pursue(NodePath target_object, float pursue_wt = 1.0)
  PyObject *param1;
  float param2 = 1.0;
  static const char *keyword_list[] = {"target_object", "pursue_wt", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:pursue", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "AIBehaviors.pursue", true, true);
    if (param1_this != nullptr) {
      ((*local_this).pursue)(*param1_this, (float)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pursue(const AIBehaviors self, NodePath target_object, float pursue_wt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_pursue_17_comment =
  "C++ Interface:\n"
  "pursue(const AIBehaviors self, NodePath target_object, float pursue_wt)\n"
  "\n"
  "/**\n"
  " * This function activates pursue.  This is the function we want the user to\n"
  " * call for pursue to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_pursue_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::evade(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float evade_wt = 1.0)
 */
static PyObject *Dtool_AIBehaviors_evade_18(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.evade")) {
    return nullptr;
  }
  // 1-void AIBehaviors::evade(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float evade_wt = 1.0)
  PyObject *param1;
  double param2 = 10.0;
  double param3 = 10.0;
  float param4 = 1.0;
  static const char *keyword_list[] = {"target_object", "panic_distance", "relax_distance", "evade_wt", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ddf:evade", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "AIBehaviors.evade", true, true);
    if (param1_this != nullptr) {
      ((*local_this).evade)(*param1_this, (double)param2, (double)param3, (float)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "evade(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float evade_wt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_evade_18_comment =
  "C++ Interface:\n"
  "evade(const AIBehaviors self, NodePath target_object, double panic_distance, double relax_distance, float evade_wt)\n"
  "\n"
  "/**\n"
  " * This function activates evade_activate.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_evade_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::arrival(double distance = 10.0)
 */
static PyObject *Dtool_AIBehaviors_arrival_19(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.arrival")) {
    return nullptr;
  }
  // 1-void AIBehaviors::arrival(double distance = 10.0)
  double param1 = 10.0;
  static const char *keyword_list[] = {"distance", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|d:arrival", (char **)keyword_list, &param1)) {
    ((*local_this).arrival)((double)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "arrival(const AIBehaviors self, double distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_arrival_19_comment =
  "C++ Interface:\n"
  "arrival(const AIBehaviors self, double distance)\n"
  "\n"
  "/**\n"
  " * This function activates arrival.  This is the function we want the user to\n"
  " * call for arrival to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_arrival_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::flock(float flock_wt)
 */
static PyObject *Dtool_AIBehaviors_flock_20(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.flock")) {
    return nullptr;
  }
  // 1-void AIBehaviors::flock(float flock_wt)
  if (PyNumber_Check(arg)) {
    ((*local_this).flock)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flock(const AIBehaviors self, float flock_wt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_flock_20_comment =
  "C++ Interface:\n"
  "flock(const AIBehaviors self, float flock_wt)\n"
  "\n"
  "/**\n"
  " * This function activates flock.  This is the function we want the user to\n"
  " * call for flock to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_flock_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::wander(double wander_radius = 5.0, int flag = 0, double aoe = 0.0, float wander_weight = 1.0)
 */
static PyObject *Dtool_AIBehaviors_wander_21(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.wander")) {
    return nullptr;
  }
  // 1-void AIBehaviors::wander(double wander_radius = 5.0, int flag = 0, double aoe = 0.0, float wander_weight = 1.0)
  double param1 = 5.0;
  int param2 = 0;
  double param3 = 0.0;
  float param4 = 1.0;
  static const char *keyword_list[] = {"wander_radius", "flag", "aoe", "wander_weight", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|didf:wander", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).wander)((double)param1, (int)param2, (double)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wander(const AIBehaviors self, double wander_radius, int flag, double aoe, float wander_weight)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_wander_21_comment =
  "C++ Interface:\n"
  "wander(const AIBehaviors self, double wander_radius, int flag, double aoe, float wander_weight)\n"
  "\n"
  "/**\n"
  " * This function activates wander.  This is the function we want the user to\n"
  " * call for flock to be done.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_wander_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::obstacle_avoidance(float feeler_length = 1.0)
 */
static PyObject *Dtool_AIBehaviors_obstacle_avoidance_22(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.obstacle_avoidance")) {
    return nullptr;
  }
  // 1-void AIBehaviors::obstacle_avoidance(float feeler_length = 1.0)
  float param1 = 1.0;
  static const char *keyword_list[] = {"feeler_length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:obstacle_avoidance", (char **)keyword_list, &param1)) {
    ((*local_this).obstacle_avoidance)((float)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "obstacle_avoidance(const AIBehaviors self, float feeler_length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_obstacle_avoidance_22_comment =
  "C++ Interface:\n"
  "obstacle_avoidance(const AIBehaviors self, float feeler_length)\n"
  "\n"
  "/**\n"
  " * This function activates obstacle avoidance for a given character.  This is\n"
  " * the function we want the user to call for obstacle avoidance to be\n"
  " * performed.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_obstacle_avoidance_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::path_follow(float follow_wt)
 */
static PyObject *Dtool_AIBehaviors_path_follow_23(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.path_follow")) {
    return nullptr;
  }
  // 1-void AIBehaviors::path_follow(float follow_wt)
  if (PyNumber_Check(arg)) {
    ((*local_this).path_follow)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "path_follow(const AIBehaviors self, float follow_wt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_path_follow_23_comment =
  "C++ Interface:\n"
  "path_follow(const AIBehaviors self, float follow_wt)\n"
  "\n"
  "/**\n"
  " * This function activates path following.  This is the function we want the\n"
  " * user to call for path following.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_path_follow_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::add_to_path(LVecBase3 pos)
 */
static PyObject *Dtool_AIBehaviors_add_to_path_24(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.add_to_path")) {
    return nullptr;
  }
  // 1-void AIBehaviors::add_to_path(LVecBase3 pos)
  LVecBase3f arg_local;
  LVecBase3 *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AIBehaviors.add_to_path", "LVecBase3f");
  }
  ((*local_this).add_to_path)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_path(const AIBehaviors self, LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_add_to_path_24_comment =
  "C++ Interface:\n"
  "add_to_path(const AIBehaviors self, LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * This function adds positions to the path to follow.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_add_to_path_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::start_follow(std::string type = "normal")
 */
static PyObject *Dtool_AIBehaviors_start_follow_25(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.start_follow")) {
    return nullptr;
  }
  // 1-void AIBehaviors::start_follow(std::string type = "normal")
  const char *param1_str = "normal";
  Py_ssize_t param1_len = 6;
  static const char *keyword_list[] = {"type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:start_follow", (char **)keyword_list, &param1_str, &param1_len)) {
    ((*local_this).start_follow)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start_follow(const AIBehaviors self, str type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_start_follow_25_comment =
  "C++ Interface:\n"
  "start_follow(const AIBehaviors self, str type)\n";
#else
static const char *Dtool_AIBehaviors_start_follow_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::init_path_find(char const *navmesh_filename)
 */
static PyObject *Dtool_AIBehaviors_init_path_find_26(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.init_path_find")) {
    return nullptr;
  }
  // 1-void AIBehaviors::init_path_find(char const *navmesh_filename)
  char const *param1;
  if (PyArg_Parse(arg, "z:init_path_find", &param1)) {
    ((*local_this).init_path_find)((char const *)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "init_path_find(const AIBehaviors self, str navmesh_filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_init_path_find_26_comment =
  "C++ Interface:\n"
  "init_path_find(const AIBehaviors self, str navmesh_filename)\n"
  "\n"
  "// should have different function names.\n"
  "\n"
  "/**\n"
  " * This function activates path finding in the character.  This function\n"
  " * accepts the meshdata in .csv format.\n"
  " *\n"
  " */";
#else
static const char *Dtool_AIBehaviors_init_path_find_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::path_find_to(LVecBase3 pos, std::string type = "normal")
 * void AIBehaviors::path_find_to(NodePath target, std::string type = "normal")
 */
static PyObject *Dtool_AIBehaviors_path_find_to_27(PyObject *self, PyObject *args, PyObject *kwds) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.path_find_to")) {
    return nullptr;
  }
  {
    // -2 void AIBehaviors::path_find_to(LVecBase3 pos, std::string type = "normal")
    PyObject *param1;
    const char *param2_str = "normal";
    Py_ssize_t param2_len = 6;
    static const char *keyword_list[] = {"pos", "type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:path_find_to", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      LVecBase3 *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
      if (param1_this != nullptr) {
        ((*local_this).path_find_to)(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::path_find_to(NodePath target, std::string type = "normal")
    PyObject *param1;
    const char *param2_str = "normal";
    Py_ssize_t param2_len = 6;
    static const char *keyword_list[] = {"target", "type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:path_find_to", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      NodePath *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
      if (param1_this != nullptr) {
        ((*local_this).path_find_to)(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void AIBehaviors::path_find_to(LVecBase3 pos, std::string type = "normal")
    PyObject *param1;
    const char *param2_str = "normal";
    Py_ssize_t param2_len = 6;
    static const char *keyword_list[] = {"pos", "type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:path_find_to", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      LVecBase3f param1_local;
      LVecBase3 *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
      if ((param1_this != nullptr)) {
        ((*local_this).path_find_to)(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void AIBehaviors::path_find_to(NodePath target, std::string type = "normal")
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "path_find_to(const AIBehaviors self, LVecBase3f pos, str type)\n"
      "path_find_to(const AIBehaviors self, NodePath target, str type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_path_find_to_27_comment =
  "C++ Interface:\n"
  "path_find_to(const AIBehaviors self, LVecBase3f pos, str type)\n"
  "path_find_to(const AIBehaviors self, NodePath target, str type)\n"
  "\n"
  "/**\n"
  " * This function checks for the source and target in the navigation mesh for\n"
  " * its availability and then finds the best path via the A* algorithm Then it\n"
  " * calls the path follower to make the object follow the path.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function checks for the source and target in the navigation mesh for\n"
  " * its availability and then finds the best path via the A* algorithm Then it\n"
  " * calls the path follower to make the object follow the path.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_path_find_to_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::add_static_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIBehaviors_add_static_obstacle_28(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.add_static_obstacle")) {
    return nullptr;
  }
  // 1-void AIBehaviors::add_static_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIBehaviors.add_static_obstacle", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_static_obstacle)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_static_obstacle(const AIBehaviors self, NodePath obstacle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_add_static_obstacle_28_comment =
  "C++ Interface:\n"
  "add_static_obstacle(const AIBehaviors self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function allows the user to dynamically add obstacles to the game\n"
  " * environment.  The function will update the nodes within the bounding volume\n"
  " * of the obstacle as non-traversable.  Hence will not be considered by the\n"
  " * pathfinding algorithm.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_add_static_obstacle_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::add_dynamic_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIBehaviors_add_dynamic_obstacle_29(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.add_dynamic_obstacle")) {
    return nullptr;
  }
  // 1-void AIBehaviors::add_dynamic_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIBehaviors.add_dynamic_obstacle", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_dynamic_obstacle)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dynamic_obstacle(const AIBehaviors self, NodePath obstacle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_add_dynamic_obstacle_29_comment =
  "C++ Interface:\n"
  "add_dynamic_obstacle(const AIBehaviors self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function starts the pathfinding obstacle navigation for the passed in\n"
  " * obstacle.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_add_dynamic_obstacle_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::remove_ai(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_remove_ai_30(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.remove_ai")) {
    return nullptr;
  }
  // 1-void AIBehaviors::remove_ai(std::string ai_type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).remove_ai)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_ai(const AIBehaviors self, str ai_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_remove_ai_30_comment =
  "C++ Interface:\n"
  "remove_ai(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function removes individual or all the AIs.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_remove_ai_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::pause_ai(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_pause_ai_31(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.pause_ai")) {
    return nullptr;
  }
  // 1-void AIBehaviors::pause_ai(std::string ai_type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).pause_ai)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pause_ai(const AIBehaviors self, str ai_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_pause_ai_31_comment =
  "C++ Interface:\n"
  "pause_ai(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function pauses individual or all the AIs.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_pause_ai_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIBehaviors::resume_ai(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_resume_ai_32(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.resume_ai")) {
    return nullptr;
  }
  // 1-void AIBehaviors::resume_ai(std::string ai_type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).resume_ai)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resume_ai(const AIBehaviors self, str ai_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_resume_ai_32_comment =
  "C++ Interface:\n"
  "resume_ai(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function resumes individual or all the AIs\n"
  " */";
#else
static const char *Dtool_AIBehaviors_resume_ai_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string AIBehaviors::behavior_status(std::string ai_type)
 */
static PyObject *Dtool_AIBehaviors_behavior_status_33(PyObject *self, PyObject *arg) {
  AIBehaviors *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIBehaviors, (void **)&local_this, "AIBehaviors.behavior_status")) {
    return nullptr;
  }
  // 1-std::string AIBehaviors::behavior_status(std::string ai_type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*local_this).behavior_status)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "behavior_status(const AIBehaviors self, str ai_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIBehaviors_behavior_status_33_comment =
  "C++ Interface:\n"
  "behavior_status(const AIBehaviors self, str ai_type)\n"
  "\n"
  "/**\n"
  " * This function returns the status of an AI Type whether it is active, paused\n"
  " * or disabled.  It returns -1 if an invalid string is passed.\n"
  " */";
#else
static const char *Dtool_AIBehaviors_behavior_status_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AIBehaviors::AIBehaviors(AIBehaviors const &) = default
 */
static int Dtool_Init_AIBehaviors(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AIBehaviors() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline AIBehaviors::AIBehaviors(AIBehaviors const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    AIBehaviors const *param0_this = (AIBehaviors *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AIBehaviors, 0, "AIBehaviors.AIBehaviors", true, true);
    if (param0_this != nullptr) {
      AIBehaviors *return_value = new AIBehaviors(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AIBehaviors, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AIBehaviors(const AIBehaviors param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AIBehaviors(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AIBehaviors) {
    printf("AIBehaviors ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AIBehaviors *local_this = (AIBehaviors *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AIBehaviors) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AIBehaviors(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AIBehaviors) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AINode
 */
/**
 * Python function wrapper for:
 * bool AINode::contains(float x, float y)
 */
static PyObject *Dtool_AINode_contains_38(PyObject *self, PyObject *args, PyObject *kwds) {
  AINode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AINode, (void **)&local_this, "AINode.contains")) {
    return nullptr;
  }
  // 1-bool AINode::contains(float x, float y)
  float param1;
  float param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:contains", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).contains)((float)param1, (float)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "contains(const AINode self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AINode_contains_38_comment =
  "C++ Interface:\n"
  "contains(const AINode self, float x, float y)\n"
  "\n"
  "/**\n"
  " * This is a handy function which returns true if the passed position is\n"
  " * within the node's dimensions.\n"
  " */";
#else
static const char *Dtool_AINode_contains_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AINode::AINode(AINode const &) = default
 * explicit AINode::AINode(int grid_x, int grid_y, LVecBase3 pos, float w, float l, float h)
 */
static int Dtool_Init_AINode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline AINode::AINode(AINode const &) = default
      AINode const *arg_this = (AINode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AINode, 0, "AINode.AINode", true, true);
      if (arg_this != nullptr) {
        AINode *return_value = new AINode(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AINode, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-explicit AINode::AINode(int grid_x, int grid_y, LVecBase3 pos, float w, float l, float h)
      int param0;
      int param1;
      PyObject *param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"grid_x", "grid_y", "pos", "w", "l", "h", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOfff:AINode", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        LVecBase3f param2_local;
        LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "AINode.AINode", "LVecBase3f");
          return -1;
        }
        AINode *return_value = new AINode((int)param0, (int)param1, *param2_this, (float)param3, (float)param4, (float)param5);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AINode, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AINode() takes 1 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AINode(const AINode param0)\n"
      "AINode(int grid_x, int grid_y, LVecBase3f pos, float w, float l, float h)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AINode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AINode) {
    printf("AINode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AINode *local_this = (AINode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AINode) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AINode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AINode) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Flock
 */
/**
 * Python function wrapper for:
 * void Flock::add_ai_char(AICharacter *ai_char)
 */
static PyObject *Dtool_Flock_add_ai_char_42(PyObject *self, PyObject *arg) {
  Flock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Flock, (void **)&local_this, "Flock.add_ai_char")) {
    return nullptr;
  }
  // 1-void Flock::add_ai_char(AICharacter *ai_char)
  AICharacter *arg_this = (AICharacter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AICharacter, 1, "Flock.add_ai_char", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_ai_char)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_ai_char(const Flock self, AICharacter ai_char)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Flock_add_ai_char_42_comment =
  "C++ Interface:\n"
  "add_ai_char(const Flock self, AICharacter ai_char)\n"
  "\n"
  "// Function to add the ai characters to _ai_char_list.\n"
  "\n"
  "/**\n"
  " * This function adds AI characters to the flock.\n"
  " */";
#else
static const char *Dtool_Flock_add_ai_char_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned int Flock::get_id(void)
 */
static PyObject *Dtool_Flock_get_id_43(PyObject *self, PyObject *) {
  Flock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Flock, (void **)&local_this, "Flock.get_id")) {
    return nullptr;
  }
  // 1-unsigned int Flock::get_id(void)
  unsigned int return_value = ((*local_this).get_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Flock_get_id_43_comment =
  "C++ Interface:\n"
  "get_id(const Flock self)\n"
  "\n"
  "// Function to access the private member flock_id.";
#else
static const char *Dtool_Flock_get_id_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Flock::Flock(Flock const &) = default
 * explicit Flock::Flock(unsigned int flock_id, double vcone_angle, double vcone_radius, unsigned int separation_wt = 2, unsigned int cohesion_wt = 4, unsigned int alignment_wt = 1)
 */
static int Dtool_Init_Flock(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Flock::Flock(Flock const &) = default
      Flock const *arg_this = (Flock *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Flock, 0, "Flock.Flock", true, true);
      if (arg_this != nullptr) {
        Flock *return_value = new Flock(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Flock, true, false);
      }
    }
    break;
  case 3:
  case 4:
  case 5:
  case 6:
    {
      // 1-explicit Flock::Flock(unsigned int flock_id, double vcone_angle, double vcone_radius, unsigned int separation_wt = 2, unsigned int cohesion_wt = 4, unsigned int alignment_wt = 1)
      unsigned long param0;
      double param1;
      double param2;
      unsigned long param3 = 2;
      unsigned long param4 = 4;
      unsigned long param5 = 1;
      static const char *keyword_list[] = {"flock_id", "vcone_angle", "vcone_radius", "separation_wt", "cohesion_wt", "alignment_wt", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kdd|kkk:Flock", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param0 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param0);
          return -1;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param3 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param3);
          return -1;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param4 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param4);
          return -1;
        }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (param5 > UINT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %lu out of range for unsigned integer",
                       param5);
          return -1;
        }
#endif
        Flock *return_value = new Flock((unsigned int)param0, (double)param1, (double)param2, (unsigned int)param3, (unsigned int)param4, (unsigned int)param5);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Flock, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Flock() takes 1, 3, 4, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Flock(const Flock param0)\n"
      "Flock(int flock_id, double vcone_angle, double vcone_radius, int separation_wt, int cohesion_wt, int alignment_wt)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Flock(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Flock) {
    printf("Flock ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Flock *local_this = (Flock *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Flock) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Flock(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Flock) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AIWorld
 */
/**
 * Python function wrapper for:
 * void AIWorld::add_ai_char(AICharacter *ai_ch)
 */
static PyObject *Dtool_AIWorld_add_ai_char_47(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.add_ai_char")) {
    return nullptr;
  }
  // 1-void AIWorld::add_ai_char(AICharacter *ai_ch)
  AICharacter *arg_this = (AICharacter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AICharacter, 1, "AIWorld.add_ai_char", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_ai_char)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_ai_char(const AIWorld self, AICharacter ai_ch)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_add_ai_char_47_comment =
  "C++ Interface:\n"
  "add_ai_char(const AIWorld self, AICharacter ai_ch)\n";
#else
static const char *Dtool_AIWorld_add_ai_char_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::remove_ai_char(std::string name)
 */
static PyObject *Dtool_AIWorld_remove_ai_char_48(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.remove_ai_char")) {
    return nullptr;
  }
  // 1-void AIWorld::remove_ai_char(std::string name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).remove_ai_char)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_ai_char(const AIWorld self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_remove_ai_char_48_comment =
  "C++ Interface:\n"
  "remove_ai_char(const AIWorld self, str name)\n";
#else
static const char *Dtool_AIWorld_remove_ai_char_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::add_flock(Flock *flock)
 */
static PyObject *Dtool_AIWorld_add_flock_49(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.add_flock")) {
    return nullptr;
  }
  // 1-void AIWorld::add_flock(Flock *flock)
  Flock *arg_this = (Flock *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Flock, 1, "AIWorld.add_flock", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_flock)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_flock(const AIWorld self, Flock flock)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_add_flock_49_comment =
  "C++ Interface:\n"
  "add_flock(const AIWorld self, Flock flock)\n"
  "\n"
  "/**\n"
  " * This function adds all the AI characters in the Flock object to the\n"
  " * AICharPool.  This function allows adding the AI characetrs as part of a\n"
  " * flock.\n"
  " */";
#else
static const char *Dtool_AIWorld_add_flock_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::flock_off(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_flock_off_50(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.flock_off")) {
    return nullptr;
  }
  // 1-void AIWorld::flock_off(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).flock_off)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flock_off(const AIWorld self, int flock_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_flock_off_50_comment =
  "C++ Interface:\n"
  "flock_off(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function turns off the flock behavior temporarily.  Similar to pausing\n"
  " * the behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_flock_off_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::flock_on(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_flock_on_51(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.flock_on")) {
    return nullptr;
  }
  // 1-void AIWorld::flock_on(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).flock_on)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flock_on(const AIWorld self, int flock_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_flock_on_51_comment =
  "C++ Interface:\n"
  "flock_on(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function turns on the flock behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_flock_on_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::remove_flock(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_remove_flock_52(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.remove_flock")) {
    return nullptr;
  }
  // 1-void AIWorld::remove_flock(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).remove_flock)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_flock(const AIWorld self, int flock_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_remove_flock_52_comment =
  "C++ Interface:\n"
  "remove_flock(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function removes the flock behavior completely.\n"
  " */";
#else
static const char *Dtool_AIWorld_remove_flock_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Flock AIWorld::get_flock(unsigned int flock_id)
 */
static PyObject *Dtool_AIWorld_get_flock_53(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.get_flock")) {
    return nullptr;
  }
  // 1-Flock AIWorld::get_flock(unsigned int flock_id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Flock *return_value = new Flock(((*local_this).get_flock)((unsigned int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Flock, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_flock(const AIWorld self, int flock_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_get_flock_53_comment =
  "C++ Interface:\n"
  "get_flock(const AIWorld self, int flock_id)\n"
  "\n"
  "/**\n"
  " * This function returns a handle to the Flock whose id is passed.\n"
  " */";
#else
static const char *Dtool_AIWorld_get_flock_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::add_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIWorld_add_obstacle_54(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.add_obstacle")) {
    return nullptr;
  }
  // 1-void AIWorld::add_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIWorld.add_obstacle", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_obstacle)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_obstacle(const AIWorld self, NodePath obstacle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_add_obstacle_54_comment =
  "C++ Interface:\n"
  "add_obstacle(const AIWorld self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function adds the nodepath as an obstacle that is needed by the\n"
  " * obstacle avoidance behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_add_obstacle_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::remove_obstacle(NodePath obstacle)
 */
static PyObject *Dtool_AIWorld_remove_obstacle_55(PyObject *self, PyObject *arg) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.remove_obstacle")) {
    return nullptr;
  }
  // 1-void AIWorld::remove_obstacle(NodePath obstacle)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "AIWorld.remove_obstacle", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_obstacle)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_obstacle(const AIWorld self, NodePath obstacle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_remove_obstacle_55_comment =
  "C++ Interface:\n"
  "remove_obstacle(const AIWorld self, NodePath obstacle)\n"
  "\n"
  "/**\n"
  " * This function removes the nodepath from the obstacles list that is needed\n"
  " * by the obstacle avoidance behavior.\n"
  " */";
#else
static const char *Dtool_AIWorld_remove_obstacle_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::print_list(void)
 */
static PyObject *Dtool_AIWorld_print_list_56(PyObject *self, PyObject *) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.print_list")) {
    return nullptr;
  }
  // 1-void AIWorld::print_list(void)
  ((*local_this).print_list)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_print_list_56_comment =
  "C++ Interface:\n"
  "print_list(const AIWorld self)\n"
  "\n"
  "/**\n"
  " * This function prints the names of the AI characters that have been added to\n"
  " * the AIWorld.  Useful for debugging purposes.\n"
  " */";
#else
static const char *Dtool_AIWorld_print_list_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AIWorld::update(void)
 */
static PyObject *Dtool_AIWorld_update_57(PyObject *self, PyObject *) {
  AIWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AIWorld, (void **)&local_this, "AIWorld.update")) {
    return nullptr;
  }
  // 1-void AIWorld::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AIWorld_update_57_comment =
  "C++ Interface:\n"
  "update(const AIWorld self)\n"
  "\n"
  "/**\n"
  " * The AIWorld update function calls the update function of all the AI\n"
  " * characters which have been added to the AIWorld.\n"
  " */";
#else
static const char *Dtool_AIWorld_update_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AIWorld::AIWorld(AIWorld const &) = default
 * AIWorld::AIWorld(NodePath render)
 */
static int Dtool_Init_AIWorld(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AIWorld() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline AIWorld::AIWorld(AIWorld const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      AIWorld const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_AIWorld);
      if (param0_this != nullptr) {
        AIWorld *return_value = new AIWorld(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AIWorld, true, false);
      }
    }
  }

  {
    // -2 AIWorld::AIWorld(NodePath render)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "render")) {
      NodePath *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
      if (param0_this != nullptr) {
        AIWorld *return_value = new AIWorld(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AIWorld, true, false);
      }
    }
  }

  // No coercion possible: inline AIWorld::AIWorld(AIWorld const &) = default
  // No coercion possible: AIWorld::AIWorld(NodePath render)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AIWorld(const AIWorld param0)\n"
      "AIWorld(NodePath render)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AIWorld(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AIWorld) {
    printf("AIWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AIWorld *local_this = (AIWorld *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AIWorld) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AIWorld(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AIWorld) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for AICharacter (AICharacter)
 */
static PyMethodDef Dtool_Methods_AICharacter[] = {
  {"get_mass", &Dtool_AICharacter_get_mass_3, METH_NOARGS, (const char *)Dtool_AICharacter_get_mass_3_comment},
  {"getMass", &Dtool_AICharacter_get_mass_3, METH_NOARGS, (const char *)Dtool_AICharacter_get_mass_3_comment},
  {"set_mass", &Dtool_AICharacter_set_mass_4, METH_O, (const char *)Dtool_AICharacter_set_mass_4_comment},
  {"setMass", &Dtool_AICharacter_set_mass_4, METH_O, (const char *)Dtool_AICharacter_set_mass_4_comment},
  {"get_velocity", &Dtool_AICharacter_get_velocity_5, METH_NOARGS, (const char *)Dtool_AICharacter_get_velocity_5_comment},
  {"getVelocity", &Dtool_AICharacter_get_velocity_5, METH_NOARGS, (const char *)Dtool_AICharacter_get_velocity_5_comment},
  {"get_max_force", &Dtool_AICharacter_get_max_force_6, METH_NOARGS, (const char *)Dtool_AICharacter_get_max_force_6_comment},
  {"getMaxForce", &Dtool_AICharacter_get_max_force_6, METH_NOARGS, (const char *)Dtool_AICharacter_get_max_force_6_comment},
  {"set_max_force", &Dtool_AICharacter_set_max_force_7, METH_O, (const char *)Dtool_AICharacter_set_max_force_7_comment},
  {"setMaxForce", &Dtool_AICharacter_set_max_force_7, METH_O, (const char *)Dtool_AICharacter_set_max_force_7_comment},
  {"get_node_path", &Dtool_AICharacter_get_node_path_8, METH_NOARGS, (const char *)Dtool_AICharacter_get_node_path_8_comment},
  {"getNodePath", &Dtool_AICharacter_get_node_path_8, METH_NOARGS, (const char *)Dtool_AICharacter_get_node_path_8_comment},
  {"set_node_path", &Dtool_AICharacter_set_node_path_9, METH_O, (const char *)Dtool_AICharacter_set_node_path_9_comment},
  {"setNodePath", &Dtool_AICharacter_set_node_path_9, METH_O, (const char *)Dtool_AICharacter_set_node_path_9_comment},
  {"get_ai_behaviors", &Dtool_AICharacter_get_ai_behaviors_10, METH_NOARGS, (const char *)Dtool_AICharacter_get_ai_behaviors_10_comment},
  {"getAiBehaviors", &Dtool_AICharacter_get_ai_behaviors_10, METH_NOARGS, (const char *)Dtool_AICharacter_get_ai_behaviors_10_comment},
  {"set_pf_guide", &Dtool_AICharacter_set_pf_guide_11, METH_O, (const char *)Dtool_AICharacter_set_pf_guide_11_comment},
  {"setPfGuide", &Dtool_AICharacter_set_pf_guide_11, METH_O, (const char *)Dtool_AICharacter_set_pf_guide_11_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AICharacter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AICharacter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AICharacter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AICharacter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AICharacter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AICharacter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ai.AICharacter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AICharacter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AICharacter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AICharacter,
    &Dtool_SequenceMethods_AICharacter,
    &Dtool_MappingMethods_AICharacter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AICharacter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AICharacter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AICharacter,
    PyType_GenericAlloc,
    Dtool_new_AICharacter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AICharacter,
  Dtool_UpcastInterface_AICharacter,
  Dtool_DowncastInterface_AICharacter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AICharacter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_AICharacter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_AICharacter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AICharacter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AICharacter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AICharacter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AICharacter);
  }
}

/**
 * Python method tables for AIBehaviors (AIBehaviors)
 */
static PyMethodDef Dtool_Methods_AIBehaviors[] = {
  {"seek", (PyCFunction) &Dtool_AIBehaviors_seek_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_seek_15_comment},
  {"flee", (PyCFunction) &Dtool_AIBehaviors_flee_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_flee_16_comment},
  {"pursue", (PyCFunction) &Dtool_AIBehaviors_pursue_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_pursue_17_comment},
  {"evade", (PyCFunction) &Dtool_AIBehaviors_evade_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_evade_18_comment},
  {"arrival", (PyCFunction) &Dtool_AIBehaviors_arrival_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_arrival_19_comment},
  {"flock", &Dtool_AIBehaviors_flock_20, METH_O, (const char *)Dtool_AIBehaviors_flock_20_comment},
  {"wander", (PyCFunction) &Dtool_AIBehaviors_wander_21, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_wander_21_comment},
  {"obstacle_avoidance", (PyCFunction) &Dtool_AIBehaviors_obstacle_avoidance_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_obstacle_avoidance_22_comment},
  {"obstacleAvoidance", (PyCFunction) &Dtool_AIBehaviors_obstacle_avoidance_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_obstacle_avoidance_22_comment},
  {"path_follow", &Dtool_AIBehaviors_path_follow_23, METH_O, (const char *)Dtool_AIBehaviors_path_follow_23_comment},
  {"pathFollow", &Dtool_AIBehaviors_path_follow_23, METH_O, (const char *)Dtool_AIBehaviors_path_follow_23_comment},
  {"add_to_path", &Dtool_AIBehaviors_add_to_path_24, METH_O, (const char *)Dtool_AIBehaviors_add_to_path_24_comment},
  {"addToPath", &Dtool_AIBehaviors_add_to_path_24, METH_O, (const char *)Dtool_AIBehaviors_add_to_path_24_comment},
  {"start_follow", (PyCFunction) &Dtool_AIBehaviors_start_follow_25, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_start_follow_25_comment},
  {"startFollow", (PyCFunction) &Dtool_AIBehaviors_start_follow_25, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_start_follow_25_comment},
  {"init_path_find", &Dtool_AIBehaviors_init_path_find_26, METH_O, (const char *)Dtool_AIBehaviors_init_path_find_26_comment},
  {"initPathFind", &Dtool_AIBehaviors_init_path_find_26, METH_O, (const char *)Dtool_AIBehaviors_init_path_find_26_comment},
  {"path_find_to", (PyCFunction) &Dtool_AIBehaviors_path_find_to_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_path_find_to_27_comment},
  {"pathFindTo", (PyCFunction) &Dtool_AIBehaviors_path_find_to_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AIBehaviors_path_find_to_27_comment},
  {"add_static_obstacle", &Dtool_AIBehaviors_add_static_obstacle_28, METH_O, (const char *)Dtool_AIBehaviors_add_static_obstacle_28_comment},
  {"addStaticObstacle", &Dtool_AIBehaviors_add_static_obstacle_28, METH_O, (const char *)Dtool_AIBehaviors_add_static_obstacle_28_comment},
  {"add_dynamic_obstacle", &Dtool_AIBehaviors_add_dynamic_obstacle_29, METH_O, (const char *)Dtool_AIBehaviors_add_dynamic_obstacle_29_comment},
  {"addDynamicObstacle", &Dtool_AIBehaviors_add_dynamic_obstacle_29, METH_O, (const char *)Dtool_AIBehaviors_add_dynamic_obstacle_29_comment},
  {"remove_ai", &Dtool_AIBehaviors_remove_ai_30, METH_O, (const char *)Dtool_AIBehaviors_remove_ai_30_comment},
  {"removeAi", &Dtool_AIBehaviors_remove_ai_30, METH_O, (const char *)Dtool_AIBehaviors_remove_ai_30_comment},
  {"pause_ai", &Dtool_AIBehaviors_pause_ai_31, METH_O, (const char *)Dtool_AIBehaviors_pause_ai_31_comment},
  {"pauseAi", &Dtool_AIBehaviors_pause_ai_31, METH_O, (const char *)Dtool_AIBehaviors_pause_ai_31_comment},
  {"resume_ai", &Dtool_AIBehaviors_resume_ai_32, METH_O, (const char *)Dtool_AIBehaviors_resume_ai_32_comment},
  {"resumeAi", &Dtool_AIBehaviors_resume_ai_32, METH_O, (const char *)Dtool_AIBehaviors_resume_ai_32_comment},
  {"behavior_status", &Dtool_AIBehaviors_behavior_status_33, METH_O, (const char *)Dtool_AIBehaviors_behavior_status_33_comment},
  {"behaviorStatus", &Dtool_AIBehaviors_behavior_status_33, METH_O, (const char *)Dtool_AIBehaviors_behavior_status_33_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AIBehaviors = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_AIBehaviors = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ai.AIBehaviors",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AIBehaviors,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AIBehaviors,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements all the steering behaviors of the AI framework, such\n"
    " * as seek, flee, pursue, evade, wander and flock.  Each steering behavior has\n"
    " * a weight which is used when more than one type of steering behavior is\n"
    " * acting on the same ai character.  The weight decides the contribution of\n"
    " * each type of steering behavior.  The AICharacter class has a handle to an\n"
    " * object of this class and this allows to invoke the steering behaviors via\n"
    " * the AICharacter.  This class also provides functionality such as pausing,\n"
    " * resuming and removing the AI behaviors of an AI character at anytime.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AIBehaviors,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AIBehaviors,
    PyType_GenericAlloc,
    Dtool_new_AIBehaviors,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AIBehaviors,
  Dtool_UpcastInterface_AIBehaviors,
  Dtool_DowncastInterface_AIBehaviors,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AIBehaviors(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AIBehaviors._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AIBehaviors._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AIBehaviors) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AIBehaviors)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AIBehaviors);
  }
}

/**
 * Python method tables for AINode (AINode)
 */
static PyMethodDef Dtool_Methods_AINode[] = {
  {"contains", (PyCFunction) &Dtool_AINode_contains_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AINode_contains_38_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AINode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_AINode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ai.AINode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AINode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AINode,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to assign the nodes on the mesh.  It holds all the data\n"
    " * necessary to compute A* algorithm.  It also maintains a lot of vital\n"
    " * information such as the neighbor nodes of each node and also its position\n"
    " * on the mesh.  Note: The Mesh Generator which is a standalone tool makes use\n"
    " * of this class to generate the nodes on the mesh.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AINode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AINode,
    PyType_GenericAlloc,
    Dtool_new_AINode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AINode,
  Dtool_UpcastInterface_AINode,
  Dtool_DowncastInterface_AINode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AINode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AINode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AINode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AINode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AINode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AINode);
  }
}

/**
 * Python method tables for Flock (Flock)
 */
static PyMethodDef Dtool_Methods_Flock[] = {
  {"add_ai_char", &Dtool_Flock_add_ai_char_42, METH_O, (const char *)Dtool_Flock_add_ai_char_42_comment},
  {"addAiChar", &Dtool_Flock_add_ai_char_42, METH_O, (const char *)Dtool_Flock_add_ai_char_42_comment},
  {"get_id", &Dtool_Flock_get_id_43, METH_NOARGS, (const char *)Dtool_Flock_get_id_43_comment},
  {"getId", &Dtool_Flock_get_id_43, METH_NOARGS, (const char *)Dtool_Flock_get_id_43_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Flock = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Flock = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ai.Flock",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Flock,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Flock,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to define the flock attributes and the AI characters\n"
    " * which are part of the flock.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Flock,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Flock,
    PyType_GenericAlloc,
    Dtool_new_Flock,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Flock,
  Dtool_UpcastInterface_Flock,
  Dtool_DowncastInterface_Flock,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Flock(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Flock._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Flock._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Flock) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Flock)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Flock);
  }
}

/**
 * Python method tables for AIWorld (AIWorld)
 */
static PyMethodDef Dtool_Methods_AIWorld[] = {
  {"add_ai_char", &Dtool_AIWorld_add_ai_char_47, METH_O, (const char *)Dtool_AIWorld_add_ai_char_47_comment},
  {"addAiChar", &Dtool_AIWorld_add_ai_char_47, METH_O, (const char *)Dtool_AIWorld_add_ai_char_47_comment},
  {"remove_ai_char", &Dtool_AIWorld_remove_ai_char_48, METH_O, (const char *)Dtool_AIWorld_remove_ai_char_48_comment},
  {"removeAiChar", &Dtool_AIWorld_remove_ai_char_48, METH_O, (const char *)Dtool_AIWorld_remove_ai_char_48_comment},
  {"add_flock", &Dtool_AIWorld_add_flock_49, METH_O, (const char *)Dtool_AIWorld_add_flock_49_comment},
  {"addFlock", &Dtool_AIWorld_add_flock_49, METH_O, (const char *)Dtool_AIWorld_add_flock_49_comment},
  {"flock_off", &Dtool_AIWorld_flock_off_50, METH_O, (const char *)Dtool_AIWorld_flock_off_50_comment},
  {"flockOff", &Dtool_AIWorld_flock_off_50, METH_O, (const char *)Dtool_AIWorld_flock_off_50_comment},
  {"flock_on", &Dtool_AIWorld_flock_on_51, METH_O, (const char *)Dtool_AIWorld_flock_on_51_comment},
  {"flockOn", &Dtool_AIWorld_flock_on_51, METH_O, (const char *)Dtool_AIWorld_flock_on_51_comment},
  {"remove_flock", &Dtool_AIWorld_remove_flock_52, METH_O, (const char *)Dtool_AIWorld_remove_flock_52_comment},
  {"removeFlock", &Dtool_AIWorld_remove_flock_52, METH_O, (const char *)Dtool_AIWorld_remove_flock_52_comment},
  {"get_flock", &Dtool_AIWorld_get_flock_53, METH_O, (const char *)Dtool_AIWorld_get_flock_53_comment},
  {"getFlock", &Dtool_AIWorld_get_flock_53, METH_O, (const char *)Dtool_AIWorld_get_flock_53_comment},
  {"add_obstacle", &Dtool_AIWorld_add_obstacle_54, METH_O, (const char *)Dtool_AIWorld_add_obstacle_54_comment},
  {"addObstacle", &Dtool_AIWorld_add_obstacle_54, METH_O, (const char *)Dtool_AIWorld_add_obstacle_54_comment},
  {"remove_obstacle", &Dtool_AIWorld_remove_obstacle_55, METH_O, (const char *)Dtool_AIWorld_remove_obstacle_55_comment},
  {"removeObstacle", &Dtool_AIWorld_remove_obstacle_55, METH_O, (const char *)Dtool_AIWorld_remove_obstacle_55_comment},
  {"print_list", &Dtool_AIWorld_print_list_56, METH_NOARGS, (const char *)Dtool_AIWorld_print_list_56_comment},
  {"printList", &Dtool_AIWorld_print_list_56, METH_NOARGS, (const char *)Dtool_AIWorld_print_list_56_comment},
  {"update", &Dtool_AIWorld_update_57, METH_NOARGS, (const char *)Dtool_AIWorld_update_57_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AIWorld = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_AIWorld = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ai.AIWorld",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AIWorld,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AIWorld,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class that implements the virtual AI world which keeps track of the AI\n"
    " * characters active at any given time.  It contains a linked list of AI\n"
    " * characters, obstactle data and unique name for each character.  It also\n"
    " * updates each characters state.  The AI characters can also be added to the\n"
    " * world as flocks.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AIWorld,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AIWorld,
    PyType_GenericAlloc,
    Dtool_new_AIWorld,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AIWorld,
  Dtool_UpcastInterface_AIWorld,
  Dtool_DowncastInterface_AIWorld,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AIWorld(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AIWorld._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AIWorld._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AIWorld) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AIWorld)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AIWorld);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libpandaai_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libpandaai_BuildInstants(PyObject *module) {
  (void) module;
  // AICharacter
  Dtool_PyModuleClassInit_AICharacter(module);
  PyModule_AddObject(module, "AICharacter", (PyObject *)&Dtool_AICharacter);
  // AIBehaviors
  Dtool_PyModuleClassInit_AIBehaviors(module);
  PyModule_AddObject(module, "AIBehaviors", (PyObject *)&Dtool_AIBehaviors);
  // AINode
  Dtool_PyModuleClassInit_AINode(module);
  PyModule_AddObject(module, "AINode", (PyObject *)&Dtool_AINode);
  // Flock
  Dtool_PyModuleClassInit_Flock(module);
  PyModule_AddObject(module, "Flock", (PyObject *)&Dtool_Flock);
  // AIWorld
  Dtool_PyModuleClassInit_AIWorld(module);
  PyModule_AddObject(module, "AIWorld", (PyObject *)&Dtool_AIWorld);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libpandaai_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libpandaai_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583615428,  /* file_identifier */
  "libpandaai",  /* library_name */
  "s1eG",  /* library_hash_name */
  "panda3d.ai",  /* module_name */
  "libpandaai.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  139  /* next_index */
};

Configure(_in_configure_libpandaai);
ConfigureFn(_in_configure_libpandaai) {
  interrogate_request_module(&_in_module_def);
}

