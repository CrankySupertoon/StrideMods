/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/char -Ipanda/src/char -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3char_igate.cxx -od built/pandac/input/libp3char.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/char -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3char character.h characterJoint.h characterJointBundle.h characterJointEffect.h characterSlider.h characterVertexSlider.h config_char.h jointVertexTransform.h p3char_composite1.cxx p3char_composite2.cxx
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "character.h"
#include "characterJoint.h"
#include "characterJointBundle.h"
#include "characterJointEffect.h"
#include "characterSlider.h"
#include "characterVertexSlider.h"
#include "configVariableBool.h"
#include "config_char.h"
#include "geom.h"
#include "jointVertexTransform.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pandabase.h"
#include "partBundleNode.h"
#include "pointerTo.h"
#include "renderEffect.h"
#include "sliderTable.h"
#include "transformBlendTable.h"
#include "transformTable.h"
#include "vector_PartGroupStar.h"
#include "weakPointerTo.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CharacterJoint
 */
typedef CharacterJoint CharacterJoint_localtype;
Define_Module_ClassRef(panda3d.core, CharacterJoint, CharacterJoint_localtype, CharacterJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterJoint = &Dtool_CharacterJoint;
static void Dtool_PyModuleClassInit_CharacterJoint(PyObject *module);

/**
 * Forward declarations for top-level class CharacterSlider
 */
typedef CharacterSlider CharacterSlider_localtype;
Define_Module_ClassRef(panda3d.core, CharacterSlider, CharacterSlider_localtype, CharacterSlider);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterSlider = &Dtool_CharacterSlider;
static void Dtool_PyModuleClassInit_CharacterSlider(PyObject *module);

/**
 * Forward declarations for top-level class CharacterVertexSlider
 */
typedef CharacterVertexSlider CharacterVertexSlider_localtype;
Define_Module_ClassRef(panda3d.core, CharacterVertexSlider, CharacterVertexSlider_localtype, CharacterVertexSlider);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterVertexSlider = &Dtool_CharacterVertexSlider;
static void Dtool_PyModuleClassInit_CharacterVertexSlider(PyObject *module);
bool Dtool_ConstCoerce_CharacterVertexSlider(PyObject *args, CPT(CharacterVertexSlider) &coerced);
bool Dtool_Coerce_CharacterVertexSlider(PyObject *args, PT(CharacterVertexSlider) &coerced);

/**
 * Forward declarations for top-level class JointVertexTransform
 */
typedef JointVertexTransform JointVertexTransform_localtype;
Define_Module_ClassRef(panda3d.core, JointVertexTransform, JointVertexTransform_localtype, JointVertexTransform);
static struct Dtool_PyTypedObject *const Dtool_Ptr_JointVertexTransform = &Dtool_JointVertexTransform;
static void Dtool_PyModuleClassInit_JointVertexTransform(PyObject *module);
bool Dtool_ConstCoerce_JointVertexTransform(PyObject *args, CPT(JointVertexTransform) &coerced);
bool Dtool_Coerce_JointVertexTransform(PyObject *args, PT(JointVertexTransform) &coerced);

/**
 * Forward declarations for top-level class Character
 */
typedef Character Character_localtype;
Define_Module_ClassRef(panda3d.core, Character, Character_localtype, Character);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Character = &Dtool_Character;
static void Dtool_PyModuleClassInit_Character(PyObject *module);

/**
 * Forward declarations for top-level class CharacterJointBundle
 */
typedef CharacterJointBundle CharacterJointBundle_localtype;
Define_Module_ClassRef(panda3d.core, CharacterJointBundle, CharacterJointBundle_localtype, CharacterJointBundle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterJointBundle = &Dtool_CharacterJointBundle;
static void Dtool_PyModuleClassInit_CharacterJointBundle(PyObject *module);

/**
 * Forward declarations for top-level class CharacterJointEffect
 */
typedef CharacterJointEffect CharacterJointEffect_localtype;
Define_Module_ClassRef(panda3d.core, CharacterJointEffect, CharacterJointEffect_localtype, CharacterJointEffect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CharacterJointEffect = &Dtool_CharacterJointEffect;
static void Dtool_PyModuleClassInit_CharacterJointEffect(PyObject *module);
bool Dtool_ConstCoerce_CharacterJointEffect(PyObject *args, CPT(CharacterJointEffect) &coerced);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"CharacterJoint", &Dtool_CharacterJoint},
  {"CharacterSlider", &Dtool_CharacterSlider},
  {"CharacterVertexSlider", &Dtool_CharacterVertexSlider},
  {"JointVertexTransform", &Dtool_JointVertexTransform},
  {"Character", &Dtool_Character},
  {"CharacterJointBundle", &Dtool_CharacterJointBundle},
  {"CharacterJointEffect", &Dtool_CharacterJointEffect},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[5].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[6].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[7].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[8].type)
  {"TransformState", nullptr},
#define Dtool_Ptr_TransformState (imports[9].type)
  {"PartGroup", nullptr},
#define Dtool_Ptr_PartGroup (imports[10].type)
  {"VertexTransform", nullptr},
#define Dtool_Ptr_VertexTransform (imports[11].type)
  {"VertexSlider", nullptr},
#define Dtool_Ptr_VertexSlider (imports[12].type)
  {"RenderEffect", nullptr},
#define Dtool_Ptr_RenderEffect (imports[13].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[14].type)
  {"PartBundle", nullptr},
#define Dtool_Ptr_PartBundle (imports[15].type)
  {"MovingPartBase", nullptr},
#define Dtool_Ptr_MovingPartBase (imports[16].type)
  {"MovingPartMatrix", nullptr},
#define Dtool_Ptr_MovingPartMatrix (imports[17].type)
  {"MovingPart< ACMatrixSwitchType >", nullptr},
#define Dtool_Ptr_MovingPart_ACMatrixSwitchType (imports[18].type)
  {"NodePathCollection", nullptr},
#define Dtool_Ptr_NodePathCollection (imports[19].type)
  {"MovingPartScalar", nullptr},
#define Dtool_Ptr_MovingPartScalar (imports[20].type)
  {"MovingPart< ACScalarSwitchType >", nullptr},
#define Dtool_Ptr_MovingPart_ACScalarSwitchType (imports[21].type)
  {"PartBundleHandle", nullptr},
#define Dtool_Ptr_PartBundleHandle (imports[22].type)
  {"PartBundleNode", nullptr},
#define Dtool_Ptr_PartBundleNode (imports[23].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// TransformState
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// PartGroup
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PartGroup;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartGroup = &Dtool_PartGroup;
#endif
// VertexTransform
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_VertexTransform;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexTransform = &Dtool_VertexTransform;
#endif
// VertexSlider
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_VertexSlider;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexSlider = &Dtool_VertexSlider;
#endif
// RenderEffect
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_RenderEffect;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderEffect = &Dtool_RenderEffect;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// PartBundle
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PartBundle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundle = &Dtool_PartBundle;
#endif
// MovingPartBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_MovingPartBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartBase = &Dtool_MovingPartBase;
#endif
// MovingPartMatrix
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_MovingPartMatrix;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartMatrix = &Dtool_MovingPartMatrix;
#endif
// MovingPart< ACMatrixSwitchType >
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_MovingPart_ACMatrixSwitchType;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACMatrixSwitchType = &Dtool_MovingPart_ACMatrixSwitchType;
#endif
// NodePathCollection
#ifndef LINK_ALL_STATIC
inline static NodePathCollection *Dtool_Coerce_NodePathCollection(PyObject *args, NodePathCollection &coerced) {
  nassertr(Dtool_Ptr_NodePathCollection != nullptr, nullptr);
  nassertr(Dtool_Ptr_NodePathCollection->_Dtool_Coerce != nullptr, nullptr);
  return ((NodePathCollection *(*)(PyObject *, NodePathCollection &))Dtool_Ptr_NodePathCollection->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_NodePathCollection;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePathCollection = &Dtool_NodePathCollection;
extern NodePathCollection *Dtool_Coerce_NodePathCollection(PyObject *args, NodePathCollection &coerced);
#endif
// MovingPartScalar
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_MovingPartScalar;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartScalar = &Dtool_MovingPartScalar;
#endif
// MovingPart< ACScalarSwitchType >
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_MovingPart_ACScalarSwitchType;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACScalarSwitchType = &Dtool_MovingPart_ACScalarSwitchType;
#endif
// PartBundleHandle
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced) {
  nassertr(Dtool_Ptr_PartBundleHandle != nullptr, false);
  nassertr(Dtool_Ptr_PartBundleHandle->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(PartBundleHandle) &))Dtool_Ptr_PartBundleHandle->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced) {
  nassertr(Dtool_Ptr_PartBundleHandle != nullptr, false);
  nassertr(Dtool_Ptr_PartBundleHandle->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(PartBundleHandle) &))Dtool_Ptr_PartBundleHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PartBundleHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleHandle = &Dtool_PartBundleHandle;
extern bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced);
extern bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced);
#endif
// PartBundleNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PartBundleNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleNode = &Dtool_PartBundleNode;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CharacterJoint
 */
/**
 * Python function wrapper for:
 * bool CharacterJoint::add_net_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_add_net_transform_4(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.add_net_transform")) {
    return nullptr;
  }
  // 1-bool CharacterJoint::add_net_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.add_net_transform", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).add_net_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_net_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_add_net_transform_4_comment =
  "C++ Interface:\n"
  "add_net_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds the indicated node to the list of nodes that will be updated each\n"
  " * frame with the joint's net transform from the root.  Returns true if the\n"
  " * node is successfully added, false if it had already been added.\n"
  " *\n"
  " * A CharacterJointEffect for this joint's Character will automatically be\n"
  " * added to the specified node.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_add_net_transform_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::remove_net_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_remove_net_transform_5(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.remove_net_transform")) {
    return nullptr;
  }
  // 1-bool CharacterJoint::remove_net_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.remove_net_transform", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_net_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_net_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_remove_net_transform_5_comment =
  "C++ Interface:\n"
  "remove_net_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Removes the indicated node from the list of nodes that will be updated each\n"
  " * frame with the joint's net transform from the root.  Returns true if the\n"
  " * node is successfully removed, false if it was not on the list.\n"
  " *\n"
  " * If the node has a CharacterJointEffect that matches this joint's Character,\n"
  " * it will be cleared.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_remove_net_transform_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::has_net_transform(PandaNode *node) const
 */
static PyObject *Dtool_CharacterJoint_has_net_transform_6(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJoint)) {
    return nullptr;
  }
  // 1-bool CharacterJoint::has_net_transform(PandaNode *node) const
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.has_net_transform", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const CharacterJoint*)local_this).has_net_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_net_transform(CharacterJoint self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_has_net_transform_6_comment =
  "C++ Interface:\n"
  "has_net_transform(CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Returns true if the node is on the list of nodes that will be updated each\n"
  " * frame with the joint's net transform from the root, false otherwise.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_has_net_transform_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CharacterJoint::clear_net_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_clear_net_transforms_7(PyObject *self, PyObject *) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.clear_net_transforms")) {
    return nullptr;
  }
  // 1-void CharacterJoint::clear_net_transforms(void)
  ((*local_this).clear_net_transforms)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_clear_net_transforms_7_comment =
  "C++ Interface:\n"
  "clear_net_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Removes all nodes from the list of nodes that will be updated each frame\n"
  " * with the joint's net transform from the root.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_clear_net_transforms_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection CharacterJoint::get_net_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_get_net_transforms_8(PyObject *self, PyObject *) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.get_net_transforms")) {
    return nullptr;
  }
  // 1-NodePathCollection CharacterJoint::get_net_transforms(void)
  NodePathCollection *return_value = new NodePathCollection(((*local_this).get_net_transforms)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_net_transforms_8_comment =
  "C++ Interface:\n"
  "get_net_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Returns a list of the net transforms set for this node.  Note that this\n"
  " * returns a list of NodePaths, even though the net transforms are actually a\n"
  " * list of PandaNodes.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_net_transforms_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::add_local_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_add_local_transform_9(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.add_local_transform")) {
    return nullptr;
  }
  // 1-bool CharacterJoint::add_local_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.add_local_transform", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).add_local_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_add_local_transform_9_comment =
  "C++ Interface:\n"
  "add_local_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Adds the indicated node to the list of nodes that will be updated each\n"
  " * frame with the joint's local transform from its parent.  Returns true if\n"
  " * the node is successfully added, false if it had already been added.\n"
  " *\n"
  " * The Character pointer should be the Character object that owns this joint;\n"
  " * this will be used to create a CharacterJointEffect for this node.  If it is\n"
  " * NULL, no such effect will be created.\n"
  " *\n"
  " * A CharacterJointEffect for this joint's Character will automatically be\n"
  " * added to the specified node.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_add_local_transform_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::remove_local_transform(PandaNode *node)
 */
static PyObject *Dtool_CharacterJoint_remove_local_transform_10(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.remove_local_transform")) {
    return nullptr;
  }
  // 1-bool CharacterJoint::remove_local_transform(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.remove_local_transform", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_local_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_local_transform(const CharacterJoint self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_remove_local_transform_10_comment =
  "C++ Interface:\n"
  "remove_local_transform(const CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Removes the indicated node from the list of nodes that will be updated each\n"
  " * frame with the joint's local transform from its parent.  Returns true if\n"
  " * the node is successfully removed, false if it was not on the list.\n"
  " *\n"
  " * If the node has a CharacterJointEffect that matches this joint's Character,\n"
  " * it will be cleared.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_remove_local_transform_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CharacterJoint::has_local_transform(PandaNode *node) const
 */
static PyObject *Dtool_CharacterJoint_has_local_transform_11(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJoint)) {
    return nullptr;
  }
  // 1-bool CharacterJoint::has_local_transform(PandaNode *node) const
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "CharacterJoint.has_local_transform", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const CharacterJoint*)local_this).has_local_transform)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_local_transform(CharacterJoint self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_has_local_transform_11_comment =
  "C++ Interface:\n"
  "has_local_transform(CharacterJoint self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Returns true if the node is on the list of nodes that will be updated each\n"
  " * frame with the joint's local transform from its parent, false otherwise.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_has_local_transform_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CharacterJoint::clear_local_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_clear_local_transforms_12(PyObject *self, PyObject *) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.clear_local_transforms")) {
    return nullptr;
  }
  // 1-void CharacterJoint::clear_local_transforms(void)
  ((*local_this).clear_local_transforms)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_clear_local_transforms_12_comment =
  "C++ Interface:\n"
  "clear_local_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Removes all nodes from the list of nodes that will be updated each frame\n"
  " * with the joint's local transform from its parent.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_clear_local_transforms_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePathCollection CharacterJoint::get_local_transforms(void)
 */
static PyObject *Dtool_CharacterJoint_get_local_transforms_13(PyObject *self, PyObject *) {
  CharacterJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CharacterJoint, (void **)&local_this, "CharacterJoint.get_local_transforms")) {
    return nullptr;
  }
  // 1-NodePathCollection CharacterJoint::get_local_transforms(void)
  NodePathCollection *return_value = new NodePathCollection(((*local_this).get_local_transforms)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePathCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_local_transforms_13_comment =
  "C++ Interface:\n"
  "get_local_transforms(const CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Returns a list of the local transforms set for this node.  Note that this\n"
  " * returns a list of NodePaths, even though the local transforms are actually\n"
  " * a list of PandaNodes.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_local_transforms_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &CharacterJoint::get_transform(void) const
 * void CharacterJoint::get_transform(LMatrix4 &transform) const
 */
static PyObject *Dtool_CharacterJoint_get_transform_14(PyObject *self, PyObject *args) {
  CharacterJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJoint)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LMatrix4 const &CharacterJoint::get_transform(void) const
      LMatrix4 const *return_value = &(((*(const CharacterJoint*)local_this).get_transform)());
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void CharacterJoint::get_transform(LMatrix4 &transform) const
      LMatrix4f arg_local;
      LMatrix4 *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "CharacterJoint.get_transform", "LMatrix4f");
      }
      ((*(const CharacterJoint*)local_this).get_transform)(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_transform() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_transform(CharacterJoint self)\n"
      "get_transform(CharacterJoint self, LMatrix4f transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_transform_14_comment =
  "C++ Interface:\n"
  "get_transform(CharacterJoint self)\n"
  "get_transform(CharacterJoint self, LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Returns the transform matrix of the joint\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the joint's current transform into the indicated matrix.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_transform_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< TransformState > CharacterJoint::get_transform_state(void) const
 */
static PyObject *Dtool_CharacterJoint_get_transform_state_15(PyObject *self, PyObject *) {
  CharacterJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJoint)) {
    return nullptr;
  }
  // 1-ConstPointerTo< TransformState > CharacterJoint::get_transform_state(void) const
  ConstPointerTo< TransformState > return_value = ((*(const CharacterJoint*)local_this).get_transform_state)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  TransformState const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_transform_state_15_comment =
  "C++ Interface:\n"
  "get_transform_state(CharacterJoint self)\n";
#else
static const char *Dtool_CharacterJoint_get_transform_state_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CharacterJoint::get_net_transform(LMatrix4 &transform) const
 */
static PyObject *Dtool_CharacterJoint_get_net_transform_16(PyObject *self, PyObject *arg) {
  CharacterJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJoint)) {
    return nullptr;
  }
  // 1-void CharacterJoint::get_net_transform(LMatrix4 &transform) const
  LMatrix4f arg_local;
  LMatrix4 *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CharacterJoint.get_net_transform", "LMatrix4f");
  }
  ((*(const CharacterJoint*)local_this).get_net_transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_transform(CharacterJoint self, LMatrix4f transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_net_transform_16_comment =
  "C++ Interface:\n"
  "get_net_transform(CharacterJoint self, LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Copies the joint's current net transform (composed from the root of the\n"
  " * character joint hierarchy) into the indicated matrix.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_net_transform_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Character *CharacterJoint::get_character(void) const
 */
static PyObject *Dtool_CharacterJoint_get_character_17(PyObject *self, PyObject *) {
  CharacterJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJoint)) {
    return nullptr;
  }
  // 1-Character *CharacterJoint::get_character(void) const
  Character *return_value = ((*(const CharacterJoint*)local_this).get_character)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Character, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_character_17_comment =
  "C++ Interface:\n"
  "get_character(CharacterJoint self)\n"
  "\n"
  "/**\n"
  " * Returns the Character that owns this joint.\n"
  " */";
#else
static const char *Dtool_CharacterJoint_get_character_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterJoint::get_class_type(void)
 */
static PyObject *Dtool_CharacterJoint_get_class_type_18(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CharacterJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJoint_get_class_type_18_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterJoint_get_class_type_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, std::string const &name, LMatrix4 const &default_value)
 */
static int Dtool_Init_CharacterJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, std::string const &name, LMatrix4 const &default_value)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  PyObject *param4;
  static const char *keyword_list[] = {"character", "root", "parent", "name", "default_value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOs#O:CharacterJoint", (char **)keyword_list, &param0, &param1, &param2, &param3_str, &param3_len, &param4)) {
    Character *param0_this = (Character *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Character, 0, "CharacterJoint.CharacterJoint", false, true);
    PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundle, 1, "CharacterJoint.CharacterJoint", false, true);
    PartGroup *param2_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PartGroup, 2, "CharacterJoint.CharacterJoint", false, true);
    LMatrix4f param4_local;
    LMatrix4 const *param4_this = Dtool_Coerce_LMatrix4f(param4, param4_local);
    if (!(param4_this != nullptr)) {
      Dtool_Raise_ArgTypeError(param4, 4, "CharacterJoint.CharacterJoint", "LMatrix4f");
      return -1;
    }
    if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
      CharacterJoint *return_value = new CharacterJoint(param0_this, param1_this, param2_this, std::string(param3_str, param3_len), *param4_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterJoint, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterJoint(Character character, PartBundle root, PartGroup parent, str name, const LMatrix4f default_value)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CharacterJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CharacterJoint) {
    printf("CharacterJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CharacterJoint *local_this = (CharacterJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CharacterJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    return (MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartMatrix) {
    return (MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *)(MovingPartMatrix *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CharacterJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CharacterJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    MovingPart< ACMatrixSwitchType >* other_this = (MovingPart< ACMatrixSwitchType >*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartMatrix) {
    MovingPartMatrix* other_this = (MovingPartMatrix*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CharacterSlider
 */
/**
 * Python function wrapper for:
 * static TypeHandle CharacterSlider::get_class_type(void)
 */
static PyObject *Dtool_CharacterSlider_get_class_type_22(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterSlider::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CharacterSlider::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterSlider_get_class_type_22_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterSlider_get_class_type_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &name, PN_stdfloat default_value = 0)
 */
static int Dtool_Init_CharacterSlider(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &name, PN_stdfloat default_value = 0)
  PyObject *param0;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  float param2 = 0;
  static const char *keyword_list[] = {"parent", "name", "default_value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#|f:CharacterSlider", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2)) {
    PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartGroup, 0, "CharacterSlider.CharacterSlider", false, true);
    if (param0_this != nullptr) {
      CharacterSlider *return_value = new CharacterSlider(param0_this, std::string(param1_str, param1_len), (PN_stdfloat)param2);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterSlider, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterSlider(PartGroup parent, str name, float default_value)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CharacterSlider(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CharacterSlider) {
    printf("CharacterSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CharacterSlider *local_this = (CharacterSlider *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CharacterSlider) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    return (MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartScalar) {
    return (MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *)(MovingPartScalar *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CharacterSlider(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CharacterSlider) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    MovingPart< ACScalarSwitchType >* other_this = (MovingPart< ACScalarSwitchType >*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartScalar) {
    MovingPartScalar* other_this = (MovingPartScalar*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterSlider*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CharacterVertexSlider
 */
/**
 * Python function wrapper for:
 * inline CharacterSlider const *CharacterVertexSlider::get_char_slider(void) const
 */
static PyObject *Dtool_CharacterVertexSlider_get_char_slider_26(PyObject *self, PyObject *) {
  CharacterVertexSlider *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterVertexSlider)) {
    return nullptr;
  }
  // 1-inline CharacterSlider const *CharacterVertexSlider::get_char_slider(void) const
  CharacterSlider const *return_value = ((*(const CharacterVertexSlider*)local_this).get_char_slider)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterSlider, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CharacterVertexSlider_get_char_slider_26_comment =
  "C++ Interface:\n"
  "get_char_slider(CharacterVertexSlider self)\n"
  "\n"
  "/**\n"
  " * Returns the CharacterSlider object for which this object returns the slider\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_CharacterVertexSlider_get_char_slider_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterVertexSlider::get_class_type(void)
 */
static PyObject *Dtool_CharacterVertexSlider_get_class_type_27(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterVertexSlider::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CharacterVertexSlider::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterVertexSlider_get_class_type_27_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterVertexSlider_get_class_type_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
 */
static int Dtool_Init_CharacterVertexSlider(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CharacterVertexSlider() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "char_slider")) {
    // 1-CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
    CharacterSlider *arg_this = (CharacterSlider *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterSlider, 0, "CharacterVertexSlider.CharacterVertexSlider", false, true);
    if (arg_this != nullptr) {
      CharacterVertexSlider *return_value = new CharacterVertexSlider(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterVertexSlider, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterVertexSlider(CharacterSlider char_slider)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CharacterVertexSlider(PyObject *args, CPT(CharacterVertexSlider) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CharacterVertexSlider)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
    CharacterSlider *arg_this = (CharacterSlider *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterSlider, 0, "CharacterVertexSlider.CharacterVertexSlider", false, false);
    if (arg_this != nullptr) {
      CharacterVertexSlider *return_value = new CharacterVertexSlider(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_CharacterVertexSlider(PyObject *args, PT(CharacterVertexSlider) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CharacterVertexSlider)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider)
    CharacterSlider *arg_this = (CharacterSlider *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterSlider, 0, "CharacterVertexSlider.CharacterVertexSlider", false, false);
    if (arg_this != nullptr) {
      CharacterVertexSlider *return_value = new CharacterVertexSlider(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CharacterVertexSlider(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CharacterVertexSlider) {
    printf("CharacterVertexSlider ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CharacterVertexSlider *local_this = (CharacterVertexSlider *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CharacterVertexSlider) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(VertexSlider *) local_this;
  }
  if (requested_type == Dtool_Ptr_VertexSlider) {
    return (VertexSlider *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CharacterVertexSlider(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CharacterVertexSlider) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  if (from_type == Dtool_Ptr_VertexSlider) {
    VertexSlider* other_this = (VertexSlider*)from_this;
    return (CharacterVertexSlider*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class JointVertexTransform
 */
/**
 * Python function wrapper for:
 * inline CharacterJoint const *JointVertexTransform::get_joint(void) const
 */
static PyObject *Dtool_JointVertexTransform_get_joint_31(PyObject *self, PyObject *) {
  JointVertexTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_JointVertexTransform)) {
    return nullptr;
  }
  // 1-inline CharacterJoint const *JointVertexTransform::get_joint(void) const
  CharacterJoint const *return_value = ((*(const JointVertexTransform*)local_this).get_joint)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterJoint, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_JointVertexTransform_get_joint_31_comment =
  "C++ Interface:\n"
  "get_joint(JointVertexTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the joint for which this object returns the transform.\n"
  " */";
#else
static const char *Dtool_JointVertexTransform_get_joint_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle JointVertexTransform::get_class_type(void)
 */
static PyObject *Dtool_JointVertexTransform_get_class_type_32(PyObject *, PyObject *) {
  // 1-static TypeHandle JointVertexTransform::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((JointVertexTransform::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_JointVertexTransform_get_class_type_32_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_JointVertexTransform_get_class_type_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
 */
static int Dtool_Init_JointVertexTransform(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "JointVertexTransform() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "joint")) {
    // 1-JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
    CharacterJoint *arg_this = (CharacterJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterJoint, 0, "JointVertexTransform.JointVertexTransform", false, true);
    if (arg_this != nullptr) {
      JointVertexTransform *return_value = new JointVertexTransform(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_JointVertexTransform, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "JointVertexTransform(CharacterJoint joint)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_JointVertexTransform(PyObject *args, CPT(JointVertexTransform) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_JointVertexTransform)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
    CharacterJoint *arg_this = (CharacterJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterJoint, 0, "JointVertexTransform.JointVertexTransform", false, false);
    if (arg_this != nullptr) {
      JointVertexTransform *return_value = new JointVertexTransform(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_JointVertexTransform(PyObject *args, PT(JointVertexTransform) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_JointVertexTransform)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-JointVertexTransform::JointVertexTransform(CharacterJoint *joint)
    CharacterJoint *arg_this = (CharacterJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CharacterJoint, 0, "JointVertexTransform.JointVertexTransform", false, false);
    if (arg_this != nullptr) {
      JointVertexTransform *return_value = new JointVertexTransform(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_JointVertexTransform(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_JointVertexTransform) {
    printf("JointVertexTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  JointVertexTransform *local_this = (JointVertexTransform *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_JointVertexTransform) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(VertexTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_VertexTransform) {
    return (VertexTransform *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_JointVertexTransform(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_JointVertexTransform) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (JointVertexTransform*)other_this;
  }
  if (from_type == Dtool_Ptr_VertexTransform) {
    VertexTransform* other_this = (VertexTransform*)from_this;
    return (JointVertexTransform*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Character
 */
/**
 * Python function wrapper for:
 * inline CharacterJointBundle *Character::get_bundle(int i) const
 */
static PyObject *Dtool_Character_get_bundle_36(PyObject *self, PyObject *arg) {
  Character *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Character)) {
    return nullptr;
  }
  // 1-inline CharacterJointBundle *Character::get_bundle(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CharacterJointBundle *return_value = ((*(const Character*)local_this).get_bundle)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterJointBundle, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle(Character self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Character_get_bundle_36_comment =
  "C++ Interface:\n"
  "get_bundle(Character self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Character_get_bundle_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle)
 */
static PyObject *Dtool_Character_merge_bundles_37(PyObject *self, PyObject *args, PyObject *kwds) {
  Character *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.merge_bundles")) {
    return nullptr;
  }
  // 1-void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"old_bundle_handle", "other_bundle_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:merge_bundles", (char **)keyword_list, &param1, &param2)) {
    PT(PartBundleHandle) param1_this;
    if (!Dtool_Coerce_PartBundleHandle(param1, param1_this)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Character.merge_bundles", "PartBundleHandle");
    }
    PT(PartBundleHandle) param2_this;
    if (!Dtool_Coerce_PartBundleHandle(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Character.merge_bundles", "PartBundleHandle");
    }
    ((*local_this).merge_bundles)(std::move(param1_this), std::move(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge_bundles(const Character self, PartBundleHandle old_bundle_handle, PartBundleHandle other_bundle_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Character_merge_bundles_37_comment =
  "C++ Interface:\n"
  "merge_bundles(const Character self, PartBundleHandle old_bundle_handle, PartBundleHandle other_bundle_handle)\n"
  "\n"
  "/**\n"
  " * Merges old_bundle_handle->get_bundle() with new_bundle.  old_bundle_handle\n"
  " * must be one of the PartBundleHandle within this node.  At the end of this\n"
  " * call, the bundle pointer within the old_bundle_handle will be replaced with\n"
  " * that within the new_bundle_handle pointer, and all geometry within this\n"
  " * node will be updated to reference new_bundle.\n"
  " *\n"
  " * Normally, this is called when the two bundles have the same, or nearly the\n"
  " * same, hierarchies.  In this case, new_bundle will simply be assigned over\n"
  " * the old_bundle position.  However, if any joints are present in one bundle\n"
  " * or the other, new_bundle will be modified to contain the union of all\n"
  " * joints.\n"
  " *\n"
  " * The geometry below this node is also updated to reference new_bundle,\n"
  " * instead of the original old_bundle.\n"
  " *\n"
  " * This method is intended to unify two different models that share a common\n"
  " * skeleton, for instance, different LOD's of the same model.\n"
  " */";
#else
static const char *Dtool_Character_merge_bundles_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::set_lod_animation(LPoint3 const &center, PN_stdfloat far_distance, PN_stdfloat near_distance, PN_stdfloat delay_factor)
 */
static PyObject *Dtool_Character_set_lod_animation_38(PyObject *self, PyObject *args, PyObject *kwds) {
  Character *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.set_lod_animation")) {
    return nullptr;
  }
  // 1-void Character::set_lod_animation(LPoint3 const &center, PN_stdfloat far_distance, PN_stdfloat near_distance, PN_stdfloat delay_factor)
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"center", "far_distance", "near_distance", "delay_factor", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:set_lod_animation", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Character.set_lod_animation", "LPoint3f");
    }
    ((*local_this).set_lod_animation)(*param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_animation(const Character self, const LPoint3f center, float far_distance, float near_distance, float delay_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Character_set_lod_animation_38_comment =
  "C++ Interface:\n"
  "set_lod_animation(const Character self, const LPoint3f center, float far_distance, float near_distance, float delay_factor)\n"
  "\n"
  "/**\n"
  " * Activates a special mode in which the character animates less frequently as\n"
  " * it gets further from the camera.  This is intended as a simple optimization\n"
  " * to minimize the effort of computing animation for lots of characters that\n"
  " * may not necessarily be very important to animate every frame.\n"
  " *\n"
  " * If the character is closer to the camera than near_distance, then it is\n"
  " * animated its normal rate, every frame.  If the character is exactly\n"
  " * far_distance away, it is animated only every delay_factor seconds (which\n"
  " * should be a number greater than 0).  If the character is between\n"
  " * near_distance and far_distance, its animation rate is linearly interpolated\n"
  " * according to its distance between the two.  The interpolation function\n"
  " * continues beyond far_distance, so that the character is animated\n"
  " * increasingly less frequently as it gets farther away.\n"
  " *\n"
  " * The distance calculations are made from center, which is a fixed point\n"
  " * relative to the character node, to the camera's lod center or cull center\n"
  " * node (or to the camera node itself).\n"
  " *\n"
  " * If multiple cameras are viewing the character in any given frame, the\n"
  " * closest one counts.\n"
  " */";
#else
static const char *Dtool_Character_set_lod_animation_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::clear_lod_animation(void)
 */
static PyObject *Dtool_Character_clear_lod_animation_39(PyObject *self, PyObject *) {
  Character *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.clear_lod_animation")) {
    return nullptr;
  }
  // 1-void Character::clear_lod_animation(void)
  ((*local_this).clear_lod_animation)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_clear_lod_animation_39_comment =
  "C++ Interface:\n"
  "clear_lod_animation(const Character self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a recent call to set_lod_animation().  Henceforth, the\n"
  " * character will animate every frame, regardless of its distance from the\n"
  " * camera.\n"
  " */";
#else
static const char *Dtool_Character_clear_lod_animation_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CharacterJoint *Character::find_joint(std::string const &name) const
 */
static PyObject *Dtool_Character_find_joint_40(PyObject *self, PyObject *arg) {
  Character *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Character)) {
    return nullptr;
  }
  // 1-CharacterJoint *Character::find_joint(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    CharacterJoint *return_value = ((*(const Character*)local_this).find_joint)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterJoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_joint(Character self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Character_find_joint_40_comment =
  "C++ Interface:\n"
  "find_joint(Character self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the joint with the given name, if there is such a\n"
  " * joint, or NULL if there is no such joint.  This will not return a pointer\n"
  " * to a slider.\n"
  " */";
#else
static const char *Dtool_Character_find_joint_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CharacterSlider *Character::find_slider(std::string const &name) const
 */
static PyObject *Dtool_Character_find_slider_41(PyObject *self, PyObject *arg) {
  Character *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Character)) {
    return nullptr;
  }
  // 1-CharacterSlider *Character::find_slider(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    CharacterSlider *return_value = ((*(const Character*)local_this).find_slider)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CharacterSlider, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_slider(Character self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Character_find_slider_41_comment =
  "C++ Interface:\n"
  "find_slider(Character self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the slider with the given name, if there is such a\n"
  " * slider, or NULL if there is no such slider.  This will not return a pointer\n"
  " * to a joint.\n"
  " */";
#else
static const char *Dtool_Character_find_slider_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::write_parts(std::ostream &out) const
 */
static PyObject *Dtool_Character_write_parts_42(PyObject *self, PyObject *arg) {
  Character *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Character)) {
    return nullptr;
  }
  // 1-void Character::write_parts(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Character.write_parts", false, true);
  if (arg_this != nullptr) {
    ((*(const Character*)local_this).write_parts)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_parts(Character self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Character_write_parts_42_comment =
  "C++ Interface:\n"
  "write_parts(Character self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a list of the Character's joints and sliders, in their hierchical\n"
  " * structure, to the indicated output stream.\n"
  " */";
#else
static const char *Dtool_Character_write_parts_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::write_part_values(std::ostream &out) const
 */
static PyObject *Dtool_Character_write_part_values_43(PyObject *self, PyObject *arg) {
  Character *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Character)) {
    return nullptr;
  }
  // 1-void Character::write_part_values(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Character.write_part_values", false, true);
  if (arg_this != nullptr) {
    ((*(const Character*)local_this).write_part_values)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_part_values(Character self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Character_write_part_values_43_comment =
  "C++ Interface:\n"
  "write_part_values(Character self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a list of the Character's joints and sliders, along with each\n"
  " * current position, in their hierchical structure, to the indicated output\n"
  " * stream.\n"
  " */";
#else
static const char *Dtool_Character_write_part_values_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::update_to_now(void)
 */
static PyObject *Dtool_Character_update_to_now_44(PyObject *self, PyObject *) {
  Character *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.update_to_now")) {
    return nullptr;
  }
  // 1-void Character::update_to_now(void)
  ((*local_this).update_to_now)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_update_to_now_44_comment =
  "C++ Interface:\n"
  "update_to_now(const Character self)\n"
  "\n"
  "/**\n"
  " * Advances the character's frame to the current time, and then calls\n"
  " * update().  This can be used by show code to force an update of the\n"
  " * character's position to the current frame, regardless of whether the\n"
  " * character is currently onscreen and animating.\n"
  " *\n"
  " * @deprecated Call update() instead.\n"
  " */";
#else
static const char *Dtool_Character_update_to_now_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::update(void)
 */
static PyObject *Dtool_Character_update_45(PyObject *self, PyObject *) {
  Character *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.update")) {
    return nullptr;
  }
  // 1-void Character::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_update_45_comment =
  "C++ Interface:\n"
  "update(const Character self)\n"
  "\n"
  "/**\n"
  " * Recalculates the Character's joints and vertices for the current frame.\n"
  " * Normally this is performed automatically during the render and need not be\n"
  " * called explicitly.\n"
  " */";
#else
static const char *Dtool_Character_update_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Character::force_update(void)
 */
static PyObject *Dtool_Character_force_update_46(PyObject *self, PyObject *) {
  Character *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Character, (void **)&local_this, "Character.force_update")) {
    return nullptr;
  }
  // 1-void Character::force_update(void)
  ((*local_this).force_update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Character_force_update_46_comment =
  "C++ Interface:\n"
  "force_update(const Character self)\n"
  "\n"
  "/**\n"
  " * Recalculates the character even if we think it doesn't need it.\n"
  " */";
#else
static const char *Dtool_Character_force_update_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Character::get_class_type(void)
 */
static PyObject *Dtool_Character_get_class_type_47(PyObject *, PyObject *) {
  // 1-static TypeHandle Character::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Character::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Character_get_class_type_47_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Character_get_class_type_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Character::Character(Character const &) = default
 * explicit Character::Character(std::string const &name)
 */
static int Dtool_Init_Character(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Character() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline Character::Character(Character const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      Character const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Character);
      if (param0_this != nullptr) {
        Character *return_value = new Character(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Character, true, false);
      }
    }
  }

  {
    // -2 explicit Character::Character(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Character", (char **)keyword_list, &param0_str, &param0_len)) {
      Character *return_value = new Character(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Character, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline Character::Character(Character const &) = default
  // No coercion possible: explicit Character::Character(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Character(const Character param0)\n"
      "Character(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Character(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Character) {
    printf("Character ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Character *local_this = (Character *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Character) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartBundleNode) {
    return (PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PartBundleNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Character(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Character) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_PartBundleNode) {
    PartBundleNode* other_this = (PartBundleNode*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (Character*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (Character*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CharacterJointBundle
 */
/**
 * Python function wrapper for:
 * inline Character *CharacterJointBundle::get_node(int n) const
 */
static PyObject *Dtool_CharacterJointBundle_get_node_51(PyObject *self, PyObject *arg) {
  CharacterJointBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJointBundle)) {
    return nullptr;
  }
  // 1-inline Character *CharacterJointBundle::get_node(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Character *return_value = ((*(const CharacterJointBundle*)local_this).get_node)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Character, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(CharacterJointBundle self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointBundle_get_node_51_comment =
  "C++ Interface:\n"
  "get_node(CharacterJointBundle self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth Character associated with this PartBundle.\n"
  " */";
#else
static const char *Dtool_CharacterJointBundle_get_node_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterJointBundle::get_class_type(void)
 */
static PyObject *Dtool_CharacterJointBundle_get_class_type_52(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterJointBundle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CharacterJointBundle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointBundle_get_class_type_52_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterJointBundle_get_class_type_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit CharacterJointBundle::CharacterJointBundle(std::string const &name = "")
 */
static int Dtool_Init_CharacterJointBundle(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit CharacterJointBundle::CharacterJointBundle(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:CharacterJointBundle", (char **)keyword_list, &param0_str, &param0_len)) {
    CharacterJointBundle *return_value = new CharacterJointBundle(std::string(param0_str, param0_len));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CharacterJointBundle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CharacterJointBundle(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CharacterJointBundle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CharacterJointBundle) {
    printf("CharacterJointBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CharacterJointBundle *local_this = (CharacterJointBundle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CharacterJointBundle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartBundle) {
    return (PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(PartBundle *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CharacterJointBundle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CharacterJointBundle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_PartBundle) {
    PartBundle* other_this = (PartBundle*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterJointBundle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CharacterJointEffect
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
 */
static PyObject *Dtool_CharacterJointEffect_make_55(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
  Character *arg_this = (Character *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Character, 0, "CharacterJointEffect.make", false, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderEffect > return_value = (CharacterJointEffect::make)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderEffect const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderEffect, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(Character character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointEffect_make_55_comment =
  "C++ Interface:\n"
  "make(Character character)\n"
  "\n"
  "/**\n"
  " * Constructs a new CharacterJointEffect object that references the indicated\n"
  " * character.  When a relative get_transform() is called on the node that\n"
  " * contains the CharacterJointEffect, it will implicitly call\n"
  " * character->update() first.\n"
  " */";
#else
static const char *Dtool_CharacterJointEffect_make_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Character > CharacterJointEffect::get_character(void) const
 */
static PyObject *Dtool_CharacterJointEffect_get_character_56(PyObject *self, PyObject *) {
  CharacterJointEffect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CharacterJointEffect)) {
    return nullptr;
  }
  // 1-inline PointerTo< Character > CharacterJointEffect::get_character(void) const
  PointerTo< Character > return_value = ((*(const CharacterJointEffect*)local_this).get_character)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Character *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Character, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointEffect_get_character_56_comment =
  "C++ Interface:\n"
  "get_character(CharacterJointEffect self)\n"
  "\n"
  "/**\n"
  " * Returns the Character that will get update() called on it when this node's\n"
  " * relative transform is queried, or NULL if there is no such character.\n"
  " */";
#else
static const char *Dtool_CharacterJointEffect_get_character_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CharacterJointEffect::get_class_type(void)
 */
static PyObject *Dtool_CharacterJointEffect_get_class_type_57(PyObject *, PyObject *) {
  // 1-static TypeHandle CharacterJointEffect::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CharacterJointEffect::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CharacterJointEffect_get_class_type_57_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CharacterJointEffect_get_class_type_57_comment = nullptr;
#endif

static int Dtool_Init_CharacterJointEffect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_CharacterJointEffect(PyObject *args, CPT(CharacterJointEffect) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CharacterJointEffect)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderEffect > CharacterJointEffect::make(Character *character)
    Character *arg_this = (Character *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Character, 0, "CharacterJointEffect.make", false, false);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderEffect > return_value = (CharacterJointEffect::make)(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((CharacterJointEffect const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CharacterJointEffect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CharacterJointEffect) {
    printf("CharacterJointEffect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CharacterJointEffect *local_this = (CharacterJointEffect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CharacterJointEffect) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderEffect) {
    return (RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderEffect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CharacterJointEffect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CharacterJointEffect) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderEffect) {
    RenderEffect* other_this = (RenderEffect*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CharacterJointEffect*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for CharacterJoint (CharacterJoint)
 */
static PyMethodDef Dtool_Methods_CharacterJoint[] = {
  {"add_net_transform", &Dtool_CharacterJoint_add_net_transform_4, METH_O, (const char *)Dtool_CharacterJoint_add_net_transform_4_comment},
  {"addNetTransform", &Dtool_CharacterJoint_add_net_transform_4, METH_O, (const char *)Dtool_CharacterJoint_add_net_transform_4_comment},
  {"remove_net_transform", &Dtool_CharacterJoint_remove_net_transform_5, METH_O, (const char *)Dtool_CharacterJoint_remove_net_transform_5_comment},
  {"removeNetTransform", &Dtool_CharacterJoint_remove_net_transform_5, METH_O, (const char *)Dtool_CharacterJoint_remove_net_transform_5_comment},
  {"has_net_transform", &Dtool_CharacterJoint_has_net_transform_6, METH_O, (const char *)Dtool_CharacterJoint_has_net_transform_6_comment},
  {"hasNetTransform", &Dtool_CharacterJoint_has_net_transform_6, METH_O, (const char *)Dtool_CharacterJoint_has_net_transform_6_comment},
  {"clear_net_transforms", &Dtool_CharacterJoint_clear_net_transforms_7, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_net_transforms_7_comment},
  {"clearNetTransforms", &Dtool_CharacterJoint_clear_net_transforms_7, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_net_transforms_7_comment},
  {"get_net_transforms", &Dtool_CharacterJoint_get_net_transforms_8, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_net_transforms_8_comment},
  {"getNetTransforms", &Dtool_CharacterJoint_get_net_transforms_8, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_net_transforms_8_comment},
  {"add_local_transform", &Dtool_CharacterJoint_add_local_transform_9, METH_O, (const char *)Dtool_CharacterJoint_add_local_transform_9_comment},
  {"addLocalTransform", &Dtool_CharacterJoint_add_local_transform_9, METH_O, (const char *)Dtool_CharacterJoint_add_local_transform_9_comment},
  {"remove_local_transform", &Dtool_CharacterJoint_remove_local_transform_10, METH_O, (const char *)Dtool_CharacterJoint_remove_local_transform_10_comment},
  {"removeLocalTransform", &Dtool_CharacterJoint_remove_local_transform_10, METH_O, (const char *)Dtool_CharacterJoint_remove_local_transform_10_comment},
  {"has_local_transform", &Dtool_CharacterJoint_has_local_transform_11, METH_O, (const char *)Dtool_CharacterJoint_has_local_transform_11_comment},
  {"hasLocalTransform", &Dtool_CharacterJoint_has_local_transform_11, METH_O, (const char *)Dtool_CharacterJoint_has_local_transform_11_comment},
  {"clear_local_transforms", &Dtool_CharacterJoint_clear_local_transforms_12, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_local_transforms_12_comment},
  {"clearLocalTransforms", &Dtool_CharacterJoint_clear_local_transforms_12, METH_NOARGS, (const char *)Dtool_CharacterJoint_clear_local_transforms_12_comment},
  {"get_local_transforms", &Dtool_CharacterJoint_get_local_transforms_13, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_local_transforms_13_comment},
  {"getLocalTransforms", &Dtool_CharacterJoint_get_local_transforms_13, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_local_transforms_13_comment},
  {"get_transform", &Dtool_CharacterJoint_get_transform_14, METH_VARARGS, (const char *)Dtool_CharacterJoint_get_transform_14_comment},
  {"getTransform", &Dtool_CharacterJoint_get_transform_14, METH_VARARGS, (const char *)Dtool_CharacterJoint_get_transform_14_comment},
  {"get_transform_state", &Dtool_CharacterJoint_get_transform_state_15, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_transform_state_15_comment},
  {"getTransformState", &Dtool_CharacterJoint_get_transform_state_15, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_transform_state_15_comment},
  {"get_net_transform", &Dtool_CharacterJoint_get_net_transform_16, METH_O, (const char *)Dtool_CharacterJoint_get_net_transform_16_comment},
  {"getNetTransform", &Dtool_CharacterJoint_get_net_transform_16, METH_O, (const char *)Dtool_CharacterJoint_get_net_transform_16_comment},
  {"get_character", &Dtool_CharacterJoint_get_character_17, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_character_17_comment},
  {"getCharacter", &Dtool_CharacterJoint_get_character_17, METH_NOARGS, (const char *)Dtool_CharacterJoint_get_character_17_comment},
  {"get_class_type", &Dtool_CharacterJoint_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJoint_get_class_type_18_comment},
  {"getClassType", &Dtool_CharacterJoint_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJoint_get_class_type_18_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CharacterJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CharacterJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CharacterJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CharacterJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CharacterJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CharacterJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CharacterJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CharacterJoint,
    &Dtool_SequenceMethods_CharacterJoint,
    &Dtool_MappingMethods_CharacterJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CharacterJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents one joint of the character's animation, containing an\n"
    " * animating transform matrix.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CharacterJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CharacterJoint,
    PyType_GenericAlloc,
    Dtool_new_CharacterJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterJoint,
  Dtool_UpcastInterface_CharacterJoint,
  Dtool_DowncastInterface_CharacterJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CharacterJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_MovingPartMatrix != nullptr);
    assert(Dtool_Ptr_MovingPartMatrix->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_MovingPartMatrix->_Dtool_ModuleClassInit(nullptr);
    Dtool_CharacterJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_MovingPartMatrix);
    Dtool_CharacterJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CharacterJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterJoint);
  }
}

/**
 * Python method tables for CharacterSlider (CharacterSlider)
 */
static PyMethodDef Dtool_Methods_CharacterSlider[] = {
  {"get_class_type", &Dtool_CharacterSlider_get_class_type_22, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterSlider_get_class_type_22_comment},
  {"getClassType", &Dtool_CharacterSlider_get_class_type_22, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterSlider_get_class_type_22_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CharacterSlider = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterSlider = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CharacterSlider = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CharacterSlider = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CharacterSlider = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CharacterSlider = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CharacterSlider",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterSlider,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CharacterSlider,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CharacterSlider,
    &Dtool_SequenceMethods_CharacterSlider,
    &Dtool_MappingMethods_CharacterSlider,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CharacterSlider,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a morph slider within the character.  It's simply a single\n"
    " * floating-point value that animates generally between 0 and 1, that controls\n"
    " * the effects of one or more morphs within the character.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CharacterSlider,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CharacterSlider,
    PyType_GenericAlloc,
    Dtool_new_CharacterSlider,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterSlider,
  Dtool_UpcastInterface_CharacterSlider,
  Dtool_DowncastInterface_CharacterSlider,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CharacterSlider(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_MovingPartScalar != nullptr);
    assert(Dtool_Ptr_MovingPartScalar->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_MovingPartScalar->_Dtool_ModuleClassInit(nullptr);
    Dtool_CharacterSlider._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_MovingPartScalar);
    Dtool_CharacterSlider._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CharacterSlider._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterSlider) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterSlider)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterSlider);
  }
}

/**
 * Python method tables for CharacterVertexSlider (CharacterVertexSlider)
 */
static PyMethodDef Dtool_Methods_CharacterVertexSlider[] = {
  {"get_char_slider", &Dtool_CharacterVertexSlider_get_char_slider_26, METH_NOARGS, (const char *)Dtool_CharacterVertexSlider_get_char_slider_26_comment},
  {"getCharSlider", &Dtool_CharacterVertexSlider_get_char_slider_26, METH_NOARGS, (const char *)Dtool_CharacterVertexSlider_get_char_slider_26_comment},
  {"get_class_type", &Dtool_CharacterVertexSlider_get_class_type_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterVertexSlider_get_class_type_27_comment},
  {"getClassType", &Dtool_CharacterVertexSlider_get_class_type_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterVertexSlider_get_class_type_27_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CharacterVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CharacterVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CharacterVertexSlider = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CharacterVertexSlider = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CharacterVertexSlider = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CharacterVertexSlider",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterVertexSlider,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CharacterVertexSlider,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CharacterVertexSlider,
    &Dtool_SequenceMethods_CharacterVertexSlider,
    &Dtool_MappingMethods_CharacterVertexSlider,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CharacterVertexSlider,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on VertexSlider that returns the slider value\n"
    " * associated with a particular CharacterSlider object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CharacterVertexSlider,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CharacterVertexSlider,
    PyType_GenericAlloc,
    Dtool_new_CharacterVertexSlider,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterVertexSlider,
  Dtool_UpcastInterface_CharacterVertexSlider,
  Dtool_DowncastInterface_CharacterVertexSlider,
  (CoerceFunction)Dtool_ConstCoerce_CharacterVertexSlider,
  (CoerceFunction)Dtool_Coerce_CharacterVertexSlider,
};

static void Dtool_PyModuleClassInit_CharacterVertexSlider(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_VertexSlider != nullptr);
    assert(Dtool_Ptr_VertexSlider->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_VertexSlider->_Dtool_ModuleClassInit(nullptr);
    Dtool_CharacterVertexSlider._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_VertexSlider);
    Dtool_CharacterVertexSlider._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CharacterVertexSlider._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterVertexSlider) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterVertexSlider)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterVertexSlider);
  }
}

/**
 * Python method tables for JointVertexTransform (JointVertexTransform)
 */
static PyMethodDef Dtool_Methods_JointVertexTransform[] = {
  {"get_joint", &Dtool_JointVertexTransform_get_joint_31, METH_NOARGS, (const char *)Dtool_JointVertexTransform_get_joint_31_comment},
  {"getJoint", &Dtool_JointVertexTransform_get_joint_31, METH_NOARGS, (const char *)Dtool_JointVertexTransform_get_joint_31_comment},
  {"get_class_type", &Dtool_JointVertexTransform_get_class_type_32, METH_NOARGS | METH_STATIC, (const char *)Dtool_JointVertexTransform_get_class_type_32_comment},
  {"getClassType", &Dtool_JointVertexTransform_get_class_type_32, METH_NOARGS | METH_STATIC, (const char *)Dtool_JointVertexTransform_get_class_type_32_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_JointVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_JointVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_JointVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_JointVertexTransform = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_JointVertexTransform = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_JointVertexTransform = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.JointVertexTransform",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_JointVertexTransform,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_JointVertexTransform,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_JointVertexTransform,
    &Dtool_SequenceMethods_JointVertexTransform,
    &Dtool_MappingMethods_JointVertexTransform,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_JointVertexTransform,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on VertexTransform that returns the transform\n"
    " * necessary to move vertices as if they were assigned to the indicated joint.\n"
    " * The geometry itself should be parented to the scene graph at the level of\n"
    " * the character's root joint; that is, it should not be parented under a node\n"
    " * directly animated by any joints.\n"
    " *\n"
    " * Multiple combinations of these with different weights are used to implement\n"
    " * soft-skinned vertices for an animated character.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_JointVertexTransform,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_JointVertexTransform,
    PyType_GenericAlloc,
    Dtool_new_JointVertexTransform,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_JointVertexTransform,
  Dtool_UpcastInterface_JointVertexTransform,
  Dtool_DowncastInterface_JointVertexTransform,
  (CoerceFunction)Dtool_ConstCoerce_JointVertexTransform,
  (CoerceFunction)Dtool_Coerce_JointVertexTransform,
};

static void Dtool_PyModuleClassInit_JointVertexTransform(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_VertexTransform != nullptr);
    assert(Dtool_Ptr_VertexTransform->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_VertexTransform->_Dtool_ModuleClassInit(nullptr);
    Dtool_JointVertexTransform._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_VertexTransform);
    Dtool_JointVertexTransform._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_JointVertexTransform._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_JointVertexTransform) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(JointVertexTransform)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_JointVertexTransform);
  }
}

/**
 * Python method tables for Character (Character)
 */
static PyMethodDef Dtool_Methods_Character[] = {
  {"get_bundle", &Dtool_Character_get_bundle_36, METH_O, (const char *)Dtool_Character_get_bundle_36_comment},
  {"getBundle", &Dtool_Character_get_bundle_36, METH_O, (const char *)Dtool_Character_get_bundle_36_comment},
  {"merge_bundles", (PyCFunction) &Dtool_Character_merge_bundles_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_merge_bundles_37_comment},
  {"mergeBundles", (PyCFunction) &Dtool_Character_merge_bundles_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_merge_bundles_37_comment},
  {"set_lod_animation", (PyCFunction) &Dtool_Character_set_lod_animation_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_set_lod_animation_38_comment},
  {"setLodAnimation", (PyCFunction) &Dtool_Character_set_lod_animation_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Character_set_lod_animation_38_comment},
  {"clear_lod_animation", &Dtool_Character_clear_lod_animation_39, METH_NOARGS, (const char *)Dtool_Character_clear_lod_animation_39_comment},
  {"clearLodAnimation", &Dtool_Character_clear_lod_animation_39, METH_NOARGS, (const char *)Dtool_Character_clear_lod_animation_39_comment},
  {"find_joint", &Dtool_Character_find_joint_40, METH_O, (const char *)Dtool_Character_find_joint_40_comment},
  {"findJoint", &Dtool_Character_find_joint_40, METH_O, (const char *)Dtool_Character_find_joint_40_comment},
  {"find_slider", &Dtool_Character_find_slider_41, METH_O, (const char *)Dtool_Character_find_slider_41_comment},
  {"findSlider", &Dtool_Character_find_slider_41, METH_O, (const char *)Dtool_Character_find_slider_41_comment},
  {"write_parts", &Dtool_Character_write_parts_42, METH_O, (const char *)Dtool_Character_write_parts_42_comment},
  {"writeParts", &Dtool_Character_write_parts_42, METH_O, (const char *)Dtool_Character_write_parts_42_comment},
  {"write_part_values", &Dtool_Character_write_part_values_43, METH_O, (const char *)Dtool_Character_write_part_values_43_comment},
  {"writePartValues", &Dtool_Character_write_part_values_43, METH_O, (const char *)Dtool_Character_write_part_values_43_comment},
  {"update_to_now", &Dtool_Character_update_to_now_44, METH_NOARGS, (const char *)Dtool_Character_update_to_now_44_comment},
  {"updateToNow", &Dtool_Character_update_to_now_44, METH_NOARGS, (const char *)Dtool_Character_update_to_now_44_comment},
  {"update", &Dtool_Character_update_45, METH_NOARGS, (const char *)Dtool_Character_update_45_comment},
  {"force_update", &Dtool_Character_force_update_46, METH_NOARGS, (const char *)Dtool_Character_force_update_46_comment},
  {"forceUpdate", &Dtool_Character_force_update_46, METH_NOARGS, (const char *)Dtool_Character_force_update_46_comment},
  {"get_class_type", &Dtool_Character_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_Character_get_class_type_47_comment},
  {"getClassType", &Dtool_Character_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_Character_get_class_type_47_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Character = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Character = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Character = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Character = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Character = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Character = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Character",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Character,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Character,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Character,
    &Dtool_SequenceMethods_Character,
    &Dtool_MappingMethods_Character,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Character,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animated character, with skeleton-morph animation and either soft-\n"
    " * skinned or hard-skinned vertices.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Character,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Character,
    PyType_GenericAlloc,
    Dtool_new_Character,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Character,
  Dtool_UpcastInterface_Character,
  Dtool_DowncastInterface_Character,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Character(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PartBundleNode != nullptr);
    assert(Dtool_Ptr_PartBundleNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PartBundleNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_Character._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PartBundleNode);
    Dtool_Character._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Character._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Character) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Character)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Character);
  }
}

/**
 * Python method tables for CharacterJointBundle (CharacterJointBundle)
 */
static PyMethodDef Dtool_Methods_CharacterJointBundle[] = {
  {"get_node", &Dtool_CharacterJointBundle_get_node_51, METH_O, (const char *)Dtool_CharacterJointBundle_get_node_51_comment},
  {"getNode", &Dtool_CharacterJointBundle_get_node_51, METH_O, (const char *)Dtool_CharacterJointBundle_get_node_51_comment},
  {"get_class_type", &Dtool_CharacterJointBundle_get_class_type_52, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointBundle_get_class_type_52_comment},
  {"getClassType", &Dtool_CharacterJointBundle_get_class_type_52, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointBundle_get_class_type_52_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CharacterJointBundle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterJointBundle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CharacterJointBundle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CharacterJointBundle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CharacterJointBundle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CharacterJointBundle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CharacterJointBundle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterJointBundle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CharacterJointBundle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CharacterJointBundle,
    &Dtool_SequenceMethods_CharacterJointBundle,
    &Dtool_MappingMethods_CharacterJointBundle,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CharacterJointBundle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The collection of all the joints and sliders in the character.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CharacterJointBundle,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CharacterJointBundle,
    PyType_GenericAlloc,
    Dtool_new_CharacterJointBundle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterJointBundle,
  Dtool_UpcastInterface_CharacterJointBundle,
  Dtool_DowncastInterface_CharacterJointBundle,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CharacterJointBundle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PartBundle != nullptr);
    assert(Dtool_Ptr_PartBundle->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PartBundle->_Dtool_ModuleClassInit(nullptr);
    Dtool_CharacterJointBundle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PartBundle);
    Dtool_CharacterJointBundle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CharacterJointBundle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterJointBundle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterJointBundle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterJointBundle);
  }
}

/**
 * Python method tables for CharacterJointEffect (CharacterJointEffect)
 */
static PyMethodDef Dtool_Methods_CharacterJointEffect[] = {
  {"make", &Dtool_CharacterJointEffect_make_55, METH_O | METH_STATIC, (const char *)Dtool_CharacterJointEffect_make_55_comment},
  {"get_character", &Dtool_CharacterJointEffect_get_character_56, METH_NOARGS, (const char *)Dtool_CharacterJointEffect_get_character_56_comment},
  {"getCharacter", &Dtool_CharacterJointEffect_get_character_56, METH_NOARGS, (const char *)Dtool_CharacterJointEffect_get_character_56_comment},
  {"get_class_type", &Dtool_CharacterJointEffect_get_class_type_57, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointEffect_get_class_type_57_comment},
  {"getClassType", &Dtool_CharacterJointEffect_get_class_type_57, METH_NOARGS | METH_STATIC, (const char *)Dtool_CharacterJointEffect_get_class_type_57_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CharacterJointEffect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CharacterJointEffect = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CharacterJointEffect = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CharacterJointEffect = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CharacterJointEffect = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CharacterJointEffect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CharacterJointEffect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CharacterJointEffect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CharacterJointEffect,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CharacterJointEffect,
    &Dtool_SequenceMethods_CharacterJointEffect,
    &Dtool_MappingMethods_CharacterJointEffect,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CharacterJointEffect,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This effect will be added automatically to a node by\n"
    " * CharacterJoint::add_net_transform() and\n"
    " * CharacterJoint::add_local_transform().\n"
    " *\n"
    " * The effect binds the node back to the character, so that querying the\n"
    " * relative transform of the affected node will automatically force the\n"
    " * indicated character to be updated first.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CharacterJointEffect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CharacterJointEffect,
    PyType_GenericAlloc,
    Dtool_new_CharacterJointEffect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CharacterJointEffect,
  Dtool_UpcastInterface_CharacterJointEffect,
  Dtool_DowncastInterface_CharacterJointEffect,
  (CoerceFunction)Dtool_ConstCoerce_CharacterJointEffect,
  nullptr,
};

static void Dtool_PyModuleClassInit_CharacterJointEffect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderEffect != nullptr);
    assert(Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderEffect->_Dtool_ModuleClassInit(nullptr);
    Dtool_CharacterJointEffect._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderEffect);
    Dtool_CharacterJointEffect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CharacterJointEffect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CharacterJointEffect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CharacterJointEffect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CharacterJointEffect);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3char_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    CharacterJoint::init_type();
    TypeHandle handle = CharacterJoint::get_class_type();
    Dtool_CharacterJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CharacterJoint);
  }
  {
    CharacterSlider::init_type();
    TypeHandle handle = CharacterSlider::get_class_type();
    Dtool_CharacterSlider._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CharacterSlider);
  }
  {
    CharacterVertexSlider::init_type();
    TypeHandle handle = CharacterVertexSlider::get_class_type();
    Dtool_CharacterVertexSlider._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CharacterVertexSlider);
  }
  {
    JointVertexTransform::init_type();
    TypeHandle handle = JointVertexTransform::get_class_type();
    Dtool_JointVertexTransform._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_JointVertexTransform);
  }
  {
    Character::init_type();
    TypeHandle handle = Character::get_class_type();
    Dtool_Character._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Character);
  }
  {
    CharacterJointBundle::init_type();
    TypeHandle handle = CharacterJointBundle::get_class_type();
    Dtool_CharacterJointBundle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CharacterJointBundle);
  }
  {
    CharacterJointEffect::init_type();
    TypeHandle handle = CharacterJointEffect::get_class_type();
    Dtool_CharacterJointEffect._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CharacterJointEffect);
  }
}

void Dtool_libp3char_BuildInstants(PyObject *module) {
  (void) module;
  // CharacterJoint
  Dtool_PyModuleClassInit_CharacterJoint(module);
  PyModule_AddObject(module, "CharacterJoint", (PyObject *)&Dtool_CharacterJoint);
  // CharacterSlider
  Dtool_PyModuleClassInit_CharacterSlider(module);
  PyModule_AddObject(module, "CharacterSlider", (PyObject *)&Dtool_CharacterSlider);
  // CharacterVertexSlider
  Dtool_PyModuleClassInit_CharacterVertexSlider(module);
  PyModule_AddObject(module, "CharacterVertexSlider", (PyObject *)&Dtool_CharacterVertexSlider);
  // JointVertexTransform
  Dtool_PyModuleClassInit_JointVertexTransform(module);
  PyModule_AddObject(module, "JointVertexTransform", (PyObject *)&Dtool_JointVertexTransform);
  // Character
  Dtool_PyModuleClassInit_Character(module);
  PyModule_AddObject(module, "Character", (PyObject *)&Dtool_Character);
  // CharacterJointBundle
  Dtool_PyModuleClassInit_CharacterJointBundle(module);
  PyModule_AddObject(module, "CharacterJointBundle", (PyObject *)&Dtool_CharacterJointBundle);
  // CharacterJointEffect
  Dtool_PyModuleClassInit_CharacterJointEffect(module);
  PyModule_AddObject(module, "CharacterJointEffect", (PyObject *)&Dtool_CharacterJointEffect);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3char_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3char_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613623,  /* file_identifier */
  "libp3char",  /* library_name */
  "uMZI",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3char.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  157  /* next_index */
};

Configure(_in_configure_libp3char);
ConfigureFn(_in_configure_libp3char) {
  interrogate_request_module(&_in_module_def);
}

