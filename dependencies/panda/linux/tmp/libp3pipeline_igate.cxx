/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/pipeline -Ipanda/src/pipeline -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3pipeline_igate.cxx -od built/pandac/input/libp3pipeline.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pipeline -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3pipeline blockerSimple.h conditionVar.h conditionVarDebug.h conditionVarDirect.h conditionVarDummyImpl.h conditionVarFull.h conditionVarImpl.h conditionVarPosixImpl.h conditionVarSimpleImpl.h conditionVarSpinlockImpl.h conditionVarWin32Impl.h config_pipeline.h contextSwitch.h cycleData.h cycleDataLockedReader.h cycleDataLockedStageReader.h cycleDataReader.h cycleDataStageReader.h cycleDataStageWriter.h cycleDataWriter.h cyclerHolder.h externalThread.h genericThread.h lightMutex.h lightMutexDirect.h lightMutexHolder.h lightReMutex.h lightReMutexDirect.h lightReMutexHolder.h mainThread.h mutexDebug.h mutexDirect.h mutexHolder.h mutexSimpleImpl.h mutexTrueImpl.h p3pipeline_composite1.cxx p3pipeline_composite2.cxx pipeline.h pipelineCycler.h pipelineCyclerBase.h pipelineCyclerDummyImpl.h pipelineCyclerLinks.h pipelineCyclerTrivialImpl.h pipelineCyclerTrueImpl.h pmutex.h pmutex_ext.h psemaphore.h pythonThread.h reMutex.h reMutexDirect.h reMutexHolder.h reMutexSpinlockImpl.h reMutex_ext.h thread.h threadDummyImpl.h threadImpl.h threadPosixImpl.h threadPriority.h threadSimpleImpl.h threadSimpleManager.h threadWin32Impl.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "blockerSimple.h"
#include "conditionVar.h"
#include "conditionVarDebug.h"
#include "conditionVarDirect.h"
#include "conditionVarDummyImpl.h"
#include "conditionVarFull.h"
#include "conditionVarImpl.h"
#include "conditionVarPosixImpl.h"
#include "conditionVarSimpleImpl.h"
#include "conditionVarSpinlockImpl.h"
#include "conditionVarWin32Impl.h"
#include "config_pipeline.h"
#include "contextSwitch.h"
#include "cycleData.h"
#include "cycleDataLockedReader.h"
#include "cycleDataLockedStageReader.h"
#include "cycleDataReader.h"
#include "cycleDataStageReader.h"
#include "cycleDataStageWriter.h"
#include "cycleDataWriter.h"
#include "cyclerHolder.h"
#include "dtoolbase.h"
#include "extension.h"
#include "externalThread.h"
#include "genericThread.h"
#include "lightMutex.h"
#include "lightMutexDirect.h"
#include "lightMutexHolder.h"
#include "lightReMutex.h"
#include "lightReMutexDirect.h"
#include "lightReMutexHolder.h"
#include "mainThread.h"
#include "mutexDebug.h"
#include "mutexDirect.h"
#include "mutexHolder.h"
#include "mutexSimpleImpl.h"
#include "mutexTrueImpl.h"
#include "nodeReferenceCount.h"
#include "pandabase.h"
#include "pipeline.h"
#include "pipelineCycler.h"
#include "pipelineCyclerBase.h"
#include "pipelineCyclerDummyImpl.h"
#include "pipelineCyclerLinks.h"
#include "pipelineCyclerTrivialImpl.h"
#include "pipelineCyclerTrueImpl.h"
#include "pmutex.h"
#include "pmutex_ext.h"
#include "psemaphore.h"
#include "py_panda.h"
#include "pythonThread.h"
#include "reMutex.h"
#include "reMutexDirect.h"
#include "reMutexHolder.h"
#include "reMutexSpinlockImpl.h"
#include "reMutex_ext.h"
#include "selectThreadImpl.h"
#include "thread.h"
#include "threadDummyImpl.h"
#include "threadImpl.h"
#include "threadPosixImpl.h"
#include "threadPriority.h"
#include "threadSimpleImpl.h"
#include "threadSimpleManager.h"
#include "threadWin32Impl.h"
#include "typeHandle.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class Thread
 */
typedef Thread Thread_localtype;
Define_Module_ClassRef(panda3d.core, Thread, Thread_localtype, Thread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
static void Dtool_PyModuleClassInit_Thread(PyObject *module);

/**
 * Forward declarations for top-level class MutexDirect
 */
typedef MutexDirect MutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, MutexDirect, MutexDirect_localtype, MutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MutexDirect = &Dtool_MutexDirect;
static void Dtool_PyModuleClassInit_MutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class Mutex
 */
typedef Mutex Mutex_localtype;
Define_Module_Class(panda3d.core, Mutex, Mutex_localtype, Mutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Mutex = &Dtool_Mutex;
static void Dtool_PyModuleClassInit_Mutex(PyObject *module);

/**
 * Forward declarations for top-level class ConditionVarDirect
 */
typedef ConditionVarDirect ConditionVarDirect_localtype;
Define_Module_Class(panda3d.core, ConditionVarDirect, ConditionVarDirect_localtype, ConditionVarDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConditionVarDirect = &Dtool_ConditionVarDirect;
static void Dtool_PyModuleClassInit_ConditionVarDirect(PyObject *module);

/**
 * Forward declarations for top-level class ConditionVar
 */
typedef ConditionVar ConditionVar_localtype;
Define_Module_Class(panda3d.core, ConditionVar, ConditionVar_localtype, ConditionVar);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConditionVar = &Dtool_ConditionVar;
static void Dtool_PyModuleClassInit_ConditionVar(PyObject *module);

/**
 * Forward declarations for top-level class ReMutexDirect
 */
typedef ReMutexDirect ReMutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, ReMutexDirect, ReMutexDirect_localtype, ReMutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReMutexDirect = &Dtool_ReMutexDirect;
static void Dtool_PyModuleClassInit_ReMutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class ReMutex
 */
typedef ReMutex ReMutex_localtype;
Define_Module_Class(panda3d.core, ReMutex, ReMutex_localtype, ReMutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReMutex = &Dtool_ReMutex;
static void Dtool_PyModuleClassInit_ReMutex(PyObject *module);

/**
 * Forward declarations for top-level class ExternalThread
 */
typedef ExternalThread ExternalThread_localtype;
Define_Module_ClassRef(panda3d.core, ExternalThread, ExternalThread_localtype, ExternalThread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ExternalThread = &Dtool_ExternalThread;
static void Dtool_PyModuleClassInit_ExternalThread(PyObject *module);

/**
 * Forward declarations for top-level class LightMutexDirect
 */
typedef LightMutexDirect LightMutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, LightMutexDirect, LightMutexDirect_localtype, LightMutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightMutexDirect = &Dtool_LightMutexDirect;
static void Dtool_PyModuleClassInit_LightMutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class LightMutex
 */
typedef LightMutex LightMutex_localtype;
Define_Module_Class(panda3d.core, LightMutex, LightMutex_localtype, LightMutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightMutex = &Dtool_LightMutex;
static void Dtool_PyModuleClassInit_LightMutex(PyObject *module);

/**
 * Forward declarations for top-level class LightReMutexDirect
 */
typedef LightReMutexDirect LightReMutexDirect_localtype;
Define_Module_Class_Private(panda3d.core, LightReMutexDirect, LightReMutexDirect_localtype, LightReMutexDirect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightReMutexDirect = &Dtool_LightReMutexDirect;
static void Dtool_PyModuleClassInit_LightReMutexDirect(PyObject *module);

/**
 * Forward declarations for top-level class LightReMutex
 */
typedef LightReMutex LightReMutex_localtype;
Define_Module_Class(panda3d.core, LightReMutex, LightReMutex_localtype, LightReMutex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightReMutex = &Dtool_LightReMutex;
static void Dtool_PyModuleClassInit_LightReMutex(PyObject *module);

/**
 * Forward declarations for top-level class MainThread
 */
typedef MainThread MainThread_localtype;
Define_Module_ClassRef(panda3d.core, MainThread, MainThread_localtype, MainThread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MainThread = &Dtool_MainThread;
static void Dtool_PyModuleClassInit_MainThread(PyObject *module);

/**
 * Forward declarations for top-level class Semaphore
 */
typedef Semaphore Semaphore_localtype;
Define_Module_Class(panda3d.core, Semaphore, Semaphore_localtype, Semaphore);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Semaphore = &Dtool_Semaphore;
static void Dtool_PyModuleClassInit_Semaphore(PyObject *module);

/**
 * Forward declarations for top-level class PythonThread
 */
typedef PythonThread PythonThread_localtype;
Define_Module_ClassRef(panda3d.core, PythonThread, PythonThread_localtype, PythonThread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PythonThread = &Dtool_PythonThread;
static void Dtool_PyModuleClassInit_PythonThread(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"Thread", &Dtool_Thread},
  {"MutexDirect", &Dtool_MutexDirect},
  {"Mutex", &Dtool_Mutex},
  {"ConditionVarDirect", &Dtool_ConditionVarDirect},
  {"ConditionVar", &Dtool_ConditionVar},
  {"ReMutexDirect", &Dtool_ReMutexDirect},
  {"ReMutex", &Dtool_ReMutex},
  {"ExternalThread", &Dtool_ExternalThread},
  {"LightMutexDirect", &Dtool_LightMutexDirect},
  {"LightMutex", &Dtool_LightMutex},
  {"LightReMutexDirect", &Dtool_LightReMutexDirect},
  {"LightReMutex", &Dtool_LightReMutex},
  {"MainThread", &Dtool_MainThread},
  {"Semaphore", &Dtool_Semaphore},
  {"PythonThread", &Dtool_PythonThread},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class Thread
 */
/**
 * Python function wrapper for:
 * static PointerTo< Thread > Thread::bind_thread(std::string const &name, std::string const &sync_name)
 */
static PyObject *Dtool_Thread_bind_thread_10(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< Thread > Thread::bind_thread(std::string const &name, std::string const &sync_name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"name", "sync_name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:bind_thread", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    PointerTo< Thread > return_value = (Thread::bind_thread)(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Thread *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Thread, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bind_thread(str name, str sync_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_bind_thread_10_comment =
  "C++ Interface:\n"
  "bind_thread(str name, str sync_name)\n"
  "\n"
  "/**\n"
  " * Returns a new Panda Thread object associated with the current thread (which\n"
  " * has been created externally). This can be used to bind a unique Panda\n"
  " * Thread object with an external thread, such as a new Python thread.\n"
  " *\n"
  " * It is particularly useful to bind a Panda Thread object to an external\n"
  " * thread for the purposes of PStats monitoring.  Without this call, each\n"
  " * external thread will be assigned the same global ExternalThread object,\n"
  " * which means they will all appear in the same PStats graph.\n"
  " *\n"
  " * It is the caller's responsibility to save the returned Thread pointer for\n"
  " * the lifetime of the external thread.  It is an error for the Thread pointer\n"
  " * to destruct while the external thread is still in the system.\n"
  " *\n"
  " * It is also an error to call this method from the main thread, or twice\n"
  " * within a given thread, unless it is given the same name each time (in which\n"
  " * case the same pointer will be returned each time).\n"
  " */";
#else
static const char *Dtool_Thread_bind_thread_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Thread::get_sync_name(void) const
 */
static PyObject *Dtool_Thread_get_sync_name_11(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline std::string const &Thread::get_sync_name(void) const
  std::string const &return_value = ((*(const Thread*)local_this).get_sync_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_sync_name_11_comment =
  "C++ Interface:\n"
  "get_sync_name(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the sync name of the thread.  This name collects threads into \"sync\n"
  " * groups\", which are expected to run synchronously.  This is mainly used for\n"
  " * the benefit of PStats; threads with the same sync name can be ticked all at\n"
  " * once via the thread_tick() call.\n"
  " */";
#else
static const char *Dtool_Thread_get_sync_name_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Thread::get_pstats_index(void) const
 */
static PyObject *Dtool_Thread_get_pstats_index_12(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline int Thread::get_pstats_index(void) const
  int return_value = ((*(const Thread*)local_this).get_pstats_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_pstats_index_12_comment =
  "C++ Interface:\n"
  "get_pstats_index(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the PStats index associated with this thread, or -1 if no index has\n"
  " * yet been associated with this thread.  This is used internally by the\n"
  " * PStatClient; you should not need to call this directly.\n"
  " */";
#else
static const char *Dtool_Thread_get_pstats_index_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Thread::get_python_index(void) const
 */
static PyObject *Dtool_Thread_get_python_index_13(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline int Thread::get_python_index(void) const
  int return_value = ((*(const Thread*)local_this).get_python_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_python_index_13_comment =
  "C++ Interface:\n"
  "get_python_index(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the Python index associated with this thread, or -1 if no index has\n"
  " * yet been associated with this thread.  This is used internally by the\n"
  " * direct.stdpy.thread module; you should not need to call this directly.\n"
  " */";
#else
static const char *Dtool_Thread_get_python_index_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string Thread::get_unique_id(void) const
 */
static PyObject *Dtool_Thread_get_unique_id_14(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline std::string Thread::get_unique_id(void) const
  std::string return_value = ((*(const Thread*)local_this).get_unique_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_unique_id_14_comment =
  "C++ Interface:\n"
  "get_unique_id(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns a string that is guaranteed to be unique to this thread, across all\n"
  " * processes on the machine, during at least the lifetime of this process.\n"
  " */";
#else
static const char *Dtool_Thread_get_unique_id_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Thread::get_pipeline_stage(void) const
 */
static PyObject *Dtool_Thread_get_pipeline_stage_15(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline int Thread::get_pipeline_stage(void) const
  int return_value = ((*(const Thread*)local_this).get_pipeline_stage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_pipeline_stage_15_comment =
  "C++ Interface:\n"
  "get_pipeline_stage(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the Pipeline stage number associated with this thread.  The default\n"
  " * stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().\n"
  " */";
#else
static const char *Dtool_Thread_get_pipeline_stage_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Thread::set_pipeline_stage(int pipeline_stage)
 */
static PyObject *Dtool_Thread_set_pipeline_stage_16(PyObject *self, PyObject *arg) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.set_pipeline_stage")) {
    return nullptr;
  }
  // 1-void Thread::set_pipeline_stage(int pipeline_stage)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_pipeline_stage)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pipeline_stage(const Thread self, int pipeline_stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_set_pipeline_stage_16_comment =
  "C++ Interface:\n"
  "set_pipeline_stage(const Thread self, int pipeline_stage)\n"
  "\n"
  "/**\n"
  " * Specifies the Pipeline stage number associated with this thread.  The\n"
  " * default stage is 0 if no stage is specified otherwise.\n"
  " *\n"
  " * This must be a value in the range [0 .. pipeline->get_num_stages() - 1].\n"
  " * It specifies the values that this thread observes for all pipelined data.\n"
  " * Typically, an application thread will leave this at 0, but a render thread\n"
  " * may set it to 1 or 2 (to operate on the previous frame's data, or the\n"
  " * second previous frame's data).\n"
  " */";
#else
static const char *Dtool_Thread_set_pipeline_stage_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Thread::set_min_pipeline_stage(int min_pipeline_stage)
 */
static PyObject *Dtool_Thread_set_min_pipeline_stage_17(PyObject *self, PyObject *arg) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.set_min_pipeline_stage")) {
    return nullptr;
  }
  // 1-inline void Thread::set_min_pipeline_stage(int min_pipeline_stage)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_min_pipeline_stage)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_pipeline_stage(const Thread self, int min_pipeline_stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_set_min_pipeline_stage_17_comment =
  "C++ Interface:\n"
  "set_min_pipeline_stage(const Thread self, int min_pipeline_stage)\n"
  "\n"
  "/**\n"
  " * Sets this thread's pipeline stage number to at least the indicated value,\n"
  " * unless it is already larger.  See set_pipeline_stage().\n"
  " */";
#else
static const char *Dtool_Thread_set_min_pipeline_stage_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Thread *Thread::get_main_thread(void)
 */
static PyObject *Dtool_Thread_get_main_thread_18(PyObject *, PyObject *) {
  // 1-static inline Thread *Thread::get_main_thread(void)
  Thread *return_value = (Thread::get_main_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_main_thread_18_comment =
  "C++ Interface:\n"
  "get_main_thread()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the \"main\" Thread object--this is the Thread that\n"
  " * started the whole process.\n"
  " */";
#else
static const char *Dtool_Thread_get_main_thread_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Thread *Thread::get_external_thread(void)
 */
static PyObject *Dtool_Thread_get_external_thread_19(PyObject *, PyObject *) {
  // 1-static inline Thread *Thread::get_external_thread(void)
  Thread *return_value = (Thread::get_external_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_external_thread_19_comment =
  "C++ Interface:\n"
  "get_external_thread()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the \"external\" Thread object--this is a special Thread\n"
  " * object that corresponds to any thread spawned outside of Panda's threading\n"
  " * interface.  Note that multiple different threads may share this same\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_Thread_get_external_thread_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Thread *Thread::get_current_thread(void)
 */
static PyObject *Dtool_Thread_get_current_thread_20(PyObject *, PyObject *) {
  // 1-static inline Thread *Thread::get_current_thread(void)
  Thread *return_value = (Thread::get_current_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_current_thread_20_comment =
  "C++ Interface:\n"
  "get_current_thread()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the currently-executing Thread object.  If this is\n"
  " * called from the main thread, this will return the same value as\n"
  " * get_main_thread().\n"
  " *\n"
  " * This will always return some valid Thread pointer.  It will never return\n"
  " * NULL, even if the current thread was spawned outside of Panda's threading\n"
  " * system, although all non-Panda threads will return the exact same Thread\n"
  " * pointer.\n"
  " */";
#else
static const char *Dtool_Thread_get_current_thread_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int Thread::get_current_pipeline_stage(void)
 */
static PyObject *Dtool_Thread_get_current_pipeline_stage_21(PyObject *, PyObject *) {
  // 1-static inline int Thread::get_current_pipeline_stage(void)
  int return_value = (Thread::get_current_pipeline_stage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_current_pipeline_stage_21_comment =
  "C++ Interface:\n"
  "get_current_pipeline_stage()\n"
  "\n"
  "/**\n"
  " * Returns the integer pipeline stage associated with the current thread.\n"
  " * This is the same thing as get_current_thread()->get_pipeline_stage(), but\n"
  " * it may be faster to retrieve in some contexts.\n"
  " */";
#else
static const char *Dtool_Thread_get_current_pipeline_stage_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool Thread::is_threading_supported(void)
 */
static PyObject *Dtool_Thread_is_threading_supported_22(PyObject *, PyObject *) {
  // 1-static inline bool Thread::is_threading_supported(void)
  bool return_value = (Thread::is_threading_supported)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_threading_supported_22_comment =
  "C++ Interface:\n"
  "is_threading_supported()\n"
  "\n"
  "/**\n"
  " * Returns true if threading support has been compiled in and enabled, or\n"
  " * false if no threading is available (and Thread::start() will always fail).\n"
  " */";
#else
static const char *Dtool_Thread_is_threading_supported_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool Thread::is_true_threads(void)
 */
static PyObject *Dtool_Thread_is_true_threads_23(PyObject *, PyObject *) {
  // 1-static inline bool Thread::is_true_threads(void)
  bool return_value = (Thread::is_true_threads)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_true_threads_23_comment =
  "C++ Interface:\n"
  "is_true_threads()\n"
  "\n"
  "/**\n"
  " * Returns true if a real threading library is available that supports actual\n"
  " * OS-implemented threads, or false if the only threading we can provide is\n"
  " * simulated user-space threading.\n"
  " */";
#else
static const char *Dtool_Thread_is_true_threads_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool Thread::is_simple_threads(void)
 */
static PyObject *Dtool_Thread_is_simple_threads_24(PyObject *, PyObject *) {
  // 1-static inline bool Thread::is_simple_threads(void)
  bool return_value = (Thread::is_simple_threads)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_simple_threads_24_comment =
  "C++ Interface:\n"
  "is_simple_threads()\n"
  "\n"
  "/**\n"
  " * Returns true if Panda is currently compiled for \"simple threads\", which is\n"
  " * to say, cooperative context switching only, reducing the need for quite so\n"
  " * many critical section protections.  This is not necessarily the opposite of\n"
  " * \"true threads\", since one possible implementation of simple threads is via\n"
  " * true threads with mutex protection to ensure only one runs at a time.\n"
  " */";
#else
static const char *Dtool_Thread_is_simple_threads_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::sleep(double seconds)
 */
static PyObject *Dtool_Thread_sleep_25(PyObject *, PyObject *arg) {
  // 1-static inline void Thread::sleep(double seconds)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (Thread::sleep)(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sleep(double seconds)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_sleep_25_comment =
  "C++ Interface:\n"
  "sleep(double seconds)\n"
  "\n"
  "/**\n"
  " * Suspends the current thread for at least the indicated amount of time.  It\n"
  " * might be suspended for longer.\n"
  " */";
#else
static const char *Dtool_Thread_sleep_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::force_yield(void)
 */
static PyObject *Dtool_Thread_force_yield_26(PyObject *, PyObject *) {
  // 1-static inline void Thread::force_yield(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (Thread::force_yield)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_force_yield_26_comment =
  "C++ Interface:\n"
  "force_yield()\n"
  "\n"
  "/**\n"
  " * Suspends the current thread for the rest of the current epoch.\n"
  " */";
#else
static const char *Dtool_Thread_force_yield_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::consider_yield(void)
 */
static PyObject *Dtool_Thread_consider_yield_27(PyObject *, PyObject *) {
  // 1-static inline void Thread::consider_yield(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (Thread::consider_yield)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_consider_yield_27_comment =
  "C++ Interface:\n"
  "consider_yield()\n"
  "\n"
  "/**\n"
  " * Possibly suspends the current thread for the rest of the current epoch, if\n"
  " * it has run for enough this epoch.  This is especially important for the\n"
  " * simple thread implementation, which relies on cooperative yields like this.\n"
  " */";
#else
static const char *Dtool_Thread_consider_yield_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Thread::output(std::ostream &out) const
 */
static PyObject *Dtool_Thread_output_28(PyObject *self, PyObject *arg) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-virtual void Thread::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Thread.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Thread*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Thread self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_output_28_comment =
  "C++ Interface:\n"
  "output(Thread self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Thread_output_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Thread::output_blocker(std::ostream &out) const
 */
static PyObject *Dtool_Thread_output_blocker_29(PyObject *self, PyObject *arg) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-void Thread::output_blocker(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Thread.output_blocker", false, true);
  if (arg_this != nullptr) {
    ((*(const Thread*)local_this).output_blocker)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_blocker(Thread self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_output_blocker_29_comment =
  "C++ Interface:\n"
  "output_blocker(Thread self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a description of the mutex or condition variable that this thread is\n"
  " * blocked on.  Writes nothing if there is no blocker, or if we are not in\n"
  " * DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_Thread_output_blocker_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void Thread::write_status(std::ostream &out)
 */
static PyObject *Dtool_Thread_write_status_30(PyObject *, PyObject *arg) {
  // 1-static void Thread::write_status(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "Thread.write_status", false, true);
  if (arg_this != nullptr) {
    (Thread::write_status)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_status(ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_write_status_30_comment =
  "C++ Interface:\n"
  "write_status(ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Thread_write_status_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Thread::is_started(void) const
 */
static PyObject *Dtool_Thread_is_started_31(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline bool Thread::is_started(void) const
  bool return_value = ((*(const Thread*)local_this).is_started)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_started_31_comment =
  "C++ Interface:\n"
  "is_started(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns true if the thread has been started, false if it has not, or if\n"
  " * join() has already been called.\n"
  " */";
#else
static const char *Dtool_Thread_is_started_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Thread::is_joinable(void) const
 */
static PyObject *Dtool_Thread_is_joinable_32(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline bool Thread::is_joinable(void) const
  bool return_value = ((*(const Thread*)local_this).is_joinable)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Thread_is_joinable_32_comment =
  "C++ Interface:\n"
  "is_joinable(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the value of joinable that was passed to the start() call.\n"
  " */";
#else
static const char *Dtool_Thread_is_joinable_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Thread::start(ThreadPriority priority, bool joinable)
 */
static PyObject *Dtool_Thread_start_33(PyObject *self, PyObject *args, PyObject *kwds) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.start")) {
    return nullptr;
  }
  // 1-bool Thread::start(ThreadPriority priority, bool joinable)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"priority", "joinable", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:start", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*local_this).start)((ThreadPriority)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start(const Thread self, int priority, bool joinable)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_start_33_comment =
  "C++ Interface:\n"
  "start(const Thread self, int priority, bool joinable)\n"
  "\n"
  "/**\n"
  " * Starts the thread executing.  It is only valid to call this once.\n"
  " *\n"
  " * The thread will begin executing its thread_main() function, and will\n"
  " * terminate when thread_main() returns.\n"
  " *\n"
  " * priority is intended as a hint to the relative importance of this thread.\n"
  " * This may be ignored by the thread implementation.\n"
  " *\n"
  " * joinable should be set true if you intend to call join() to wait for the\n"
  " * thread to terminate, or false if you don't care and you will never call\n"
  " * join(). Note that the reference count on the Thread object is incremented\n"
  " * while the thread itself is running, so if you just want to fire and forget\n"
  " * a thread, you may pass joinable = false, and never store the Thread object.\n"
  " * It will automatically destruct itself when it finishes.\n"
  " *\n"
  " * The return value is true if the thread is successfully started, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_Thread_start_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Thread::join(void)
 */
static PyObject *Dtool_Thread_join_34(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.join")) {
    return nullptr;
  }
  // 1-inline void Thread::join(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).join)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_join_34_comment =
  "C++ Interface:\n"
  "join(const Thread self)\n"
  "\n"
  "/**\n"
  " * Blocks the calling process until the thread terminates.  If the thread has\n"
  " * already terminated, this returns immediately.\n"
  " */";
#else
static const char *Dtool_Thread_join_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Thread::preempt(void)
 */
static PyObject *Dtool_Thread_preempt_35(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.preempt")) {
    return nullptr;
  }
  // 1-inline void Thread::preempt(void)
  ((*local_this).preempt)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_preempt_35_comment =
  "C++ Interface:\n"
  "preempt(const Thread self)\n"
  "\n"
  "/**\n"
  " * Indicates that this thread should run as soon as possible, preemptying any\n"
  " * other threads that may be scheduled to run.  This may not be implemented on\n"
  " * every platform.\n"
  " */";
#else
static const char *Dtool_Thread_preempt_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypedReferenceCount *Thread::get_current_task(void) const
 */
static PyObject *Dtool_Thread_get_current_task_36(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Thread)) {
    return nullptr;
  }
  // 1-inline TypedReferenceCount *Thread::get_current_task(void) const
  TypedReferenceCount *return_value = ((*(const Thread*)local_this).get_current_task)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_current_task_36_comment =
  "C++ Interface:\n"
  "get_current_task(Thread self)\n"
  "\n"
  "/**\n"
  " * Returns the task currently executing on this thread (via the\n"
  " * AsyncTaskManager), if any, or NULL if the thread is not currently servicing\n"
  " * a task.\n"
  " */";
#else
static const char *Dtool_Thread_get_current_task_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Thread::set_python_index(int index)
 */
static PyObject *Dtool_Thread_set_python_index_37(PyObject *self, PyObject *arg) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.set_python_index")) {
    return nullptr;
  }
  // 1-inline void Thread::set_python_index(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_python_index)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_python_index(const Thread self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Thread_set_python_index_37_comment =
  "C++ Interface:\n"
  "set_python_index(const Thread self, int index)\n"
  "\n"
  "/**\n"
  " * Stores a Python index to be associated with this thread.  This is used\n"
  " * internally by the thread module; you should not need to call this directly.\n"
  " */";
#else
static const char *Dtool_Thread_set_python_index_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void Thread::prepare_for_exit(void)
 */
static PyObject *Dtool_Thread_prepare_for_exit_38(PyObject *, PyObject *) {
  // 1-static inline void Thread::prepare_for_exit(void)
  (Thread::prepare_for_exit)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Thread_prepare_for_exit_38_comment =
  "C++ Interface:\n"
  "prepare_for_exit()\n"
  "\n"
  "/**\n"
  " * Should be called by the main thread just before exiting the program, this\n"
  " * blocks until any remaining thread cleanup has finished.\n"
  " */";
#else
static const char *Dtool_Thread_prepare_for_exit_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Thread::get_class_type(void)
 */
static PyObject *Dtool_Thread_get_class_type_61(PyObject *, PyObject *) {
  // 1-static TypeHandle Thread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Thread::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Thread_get_class_type_61_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Thread_get_class_type_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_Thread_upcast_to_TypedReferenceCount_4(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Thread_upcast_to_TypedReferenceCount_4_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const Thread self)\n"
  "\n"
  "upcast from Thread to TypedReferenceCount";
#else
static const char *Dtool_Thread_upcast_to_TypedReferenceCount_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *Thread::upcast_to_Namable(void)
 */
static PyObject *Dtool_Thread_upcast_to_Namable_7(PyObject *self, PyObject *) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *Thread::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Thread_upcast_to_Namable_7_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const Thread self)\n"
  "\n"
  "upcast from Thread to Namable";
#else
static const char *Dtool_Thread_upcast_to_Namable_7_comment = nullptr;
#endif

static PyObject *Dtool_Thread_sync_name_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &Thread::get_sync_name(void) const
  std::string const &return_value = ((*(const Thread*)local_this).get_sync_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_pstats_index_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Thread::get_pstats_index(void) const
  int return_value = ((*(const Thread*)local_this).get_pstats_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_python_index_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Thread::get_python_index(void) const
  int return_value = ((*(const Thread*)local_this).get_python_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_unique_id_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string Thread::get_unique_id(void) const
  std::string return_value = ((*(const Thread*)local_this).get_unique_id)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_pipeline_stage_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int Thread::get_pipeline_stage(void) const
  int return_value = ((*(const Thread*)local_this).get_pipeline_stage)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Thread_pipeline_stage_Setter(PyObject *self, PyObject *arg, void *) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Thread, (void **)&local_this, "Thread.pipeline_stage")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pipeline_stage attribute");
    return -1;
  }
  // 1-void Thread::set_pipeline_stage(int pipeline_stage)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_pipeline_stage)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pipeline_stage(const Thread self, int pipeline_stage)\n");
  }
  return -1;
}

static PyObject *Dtool_Thread_main_thread_Getter(PyObject *self, void *) {
  // 1-static inline Thread *Thread::get_main_thread(void)
  Thread *return_value = (Thread::get_main_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_Thread_external_thread_Getter(PyObject *self, void *) {
  // 1-static inline Thread *Thread::get_external_thread(void)
  Thread *return_value = (Thread::get_external_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_Thread_current_thread_Getter(PyObject *self, void *) {
  // 1-static inline Thread *Thread::get_current_thread(void)
  Thread *return_value = (Thread::get_current_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_Thread_current_pipeline_stage_Getter(PyObject *self, void *) {
  // 1-static inline int Thread::get_current_pipeline_stage(void)
  int return_value = (Thread::get_current_pipeline_stage)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_threading_supported_Getter(PyObject *self, void *) {
  // 1-static inline bool Thread::is_threading_supported(void)
  bool return_value = (Thread::is_threading_supported)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_true_threads_Getter(PyObject *self, void *) {
  // 1-static inline bool Thread::is_true_threads(void)
  bool return_value = (Thread::is_true_threads)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_simple_threads_Getter(PyObject *self, void *) {
  // 1-static inline bool Thread::is_simple_threads(void)
  bool return_value = (Thread::is_simple_threads)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_started_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Thread::is_started(void) const
  bool return_value = ((*(const Thread*)local_this).is_started)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_joinable_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool Thread::is_joinable(void) const
  bool return_value = ((*(const Thread*)local_this).is_joinable)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Thread_current_task_Getter(PyObject *self, void *) {
  const Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TypedReferenceCount *Thread::get_current_task(void) const
  TypedReferenceCount *return_value = ((*(const Thread*)local_this).get_current_task)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_Thread(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_Thread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Thread) {
    printf("Thread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Thread *local_this = (Thread *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Thread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Thread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Thread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (Thread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Thread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Thread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (Thread*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MutexDirect
 */
/**
 * Python function wrapper for:
 * inline void MutexDirect::acquire(void) const
 */
static PyObject *Dtool_MutexDirect_acquire_63(PyObject *self, PyObject *) {
  MutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MutexDirect)) {
    return nullptr;
  }
  // 1-inline void MutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*(const MutexDirect*)local_this).acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_acquire_63_comment =
  "C++ Interface:\n"
  "acquire(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Grabs the mutex if it is available.  If it is not available, blocks until\n"
  " * it becomes available, then grabs it.  In either case, the function does not\n"
  " * return until the mutex is held; you should then call unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * mutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see MutexHolder.\n"
  " */";
#else
static const char *Dtool_MutexDirect_acquire_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MutexDirect::try_acquire(void) const
 */
static PyObject *Dtool_MutexDirect_try_acquire_64(PyObject *self, PyObject *) {
  MutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MutexDirect)) {
    return nullptr;
  }
  // 1-inline bool MutexDirect::try_acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const MutexDirect*)local_this).try_acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_try_acquire_64_comment =
  "C++ Interface:\n"
  "try_acquire(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns immediately, with a true value indicating the mutex has been\n"
  " * acquired, and false indicating it has not.\n"
  " *\n"
  " * @deprecated Python users should use acquire(False), C++ users try_lock()\n"
  " */";
#else
static const char *Dtool_MutexDirect_try_acquire_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MutexDirect::release(void) const
 */
static PyObject *Dtool_MutexDirect_release_65(PyObject *self, PyObject *) {
  MutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MutexDirect)) {
    return nullptr;
  }
  // 1-inline void MutexDirect::release(void) const
  ((*(const MutexDirect*)local_this).release)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_release_65_comment =
  "C++ Interface:\n"
  "release(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the mutex.  It is an error to call this if the mutex was not\n"
  " * already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * mutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_MutexDirect_release_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_MutexDirect_debug_is_locked_66(PyObject *self, PyObject *) {
  MutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MutexDirect)) {
    return nullptr;
  }
  // 1-inline bool MutexDirect::debug_is_locked(void) const
  bool return_value = ((*(const MutexDirect*)local_this).debug_is_locked)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_debug_is_locked_66_comment =
  "C++ Interface:\n"
  "debug_is_locked(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the Mutex, false otherwise.\n"
  " * This method is only intended for use in debugging, hence the method name;\n"
  " * in the MutexDirect case, it always returns true, since there's not a\n"
  " * reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_MutexDirect_debug_is_locked_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_MutexDirect_set_name_67(PyObject *self, PyObject *arg) {
  MutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MutexDirect, (void **)&local_this, "MutexDirect.set_name")) {
    return nullptr;
  }
  // 1-inline void MutexDirect::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const MutexDirect self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_set_name_67_comment =
  "C++ Interface:\n"
  "set_name(const MutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_set_name_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void MutexDirect::clear_name(void)
 */
static PyObject *Dtool_MutexDirect_clear_name_68(PyObject *self, PyObject *) {
  MutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MutexDirect, (void **)&local_this, "MutexDirect.clear_name")) {
    return nullptr;
  }
  // 1-inline void MutexDirect::clear_name(void)
  ((*local_this).clear_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_clear_name_68_comment =
  "C++ Interface:\n"
  "clear_name(const MutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_clear_name_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool MutexDirect::has_name(void) const
 */
static PyObject *Dtool_MutexDirect_has_name_69(PyObject *self, PyObject *) {
  MutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MutexDirect)) {
    return nullptr;
  }
  // 1-inline bool MutexDirect::has_name(void) const
  bool return_value = ((*(const MutexDirect*)local_this).has_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_has_name_69_comment =
  "C++ Interface:\n"
  "has_name(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_has_name_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string MutexDirect::get_name(void) const
 */
static PyObject *Dtool_MutexDirect_get_name_70(PyObject *self, PyObject *) {
  MutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MutexDirect)) {
    return nullptr;
  }
  // 1-inline std::string MutexDirect::get_name(void) const
  std::string return_value = ((*(const MutexDirect*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_get_name_70_comment =
  "C++ Interface:\n"
  "get_name(MutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_MutexDirect_get_name_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MutexDirect::output(std::ostream &out) const
 */
static PyObject *Dtool_MutexDirect_output_71(PyObject *self, PyObject *arg) {
  MutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MutexDirect)) {
    return nullptr;
  }
  // 1-void MutexDirect::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "MutexDirect.output", false, true);
  if (arg_this != nullptr) {
    ((*(const MutexDirect*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MutexDirect self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MutexDirect_output_71_comment =
  "C++ Interface:\n"
  "output(MutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in MutexDebug, but non-virtual in\n"
  " * MutexDirect.\n"
  " */";
#else
static const char *Dtool_MutexDirect_output_71_comment = nullptr;
#endif

static int Dtool_Init_MutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MutexDirect) {
    printf("MutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MutexDirect *local_this = (MutexDirect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MutexDirect) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MutexDirect) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Mutex
 */
/**
 * Python function wrapper for:
 * bool Mutex::acquire(bool blocking = true) const
 */
static PyObject *Dtool_Mutex_acquire_75(PyObject *self, PyObject *args, PyObject *kwds) {
  Mutex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Mutex)) {
    return nullptr;
  }
  // 1-bool Mutex::acquire(bool blocking = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "blocking")) {
    bool return_value = invoke_extension((const Mutex*)local_this).acquire((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "acquire(Mutex self, bool blocking)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Mutex_acquire_75_comment =
  "C++ Interface:\n"
  "acquire(Mutex self, bool blocking)\n";
#else
static const char *Dtool_Mutex_acquire_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Mutex::__enter__(void)
 */
static PyObject *Dtool_Mutex_enter_76(PyObject *self, PyObject *) {
  Mutex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Mutex, (void **)&local_this, "Mutex.__enter__")) {
    return nullptr;
  }
  // 1-bool Mutex::__enter__(void)
  bool return_value = invoke_extension(local_this).__enter__();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Mutex_enter_76_comment =
  "C++ Interface:\n"
  "__enter__(const Mutex self)\n";
#else
static const char *Dtool_Mutex_enter_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Mutex::__exit__(PyObject *, PyObject *, PyObject *)
 */
static PyObject *Dtool_Mutex_exit_77(PyObject *self, PyObject *args) {
  Mutex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Mutex, (void **)&local_this, "Mutex.__exit__")) {
    return nullptr;
  }
  // 1-void Mutex::__exit__(PyObject *, PyObject *, PyObject *)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  if (PyArg_UnpackTuple(args, "__exit__", 3, 3, &param1, &param2, &param3)) {
    invoke_extension(local_this).__exit__(param1, param2, param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__exit__(const Mutex self, object param0, object param1, object param2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Mutex_exit_77_comment =
  "C++ Interface:\n"
  "__exit__(const Mutex self, object param0, object param1, object param2)\n";
#else
static const char *Dtool_Mutex_exit_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Mutex::Mutex(void)
 * inline explicit Mutex::Mutex(std::string const &name)
 */
static int Dtool_Init_Mutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Mutex::Mutex(void)
      Mutex *return_value = new Mutex();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Mutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-inline explicit Mutex::Mutex(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          Mutex *return_value = new Mutex(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Mutex, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Mutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Mutex()\n"
      "Mutex(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Mutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Mutex) {
    printf("Mutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Mutex *local_this = (Mutex *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Mutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MutexDirect) {
    return (MutexDirect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Mutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Mutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MutexDirect) {
    MutexDirect* other_this = (MutexDirect*)from_this;
    return (Mutex*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConditionVarDirect
 */
/**
 * Python function wrapper for:
 * inline MutexDirect &ConditionVarDirect::get_mutex(void) const
 */
static PyObject *Dtool_ConditionVarDirect_get_mutex_80(PyObject *self, PyObject *) {
  ConditionVarDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConditionVarDirect)) {
    return nullptr;
  }
  // 1-inline MutexDirect &ConditionVarDirect::get_mutex(void) const
  MutexDirect *return_value = &(((*(const ConditionVarDirect*)local_this).get_mutex)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_MutexDirect, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_get_mutex_80_comment =
  "C++ Interface:\n"
  "get_mutex(ConditionVarDirect self)\n"
  "\n"
  "/**\n"
  " * Returns the mutex associated with this condition variable.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_get_mutex_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarDirect::wait(void)
 * inline void ConditionVarDirect::wait(double timeout)
 */
static PyObject *Dtool_ConditionVarDirect_wait_81(PyObject *self, PyObject *args) {
  ConditionVarDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarDirect, (void **)&local_this, "ConditionVarDirect.wait")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void ConditionVarDirect::wait(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).wait)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void ConditionVarDirect::wait(double timeout)
      if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*local_this).wait)(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "wait() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wait(const ConditionVarDirect self)\n"
      "wait(const ConditionVarDirect self, double timeout)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_wait_81_comment =
  "C++ Interface:\n"
  "wait(const ConditionVarDirect self)\n"
  "wait(const ConditionVarDirect self, double timeout)\n"
  "\n"
  "/**\n"
  " * Waits on the condition.  The caller must already be holding the lock\n"
  " * associated with the condition variable before calling this function.\n"
  " *\n"
  " * wait() will release the lock, then go to sleep until some other thread\n"
  " * calls notify() on this condition variable.  At that time at least one\n"
  " * thread waiting on the same ConditionVarDirect will grab the lock again, and\n"
  " * then return from wait().\n"
  " *\n"
  " * It is possible that wait() will return even if no one has called notify().\n"
  " * It is the responsibility of the calling process to verify the condition on\n"
  " * return from wait, and possibly loop back to wait again if necessary.\n"
  " *\n"
  " * Note the semantics of a condition variable: the mutex must be held before\n"
  " * wait() is called, and it will still be held when wait() returns.  However,\n"
  " * it will be temporarily released during the wait() call itself.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Waits on the condition, with a timeout.  The function will return when the\n"
  " * condition variable is notified, or the timeout occurs.  There is no way to\n"
  " * directly tell which happened, and it is possible that neither in fact\n"
  " * happened (spurious wakeups are possible).\n"
  " *\n"
  " * See wait() with no parameters for more.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_wait_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarDirect::notify(void)
 */
static PyObject *Dtool_ConditionVarDirect_notify_82(PyObject *self, PyObject *) {
  ConditionVarDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarDirect, (void **)&local_this, "ConditionVarDirect.notify")) {
    return nullptr;
  }
  // 1-inline void ConditionVarDirect::notify(void)
  ((*local_this).notify)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_notify_82_comment =
  "C++ Interface:\n"
  "notify(const ConditionVarDirect self)\n"
  "\n"
  "/**\n"
  " * Informs one of the other threads who are currently blocked on wait() that\n"
  " * the relevant condition has changed.  If multiple threads are currently\n"
  " * waiting, at least one of them will be woken up, although there is no way to\n"
  " * predict which one.  It is possible that more than one thread will be woken\n"
  " * up.\n"
  " *\n"
  " * If no threads are waiting, this is a no-op: the notify event is lost.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_notify_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ConditionVarDirect::notify_all(void)
 */
static PyObject *Dtool_ConditionVarDirect_notify_all_83(PyObject *self, PyObject *) {
  ConditionVarDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConditionVarDirect, (void **)&local_this, "ConditionVarDirect.notify_all")) {
    return nullptr;
  }
  // 1-inline void ConditionVarDirect::notify_all(void)
  ((*local_this).notify_all)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_notify_all_83_comment =
  "C++ Interface:\n"
  "notify_all(const ConditionVarDirect self)\n"
  "\n"
  "/**\n"
  " * Informs all of the other threads who are currently blocked on wait() that\n"
  " * the relevant condition has changed.\n"
  " *\n"
  " * If no threads are waiting, this is a no-op: the notify event is lost.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_notify_all_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConditionVarDirect::output(std::ostream &out) const
 */
static PyObject *Dtool_ConditionVarDirect_output_84(PyObject *self, PyObject *arg) {
  ConditionVarDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConditionVarDirect)) {
    return nullptr;
  }
  // 1-void ConditionVarDirect::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ConditionVarDirect.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConditionVarDirect*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConditionVarDirect self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConditionVarDirect_output_84_comment =
  "C++ Interface:\n"
  "output(ConditionVarDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in ConditionVarDebug, but non-virtual in\n"
  " * ConditionVarDirect.\n"
  " */";
#else
static const char *Dtool_ConditionVarDirect_output_84_comment = nullptr;
#endif

static int Dtool_Init_ConditionVarDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConditionVarDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConditionVarDirect) {
    printf("ConditionVarDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConditionVarDirect *local_this = (ConditionVarDirect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConditionVarDirect) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConditionVarDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConditionVarDirect) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConditionVar
 */
/**
 * Python function wrapper for:
 * inline Mutex &ConditionVar::get_mutex(void) const
 */
static PyObject *Dtool_ConditionVar_get_mutex_88(PyObject *self, PyObject *) {
  ConditionVar *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConditionVar)) {
    return nullptr;
  }
  // 1-inline Mutex &ConditionVar::get_mutex(void) const
  Mutex *return_value = &(((*(const ConditionVar*)local_this).get_mutex)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Mutex, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConditionVar_get_mutex_88_comment =
  "C++ Interface:\n"
  "get_mutex(ConditionVar self)\n"
  "\n"
  "/**\n"
  " * Returns the mutex associated with this condition variable.\n"
  " */";
#else
static const char *Dtool_ConditionVar_get_mutex_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit ConditionVar::ConditionVar(Mutex &mutex)
 */
static int Dtool_Init_ConditionVar(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConditionVar() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "mutex")) {
    // 1-inline explicit ConditionVar::ConditionVar(Mutex &mutex)
    Mutex *arg_this = (Mutex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Mutex, 0, "ConditionVar.ConditionVar", false, true);
    if (arg_this != nullptr) {
      ConditionVar *return_value = new ConditionVar(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConditionVar, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConditionVar(Mutex mutex)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConditionVar(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConditionVar) {
    printf("ConditionVar ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConditionVar *local_this = (ConditionVar *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConditionVar) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConditionVarDirect) {
    return (ConditionVarDirect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConditionVar(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConditionVar) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConditionVarDirect) {
    ConditionVarDirect* other_this = (ConditionVarDirect*)from_this;
    return (ConditionVar*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ReMutexDirect
 */
/**
 * Python function wrapper for:
 * inline void ReMutexDirect::acquire(void) const
 * inline void ReMutexDirect::acquire(Thread *current_thread) const
 */
static PyObject *Dtool_ReMutexDirect_acquire_91(PyObject *self, PyObject *args) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void ReMutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*(const ReMutexDirect*)local_this).acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void ReMutexDirect::acquire(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ReMutexDirect.acquire", false, true);
      if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*(const ReMutexDirect*)local_this).acquire)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "acquire() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "acquire(ReMutexDirect self)\n"
      "acquire(ReMutexDirect self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_acquire_91_comment =
  "C++ Interface:\n"
  "acquire(ReMutexDirect self)\n"
  "acquire(ReMutexDirect self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Grabs the reMutex if it is available.  If it is not available, blocks until\n"
  " * it becomes available, then grabs it.  In either case, the function does not\n"
  " * return until the reMutex is held; you should then call unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * reMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see ReMutexHolder.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on acquire() accepts the current thread as a parameter, if it\n"
  " * is already known, as an optimization.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_acquire_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ReMutexDirect::try_acquire(void) const
 * inline bool ReMutexDirect::try_acquire(Thread *current_thread) const
 */
static PyObject *Dtool_ReMutexDirect_try_acquire_92(PyObject *self, PyObject *args) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool ReMutexDirect::try_acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*(const ReMutexDirect*)local_this).try_acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool ReMutexDirect::try_acquire(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ReMutexDirect.try_acquire", false, true);
      if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*(const ReMutexDirect*)local_this).try_acquire)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "try_acquire() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "try_acquire(ReMutexDirect self)\n"
      "try_acquire(ReMutexDirect self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_try_acquire_92_comment =
  "C++ Interface:\n"
  "try_acquire(ReMutexDirect self)\n"
  "try_acquire(ReMutexDirect self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns immediately, with a true value indicating the mutex has been\n"
  " * acquired, and false indicating it has not.\n"
  " *\n"
  " * @deprecated Python users should use acquire(False), C++ users try_lock()\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns immediately, with a true value indicating the mutex has been\n"
  " * acquired, and false indicating it has not.\n"
  " *\n"
  " * @deprecated Python users should use acquire(False), C++ users try_lock()\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_try_acquire_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::elevate_lock(void) const
 */
static PyObject *Dtool_ReMutexDirect_elevate_lock_93(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  // 1-inline void ReMutexDirect::elevate_lock(void) const
  ((*(const ReMutexDirect*)local_this).elevate_lock)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_elevate_lock_93_comment =
  "C++ Interface:\n"
  "elevate_lock(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * This method increments the lock count, assuming the calling thread already\n"
  " * holds the lock.  After this call, release() will need to be called one\n"
  " * additional time to release the lock.\n"
  " *\n"
  " * This method really performs the same function as acquire(), but it offers a\n"
  " * potential (slight) performance benefit when the calling thread knows that\n"
  " * it already holds the lock.  It is an error to call this when the calling\n"
  " * thread does not hold the lock.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_elevate_lock_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::release(void) const
 */
static PyObject *Dtool_ReMutexDirect_release_94(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  // 1-inline void ReMutexDirect::release(void) const
  ((*(const ReMutexDirect*)local_this).release)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_release_94_comment =
  "C++ Interface:\n"
  "release(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the reMutex.  It is an error to call this if the reMutex was not\n"
  " * already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * reMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_release_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ReMutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_ReMutexDirect_debug_is_locked_95(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  // 1-inline bool ReMutexDirect::debug_is_locked(void) const
  bool return_value = ((*(const ReMutexDirect*)local_this).debug_is_locked)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_debug_is_locked_95_comment =
  "C++ Interface:\n"
  "debug_is_locked(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the ReMutex, false otherwise.\n"
  " * This method is only intended for use in debugging, hence the method name;\n"
  " * in the ReMutexDirect case, it always returns true, since there's not a\n"
  " * reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_debug_is_locked_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_ReMutexDirect_set_name_96(PyObject *self, PyObject *arg) {
  ReMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ReMutexDirect, (void **)&local_this, "ReMutexDirect.set_name")) {
    return nullptr;
  }
  // 1-inline void ReMutexDirect::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const ReMutexDirect self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_set_name_96_comment =
  "C++ Interface:\n"
  "set_name(const ReMutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_set_name_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ReMutexDirect::clear_name(void)
 */
static PyObject *Dtool_ReMutexDirect_clear_name_97(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ReMutexDirect, (void **)&local_this, "ReMutexDirect.clear_name")) {
    return nullptr;
  }
  // 1-inline void ReMutexDirect::clear_name(void)
  ((*local_this).clear_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_clear_name_97_comment =
  "C++ Interface:\n"
  "clear_name(const ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_clear_name_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ReMutexDirect::has_name(void) const
 */
static PyObject *Dtool_ReMutexDirect_has_name_98(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  // 1-inline bool ReMutexDirect::has_name(void) const
  bool return_value = ((*(const ReMutexDirect*)local_this).has_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_has_name_98_comment =
  "C++ Interface:\n"
  "has_name(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_has_name_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string ReMutexDirect::get_name(void) const
 */
static PyObject *Dtool_ReMutexDirect_get_name_99(PyObject *self, PyObject *) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  // 1-inline std::string ReMutexDirect::get_name(void) const
  std::string return_value = ((*(const ReMutexDirect*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_get_name_99_comment =
  "C++ Interface:\n"
  "get_name(ReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_get_name_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ReMutexDirect::output(std::ostream &out) const
 */
static PyObject *Dtool_ReMutexDirect_output_100(PyObject *self, PyObject *arg) {
  ReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutexDirect)) {
    return nullptr;
  }
  // 1-void ReMutexDirect::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ReMutexDirect.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ReMutexDirect*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ReMutexDirect self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ReMutexDirect_output_100_comment =
  "C++ Interface:\n"
  "output(ReMutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in MutexDebug, but non-virtual in\n"
  " * ReMutexDirect.\n"
  " */";
#else
static const char *Dtool_ReMutexDirect_output_100_comment = nullptr;
#endif

static int Dtool_Init_ReMutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ReMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ReMutexDirect) {
    printf("ReMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ReMutexDirect *local_this = (ReMutexDirect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ReMutexDirect) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ReMutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ReMutexDirect) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ReMutex
 */
/**
 * Python function wrapper for:
 * bool ReMutex::acquire(bool blocking = true) const
 */
static PyObject *Dtool_ReMutex_acquire_104(PyObject *self, PyObject *args, PyObject *kwds) {
  ReMutex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReMutex)) {
    return nullptr;
  }
  // 1-bool ReMutex::acquire(bool blocking = true) const
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "blocking")) {
    bool return_value = invoke_extension((const ReMutex*)local_this).acquire((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "acquire(ReMutex self, bool blocking)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ReMutex_acquire_104_comment =
  "C++ Interface:\n"
  "acquire(ReMutex self, bool blocking)\n";
#else
static const char *Dtool_ReMutex_acquire_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ReMutex::__enter__(void)
 */
static PyObject *Dtool_ReMutex_enter_105(PyObject *self, PyObject *) {
  ReMutex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ReMutex, (void **)&local_this, "ReMutex.__enter__")) {
    return nullptr;
  }
  // 1-bool ReMutex::__enter__(void)
  bool return_value = invoke_extension(local_this).__enter__();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReMutex_enter_105_comment =
  "C++ Interface:\n"
  "__enter__(const ReMutex self)\n";
#else
static const char *Dtool_ReMutex_enter_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ReMutex::__exit__(PyObject *, PyObject *, PyObject *)
 */
static PyObject *Dtool_ReMutex_exit_106(PyObject *self, PyObject *args) {
  ReMutex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ReMutex, (void **)&local_this, "ReMutex.__exit__")) {
    return nullptr;
  }
  // 1-void ReMutex::__exit__(PyObject *, PyObject *, PyObject *)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  if (PyArg_UnpackTuple(args, "__exit__", 3, 3, &param1, &param2, &param3)) {
    invoke_extension(local_this).__exit__(param1, param2, param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__exit__(const ReMutex self, object param0, object param1, object param2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ReMutex_exit_106_comment =
  "C++ Interface:\n"
  "__exit__(const ReMutex self, object param0, object param1, object param2)\n";
#else
static const char *Dtool_ReMutex_exit_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ReMutex::ReMutex(void)
 * inline explicit ReMutex::ReMutex(std::string const &name)
 */
static int Dtool_Init_ReMutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ReMutex::ReMutex(void)
      ReMutex *return_value = new ReMutex();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ReMutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-inline explicit ReMutex::ReMutex(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          ReMutex *return_value = new ReMutex(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ReMutex, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ReMutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ReMutex()\n"
      "ReMutex(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ReMutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ReMutex) {
    printf("ReMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ReMutex *local_this = (ReMutex *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ReMutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReMutexDirect) {
    return (ReMutexDirect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ReMutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ReMutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReMutexDirect) {
    ReMutexDirect* other_this = (ReMutexDirect*)from_this;
    return (ReMutex*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ExternalThread
 */
/**
 * Python function wrapper for:
 * static TypeHandle ExternalThread::get_class_type(void)
 */
static PyObject *Dtool_ExternalThread_get_class_type_108(PyObject *, PyObject *) {
  // 1-static TypeHandle ExternalThread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ExternalThread::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ExternalThread_get_class_type_108_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ExternalThread_get_class_type_108_comment = nullptr;
#endif

static int Dtool_Init_ExternalThread(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ExternalThread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ExternalThread) {
    printf("ExternalThread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ExternalThread *local_this = (ExternalThread *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ExternalThread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_Thread) {
    return (Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(Thread *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ExternalThread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ExternalThread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_Thread) {
    Thread* other_this = (Thread*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ExternalThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ExternalThread*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightMutexDirect
 */
/**
 * Python function wrapper for:
 * inline void LightMutexDirect::acquire(void) const
 */
static PyObject *Dtool_LightMutexDirect_acquire_111(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightMutexDirect)) {
    return nullptr;
  }
  // 1-inline void LightMutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*(const LightMutexDirect*)local_this).acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_acquire_111_comment =
  "C++ Interface:\n"
  "acquire(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Grabs the lightMutex if it is available.  If it is not available, blocks\n"
  " * until it becomes available, then grabs it.  In either case, the function\n"
  " * does not return until the lightMutex is held; you should then call\n"
  " * unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see LightMutexHolder.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_acquire_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightMutexDirect::release(void) const
 */
static PyObject *Dtool_LightMutexDirect_release_112(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightMutexDirect)) {
    return nullptr;
  }
  // 1-inline void LightMutexDirect::release(void) const
  ((*(const LightMutexDirect*)local_this).release)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_release_112_comment =
  "C++ Interface:\n"
  "release(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the lightMutex.  It is an error to call this if the lightMutex was\n"
  " * not already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_release_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightMutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_LightMutexDirect_debug_is_locked_113(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightMutexDirect)) {
    return nullptr;
  }
  // 1-inline bool LightMutexDirect::debug_is_locked(void) const
  bool return_value = ((*(const LightMutexDirect*)local_this).debug_is_locked)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_debug_is_locked_113_comment =
  "C++ Interface:\n"
  "debug_is_locked(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the LightMutex, false\n"
  " * otherwise.  This method is only intended for use in debugging, hence the\n"
  " * method name; in the LightMutexDirect case, it always returns true, since\n"
  " * there's not a reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_debug_is_locked_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightMutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_LightMutexDirect_set_name_114(PyObject *self, PyObject *arg) {
  LightMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightMutexDirect, (void **)&local_this, "LightMutexDirect.set_name")) {
    return nullptr;
  }
  // 1-inline void LightMutexDirect::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const LightMutexDirect self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_set_name_114_comment =
  "C++ Interface:\n"
  "set_name(const LightMutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_set_name_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightMutexDirect::clear_name(void)
 */
static PyObject *Dtool_LightMutexDirect_clear_name_115(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightMutexDirect, (void **)&local_this, "LightMutexDirect.clear_name")) {
    return nullptr;
  }
  // 1-inline void LightMutexDirect::clear_name(void)
  ((*local_this).clear_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_clear_name_115_comment =
  "C++ Interface:\n"
  "clear_name(const LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_clear_name_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightMutexDirect::has_name(void) const
 */
static PyObject *Dtool_LightMutexDirect_has_name_116(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightMutexDirect)) {
    return nullptr;
  }
  // 1-inline bool LightMutexDirect::has_name(void) const
  bool return_value = ((*(const LightMutexDirect*)local_this).has_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_has_name_116_comment =
  "C++ Interface:\n"
  "has_name(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_has_name_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string LightMutexDirect::get_name(void) const
 */
static PyObject *Dtool_LightMutexDirect_get_name_117(PyObject *self, PyObject *) {
  LightMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightMutexDirect)) {
    return nullptr;
  }
  // 1-inline std::string LightMutexDirect::get_name(void) const
  std::string return_value = ((*(const LightMutexDirect*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_get_name_117_comment =
  "C++ Interface:\n"
  "get_name(LightMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_get_name_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LightMutexDirect::output(std::ostream &out) const
 */
static PyObject *Dtool_LightMutexDirect_output_118(PyObject *self, PyObject *arg) {
  LightMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightMutexDirect)) {
    return nullptr;
  }
  // 1-void LightMutexDirect::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LightMutexDirect.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LightMutexDirect*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightMutexDirect self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightMutexDirect_output_118_comment =
  "C++ Interface:\n"
  "output(LightMutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in LightMutexDebug, but non-virtual in\n"
  " * LightMutexDirect.\n"
  " */";
#else
static const char *Dtool_LightMutexDirect_output_118_comment = nullptr;
#endif

static int Dtool_Init_LightMutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LightMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightMutexDirect) {
    printf("LightMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightMutexDirect *local_this = (LightMutexDirect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightMutexDirect) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightMutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightMutexDirect) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightMutex
 */
/**
 * Python function wrapper for:
 * inline LightMutex::LightMutex(void)
 * inline explicit LightMutex::LightMutex(std::string const &name)
 */
static int Dtool_Init_LightMutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LightMutex::LightMutex(void)
      LightMutex *return_value = new LightMutex();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightMutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-inline explicit LightMutex::LightMutex(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          LightMutex *return_value = new LightMutex(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightMutex, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LightMutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LightMutex()\n"
      "LightMutex(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LightMutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightMutex) {
    printf("LightMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightMutex *local_this = (LightMutex *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightMutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LightMutexDirect) {
    return (LightMutexDirect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightMutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightMutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LightMutexDirect) {
    LightMutexDirect* other_this = (LightMutexDirect*)from_this;
    return (LightMutex*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightReMutexDirect
 */
/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::acquire(void) const
 * inline void LightReMutexDirect::acquire(Thread *current_thread) const
 */
static PyObject *Dtool_LightReMutexDirect_acquire_123(PyObject *self, PyObject *args) {
  LightReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightReMutexDirect)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void LightReMutexDirect::acquire(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*(const LightReMutexDirect*)local_this).acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void LightReMutexDirect::acquire(Thread *current_thread) const
      Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "LightReMutexDirect.acquire", false, true);
      if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*(const LightReMutexDirect*)local_this).acquire)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "acquire() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "acquire(LightReMutexDirect self)\n"
      "acquire(LightReMutexDirect self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_acquire_123_comment =
  "C++ Interface:\n"
  "acquire(LightReMutexDirect self)\n"
  "acquire(LightReMutexDirect self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Grabs the lightReMutex if it is available.  If it is not available, blocks\n"
  " * until it becomes available, then grabs it.  In either case, the function\n"
  " * does not return until the lightReMutex is held; you should then call\n"
  " * unlock().\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightReMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " *\n"
  " * Also see LightReMutexHolder.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on acquire() accepts the current thread as a parameter, if it\n"
  " * is already known, as an optimization.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_acquire_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::elevate_lock(void) const
 */
static PyObject *Dtool_LightReMutexDirect_elevate_lock_124(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightReMutexDirect)) {
    return nullptr;
  }
  // 1-inline void LightReMutexDirect::elevate_lock(void) const
  ((*(const LightReMutexDirect*)local_this).elevate_lock)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_elevate_lock_124_comment =
  "C++ Interface:\n"
  "elevate_lock(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * This method increments the lock count, assuming the calling thread already\n"
  " * holds the lock.  After this call, release() will need to be called one\n"
  " * additional time to release the lock.\n"
  " *\n"
  " * This method really performs the same function as acquire(), but it offers a\n"
  " * potential (slight) performance benefit when the calling thread knows that\n"
  " * it already holds the lock.  It is an error to call this when the calling\n"
  " * thread does not hold the lock.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_elevate_lock_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::release(void) const
 */
static PyObject *Dtool_LightReMutexDirect_release_125(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightReMutexDirect)) {
    return nullptr;
  }
  // 1-inline void LightReMutexDirect::release(void) const
  ((*(const LightReMutexDirect*)local_this).release)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_release_125_comment =
  "C++ Interface:\n"
  "release(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Releases the lightReMutex.  It is an error to call this if the lightReMutex\n"
  " * was not already locked.\n"
  " *\n"
  " * This method is considered const so that you can lock and unlock const\n"
  " * lightReMutexes, mainly to allow thread-safe access to otherwise const data.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_release_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightReMutexDirect::debug_is_locked(void) const
 */
static PyObject *Dtool_LightReMutexDirect_debug_is_locked_126(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightReMutexDirect)) {
    return nullptr;
  }
  // 1-inline bool LightReMutexDirect::debug_is_locked(void) const
  bool return_value = ((*(const LightReMutexDirect*)local_this).debug_is_locked)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_debug_is_locked_126_comment =
  "C++ Interface:\n"
  "debug_is_locked(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current thread has locked the LightReMutex, false\n"
  " * otherwise.  This method is only intended for use in debugging, hence the\n"
  " * method name; in the LightReMutexDirect case, it always returns true, since\n"
  " * there's not a reliable way to determine this otherwise.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_debug_is_locked_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::set_name(std::string const &name)
 */
static PyObject *Dtool_LightReMutexDirect_set_name_127(PyObject *self, PyObject *arg) {
  LightReMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightReMutexDirect, (void **)&local_this, "LightReMutexDirect.set_name")) {
    return nullptr;
  }
  // 1-inline void LightReMutexDirect::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const LightReMutexDirect self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_set_name_127_comment =
  "C++ Interface:\n"
  "set_name(const LightReMutexDirect self, str name)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_set_name_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LightReMutexDirect::clear_name(void)
 */
static PyObject *Dtool_LightReMutexDirect_clear_name_128(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LightReMutexDirect, (void **)&local_this, "LightReMutexDirect.clear_name")) {
    return nullptr;
  }
  // 1-inline void LightReMutexDirect::clear_name(void)
  ((*local_this).clear_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_clear_name_128_comment =
  "C++ Interface:\n"
  "clear_name(const LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_clear_name_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LightReMutexDirect::has_name(void) const
 */
static PyObject *Dtool_LightReMutexDirect_has_name_129(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightReMutexDirect)) {
    return nullptr;
  }
  // 1-inline bool LightReMutexDirect::has_name(void) const
  bool return_value = ((*(const LightReMutexDirect*)local_this).has_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_has_name_129_comment =
  "C++ Interface:\n"
  "has_name(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_has_name_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string LightReMutexDirect::get_name(void) const
 */
static PyObject *Dtool_LightReMutexDirect_get_name_130(PyObject *self, PyObject *) {
  LightReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightReMutexDirect)) {
    return nullptr;
  }
  // 1-inline std::string LightReMutexDirect::get_name(void) const
  std::string return_value = ((*(const LightReMutexDirect*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_get_name_130_comment =
  "C++ Interface:\n"
  "get_name(LightReMutexDirect self)\n"
  "\n"
  "/**\n"
  " * The mutex name is only defined when compiling in DEBUG_THREADS mode.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_get_name_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LightReMutexDirect::output(std::ostream &out) const
 */
static PyObject *Dtool_LightReMutexDirect_output_131(PyObject *self, PyObject *arg) {
  LightReMutexDirect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LightReMutexDirect)) {
    return nullptr;
  }
  // 1-void LightReMutexDirect::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LightReMutexDirect.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LightReMutexDirect*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LightReMutexDirect self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LightReMutexDirect_output_131_comment =
  "C++ Interface:\n"
  "output(LightReMutexDirect self, ostream out)\n"
  "\n"
  "/**\n"
  " * This method is declared virtual in MutexDebug, but non-virtual in\n"
  " * LightReMutexDirect.\n"
  " */";
#else
static const char *Dtool_LightReMutexDirect_output_131_comment = nullptr;
#endif

static int Dtool_Init_LightReMutexDirect(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LightReMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightReMutexDirect) {
    printf("LightReMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightReMutexDirect *local_this = (LightReMutexDirect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightReMutexDirect) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightReMutexDirect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightReMutexDirect) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightReMutex
 */
/**
 * Python function wrapper for:
 * inline LightReMutex::LightReMutex(void)
 * inline explicit LightReMutex::LightReMutex(std::string const &name)
 */
static int Dtool_Init_LightReMutex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LightReMutex::LightReMutex(void)
      LightReMutex *return_value = new LightReMutex();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightReMutex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-inline explicit LightReMutex::LightReMutex(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          LightReMutex *return_value = new LightReMutex(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightReMutex, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LightReMutex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LightReMutex()\n"
      "LightReMutex(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LightReMutex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightReMutex) {
    printf("LightReMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightReMutex *local_this = (LightReMutex *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightReMutex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LightReMutexDirect) {
    return (LightReMutexDirect *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightReMutex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightReMutex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LightReMutexDirect) {
    LightReMutexDirect* other_this = (LightReMutexDirect*)from_this;
    return (LightReMutex*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MainThread
 */
/**
 * Python function wrapper for:
 * static TypeHandle MainThread::get_class_type(void)
 */
static PyObject *Dtool_MainThread_get_class_type_136(PyObject *, PyObject *) {
  // 1-static TypeHandle MainThread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MainThread::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MainThread_get_class_type_136_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MainThread_get_class_type_136_comment = nullptr;
#endif

static int Dtool_Init_MainThread(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MainThread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MainThread) {
    printf("MainThread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MainThread *local_this = (MainThread *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MainThread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_Thread) {
    return (Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(Thread *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MainThread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MainThread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_Thread) {
    Thread* other_this = (Thread*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MainThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (MainThread*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Semaphore
 */
/**
 * Python function wrapper for:
 * inline void Semaphore::acquire(void)
 */
static PyObject *Dtool_Semaphore_acquire_141(PyObject *self, PyObject *) {
  Semaphore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Semaphore, (void **)&local_this, "Semaphore.acquire")) {
    return nullptr;
  }
  // 1-inline void Semaphore::acquire(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_acquire_141_comment =
  "C++ Interface:\n"
  "acquire(const Semaphore self)\n"
  "\n"
  "/**\n"
  " * Decrements the internal count.  If the count was already at zero, blocks\n"
  " * until the count is nonzero, then decrements it.\n"
  " */";
#else
static const char *Dtool_Semaphore_acquire_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Semaphore::try_acquire(void)
 */
static PyObject *Dtool_Semaphore_try_acquire_142(PyObject *self, PyObject *) {
  Semaphore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Semaphore, (void **)&local_this, "Semaphore.try_acquire")) {
    return nullptr;
  }
  // 1-inline bool Semaphore::try_acquire(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).try_acquire)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_try_acquire_142_comment =
  "C++ Interface:\n"
  "try_acquire(const Semaphore self)\n"
  "\n"
  "/**\n"
  " * If the semaphore can be acquired without blocking, does so and returns\n"
  " * true.  Otherwise, returns false.\n"
  " */";
#else
static const char *Dtool_Semaphore_try_acquire_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Semaphore::release(void)
 */
static PyObject *Dtool_Semaphore_release_143(PyObject *self, PyObject *) {
  Semaphore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Semaphore, (void **)&local_this, "Semaphore.release")) {
    return nullptr;
  }
  // 1-inline int Semaphore::release(void)
  int return_value = ((*local_this).release)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_release_143_comment =
  "C++ Interface:\n"
  "release(const Semaphore self)\n"
  "\n"
  "/**\n"
  " * Increments the semaphore's internal count.  This may wake up another thread\n"
  " * blocked on acquire().\n"
  " *\n"
  " * Returns the count of the semaphore upon release.\n"
  " */";
#else
static const char *Dtool_Semaphore_release_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Semaphore::get_count(void) const
 */
static PyObject *Dtool_Semaphore_get_count_144(PyObject *self, PyObject *) {
  Semaphore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Semaphore)) {
    return nullptr;
  }
  // 1-inline int Semaphore::get_count(void) const
  int return_value = ((*(const Semaphore*)local_this).get_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_get_count_144_comment =
  "C++ Interface:\n"
  "get_count(Semaphore self)\n"
  "\n"
  "/**\n"
  " * Returns the current semaphore count.  Note that this call is not thread-\n"
  " * safe (the count may change at any time).\n"
  " */";
#else
static const char *Dtool_Semaphore_get_count_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Semaphore::output(std::ostream &out) const
 */
static PyObject *Dtool_Semaphore_output_145(PyObject *self, PyObject *arg) {
  Semaphore *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Semaphore)) {
    return nullptr;
  }
  // 1-void Semaphore::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Semaphore.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Semaphore*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Semaphore self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Semaphore_output_145_comment =
  "C++ Interface:\n"
  "output(Semaphore self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Semaphore_output_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit Semaphore::Semaphore(int initial_count = 1)
 */
static int Dtool_Init_Semaphore(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline explicit Semaphore::Semaphore(int initial_count = 1)
  int param0 = 1;
  static const char *keyword_list[] = {"initial_count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:Semaphore", (char **)keyword_list, &param0)) {
    Semaphore *return_value = new Semaphore((int)param0);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Semaphore, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Semaphore(int initial_count)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Semaphore(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Semaphore) {
    printf("Semaphore ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Semaphore *local_this = (Semaphore *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Semaphore) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Semaphore(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Semaphore) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PythonThread
 */
/**
 * Python function wrapper for:
 * PyObject *PythonThread::join(void)
 */
static PyObject *Dtool_PythonThread_join_148(PyObject *self, PyObject *) {
  PythonThread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonThread, (void **)&local_this, "PythonThread.join")) {
    return nullptr;
  }
  // 1-PyObject *PythonThread::join(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PyObject *return_value = ((*local_this).join)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonThread_join_148_comment =
  "C++ Interface:\n"
  "join(const PythonThread self)\n";
#else
static const char *Dtool_PythonThread_join_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PythonThread::get_class_type(void)
 */
static PyObject *Dtool_PythonThread_get_class_type_155(PyObject *, PyObject *) {
  // 1-static TypeHandle PythonThread::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PythonThread::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PythonThread_get_class_type_155_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PythonThread_get_class_type_155_comment = nullptr;
#endif

static PyObject *Dtool_PythonThread_args_Getter(PyObject *self, void *) {
  const PythonThread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonThread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PyObject *PythonThread::get_args(void) const
  PyObject *return_value = ((*(const PythonThread*)local_this).get_args)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonThread_args_Setter(PyObject *self, PyObject *arg, void *) {
  PythonThread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonThread, (void **)&local_this, "PythonThread.args")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete args attribute");
    return -1;
  }
  // 1-void PythonThread::set_args(PyObject *)
  ((*local_this).set_args)(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_args(const PythonThread self, object param0)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &name, std::string const &sync_name)
 */
static int Dtool_Init_PythonThread(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &name, std::string const &sync_name)
  PyObject *param0;
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"function", "args", "name", "sync_name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#s#:PythonThread", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len)) {
    PythonThread *return_value = new PythonThread(param0, param1, std::string(param2_str, param2_len), std::string(param3_str, param3_len));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonThread, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PythonThread(object function, object args, str name, str sync_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PythonThread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PythonThread) {
    printf("PythonThread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PythonThread *local_this = (PythonThread *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PythonThread) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_Thread) {
    return (Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(Thread *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(Thread *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PythonThread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PythonThread) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_Thread) {
    Thread* other_this = (Thread*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PythonThread*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PythonThread*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for Thread (Thread)
 */
static PyMethodDef Dtool_Methods_Thread[] = {
  {"bind_thread", (PyCFunction) &Dtool_Thread_bind_thread_10, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Thread_bind_thread_10_comment},
  {"bindThread", (PyCFunction) &Dtool_Thread_bind_thread_10, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Thread_bind_thread_10_comment},
  {"get_sync_name", &Dtool_Thread_get_sync_name_11, METH_NOARGS, (const char *)Dtool_Thread_get_sync_name_11_comment},
  {"getSyncName", &Dtool_Thread_get_sync_name_11, METH_NOARGS, (const char *)Dtool_Thread_get_sync_name_11_comment},
  {"get_pstats_index", &Dtool_Thread_get_pstats_index_12, METH_NOARGS, (const char *)Dtool_Thread_get_pstats_index_12_comment},
  {"getPstatsIndex", &Dtool_Thread_get_pstats_index_12, METH_NOARGS, (const char *)Dtool_Thread_get_pstats_index_12_comment},
  {"get_python_index", &Dtool_Thread_get_python_index_13, METH_NOARGS, (const char *)Dtool_Thread_get_python_index_13_comment},
  {"getPythonIndex", &Dtool_Thread_get_python_index_13, METH_NOARGS, (const char *)Dtool_Thread_get_python_index_13_comment},
  {"get_unique_id", &Dtool_Thread_get_unique_id_14, METH_NOARGS, (const char *)Dtool_Thread_get_unique_id_14_comment},
  {"getUniqueId", &Dtool_Thread_get_unique_id_14, METH_NOARGS, (const char *)Dtool_Thread_get_unique_id_14_comment},
  {"get_pipeline_stage", &Dtool_Thread_get_pipeline_stage_15, METH_NOARGS, (const char *)Dtool_Thread_get_pipeline_stage_15_comment},
  {"getPipelineStage", &Dtool_Thread_get_pipeline_stage_15, METH_NOARGS, (const char *)Dtool_Thread_get_pipeline_stage_15_comment},
  {"set_pipeline_stage", &Dtool_Thread_set_pipeline_stage_16, METH_O, (const char *)Dtool_Thread_set_pipeline_stage_16_comment},
  {"setPipelineStage", &Dtool_Thread_set_pipeline_stage_16, METH_O, (const char *)Dtool_Thread_set_pipeline_stage_16_comment},
  {"set_min_pipeline_stage", &Dtool_Thread_set_min_pipeline_stage_17, METH_O, (const char *)Dtool_Thread_set_min_pipeline_stage_17_comment},
  {"setMinPipelineStage", &Dtool_Thread_set_min_pipeline_stage_17, METH_O, (const char *)Dtool_Thread_set_min_pipeline_stage_17_comment},
  {"get_main_thread", &Dtool_Thread_get_main_thread_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_main_thread_18_comment},
  {"getMainThread", &Dtool_Thread_get_main_thread_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_main_thread_18_comment},
  {"get_external_thread", &Dtool_Thread_get_external_thread_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_external_thread_19_comment},
  {"getExternalThread", &Dtool_Thread_get_external_thread_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_external_thread_19_comment},
  {"get_current_thread", &Dtool_Thread_get_current_thread_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_thread_20_comment},
  {"getCurrentThread", &Dtool_Thread_get_current_thread_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_thread_20_comment},
  {"get_current_pipeline_stage", &Dtool_Thread_get_current_pipeline_stage_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_pipeline_stage_21_comment},
  {"getCurrentPipelineStage", &Dtool_Thread_get_current_pipeline_stage_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_current_pipeline_stage_21_comment},
  {"is_threading_supported", &Dtool_Thread_is_threading_supported_22, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_threading_supported_22_comment},
  {"isThreadingSupported", &Dtool_Thread_is_threading_supported_22, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_threading_supported_22_comment},
  {"is_true_threads", &Dtool_Thread_is_true_threads_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_true_threads_23_comment},
  {"isTrueThreads", &Dtool_Thread_is_true_threads_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_true_threads_23_comment},
  {"is_simple_threads", &Dtool_Thread_is_simple_threads_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_simple_threads_24_comment},
  {"isSimpleThreads", &Dtool_Thread_is_simple_threads_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_is_simple_threads_24_comment},
  {"sleep", &Dtool_Thread_sleep_25, METH_O | METH_STATIC, (const char *)Dtool_Thread_sleep_25_comment},
  {"force_yield", &Dtool_Thread_force_yield_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_force_yield_26_comment},
  {"forceYield", &Dtool_Thread_force_yield_26, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_force_yield_26_comment},
  {"consider_yield", &Dtool_Thread_consider_yield_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_consider_yield_27_comment},
  {"considerYield", &Dtool_Thread_consider_yield_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_consider_yield_27_comment},
  {"output", &Dtool_Thread_output_28, METH_O, (const char *)Dtool_Thread_output_28_comment},
  {"output_blocker", &Dtool_Thread_output_blocker_29, METH_O, (const char *)Dtool_Thread_output_blocker_29_comment},
  {"outputBlocker", &Dtool_Thread_output_blocker_29, METH_O, (const char *)Dtool_Thread_output_blocker_29_comment},
  {"write_status", &Dtool_Thread_write_status_30, METH_O | METH_STATIC, (const char *)Dtool_Thread_write_status_30_comment},
  {"writeStatus", &Dtool_Thread_write_status_30, METH_O | METH_STATIC, (const char *)Dtool_Thread_write_status_30_comment},
  {"is_started", &Dtool_Thread_is_started_31, METH_NOARGS, (const char *)Dtool_Thread_is_started_31_comment},
  {"isStarted", &Dtool_Thread_is_started_31, METH_NOARGS, (const char *)Dtool_Thread_is_started_31_comment},
  {"is_joinable", &Dtool_Thread_is_joinable_32, METH_NOARGS, (const char *)Dtool_Thread_is_joinable_32_comment},
  {"isJoinable", &Dtool_Thread_is_joinable_32, METH_NOARGS, (const char *)Dtool_Thread_is_joinable_32_comment},
  {"start", (PyCFunction) &Dtool_Thread_start_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Thread_start_33_comment},
  {"join", &Dtool_Thread_join_34, METH_NOARGS, (const char *)Dtool_Thread_join_34_comment},
  {"preempt", &Dtool_Thread_preempt_35, METH_NOARGS, (const char *)Dtool_Thread_preempt_35_comment},
  {"get_current_task", &Dtool_Thread_get_current_task_36, METH_NOARGS, (const char *)Dtool_Thread_get_current_task_36_comment},
  {"getCurrentTask", &Dtool_Thread_get_current_task_36, METH_NOARGS, (const char *)Dtool_Thread_get_current_task_36_comment},
  {"set_python_index", &Dtool_Thread_set_python_index_37, METH_O, (const char *)Dtool_Thread_set_python_index_37_comment},
  {"setPythonIndex", &Dtool_Thread_set_python_index_37, METH_O, (const char *)Dtool_Thread_set_python_index_37_comment},
  {"prepare_for_exit", &Dtool_Thread_prepare_for_exit_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_prepare_for_exit_38_comment},
  {"prepareForExit", &Dtool_Thread_prepare_for_exit_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_prepare_for_exit_38_comment},
  {"get_class_type", &Dtool_Thread_get_class_type_61, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_class_type_61_comment},
  {"getClassType", &Dtool_Thread_get_class_type_61, METH_NOARGS | METH_STATIC, (const char *)Dtool_Thread_get_class_type_61_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_Thread_upcast_to_TypedReferenceCount_4, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_TypedReferenceCount_4_comment},
  {"upcastToTypedReferenceCount", &Dtool_Thread_upcast_to_TypedReferenceCount_4, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_TypedReferenceCount_4_comment},
  {"upcast_to_Namable", &Dtool_Thread_upcast_to_Namable_7, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_Namable_7_comment},
  {"upcastToNamable", &Dtool_Thread_upcast_to_Namable_7, METH_NOARGS, (const char *)Dtool_Thread_upcast_to_Namable_7_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Thread
//////////////////
static PyObject *Dtool_Repr_Thread(PyObject *self) {
  Thread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Thread, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Thread[] = {
  {(char *)"sync_name", &Dtool_Thread_sync_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"pstats_index", &Dtool_Thread_pstats_index_Getter, nullptr, nullptr, nullptr},
  {(char *)"python_index", &Dtool_Thread_python_index_Getter, nullptr, nullptr, nullptr},
  {(char *)"unique_id", &Dtool_Thread_unique_id_Getter, nullptr, nullptr, nullptr},
  {(char *)"pipeline_stage", &Dtool_Thread_pipeline_stage_Getter, &Dtool_Thread_pipeline_stage_Setter, nullptr, nullptr},
  {(char *)"started", &Dtool_Thread_started_Getter, nullptr, nullptr, nullptr},
  {(char *)"joinable", &Dtool_Thread_joinable_Getter, nullptr, nullptr, nullptr},
  {(char *)"current_task", &Dtool_Thread_current_task_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Thread = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Thread = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Thread = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Thread = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Thread = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Thread = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Thread",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Thread,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Thread,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Thread,
    &Dtool_NumberMethods_Thread,
    &Dtool_SequenceMethods_Thread,
    &Dtool_MappingMethods_Thread,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_Thread,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Thread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A thread; that is, a lightweight process.  This is an abstract base class;\n"
    " * to use it, you must subclass from it and redefine thread_main().\n"
    " *\n"
    " * The thread itself will keep a reference count on the Thread object while it\n"
    " * is running; when the thread returns from its root function, the Thread\n"
    " * object will automatically be destructed if no other pointers are\n"
    " * referencing it.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Thread,
    nullptr, // tp_members
    Dtool_Properties_Thread,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Thread,
    PyType_GenericAlloc,
    Dtool_new_Thread,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Thread,
  Dtool_UpcastInterface_Thread,
  Dtool_DowncastInterface_Thread,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Thread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_Thread._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_Thread._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Thread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_main_thread = {(char *)"main_thread", &Dtool_Thread_main_thread_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "main_thread", Dtool_NewStaticProperty(&Dtool_Thread._PyType, &def_main_thread));
    static const PyGetSetDef def_external_thread = {(char *)"external_thread", &Dtool_Thread_external_thread_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "external_thread", Dtool_NewStaticProperty(&Dtool_Thread._PyType, &def_external_thread));
    static const PyGetSetDef def_current_thread = {(char *)"current_thread", &Dtool_Thread_current_thread_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "current_thread", Dtool_NewStaticProperty(&Dtool_Thread._PyType, &def_current_thread));
    static const PyGetSetDef def_current_pipeline_stage = {(char *)"current_pipeline_stage", &Dtool_Thread_current_pipeline_stage_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "current_pipeline_stage", Dtool_NewStaticProperty(&Dtool_Thread._PyType, &def_current_pipeline_stage));
    static const PyGetSetDef def_threading_supported = {(char *)"threading_supported", &Dtool_Thread_threading_supported_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "threading_supported", Dtool_NewStaticProperty(&Dtool_Thread._PyType, &def_threading_supported));
    static const PyGetSetDef def_true_threads = {(char *)"true_threads", &Dtool_Thread_true_threads_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "true_threads", Dtool_NewStaticProperty(&Dtool_Thread._PyType, &def_true_threads));
    static const PyGetSetDef def_simple_threads = {(char *)"simple_threads", &Dtool_Thread_simple_threads_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "simple_threads", Dtool_NewStaticProperty(&Dtool_Thread._PyType, &def_simple_threads));
    if (PyType_Ready((PyTypeObject *)&Dtool_Thread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Thread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Thread);
  }
}

/**
 * Python method tables for MutexDirect (MutexDirect)
 */
static PyMethodDef Dtool_Methods_MutexDirect[] = {
  {"acquire", &Dtool_MutexDirect_acquire_63, METH_NOARGS, (const char *)Dtool_MutexDirect_acquire_63_comment},
  {"try_acquire", &Dtool_MutexDirect_try_acquire_64, METH_NOARGS, (const char *)Dtool_MutexDirect_try_acquire_64_comment},
  {"tryAcquire", &Dtool_MutexDirect_try_acquire_64, METH_NOARGS, (const char *)Dtool_MutexDirect_try_acquire_64_comment},
  {"release", &Dtool_MutexDirect_release_65, METH_NOARGS, (const char *)Dtool_MutexDirect_release_65_comment},
  {"debug_is_locked", &Dtool_MutexDirect_debug_is_locked_66, METH_NOARGS, (const char *)Dtool_MutexDirect_debug_is_locked_66_comment},
  {"debugIsLocked", &Dtool_MutexDirect_debug_is_locked_66, METH_NOARGS, (const char *)Dtool_MutexDirect_debug_is_locked_66_comment},
  {"set_name", &Dtool_MutexDirect_set_name_67, METH_O, (const char *)Dtool_MutexDirect_set_name_67_comment},
  {"setName", &Dtool_MutexDirect_set_name_67, METH_O, (const char *)Dtool_MutexDirect_set_name_67_comment},
  {"clear_name", &Dtool_MutexDirect_clear_name_68, METH_NOARGS, (const char *)Dtool_MutexDirect_clear_name_68_comment},
  {"clearName", &Dtool_MutexDirect_clear_name_68, METH_NOARGS, (const char *)Dtool_MutexDirect_clear_name_68_comment},
  {"has_name", &Dtool_MutexDirect_has_name_69, METH_NOARGS, (const char *)Dtool_MutexDirect_has_name_69_comment},
  {"hasName", &Dtool_MutexDirect_has_name_69, METH_NOARGS, (const char *)Dtool_MutexDirect_has_name_69_comment},
  {"get_name", &Dtool_MutexDirect_get_name_70, METH_NOARGS, (const char *)Dtool_MutexDirect_get_name_70_comment},
  {"getName", &Dtool_MutexDirect_get_name_70, METH_NOARGS, (const char *)Dtool_MutexDirect_get_name_70_comment},
  {"output", &Dtool_MutexDirect_output_71, METH_O, (const char *)Dtool_MutexDirect_output_71_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     MutexDirect
//////////////////
static PyObject *Dtool_Repr_MutexDirect(PyObject *self) {
  MutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MutexDirect, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MutexDirect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_MutexDirect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MutexDirect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MutexDirect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_MutexDirect,
    &Dtool_NumberMethods_MutexDirect,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_MutexDirect,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a standard mutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MutexDirect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MutexDirect,
    PyType_GenericAlloc,
    Dtool_new_MutexDirect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MutexDirect,
  Dtool_UpcastInterface_MutexDirect,
  Dtool_DowncastInterface_MutexDirect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MutexDirect);
  }
}

/**
 * Python method tables for Mutex (Mutex)
 */
static PyMethodDef Dtool_Methods_Mutex[] = {
  {"acquire", (PyCFunction) &Dtool_Mutex_acquire_75, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Mutex_acquire_75_comment},
  {"__enter__", &Dtool_Mutex_enter_76, METH_NOARGS, (const char *)Dtool_Mutex_enter_76_comment},
  {"Enter", &Dtool_Mutex_enter_76, METH_NOARGS, (const char *)Dtool_Mutex_enter_76_comment},
  {"__exit__", &Dtool_Mutex_exit_77, METH_VARARGS, (const char *)Dtool_Mutex_exit_77_comment},
  {"Exit", &Dtool_Mutex_exit_77, METH_VARARGS, (const char *)Dtool_Mutex_exit_77_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Mutex = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Mutex = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Mutex = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Mutex = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Mutex = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Mutex = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Mutex",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Mutex,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Mutex,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Mutex,
    &Dtool_SequenceMethods_Mutex,
    &Dtool_MappingMethods_Mutex,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Mutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Mutex,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Mutex,
    PyType_GenericAlloc,
    Dtool_new_Mutex,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Mutex,
  Dtool_UpcastInterface_Mutex,
  Dtool_DowncastInterface_Mutex,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Mutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MutexDirect(nullptr);
    Dtool_Mutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MutexDirect);
    Dtool_Mutex._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Mutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Mutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Mutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Mutex);
  }
}

/**
 * Python method tables for ConditionVarDirect (ConditionVarDirect)
 */
static PyMethodDef Dtool_Methods_ConditionVarDirect[] = {
  {"get_mutex", &Dtool_ConditionVarDirect_get_mutex_80, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_get_mutex_80_comment},
  {"getMutex", &Dtool_ConditionVarDirect_get_mutex_80, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_get_mutex_80_comment},
  {"wait", &Dtool_ConditionVarDirect_wait_81, METH_VARARGS, (const char *)Dtool_ConditionVarDirect_wait_81_comment},
  {"notify", &Dtool_ConditionVarDirect_notify_82, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_notify_82_comment},
  {"notify_all", &Dtool_ConditionVarDirect_notify_all_83, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_notify_all_83_comment},
  {"notifyAll", &Dtool_ConditionVarDirect_notify_all_83, METH_NOARGS, (const char *)Dtool_ConditionVarDirect_notify_all_83_comment},
  {"output", &Dtool_ConditionVarDirect_output_84, METH_O, (const char *)Dtool_ConditionVarDirect_output_84_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConditionVarDirect
//////////////////
static PyObject *Dtool_Repr_ConditionVarDirect(PyObject *self) {
  ConditionVarDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConditionVarDirect, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConditionVarDirect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConditionVarDirect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConditionVarDirect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConditionVarDirect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConditionVarDirect,
    &Dtool_NumberMethods_ConditionVarDirect,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_ConditionVarDirect,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A condition variable, usually used to communicate information about\n"
    " * changing state to a thread that is waiting for something to happen.  A\n"
    " * condition variable can be used to \"wake up\" a thread when some arbitrary\n"
    " * condition has changed.\n"
    " *\n"
    " * A condition variable is associated with a single mutex, and several\n"
    " * condition variables may share the same mutex.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConditionVarDirect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConditionVarDirect,
    PyType_GenericAlloc,
    Dtool_new_ConditionVarDirect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConditionVarDirect,
  Dtool_UpcastInterface_ConditionVarDirect,
  Dtool_DowncastInterface_ConditionVarDirect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConditionVarDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConditionVarDirect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConditionVarDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConditionVarDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConditionVarDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConditionVarDirect);
  }
}

/**
 * Python method tables for ConditionVar (ConditionVar)
 */
static PyMethodDef Dtool_Methods_ConditionVar[] = {
  {"get_mutex", &Dtool_ConditionVar_get_mutex_88, METH_NOARGS, (const char *)Dtool_ConditionVar_get_mutex_88_comment},
  {"getMutex", &Dtool_ConditionVar_get_mutex_88, METH_NOARGS, (const char *)Dtool_ConditionVar_get_mutex_88_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ConditionVar = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConditionVar = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConditionVar = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConditionVar = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConditionVar = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConditionVar = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConditionVar",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConditionVar,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConditionVar,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConditionVar,
    &Dtool_SequenceMethods_ConditionVar,
    &Dtool_MappingMethods_ConditionVar,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConditionVar,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConditionVar,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConditionVar,
    PyType_GenericAlloc,
    Dtool_new_ConditionVar,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConditionVar,
  Dtool_UpcastInterface_ConditionVar,
  Dtool_DowncastInterface_ConditionVar,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConditionVar(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConditionVarDirect(nullptr);
    Dtool_ConditionVar._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConditionVarDirect);
    Dtool_ConditionVar._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConditionVar._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConditionVar) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConditionVar)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConditionVar);
  }
}

/**
 * Python method tables for ReMutexDirect (ReMutexDirect)
 */
static PyMethodDef Dtool_Methods_ReMutexDirect[] = {
  {"acquire", &Dtool_ReMutexDirect_acquire_91, METH_VARARGS, (const char *)Dtool_ReMutexDirect_acquire_91_comment},
  {"try_acquire", &Dtool_ReMutexDirect_try_acquire_92, METH_VARARGS, (const char *)Dtool_ReMutexDirect_try_acquire_92_comment},
  {"tryAcquire", &Dtool_ReMutexDirect_try_acquire_92, METH_VARARGS, (const char *)Dtool_ReMutexDirect_try_acquire_92_comment},
  {"elevate_lock", &Dtool_ReMutexDirect_elevate_lock_93, METH_NOARGS, (const char *)Dtool_ReMutexDirect_elevate_lock_93_comment},
  {"elevateLock", &Dtool_ReMutexDirect_elevate_lock_93, METH_NOARGS, (const char *)Dtool_ReMutexDirect_elevate_lock_93_comment},
  {"release", &Dtool_ReMutexDirect_release_94, METH_NOARGS, (const char *)Dtool_ReMutexDirect_release_94_comment},
  {"debug_is_locked", &Dtool_ReMutexDirect_debug_is_locked_95, METH_NOARGS, (const char *)Dtool_ReMutexDirect_debug_is_locked_95_comment},
  {"debugIsLocked", &Dtool_ReMutexDirect_debug_is_locked_95, METH_NOARGS, (const char *)Dtool_ReMutexDirect_debug_is_locked_95_comment},
  {"set_name", &Dtool_ReMutexDirect_set_name_96, METH_O, (const char *)Dtool_ReMutexDirect_set_name_96_comment},
  {"setName", &Dtool_ReMutexDirect_set_name_96, METH_O, (const char *)Dtool_ReMutexDirect_set_name_96_comment},
  {"clear_name", &Dtool_ReMutexDirect_clear_name_97, METH_NOARGS, (const char *)Dtool_ReMutexDirect_clear_name_97_comment},
  {"clearName", &Dtool_ReMutexDirect_clear_name_97, METH_NOARGS, (const char *)Dtool_ReMutexDirect_clear_name_97_comment},
  {"has_name", &Dtool_ReMutexDirect_has_name_98, METH_NOARGS, (const char *)Dtool_ReMutexDirect_has_name_98_comment},
  {"hasName", &Dtool_ReMutexDirect_has_name_98, METH_NOARGS, (const char *)Dtool_ReMutexDirect_has_name_98_comment},
  {"get_name", &Dtool_ReMutexDirect_get_name_99, METH_NOARGS, (const char *)Dtool_ReMutexDirect_get_name_99_comment},
  {"getName", &Dtool_ReMutexDirect_get_name_99, METH_NOARGS, (const char *)Dtool_ReMutexDirect_get_name_99_comment},
  {"output", &Dtool_ReMutexDirect_output_100, METH_O, (const char *)Dtool_ReMutexDirect_output_100_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ReMutexDirect
//////////////////
static PyObject *Dtool_Repr_ReMutexDirect(PyObject *self) {
  ReMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReMutexDirect, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ReMutexDirect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ReMutexDirect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ReMutexDirect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ReMutexDirect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ReMutexDirect,
    &Dtool_NumberMethods_ReMutexDirect,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_ReMutexDirect,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a standard reMutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ReMutexDirect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ReMutexDirect,
    PyType_GenericAlloc,
    Dtool_new_ReMutexDirect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ReMutexDirect,
  Dtool_UpcastInterface_ReMutexDirect,
  Dtool_DowncastInterface_ReMutexDirect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ReMutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReMutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ReMutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ReMutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ReMutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ReMutexDirect);
  }
}

/**
 * Python method tables for ReMutex (ReMutex)
 */
static PyMethodDef Dtool_Methods_ReMutex[] = {
  {"acquire", (PyCFunction) &Dtool_ReMutex_acquire_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ReMutex_acquire_104_comment},
  {"__enter__", &Dtool_ReMutex_enter_105, METH_NOARGS, (const char *)Dtool_ReMutex_enter_105_comment},
  {"Enter", &Dtool_ReMutex_enter_105, METH_NOARGS, (const char *)Dtool_ReMutex_enter_105_comment},
  {"__exit__", &Dtool_ReMutex_exit_106, METH_VARARGS, (const char *)Dtool_ReMutex_exit_106_comment},
  {"Exit", &Dtool_ReMutex_exit_106, METH_VARARGS, (const char *)Dtool_ReMutex_exit_106_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ReMutex = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ReMutex = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ReMutex = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ReMutex = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ReMutex = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ReMutex = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ReMutex",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ReMutex,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ReMutex,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ReMutex,
    &Dtool_SequenceMethods_ReMutex,
    &Dtool_MappingMethods_ReMutex,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ReMutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ReMutex,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ReMutex,
    PyType_GenericAlloc,
    Dtool_new_ReMutex,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ReMutex,
  Dtool_UpcastInterface_ReMutex,
  Dtool_DowncastInterface_ReMutex,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ReMutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReMutexDirect(nullptr);
    Dtool_ReMutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReMutexDirect);
    Dtool_ReMutex._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ReMutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ReMutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ReMutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ReMutex);
  }
}

/**
 * Python method tables for ExternalThread (ExternalThread)
 */
static PyMethodDef Dtool_Methods_ExternalThread[] = {
  {"get_class_type", &Dtool_ExternalThread_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExternalThread_get_class_type_108_comment},
  {"getClassType", &Dtool_ExternalThread_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExternalThread_get_class_type_108_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ExternalThread = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ExternalThread = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ExternalThread = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ExternalThread = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ExternalThread = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ExternalThread = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ExternalThread",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ExternalThread,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ExternalThread,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ExternalThread,
    &Dtool_SequenceMethods_ExternalThread,
    &Dtool_MappingMethods_ExternalThread,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ExternalThread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The special \"external thread\" class.  There is one instance of these in the\n"
    " * world, and it is returned by Thread::get_external_thread().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ExternalThread,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ExternalThread,
    PyType_GenericAlloc,
    Dtool_new_ExternalThread,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ExternalThread,
  Dtool_UpcastInterface_ExternalThread,
  Dtool_DowncastInterface_ExternalThread,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ExternalThread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Thread(nullptr);
    Dtool_ExternalThread._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Thread);
    Dtool_ExternalThread._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ExternalThread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ExternalThread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ExternalThread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ExternalThread);
  }
}

/**
 * Python method tables for LightMutexDirect (LightMutexDirect)
 */
static PyMethodDef Dtool_Methods_LightMutexDirect[] = {
  {"acquire", &Dtool_LightMutexDirect_acquire_111, METH_NOARGS, (const char *)Dtool_LightMutexDirect_acquire_111_comment},
  {"release", &Dtool_LightMutexDirect_release_112, METH_NOARGS, (const char *)Dtool_LightMutexDirect_release_112_comment},
  {"debug_is_locked", &Dtool_LightMutexDirect_debug_is_locked_113, METH_NOARGS, (const char *)Dtool_LightMutexDirect_debug_is_locked_113_comment},
  {"debugIsLocked", &Dtool_LightMutexDirect_debug_is_locked_113, METH_NOARGS, (const char *)Dtool_LightMutexDirect_debug_is_locked_113_comment},
  {"set_name", &Dtool_LightMutexDirect_set_name_114, METH_O, (const char *)Dtool_LightMutexDirect_set_name_114_comment},
  {"setName", &Dtool_LightMutexDirect_set_name_114, METH_O, (const char *)Dtool_LightMutexDirect_set_name_114_comment},
  {"clear_name", &Dtool_LightMutexDirect_clear_name_115, METH_NOARGS, (const char *)Dtool_LightMutexDirect_clear_name_115_comment},
  {"clearName", &Dtool_LightMutexDirect_clear_name_115, METH_NOARGS, (const char *)Dtool_LightMutexDirect_clear_name_115_comment},
  {"has_name", &Dtool_LightMutexDirect_has_name_116, METH_NOARGS, (const char *)Dtool_LightMutexDirect_has_name_116_comment},
  {"hasName", &Dtool_LightMutexDirect_has_name_116, METH_NOARGS, (const char *)Dtool_LightMutexDirect_has_name_116_comment},
  {"get_name", &Dtool_LightMutexDirect_get_name_117, METH_NOARGS, (const char *)Dtool_LightMutexDirect_get_name_117_comment},
  {"getName", &Dtool_LightMutexDirect_get_name_117, METH_NOARGS, (const char *)Dtool_LightMutexDirect_get_name_117_comment},
  {"output", &Dtool_LightMutexDirect_output_118, METH_O, (const char *)Dtool_LightMutexDirect_output_118_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     LightMutexDirect
//////////////////
static PyObject *Dtool_Repr_LightMutexDirect(PyObject *self) {
  LightMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightMutexDirect, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LightMutexDirect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LightMutexDirect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightMutexDirect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightMutexDirect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LightMutexDirect,
    &Dtool_NumberMethods_LightMutexDirect,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_LightMutexDirect,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a lightweight Mutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightMutexDirect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightMutexDirect,
    PyType_GenericAlloc,
    Dtool_new_LightMutexDirect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightMutexDirect,
  Dtool_UpcastInterface_LightMutexDirect,
  Dtool_DowncastInterface_LightMutexDirect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightMutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LightMutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightMutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightMutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightMutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightMutexDirect);
  }
}

/**
 * Python method tables for LightMutex (LightMutex)
 */
static PyMethodDef Dtool_Methods_LightMutex[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LightMutex = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightMutex = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightMutex = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightMutex = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightMutex = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightMutex = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightMutex",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightMutex,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightMutex,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LightMutex,
    &Dtool_SequenceMethods_LightMutex,
    &Dtool_MappingMethods_LightMutex,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightMutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightMutex,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightMutex,
    PyType_GenericAlloc,
    Dtool_new_LightMutex,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightMutex,
  Dtool_UpcastInterface_LightMutex,
  Dtool_DowncastInterface_LightMutex,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightMutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightMutexDirect(nullptr);
    Dtool_LightMutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightMutexDirect);
    Dtool_LightMutex._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightMutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightMutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightMutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightMutex);
  }
}

/**
 * Python method tables for LightReMutexDirect (LightReMutexDirect)
 */
static PyMethodDef Dtool_Methods_LightReMutexDirect[] = {
  {"acquire", &Dtool_LightReMutexDirect_acquire_123, METH_VARARGS, (const char *)Dtool_LightReMutexDirect_acquire_123_comment},
  {"elevate_lock", &Dtool_LightReMutexDirect_elevate_lock_124, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_elevate_lock_124_comment},
  {"elevateLock", &Dtool_LightReMutexDirect_elevate_lock_124, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_elevate_lock_124_comment},
  {"release", &Dtool_LightReMutexDirect_release_125, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_release_125_comment},
  {"debug_is_locked", &Dtool_LightReMutexDirect_debug_is_locked_126, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_debug_is_locked_126_comment},
  {"debugIsLocked", &Dtool_LightReMutexDirect_debug_is_locked_126, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_debug_is_locked_126_comment},
  {"set_name", &Dtool_LightReMutexDirect_set_name_127, METH_O, (const char *)Dtool_LightReMutexDirect_set_name_127_comment},
  {"setName", &Dtool_LightReMutexDirect_set_name_127, METH_O, (const char *)Dtool_LightReMutexDirect_set_name_127_comment},
  {"clear_name", &Dtool_LightReMutexDirect_clear_name_128, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_clear_name_128_comment},
  {"clearName", &Dtool_LightReMutexDirect_clear_name_128, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_clear_name_128_comment},
  {"has_name", &Dtool_LightReMutexDirect_has_name_129, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_has_name_129_comment},
  {"hasName", &Dtool_LightReMutexDirect_has_name_129, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_has_name_129_comment},
  {"get_name", &Dtool_LightReMutexDirect_get_name_130, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_get_name_130_comment},
  {"getName", &Dtool_LightReMutexDirect_get_name_130, METH_NOARGS, (const char *)Dtool_LightReMutexDirect_get_name_130_comment},
  {"output", &Dtool_LightReMutexDirect_output_131, METH_O, (const char *)Dtool_LightReMutexDirect_output_131_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     LightReMutexDirect
//////////////////
static PyObject *Dtool_Repr_LightReMutexDirect(PyObject *self) {
  LightReMutexDirect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LightReMutexDirect, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LightReMutexDirect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LightReMutexDirect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightReMutexDirect",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightReMutexDirect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LightReMutexDirect,
    &Dtool_NumberMethods_LightReMutexDirect,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_LightReMutexDirect,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements a standard lightReMutex by making direct calls to the\n"
    " * underlying implementation layer.  It doesn't perform any debugging\n"
    " * operations.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightReMutexDirect,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightReMutexDirect,
    PyType_GenericAlloc,
    Dtool_new_LightReMutexDirect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightReMutexDirect,
  Dtool_UpcastInterface_LightReMutexDirect,
  Dtool_DowncastInterface_LightReMutexDirect,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightReMutexDirect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LightReMutexDirect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightReMutexDirect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightReMutexDirect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightReMutexDirect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightReMutexDirect);
  }
}

/**
 * Python method tables for LightReMutex (LightReMutex)
 */
static PyMethodDef Dtool_Methods_LightReMutex[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LightReMutex = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightReMutex = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightReMutex = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightReMutex = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightReMutex = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightReMutex = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LightReMutex",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LightReMutex,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightReMutex,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LightReMutex,
    &Dtool_SequenceMethods_LightReMutex,
    &Dtool_MappingMethods_LightReMutex,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightReMutex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightReMutex,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightReMutex,
    PyType_GenericAlloc,
    Dtool_new_LightReMutex,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightReMutex,
  Dtool_UpcastInterface_LightReMutex,
  Dtool_DowncastInterface_LightReMutex,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightReMutex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LightReMutexDirect(nullptr);
    Dtool_LightReMutex._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LightReMutexDirect);
    Dtool_LightReMutex._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LightReMutex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightReMutex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightReMutex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightReMutex);
  }
}

/**
 * Python method tables for MainThread (MainThread)
 */
static PyMethodDef Dtool_Methods_MainThread[] = {
  {"get_class_type", &Dtool_MainThread_get_class_type_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_MainThread_get_class_type_136_comment},
  {"getClassType", &Dtool_MainThread_get_class_type_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_MainThread_get_class_type_136_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MainThread = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MainThread = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MainThread = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MainThread = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MainThread = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MainThread = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MainThread",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MainThread,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MainThread,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MainThread,
    &Dtool_SequenceMethods_MainThread,
    &Dtool_MappingMethods_MainThread,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MainThread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The special \"main thread\" class.  There is one instance of these in the\n"
    " * world, and it is returned by Thread::get_main_thread().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MainThread,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MainThread,
    PyType_GenericAlloc,
    Dtool_new_MainThread,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MainThread,
  Dtool_UpcastInterface_MainThread,
  Dtool_DowncastInterface_MainThread,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MainThread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Thread(nullptr);
    Dtool_MainThread._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Thread);
    Dtool_MainThread._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MainThread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MainThread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MainThread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MainThread);
  }
}

/**
 * Python method tables for Semaphore (Semaphore)
 */
static PyMethodDef Dtool_Methods_Semaphore[] = {
  {"acquire", &Dtool_Semaphore_acquire_141, METH_NOARGS, (const char *)Dtool_Semaphore_acquire_141_comment},
  {"try_acquire", &Dtool_Semaphore_try_acquire_142, METH_NOARGS, (const char *)Dtool_Semaphore_try_acquire_142_comment},
  {"tryAcquire", &Dtool_Semaphore_try_acquire_142, METH_NOARGS, (const char *)Dtool_Semaphore_try_acquire_142_comment},
  {"release", &Dtool_Semaphore_release_143, METH_NOARGS, (const char *)Dtool_Semaphore_release_143_comment},
  {"get_count", &Dtool_Semaphore_get_count_144, METH_NOARGS, (const char *)Dtool_Semaphore_get_count_144_comment},
  {"getCount", &Dtool_Semaphore_get_count_144, METH_NOARGS, (const char *)Dtool_Semaphore_get_count_144_comment},
  {"output", &Dtool_Semaphore_output_145, METH_O, (const char *)Dtool_Semaphore_output_145_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Semaphore
//////////////////
static PyObject *Dtool_Repr_Semaphore(PyObject *self) {
  Semaphore *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Semaphore, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Semaphore = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Semaphore = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Semaphore",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Semaphore,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Semaphore,
    &Dtool_NumberMethods_Semaphore,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_Semaphore,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A classic semaphore synchronization primitive.\n"
    " *\n"
    " * A semaphore manages an internal counter which is decremented by each\n"
    " * acquire() call and incremented by each release() call.  The counter can\n"
    " * never go below zero; when acquire() finds that it is zero, it blocks,\n"
    " * waiting until some other thread calls release().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Semaphore,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Semaphore,
    PyType_GenericAlloc,
    Dtool_new_Semaphore,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Semaphore,
  Dtool_UpcastInterface_Semaphore,
  Dtool_DowncastInterface_Semaphore,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Semaphore(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Semaphore._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Semaphore._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Semaphore) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Semaphore)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Semaphore);
  }
}

/**
 * Python method tables for PythonThread (PythonThread)
 */
static PyMethodDef Dtool_Methods_PythonThread[] = {
  {"join", &Dtool_PythonThread_join_148, METH_NOARGS, (const char *)Dtool_PythonThread_join_148_comment},
  {"get_class_type", &Dtool_PythonThread_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonThread_get_class_type_155_comment},
  {"getClassType", &Dtool_PythonThread_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonThread_get_class_type_155_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PythonThread[] = {
  {(char *)"args", &Dtool_PythonThread_args_Getter, &Dtool_PythonThread_args_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PythonThread = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PythonThread = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PythonThread = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PythonThread = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PythonThread = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PythonThread = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PythonThread",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PythonThread,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PythonThread,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PythonThread,
    &Dtool_SequenceMethods_PythonThread,
    &Dtool_MappingMethods_PythonThread,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PythonThread,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is exposed to Python to allow creation of a Panda thread from\n"
    " * the Python level.  It will spawn a thread that executes an arbitrary Python\n"
    " * functor.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PythonThread,
    nullptr, // tp_members
    Dtool_Properties_PythonThread,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PythonThread,
    PyType_GenericAlloc,
    Dtool_new_PythonThread,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PythonThread,
  Dtool_UpcastInterface_PythonThread,
  Dtool_DowncastInterface_PythonThread,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PythonThread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Thread(nullptr);
    Dtool_PythonThread._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Thread);
    Dtool_PythonThread._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PythonThread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PythonThread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PythonThread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PythonThread);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pipeline_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    Thread::init_type();
    TypeHandle handle = Thread::get_class_type();
    Dtool_Thread._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Thread);
  }
  {
    ExternalThread::init_type();
    TypeHandle handle = ExternalThread::get_class_type();
    Dtool_ExternalThread._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ExternalThread);
  }
  {
    MainThread::init_type();
    TypeHandle handle = MainThread::get_class_type();
    Dtool_MainThread._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MainThread);
  }
  {
    PythonThread::init_type();
    TypeHandle handle = PythonThread::get_class_type();
    Dtool_PythonThread._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PythonThread);
  }
}

void Dtool_libp3pipeline_BuildInstants(PyObject *module) {
  (void) module;
  // enum ThreadPriority
  PyModule_AddObject(module, "TP_low", Dtool_WrapValue(::TP_low));
  PyModule_AddObject(module, "TPLow", Dtool_WrapValue(::TP_low));
  PyModule_AddObject(module, "TP_normal", Dtool_WrapValue(::TP_normal));
  PyModule_AddObject(module, "TPNormal", Dtool_WrapValue(::TP_normal));
  PyModule_AddObject(module, "TP_high", Dtool_WrapValue(::TP_high));
  PyModule_AddObject(module, "TPHigh", Dtool_WrapValue(::TP_high));
  PyModule_AddObject(module, "TP_urgent", Dtool_WrapValue(::TP_urgent));
  PyModule_AddObject(module, "TPUrgent", Dtool_WrapValue(::TP_urgent));
  // Thread
  Dtool_PyModuleClassInit_Thread(module);
  PyModule_AddObject(module, "Thread", (PyObject *)&Dtool_Thread);
  // MutexDirect
  Dtool_PyModuleClassInit_MutexDirect(module);
  PyModule_AddObject(module, "MutexDirect", (PyObject *)&Dtool_MutexDirect);
  // Mutex
  Dtool_PyModuleClassInit_Mutex(module);
  PyModule_AddObject(module, "Mutex", (PyObject *)&Dtool_Mutex);
  // ConditionVarDirect
  Dtool_PyModuleClassInit_ConditionVarDirect(module);
  PyModule_AddObject(module, "ConditionVarDirect", (PyObject *)&Dtool_ConditionVarDirect);
  // ConditionVar
  Dtool_PyModuleClassInit_ConditionVar(module);
  PyModule_AddObject(module, "ConditionVar", (PyObject *)&Dtool_ConditionVar);
  // typedef ConditionVar ConditionVarFull
  Dtool_PyModuleClassInit_ConditionVar(module);
  Py_INCREF((PyObject *)&Dtool_ConditionVar);
  PyModule_AddObject(module, "ConditionVarFull", (PyObject *)&Dtool_ConditionVar);
  // ReMutexDirect
  Dtool_PyModuleClassInit_ReMutexDirect(module);
  PyModule_AddObject(module, "ReMutexDirect", (PyObject *)&Dtool_ReMutexDirect);
  // ReMutex
  Dtool_PyModuleClassInit_ReMutex(module);
  PyModule_AddObject(module, "ReMutex", (PyObject *)&Dtool_ReMutex);
  // ExternalThread
  Dtool_PyModuleClassInit_ExternalThread(module);
  PyModule_AddObject(module, "ExternalThread", (PyObject *)&Dtool_ExternalThread);
  // LightMutexDirect
  Dtool_PyModuleClassInit_LightMutexDirect(module);
  PyModule_AddObject(module, "LightMutexDirect", (PyObject *)&Dtool_LightMutexDirect);
  // LightMutex
  Dtool_PyModuleClassInit_LightMutex(module);
  PyModule_AddObject(module, "LightMutex", (PyObject *)&Dtool_LightMutex);
  // LightReMutexDirect
  Dtool_PyModuleClassInit_LightReMutexDirect(module);
  PyModule_AddObject(module, "LightReMutexDirect", (PyObject *)&Dtool_LightReMutexDirect);
  // LightReMutex
  Dtool_PyModuleClassInit_LightReMutex(module);
  PyModule_AddObject(module, "LightReMutex", (PyObject *)&Dtool_LightReMutex);
  // MainThread
  Dtool_PyModuleClassInit_MainThread(module);
  PyModule_AddObject(module, "MainThread", (PyObject *)&Dtool_MainThread);
  // Semaphore
  Dtool_PyModuleClassInit_Semaphore(module);
  PyModule_AddObject(module, "Semaphore", (PyObject *)&Dtool_Semaphore);
  // PythonThread
  Dtool_PyModuleClassInit_PythonThread(module);
  PyModule_AddObject(module, "PythonThread", (PyObject *)&Dtool_PythonThread);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3pipeline_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3pipeline_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612502,  /* file_identifier */
  "libp3pipeline",  /* library_name */
  "kd_i",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pipeline.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  300  /* next_index */
};

Configure(_in_configure_libp3pipeline);
ConfigureFn(_in_configure_libp3pipeline) {
  interrogate_request_module(&_in_module_def);
}

