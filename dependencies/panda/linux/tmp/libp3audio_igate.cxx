/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/audio -Ipanda/src/audio -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3audio_igate.cxx -od built/pandac/input/libp3audio.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/audio -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3audio audio.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "audio.h"
#include "audioLoadRequest.h"
#include "audioManager.h"
#include "audioSound.h"
#include "filterProperties.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class FilterProperties
 */
typedef FilterProperties FilterProperties_localtype;
Define_Module_ClassRef(panda3d.core, FilterProperties, FilterProperties_localtype, FilterProperties);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FilterProperties = &Dtool_FilterProperties;
static void Dtool_PyModuleClassInit_FilterProperties(PyObject *module);

/**
 * Forward declarations for top-level class AudioSound
 */
typedef AudioSound AudioSound_localtype;
Define_Module_ClassRef(panda3d.core, AudioSound, AudioSound_localtype, AudioSound);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioSound = &Dtool_AudioSound;
static void Dtool_PyModuleClassInit_AudioSound(PyObject *module);

/**
 * Forward declarations for top-level class AudioManager
 */
typedef AudioManager AudioManager_localtype;
Define_Module_ClassRef(panda3d.core, AudioManager, AudioManager_localtype, AudioManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioManager = &Dtool_AudioManager;
static void Dtool_PyModuleClassInit_AudioManager(PyObject *module);

/**
 * Forward declarations for top-level class AudioLoadRequest
 */
typedef AudioLoadRequest AudioLoadRequest_localtype;
Define_Module_ClassRef(panda3d.core, AudioLoadRequest, AudioLoadRequest_localtype, AudioLoadRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioLoadRequest = &Dtool_AudioLoadRequest;
static void Dtool_PyModuleClassInit_AudioLoadRequest(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"FilterProperties", &Dtool_FilterProperties},
  {"AudioSound", &Dtool_AudioSound},
  {"AudioManager", &Dtool_AudioManager},
  {"AudioLoadRequest", &Dtool_AudioLoadRequest},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[6].type)
  {"AsyncFuture", nullptr},
#define Dtool_Ptr_AsyncFuture (imports[7].type)
  {"AsyncTask", nullptr},
#define Dtool_Ptr_AsyncTask (imports[8].type)
  {"MovieAudio", nullptr},
#define Dtool_Ptr_MovieAudio (imports[9].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// AsyncFuture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncFuture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncFuture = &Dtool_AsyncFuture;
#endif
// AsyncTask
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTask;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
#endif
// MovieAudio
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_MovieAudio;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieAudio = &Dtool_MovieAudio;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class FilterProperties
 */
/**
 * Python function wrapper for:
 * inline void FilterProperties::clear(void)
 */
static PyObject *Dtool_FilterProperties_clear_4(PyObject *self, PyObject *) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.clear")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_clear_4_comment =
  "C++ Interface:\n"
  "clear(const FilterProperties self)\n"
  "\n"
  "/**\n"
  " * Removes all DSP postprocessing.\n"
  " */";
#else
static const char *Dtool_FilterProperties_clear_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_lowpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
 */
static PyObject *Dtool_FilterProperties_add_lowpass_5(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_lowpass")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_lowpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
  float param1;
  float param2;
  static const char *keyword_list[] = {"cutoff_freq", "resonance_q", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_lowpass", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).add_lowpass)((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_lowpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_lowpass_5_comment =
  "C++ Interface:\n"
  "add_lowpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n"
  "\n"
  "/**\n"
  " * Add a lowpass filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_lowpass_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_highpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
 */
static PyObject *Dtool_FilterProperties_add_highpass_6(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_highpass")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_highpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
  float param1;
  float param2;
  static const char *keyword_list[] = {"cutoff_freq", "resonance_q", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_highpass", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).add_highpass)((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_highpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_highpass_6_comment =
  "C++ Interface:\n"
  "add_highpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n"
  "\n"
  "/**\n"
  " * Add a highpass filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_highpass_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_echo(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat delay, PN_stdfloat decayratio)
 */
static PyObject *Dtool_FilterProperties_add_echo_7(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_echo")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_echo(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat delay, PN_stdfloat decayratio)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"drymix", "wetmix", "delay", "decayratio", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_echo", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).add_echo)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_echo(const FilterProperties self, float drymix, float wetmix, float delay, float decayratio)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_echo_7_comment =
  "C++ Interface:\n"
  "add_echo(const FilterProperties self, float drymix, float wetmix, float delay, float decayratio)\n"
  "\n"
  "/**\n"
  " * Add a echo filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_echo_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_flange(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat depth, PN_stdfloat rate)
 */
static PyObject *Dtool_FilterProperties_add_flange_8(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_flange")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_flange(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat depth, PN_stdfloat rate)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"drymix", "wetmix", "depth", "rate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_flange", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).add_flange)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_flange(const FilterProperties self, float drymix, float wetmix, float depth, float rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_flange_8_comment =
  "C++ Interface:\n"
  "add_flange(const FilterProperties self, float drymix, float wetmix, float depth, float rate)\n"
  "\n"
  "/**\n"
  " * Add a flange filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_flange_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_distort(PN_stdfloat level)
 */
static PyObject *Dtool_FilterProperties_add_distort_9(PyObject *self, PyObject *arg) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_distort")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_distort(PN_stdfloat level)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_distort)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_distort(const FilterProperties self, float level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_distort_9_comment =
  "C++ Interface:\n"
  "add_distort(const FilterProperties self, float level)\n"
  "\n"
  "/**\n"
  " * Add a distort filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_distort_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_normalize(PN_stdfloat fadetime, PN_stdfloat threshold, PN_stdfloat maxamp)
 */
static PyObject *Dtool_FilterProperties_add_normalize_10(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_normalize")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_normalize(PN_stdfloat fadetime, PN_stdfloat threshold, PN_stdfloat maxamp)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"fadetime", "threshold", "maxamp", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_normalize", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).add_normalize)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_normalize(const FilterProperties self, float fadetime, float threshold, float maxamp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_normalize_10_comment =
  "C++ Interface:\n"
  "add_normalize(const FilterProperties self, float fadetime, float threshold, float maxamp)\n"
  "\n"
  "/**\n"
  " * Add a normalize filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_normalize_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_parameq(PN_stdfloat center_freq, PN_stdfloat bandwidth, PN_stdfloat gain)
 */
static PyObject *Dtool_FilterProperties_add_parameq_11(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_parameq")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_parameq(PN_stdfloat center_freq, PN_stdfloat bandwidth, PN_stdfloat gain)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"center_freq", "bandwidth", "gain", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_parameq", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).add_parameq)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_parameq(const FilterProperties self, float center_freq, float bandwidth, float gain)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_parameq_11_comment =
  "C++ Interface:\n"
  "add_parameq(const FilterProperties self, float center_freq, float bandwidth, float gain)\n"
  "\n"
  "/**\n"
  " * Add a parameq filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_parameq_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_pitchshift(PN_stdfloat pitch, PN_stdfloat fftsize, PN_stdfloat overlap)
 */
static PyObject *Dtool_FilterProperties_add_pitchshift_12(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_pitchshift")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_pitchshift(PN_stdfloat pitch, PN_stdfloat fftsize, PN_stdfloat overlap)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"pitch", "fftsize", "overlap", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_pitchshift", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).add_pitchshift)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_pitchshift(const FilterProperties self, float pitch, float fftsize, float overlap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_pitchshift_12_comment =
  "C++ Interface:\n"
  "add_pitchshift(const FilterProperties self, float pitch, float fftsize, float overlap)\n"
  "\n"
  "/**\n"
  " * Add a pitchshift filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_pitchshift_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_chorus(PN_stdfloat drymix, PN_stdfloat wet1, PN_stdfloat wet2, PN_stdfloat wet3, PN_stdfloat delay, PN_stdfloat rate, PN_stdfloat depth)
 */
static PyObject *Dtool_FilterProperties_add_chorus_13(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_chorus")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_chorus(PN_stdfloat drymix, PN_stdfloat wet1, PN_stdfloat wet2, PN_stdfloat wet3, PN_stdfloat delay, PN_stdfloat rate, PN_stdfloat depth)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  static const char *keyword_list[] = {"drymix", "wet1", "wet2", "wet3", "delay", "rate", "depth", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffff:add_chorus", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    ((*local_this).add_chorus)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_chorus(const FilterProperties self, float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_chorus_13_comment =
  "C++ Interface:\n"
  "add_chorus(const FilterProperties self, float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth)\n"
  "\n"
  "/**\n"
  " * Add a chorus filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_chorus_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_sfxreverb(PN_stdfloat drylevel = 0, PN_stdfloat room = -10000, PN_stdfloat roomhf = 0, PN_stdfloat decaytime = 1, PN_stdfloat decayhfratio = 0.5, PN_stdfloat reflectionslevel = -10000, PN_stdfloat reflectionsdelay = 0.020000000000000005, PN_stdfloat reverblevel = 0, PN_stdfloat reverbdelay = 0.04000000000000001, PN_stdfloat diffusion = 100, PN_stdfloat density = 100, PN_stdfloat hfreference = 5000, PN_stdfloat roomlf = 0, PN_stdfloat lfreference = 250)
 */
static PyObject *Dtool_FilterProperties_add_sfxreverb_14(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_sfxreverb")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_sfxreverb(PN_stdfloat drylevel = 0, PN_stdfloat room = -10000, PN_stdfloat roomhf = 0, PN_stdfloat decaytime = 1, PN_stdfloat decayhfratio = 0.5, PN_stdfloat reflectionslevel = -10000, PN_stdfloat reflectionsdelay = 0.020000000000000005, PN_stdfloat reverblevel = 0, PN_stdfloat reverbdelay = 0.04000000000000001, PN_stdfloat diffusion = 100, PN_stdfloat density = 100, PN_stdfloat hfreference = 5000, PN_stdfloat roomlf = 0, PN_stdfloat lfreference = 250)
  float param1 = 0;
  float param2 = -10000;
  float param3 = 0;
  float param4 = 1;
  float param5 = 0.5;
  float param6 = -10000;
  float param7 = 0.020000000000000005;
  float param8 = 0;
  float param9 = 0.04000000000000001;
  float param10 = 100;
  float param11 = 100;
  float param12 = 5000;
  float param13 = 0;
  float param14 = 250;
  static const char *keyword_list[] = {"drylevel", "room", "roomhf", "decaytime", "decayhfratio", "reflectionslevel", "reflectionsdelay", "reverblevel", "reverbdelay", "diffusion", "density", "hfreference", "roomlf", "lfreference", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|ffffffffffffff:add_sfxreverb", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14)) {
    ((*local_this).add_sfxreverb)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9, (PN_stdfloat)param10, (PN_stdfloat)param11, (PN_stdfloat)param12, (PN_stdfloat)param13, (PN_stdfloat)param14);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_sfxreverb(const FilterProperties self, float drylevel, float room, float roomhf, float decaytime, float decayhfratio, float reflectionslevel, float reflectionsdelay, float reverblevel, float reverbdelay, float diffusion, float density, float hfreference, float roomlf, float lfreference)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_sfxreverb_14_comment =
  "C++ Interface:\n"
  "add_sfxreverb(const FilterProperties self, float drylevel, float room, float roomhf, float decaytime, float decayhfratio, float reflectionslevel, float reflectionsdelay, float reverblevel, float reverbdelay, float diffusion, float density, float hfreference, float roomlf, float lfreference)\n"
  "\n"
  "/**\n"
  " * Add a reverb filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_sfxreverb_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_compress(PN_stdfloat threshold, PN_stdfloat attack, PN_stdfloat release, PN_stdfloat gainmakeup)
 */
static PyObject *Dtool_FilterProperties_add_compress_15(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_compress")) {
    return nullptr;
  }
  // 1-inline void FilterProperties::add_compress(PN_stdfloat threshold, PN_stdfloat attack, PN_stdfloat release, PN_stdfloat gainmakeup)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"threshold", "attack", "release", "gainmakeup", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_compress", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).add_compress)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_compress(const FilterProperties self, float threshold, float attack, float release, float gainmakeup)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_compress_15_comment =
  "C++ Interface:\n"
  "add_compress(const FilterProperties self, float threshold, float attack, float release, float gainmakeup)\n"
  "\n"
  "/**\n"
  " * Add a compress filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_compress_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FilterProperties::get_class_type(void)
 */
static PyObject *Dtool_FilterProperties_get_class_type_16(PyObject *, PyObject *) {
  // 1-static TypeHandle FilterProperties::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FilterProperties::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_get_class_type_16_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FilterProperties_get_class_type_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * FilterProperties::FilterProperties(void)
 * inline FilterProperties::FilterProperties(FilterProperties const &) = default
 */
static int Dtool_Init_FilterProperties(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("FilterProperties() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-FilterProperties::FilterProperties(void)
      FilterProperties *return_value = new FilterProperties();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FilterProperties, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline FilterProperties::FilterProperties(FilterProperties const &) = default
      FilterProperties const *arg_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FilterProperties, 0, "FilterProperties.FilterProperties", true, true);
      if (arg_this != nullptr) {
        FilterProperties *return_value = new FilterProperties(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FilterProperties, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "FilterProperties() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FilterProperties()\n"
      "FilterProperties(const FilterProperties param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_FilterProperties(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FilterProperties) {
    printf("FilterProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FilterProperties *local_this = (FilterProperties *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FilterProperties) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FilterProperties(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FilterProperties) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FilterProperties*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FilterProperties*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (FilterProperties*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AudioSound
 */
/**
 * Python function wrapper for:
 * virtual void AudioSound::play(void) = 0
 */
static PyObject *Dtool_AudioSound_play_18(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.play")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::play(void) = 0
  ((*local_this).play)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_play_18_comment =
  "C++ Interface:\n"
  "play(const AudioSound self)\n"
  "\n"
  "// For best compatibility, set the loop_count, volume, and balance, prior to\n"
  "// calling play().  You may set them while they're playing, but it's\n"
  "// implementation specific whether you get the results.  - Calling play() a\n"
  "// second time on the same sound before it is finished will start the sound\n"
  "// again (creating a skipping or stuttering effect).";
#else
static const char *Dtool_AudioSound_play_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::stop(void) = 0
 */
static PyObject *Dtool_AudioSound_stop_19(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.stop")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::stop(void) = 0
  ((*local_this).stop)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_stop_19_comment =
  "C++ Interface:\n"
  "stop(const AudioSound self)\n";
#else
static const char *Dtool_AudioSound_stop_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_loop(bool loop = true) = 0
 */
static PyObject *Dtool_AudioSound_set_loop_20(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_loop")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_loop(bool loop = true) = 0
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "loop")) {
    ((*local_this).set_loop)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loop(const AudioSound self, bool loop)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_loop_20_comment =
  "C++ Interface:\n"
  "set_loop(const AudioSound self, bool loop)\n"
  "\n"
  "// loop: false = play once; true = play forever.  inits to false.";
#else
static const char *Dtool_AudioSound_set_loop_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioSound::get_loop(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_loop_21(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual bool AudioSound::get_loop(void) const = 0
  bool return_value = ((*(const AudioSound*)local_this).get_loop)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_loop_21_comment =
  "C++ Interface:\n"
  "get_loop(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_loop_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_loop_count(unsigned long int loop_count = 1) = 0
 */
static PyObject *Dtool_AudioSound_set_loop_count_22(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_loop_count")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_loop_count(unsigned long int loop_count = 1) = 0
  unsigned long param1 = 1;
  static const char *keyword_list[] = {"loop_count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|k:set_loop_count", (char **)keyword_list, &param1)) {
    ((*local_this).set_loop_count)((unsigned long int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loop_count(const AudioSound self, int loop_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_loop_count_22_comment =
  "C++ Interface:\n"
  "set_loop_count(const AudioSound self, int loop_count)\n"
  "\n"
  "// loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.";
#else
static const char *Dtool_AudioSound_set_loop_count_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual unsigned long int AudioSound::get_loop_count(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_loop_count_23(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual unsigned long int AudioSound::get_loop_count(void) const = 0
  unsigned long int return_value = ((*(const AudioSound*)local_this).get_loop_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_loop_count_23_comment =
  "C++ Interface:\n"
  "get_loop_count(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_loop_count_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_time(PN_stdfloat start_time = 0.0) = 0
 */
static PyObject *Dtool_AudioSound_set_time_24(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_time")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_time(PN_stdfloat start_time = 0.0) = 0
  float param1 = 0.0;
  static const char *keyword_list[] = {"start_time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_time", (char **)keyword_list, &param1)) {
    ((*local_this).set_time)((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time(const AudioSound self, float start_time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_time_24_comment =
  "C++ Interface:\n"
  "set_time(const AudioSound self, float start_time)\n"
  "\n"
  "/**\n"
  "   * Control time position within the sound, in seconds.  This is similar (in\n"
  "   * concept) to the seek position within a file.  The value starts at 0.0 (the\n"
  "   * default) and ends at the value given by the length() method.\n"
  "   *\n"
  "   * In the past, this call did nothing if the sound was currently playing, and\n"
  "   * it was necessary to call play() to effect the change.  This is no longer\n"
  "   * the case; the time change takes effect immediately.\n"
  "   *\n"
  "   * If a sound is playing, calling get_time() repeatedly will return different\n"
  "   * results over time.  e.g.\n"
  "   * @code\n"
  "   * PN_stdfloat percent_complete = s.get_time() / s.length();\n"
  "   * @endcode\n"
  "   */";
#else
static const char *Dtool_AudioSound_set_time_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_time(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_time_25(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::get_time(void) const = 0
  PN_stdfloat return_value = ((*(const AudioSound*)local_this).get_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_time_25_comment =
  "C++ Interface:\n"
  "get_time(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_time_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_volume(PN_stdfloat volume = 1.0) = 0
 */
static PyObject *Dtool_AudioSound_set_volume_26(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_volume")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_volume(PN_stdfloat volume = 1.0) = 0
  float param1 = 1.0;
  static const char *keyword_list[] = {"volume", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_volume", (char **)keyword_list, &param1)) {
    ((*local_this).set_volume)((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_volume(const AudioSound self, float volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_volume_26_comment =
  "C++ Interface:\n"
  "set_volume(const AudioSound self, float volume)\n"
  "\n"
  "// 0 = minimum; 1.0 = maximum.  inits to 1.0.";
#else
static const char *Dtool_AudioSound_set_volume_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_volume(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_volume_27(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::get_volume(void) const = 0
  PN_stdfloat return_value = ((*(const AudioSound*)local_this).get_volume)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_volume_27_comment =
  "C++ Interface:\n"
  "get_volume(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_volume_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_balance(PN_stdfloat balance_right = 0.0) = 0
 */
static PyObject *Dtool_AudioSound_set_balance_28(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_balance")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_balance(PN_stdfloat balance_right = 0.0) = 0
  float param1 = 0.0;
  static const char *keyword_list[] = {"balance_right", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_balance", (char **)keyword_list, &param1)) {
    ((*local_this).set_balance)((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_balance(const AudioSound self, float balance_right)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_balance_28_comment =
  "C++ Interface:\n"
  "set_balance(const AudioSound self, float balance_right)\n"
  "\n"
  "// -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.";
#else
static const char *Dtool_AudioSound_set_balance_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_balance(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_balance_29(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::get_balance(void) const = 0
  PN_stdfloat return_value = ((*(const AudioSound*)local_this).get_balance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_balance_29_comment =
  "C++ Interface:\n"
  "get_balance(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_balance_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_play_rate(PN_stdfloat play_rate = 1.0) = 0
 */
static PyObject *Dtool_AudioSound_set_play_rate_30(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_play_rate")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_play_rate(PN_stdfloat play_rate = 1.0) = 0
  float param1 = 1.0;
  static const char *keyword_list[] = {"play_rate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_play_rate", (char **)keyword_list, &param1)) {
    ((*local_this).set_play_rate)((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_play_rate(const AudioSound self, float play_rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_play_rate_30_comment =
  "C++ Interface:\n"
  "set_play_rate(const AudioSound self, float play_rate)\n"
  "\n"
  "// play_rate is any positive PN_stdfloat value.  inits to 1.0.";
#else
static const char *Dtool_AudioSound_set_play_rate_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_play_rate(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_play_rate_31(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::get_play_rate(void) const = 0
  PN_stdfloat return_value = ((*(const AudioSound*)local_this).get_play_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_play_rate_31_comment =
  "C++ Interface:\n"
  "get_play_rate(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_play_rate_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_active(bool flag = true) = 0
 */
static PyObject *Dtool_AudioSound_set_active_32(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_active")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_active(bool flag = true) = 0
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "flag")) {
    ((*local_this).set_active)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const AudioSound self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_active_32_comment =
  "C++ Interface:\n"
  "set_active(const AudioSound self, bool flag)\n"
  "\n"
  "// inits to manager's state.";
#else
static const char *Dtool_AudioSound_set_active_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioSound::get_active(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_active_33(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual bool AudioSound::get_active(void) const = 0
  bool return_value = ((*(const AudioSound*)local_this).get_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_active_33_comment =
  "C++ Interface:\n"
  "get_active(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_active_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_finished_event(std::string const &event) = 0
 */
static PyObject *Dtool_AudioSound_set_finished_event_34(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_finished_event")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_finished_event(std::string const &event) = 0
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_finished_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_finished_event(const AudioSound self, str event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_finished_event_34_comment =
  "C++ Interface:\n"
  "set_finished_event(const AudioSound self, str event)\n"
  "\n"
  "// Set (or clear) the event that will be thrown when the sound finishes\n"
  "// playing.  To clear the event, pass an empty string.";
#else
static const char *Dtool_AudioSound_set_finished_event_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string const &AudioSound::get_finished_event(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_finished_event_35(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual std::string const &AudioSound::get_finished_event(void) const = 0
  std::string const &return_value = ((*(const AudioSound*)local_this).get_finished_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_finished_event_35_comment =
  "C++ Interface:\n"
  "get_finished_event(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_finished_event_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string const &AudioSound::get_name(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_name_36(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual std::string const &AudioSound::get_name(void) const = 0
  std::string const &return_value = ((*(const AudioSound*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_name_36_comment =
  "C++ Interface:\n"
  "get_name(AudioSound self)\n"
  "\n"
  "// There is no set_name(), this is intentional.";
#else
static const char *Dtool_AudioSound_get_name_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::length(void) const = 0
 */
static PyObject *Dtool_AudioSound_length_37(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::length(void) const = 0
  PN_stdfloat return_value = ((*(const AudioSound*)local_this).length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_length_37_comment =
  "C++ Interface:\n"
  "length(AudioSound self)\n"
  "\n"
  "// return: playing time in seconds.";
#else
static const char *Dtool_AudioSound_length_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_3d_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz)
 */
static PyObject *Dtool_AudioSound_set_3d_attributes_38(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_3d_attributes")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_3d_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  static const char *keyword_list[] = {"px", "py", "pz", "vx", "vy", "vz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_3d_attributes", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    ((*local_this).set_3d_attributes)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_3d_attributes(const AudioSound self, float px, float py, float pz, float vx, float vy, float vz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_3d_attributes_38_comment =
  "C++ Interface:\n"
  "set_3d_attributes(const AudioSound self, float px, float py, float pz, float vx, float vy, float vz)\n"
  "\n"
  "// Controls the position of this sound's emitter.  px, py and pz are the\n"
  "// emitter's position.  vx, vy and vz are the emitter's velocity in UNITS\n"
  "// PER SECOND (default: meters).";
#else
static const char *Dtool_AudioSound_set_3d_attributes_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_3d_min_distance(PN_stdfloat dist)
 */
static PyObject *Dtool_AudioSound_set_3d_min_distance_40(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_3d_min_distance")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_3d_min_distance(PN_stdfloat dist)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_3d_min_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_3d_min_distance(const AudioSound self, float dist)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_3d_min_distance_40_comment =
  "C++ Interface:\n"
  "set_3d_min_distance(const AudioSound self, float dist)\n"
  "\n"
  "// Controls the distance (in units) that this sound begins to fall off.\n"
  "// Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0\n"
  "// FartherSlower, >1.0";
#else
static const char *Dtool_AudioSound_set_3d_min_distance_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_3d_min_distance(void) const
 */
static PyObject *Dtool_AudioSound_get_3d_min_distance_41(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::get_3d_min_distance(void) const
  PN_stdfloat return_value = ((*(const AudioSound*)local_this).get_3d_min_distance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_3d_min_distance_41_comment =
  "C++ Interface:\n"
  "get_3d_min_distance(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_3d_min_distance_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_3d_max_distance(PN_stdfloat dist)
 */
static PyObject *Dtool_AudioSound_set_3d_max_distance_42(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_3d_max_distance")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_3d_max_distance(PN_stdfloat dist)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_3d_max_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_3d_max_distance(const AudioSound self, float dist)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_3d_max_distance_42_comment =
  "C++ Interface:\n"
  "set_3d_max_distance(const AudioSound self, float dist)\n"
  "\n"
  "// Controls the maximum distance (in units) that this sound stops falling\n"
  "// off.  The sound does not stop at that point, it just doesn't get any\n"
  "// quieter.  You should rarely need to adjust this.  Default is 1000000000.0";
#else
static const char *Dtool_AudioSound_set_3d_max_distance_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_3d_max_distance(void) const
 */
static PyObject *Dtool_AudioSound_get_3d_max_distance_43(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::get_3d_max_distance(void) const
  PN_stdfloat return_value = ((*(const AudioSound*)local_this).get_3d_max_distance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_3d_max_distance_43_comment =
  "C++ Interface:\n"
  "get_3d_max_distance(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_3d_max_distance_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_speaker_mix(int speaker)
 */
static PyObject *Dtool_AudioSound_get_speaker_mix_44(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.get_speaker_mix")) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioSound::get_speaker_mix(int speaker)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*local_this).get_speaker_mix)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_speaker_mix(const AudioSound self, int speaker)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_speaker_mix_44_comment =
  "C++ Interface:\n"
  "get_speaker_mix(const AudioSound self, int speaker)\n"
  "\n"
  "// *_speaker_mix is for use with FMOD.";
#else
static const char *Dtool_AudioSound_get_speaker_mix_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_speaker_mix(PN_stdfloat frontleft, PN_stdfloat frontright, PN_stdfloat center, PN_stdfloat sub, PN_stdfloat backleft, PN_stdfloat backright, PN_stdfloat sideleft, PN_stdfloat sideright)
 */
static PyObject *Dtool_AudioSound_set_speaker_mix_45(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_speaker_mix")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_speaker_mix(PN_stdfloat frontleft, PN_stdfloat frontright, PN_stdfloat center, PN_stdfloat sub, PN_stdfloat backleft, PN_stdfloat backright, PN_stdfloat sideleft, PN_stdfloat sideright)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  static const char *keyword_list[] = {"frontleft", "frontright", "center", "sub", "backleft", "backright", "sideleft", "sideright", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffff:set_speaker_mix", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    ((*local_this).set_speaker_mix)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_speaker_mix(const AudioSound self, float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_speaker_mix_45_comment =
  "C++ Interface:\n"
  "set_speaker_mix(const AudioSound self, float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)\n";
#else
static const char *Dtool_AudioSound_set_speaker_mix_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int AudioSound::get_priority(void)
 */
static PyObject *Dtool_AudioSound_get_priority_46(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.get_priority")) {
    return nullptr;
  }
  // 1-virtual int AudioSound::get_priority(void)
  int return_value = ((*local_this).get_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_priority_46_comment =
  "C++ Interface:\n"
  "get_priority(const AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_priority_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_priority(int priority)
 */
static PyObject *Dtool_AudioSound_set_priority_47(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_priority")) {
    return nullptr;
  }
  // 1-virtual void AudioSound::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const AudioSound self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_priority_47_comment =
  "C++ Interface:\n"
  "set_priority(const AudioSound self, int priority)\n";
#else
static const char *Dtool_AudioSound_set_priority_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioSound::configure_filters(FilterProperties *config)
 */
static PyObject *Dtool_AudioSound_configure_filters_48(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.configure_filters")) {
    return nullptr;
  }
  // 1-virtual bool AudioSound::configure_filters(FilterProperties *config)
  FilterProperties *arg_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FilterProperties, 1, "AudioSound.configure_filters", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).configure_filters)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "configure_filters(const AudioSound self, FilterProperties config)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_configure_filters_48_comment =
  "C++ Interface:\n"
  "configure_filters(const AudioSound self, FilterProperties config)\n";
#else
static const char *Dtool_AudioSound_configure_filters_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual AudioSound::SoundStatus AudioSound::status(void) const = 0
 */
static PyObject *Dtool_AudioSound_status_50(PyObject *self, PyObject *) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual AudioSound::SoundStatus AudioSound::status(void) const = 0
  AudioSound::SoundStatus return_value = ((*(const AudioSound*)local_this).status)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_status_50_comment =
  "C++ Interface:\n"
  "status(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_status_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::output(std::ostream &out) const
 */
static PyObject *Dtool_AudioSound_output_51(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual void AudioSound::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AudioSound.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AudioSound*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AudioSound self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_output_51_comment =
  "C++ Interface:\n"
  "output(AudioSound self, ostream out)\n";
#else
static const char *Dtool_AudioSound_output_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::write(std::ostream &out) const
 */
static PyObject *Dtool_AudioSound_write_52(PyObject *self, PyObject *arg) {
  AudioSound *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioSound)) {
    return nullptr;
  }
  // 1-virtual void AudioSound::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AudioSound.write", false, true);
  if (arg_this != nullptr) {
    ((*(const AudioSound*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AudioSound self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_write_52_comment =
  "C++ Interface:\n"
  "write(AudioSound self, ostream out)\n";
#else
static const char *Dtool_AudioSound_write_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AudioSound::get_class_type(void)
 */
static PyObject *Dtool_AudioSound_get_class_type_53(PyObject *, PyObject *) {
  // 1-static TypeHandle AudioSound::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AudioSound::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_class_type_53_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AudioSound_get_class_type_53_comment = nullptr;
#endif

static int Dtool_Init_AudioSound(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AudioSound(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AudioSound) {
    printf("AudioSound ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AudioSound *local_this = (AudioSound *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AudioSound) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AudioSound(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AudioSound) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AudioSound*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AudioSound*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AudioSound*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AudioManager
 */
/**
 * Python function wrapper for:
 * virtual int AudioManager::get_speaker_setup(void)
 */
static PyObject *Dtool_AudioManager_get_speaker_setup_58(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.get_speaker_setup")) {
    return nullptr;
  }
  // 1-virtual int AudioManager::get_speaker_setup(void)
  int return_value = ((*local_this).get_speaker_setup)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_speaker_setup_58_comment =
  "C++ Interface:\n"
  "get_speaker_setup(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_speaker_setup_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_speaker_setup(AudioManager::SpeakerModeCategory cat)
 */
static PyObject *Dtool_AudioManager_set_speaker_setup_59(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_speaker_setup")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::set_speaker_setup(AudioManager::SpeakerModeCategory cat)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_speaker_setup)((AudioManager::SpeakerModeCategory)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_speaker_setup(const AudioManager self, int cat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_speaker_setup_59_comment =
  "C++ Interface:\n"
  "set_speaker_setup(const AudioManager self, int cat)\n";
#else
static const char *Dtool_AudioManager_set_speaker_setup_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioManager::configure_filters(FilterProperties *config)
 */
static PyObject *Dtool_AudioManager_configure_filters_60(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.configure_filters")) {
    return nullptr;
  }
  // 1-virtual bool AudioManager::configure_filters(FilterProperties *config)
  FilterProperties *arg_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FilterProperties, 1, "AudioManager.configure_filters", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).configure_filters)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "configure_filters(const AudioManager self, FilterProperties config)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_configure_filters_60_comment =
  "C++ Interface:\n"
  "configure_filters(const AudioManager self, FilterProperties config)\n";
#else
static const char *Dtool_AudioManager_configure_filters_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< AudioManager > AudioManager::create_AudioManager(void)
 */
static PyObject *Dtool_AudioManager_create_AudioManager_61(PyObject *, PyObject *) {
  // 1-static PointerTo< AudioManager > AudioManager::create_AudioManager(void)
  PointerTo< AudioManager > return_value = (AudioManager::create_AudioManager)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  AudioManager *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioManager, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_create_AudioManager_61_comment =
  "C++ Interface:\n"
  "create_AudioManager()\n";
#else
static const char *Dtool_AudioManager_create_AudioManager_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::shutdown(void)
 */
static PyObject *Dtool_AudioManager_shutdown_62(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.shutdown")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::shutdown(void)
  ((*local_this).shutdown)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_shutdown_62_comment =
  "C++ Interface:\n"
  "shutdown(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_shutdown_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioManager::is_valid(void) = 0
 */
static PyObject *Dtool_AudioManager_is_valid_63(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.is_valid")) {
    return nullptr;
  }
  // 1-virtual bool AudioManager::is_valid(void) = 0
  bool return_value = ((*local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_is_valid_63_comment =
  "C++ Interface:\n"
  "is_valid(const AudioManager self)\n"
  "\n"
  "// If you're interested in knowing whether this audio manager is valid,\n"
  "// here's the call to do it.  It is not necessary to check whether the audio\n"
  "// manager is valid before making other calls.  You are free to use an\n"
  "// invalid sound manager, you may get silent sounds from it though.  The\n"
  "// sound manager and the sounds it creates should not crash the application\n"
  "// even when the objects are not valid.";
#else
static const char *Dtool_AudioManager_is_valid_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< AudioSound > AudioManager::get_sound(Filename const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
 * virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
 */
static PyObject *Dtool_AudioManager_get_sound_64(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.get_sound")) {
    return nullptr;
  }
  {
    // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(Filename const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
    PyObject *param1;
    PyObject *param2 = Py_False;
    int param3 = AudioManager::SM_heuristic;
    static const char *keyword_list[] = {"file_name", "positional", "mode", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Oi:get_sound", (char **)keyword_list, &param1, &param2, &param3)) {
      Filename const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr) {
        PointerTo< AudioSound > return_value = ((*local_this).get_sound)(*param1_this, (PyObject_IsTrue(param2) != 0), (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        AudioSound *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
    PyObject *param1;
    PyObject *param2 = Py_False;
    int param3 = AudioManager::SM_heuristic;
    static const char *keyword_list[] = {"source", "positional", "mode", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Oi:get_sound", (char **)keyword_list, &param1, &param2, &param3)) {
      MovieAudio *param1_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_MovieAudio, 1, "AudioManager.get_sound", false, false);
      if (param1_this != nullptr) {
        PointerTo< AudioSound > return_value = ((*local_this).get_sound)(param1_this, (PyObject_IsTrue(param2) != 0), (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        AudioSound *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(Filename const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
    PyObject *param1;
    PyObject *param2 = Py_False;
    int param3 = AudioManager::SM_heuristic;
    static const char *keyword_list[] = {"file_name", "positional", "mode", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Oi:get_sound", (char **)keyword_list, &param1, &param2, &param3)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        PointerTo< AudioSound > return_value = ((*local_this).get_sound)(*param1_this, (PyObject_IsTrue(param2) != 0), (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        AudioSound *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sound(const AudioManager self, const Filename file_name, bool positional, int mode)\n"
      "get_sound(const AudioManager self, MovieAudio source, bool positional, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_sound_64_comment =
  "C++ Interface:\n"
  "get_sound(const AudioManager self, const Filename file_name, bool positional, int mode)\n"
  "get_sound(const AudioManager self, MovieAudio source, bool positional, int mode)\n"
  "\n"
  "// Get a sound:";
#else
static const char *Dtool_AudioManager_get_sound_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AudioSound > AudioManager::get_null_sound(void)
 */
static PyObject *Dtool_AudioManager_get_null_sound_65(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.get_null_sound")) {
    return nullptr;
  }
  // 1-PointerTo< AudioSound > AudioManager::get_null_sound(void)
  PointerTo< AudioSound > return_value = ((*local_this).get_null_sound)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  AudioSound *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_null_sound_65_comment =
  "C++ Interface:\n"
  "get_null_sound(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_null_sound_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::uncache_sound(Filename const &file_name) = 0
 */
static PyObject *Dtool_AudioManager_uncache_sound_66(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.uncache_sound")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::uncache_sound(Filename const &file_name) = 0
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AudioManager.uncache_sound", "Filename");
  }
  ((*local_this).uncache_sound)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "uncache_sound(const AudioManager self, const Filename file_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_uncache_sound_66_comment =
  "C++ Interface:\n"
  "uncache_sound(const AudioManager self, const Filename file_name)\n"
  "\n"
  "// Tell the AudioManager there is no need to keep this one cached.  This\n"
  "// doesn't break any connection between AudioSounds that have already given\n"
  "// by get_sound() from this manager.  It's only affecting whether the\n"
  "// AudioManager keeps a copy of the sound in its poolcache.";
#else
static const char *Dtool_AudioManager_uncache_sound_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::clear_cache(void) = 0
 */
static PyObject *Dtool_AudioManager_clear_cache_67(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.clear_cache")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::clear_cache(void) = 0
  ((*local_this).clear_cache)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_clear_cache_67_comment =
  "C++ Interface:\n"
  "clear_cache(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_clear_cache_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_cache_limit(unsigned int count) = 0
 */
static PyObject *Dtool_AudioManager_set_cache_limit_68(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_cache_limit")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::set_cache_limit(unsigned int count) = 0
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).set_cache_limit)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_limit(const AudioManager self, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_cache_limit_68_comment =
  "C++ Interface:\n"
  "set_cache_limit(const AudioManager self, int count)\n";
#else
static const char *Dtool_AudioManager_set_cache_limit_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual unsigned int AudioManager::get_cache_limit(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_cache_limit_69(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual unsigned int AudioManager::get_cache_limit(void) const = 0
  unsigned int return_value = ((*(const AudioManager*)local_this).get_cache_limit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_cache_limit_69_comment =
  "C++ Interface:\n"
  "get_cache_limit(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_cache_limit_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_volume(PN_stdfloat volume) = 0
 */
static PyObject *Dtool_AudioManager_set_volume_70(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_volume")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::set_volume(PN_stdfloat volume) = 0
  if (PyNumber_Check(arg)) {
    ((*local_this).set_volume)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_volume(const AudioManager self, float volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_volume_70_comment =
  "C++ Interface:\n"
  "set_volume(const AudioManager self, float volume)\n"
  "\n"
  "// Control volume: FYI: If you start a sound with the volume off and turn\n"
  "// the volume up later, you'll hear the sound playing at that late point.  0\n"
  "// = minimum; 1.0 = maximum.  inits to 1.0.";
#else
static const char *Dtool_AudioManager_set_volume_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::get_volume(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_volume_71(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioManager::get_volume(void) const = 0
  PN_stdfloat return_value = ((*(const AudioManager*)local_this).get_volume)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_volume_71_comment =
  "C++ Interface:\n"
  "get_volume(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_volume_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_active(bool flag) = 0
 */
static PyObject *Dtool_AudioManager_set_active_72(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_active")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::set_active(bool flag) = 0
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const AudioManager self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_active_72_comment =
  "C++ Interface:\n"
  "set_active(const AudioManager self, bool flag)\n"
  "\n"
  "/*\n"
  " * Turn the manager on or off.  If you play a sound while the manager is\n"
  " * inactive, it won't start.  If you deactivate the manager while sounds are\n"
  " * playing, they'll stop.  If you activate the manager while looping sounds\n"
  " * are playing (those that have a loop_count of zero), they will start playing\n"
  " * from the beginning of their loop.  inits to true.\n"
  " */";
#else
static const char *Dtool_AudioManager_set_active_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioManager::get_active(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_active_73(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual bool AudioManager::get_active(void) const = 0
  bool return_value = ((*(const AudioManager*)local_this).get_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_active_73_comment =
  "C++ Interface:\n"
  "get_active(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_active_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = 0) = 0
 */
static PyObject *Dtool_AudioManager_set_concurrent_sound_limit_74(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_concurrent_sound_limit")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = 0) = 0
  unsigned long param1 = 0;
  static const char *keyword_list[] = {"limit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|k:set_concurrent_sound_limit", (char **)keyword_list, &param1)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).set_concurrent_sound_limit)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_concurrent_sound_limit(const AudioManager self, int limit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_concurrent_sound_limit_74_comment =
  "C++ Interface:\n"
  "set_concurrent_sound_limit(const AudioManager self, int limit)\n"
  "\n"
  "// This controls the number of sounds that you allow at once.  This is more\n"
  "// of a user choice -- it avoids talk over and the creation of a cacophony.\n"
  "// It can also be used to help performance.  0 == unlimited.  1 == mutually\n"
  "// exclusive (one sound at a time).  Which is an example of: n == allow n\n"
  "// sounds to be playing at the same time.";
#else
static const char *Dtool_AudioManager_set_concurrent_sound_limit_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_concurrent_sound_limit_75(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0
  unsigned int return_value = ((*(const AudioManager*)local_this).get_concurrent_sound_limit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_concurrent_sound_limit_75_comment =
  "C++ Interface:\n"
  "get_concurrent_sound_limit(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_concurrent_sound_limit_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0
 */
static PyObject *Dtool_AudioManager_reduce_sounds_playing_to_76(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.reduce_sounds_playing_to")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).reduce_sounds_playing_to)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reduce_sounds_playing_to(const AudioManager self, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_reduce_sounds_playing_to_76_comment =
  "C++ Interface:\n"
  "reduce_sounds_playing_to(const AudioManager self, int count)\n"
  "\n"
  "// This is likely to be a utility function for the concurrent_sound_limit\n"
  "// options.  It is exposed as an API, because it's reasonable that it may be\n"
  "// useful to be here.  It reduces the number of concurrently playing sounds\n"
  "// to count by some implementation specific means.  If the number of sounds\n"
  "// currently playing is at or below count then there is no effect.";
#else
static const char *Dtool_AudioManager_reduce_sounds_playing_to_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::stop_all_sounds(void) = 0
 */
static PyObject *Dtool_AudioManager_stop_all_sounds_77(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.stop_all_sounds")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::stop_all_sounds(void) = 0
  ((*local_this).stop_all_sounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_stop_all_sounds_77_comment =
  "C++ Interface:\n"
  "stop_all_sounds(const AudioManager self)\n"
  "\n"
  "// Stop playback on all sounds managed by this manager.  This is effectively\n"
  "// the same as reduce_sounds_playing_to(0), but this call may be for\n"
  "// efficient on some implementations.";
#else
static const char *Dtool_AudioManager_stop_all_sounds_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::update(void)
 */
static PyObject *Dtool_AudioManager_update_78(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.update")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_update_78_comment =
  "C++ Interface:\n"
  "update(const AudioManager self)\n"
  "\n"
  "// This should be called every frame.  Failure to call could cause problems.";
#else
static const char *Dtool_AudioManager_update_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_listener_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz, PN_stdfloat fx, PN_stdfloat fy, PN_stdfloat fz, PN_stdfloat ux, PN_stdfloat uy, PN_stdfloat uz)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_listener_attributes_79(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_listener_attributes")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::audio_3d_set_listener_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz, PN_stdfloat fx, PN_stdfloat fy, PN_stdfloat fz, PN_stdfloat ux, PN_stdfloat uy, PN_stdfloat uz)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  float param10;
  float param11;
  float param12;
  static const char *keyword_list[] = {"px", "py", "pz", "vx", "vy", "vz", "fx", "fy", "fz", "ux", "uy", "uz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffff:audio_3d_set_listener_attributes", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12)) {
    ((*local_this).audio_3d_set_listener_attributes)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9, (PN_stdfloat)param10, (PN_stdfloat)param11, (PN_stdfloat)param12);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_listener_attributes(const AudioManager self, float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_listener_attributes_79_comment =
  "C++ Interface:\n"
  "audio_3d_set_listener_attributes(const AudioManager self, float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)\n"
  "\n"
  "// This controls the \"set of ears\" that listens to 3D spacialized sound px,\n"
  "// py, pz are position coordinates.  vx, vy, vz are a velocity vector in\n"
  "// UNITS PER SECOND (default: meters). fx, fy and fz are the respective\n"
  "// components of a unit forward-vector ux, uy and uz are the respective\n"
  "// components of a unit up-vector";
#else
static const char *Dtool_AudioManager_audio_3d_set_listener_attributes_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_distance_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_distance_factor_81(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_distance_factor")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::audio_3d_set_distance_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).audio_3d_set_distance_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_distance_factor(const AudioManager self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_distance_factor_81_comment =
  "C++ Interface:\n"
  "audio_3d_set_distance_factor(const AudioManager self, float factor)\n"
  "\n"
  "// Control the \"relative scale that sets the distance factor\" units for 3D\n"
  "// spacialized audio. This is a float in units-per-meter. Default value is\n"
  "// 1.0, which means that Panda units are understood as meters; for e.g.\n"
  "// feet, set 3.28. This factor is applied only to Fmod and OpenAL at the\n"
  "// moment.";
#else
static const char *Dtool_AudioManager_audio_3d_set_distance_factor_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::audio_3d_get_distance_factor(void) const
 */
static PyObject *Dtool_AudioManager_audio_3d_get_distance_factor_82(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioManager::audio_3d_get_distance_factor(void) const
  PN_stdfloat return_value = ((*(const AudioManager*)local_this).audio_3d_get_distance_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_get_distance_factor_82_comment =
  "C++ Interface:\n"
  "audio_3d_get_distance_factor(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_audio_3d_get_distance_factor_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_doppler_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_doppler_factor_83(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_doppler_factor")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::audio_3d_set_doppler_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).audio_3d_set_doppler_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_doppler_factor(const AudioManager self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_doppler_factor_83_comment =
  "C++ Interface:\n"
  "audio_3d_set_doppler_factor(const AudioManager self, float factor)\n"
  "\n"
  "// Control the presence of the Doppler effect.  Default is 1.0 Exaggerated\n"
  "// Doppler, use >1.0 Diminshed Doppler, use <1.0";
#else
static const char *Dtool_AudioManager_audio_3d_set_doppler_factor_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::audio_3d_get_doppler_factor(void) const
 */
static PyObject *Dtool_AudioManager_audio_3d_get_doppler_factor_84(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioManager::audio_3d_get_doppler_factor(void) const
  PN_stdfloat return_value = ((*(const AudioManager*)local_this).audio_3d_get_doppler_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_get_doppler_factor_84_comment =
  "C++ Interface:\n"
  "audio_3d_get_doppler_factor(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_audio_3d_get_doppler_factor_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_drop_off_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_drop_off_factor_85(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_drop_off_factor")) {
    return nullptr;
  }
  // 1-virtual void AudioManager::audio_3d_set_drop_off_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).audio_3d_set_drop_off_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_drop_off_factor(const AudioManager self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_drop_off_factor_85_comment =
  "C++ Interface:\n"
  "audio_3d_set_drop_off_factor(const AudioManager self, float factor)\n"
  "\n"
  "// Exaggerate or diminish the effect of distance on sound.  Default is 1.0\n"
  "// Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use\n"
  "// <1.0";
#else
static const char *Dtool_AudioManager_audio_3d_set_drop_off_factor_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::audio_3d_get_drop_off_factor(void) const
 */
static PyObject *Dtool_AudioManager_audio_3d_get_drop_off_factor_86(PyObject *self, PyObject *) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat AudioManager::audio_3d_get_drop_off_factor(void) const
  PN_stdfloat return_value = ((*(const AudioManager*)local_this).audio_3d_get_drop_off_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_get_drop_off_factor_86_comment =
  "C++ Interface:\n"
  "audio_3d_get_drop_off_factor(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_audio_3d_get_drop_off_factor_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename AudioManager::get_dls_pathname(void)
 */
static PyObject *Dtool_AudioManager_get_dls_pathname_87(PyObject *, PyObject *) {
  // 1-static Filename AudioManager::get_dls_pathname(void)
  Filename *return_value = new Filename((AudioManager::get_dls_pathname)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_dls_pathname_87_comment =
  "C++ Interface:\n"
  "get_dls_pathname()\n";
#else
static const char *Dtool_AudioManager_get_dls_pathname_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::output(std::ostream &out) const
 */
static PyObject *Dtool_AudioManager_output_90(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual void AudioManager::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AudioManager.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AudioManager*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AudioManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_output_90_comment =
  "C++ Interface:\n"
  "output(AudioManager self, ostream out)\n";
#else
static const char *Dtool_AudioManager_output_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::write(std::ostream &out) const
 */
static PyObject *Dtool_AudioManager_write_91(PyObject *self, PyObject *arg) {
  AudioManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioManager)) {
    return nullptr;
  }
  // 1-virtual void AudioManager::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AudioManager.write", false, true);
  if (arg_this != nullptr) {
    ((*(const AudioManager*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AudioManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_write_91_comment =
  "C++ Interface:\n"
  "write(AudioManager self, ostream out)\n";
#else
static const char *Dtool_AudioManager_write_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AudioManager::get_class_type(void)
 */
static PyObject *Dtool_AudioManager_get_class_type_92(PyObject *, PyObject *) {
  // 1-static TypeHandle AudioManager::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AudioManager::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_class_type_92_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AudioManager_get_class_type_92_comment = nullptr;
#endif

static PyObject *Dtool_AudioManager_dls_pathname_Getter(PyObject *self, void *) {
  // 1-static Filename AudioManager::get_dls_pathname(void)
  Filename *return_value = new Filename((AudioManager::get_dls_pathname)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

static int Dtool_Init_AudioManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AudioManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AudioManager) {
    printf("AudioManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AudioManager *local_this = (AudioManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AudioManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AudioManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AudioManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AudioManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AudioManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AudioManager*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AudioLoadRequest
 */
/**
 * Python function wrapper for:
 * inline AudioManager *AudioLoadRequest::get_audio_manager(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_audio_manager_96(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioLoadRequest)) {
    return nullptr;
  }
  // 1-inline AudioManager *AudioLoadRequest::get_audio_manager(void) const
  AudioManager *return_value = ((*(const AudioLoadRequest*)local_this).get_audio_manager)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AudioManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_audio_manager_96_comment =
  "C++ Interface:\n"
  "get_audio_manager(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the AudioManager that will serve this asynchronous\n"
  " * AudioLoadRequest.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_audio_manager_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &AudioLoadRequest::get_filename(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_filename_97(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioLoadRequest)) {
    return nullptr;
  }
  // 1-inline std::string const &AudioLoadRequest::get_filename(void) const
  std::string const &return_value = ((*(const AudioLoadRequest*)local_this).get_filename)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_filename_97_comment =
  "C++ Interface:\n"
  "get_filename(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the filename associated with this asynchronous AudioLoadRequest.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_filename_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AudioLoadRequest::get_positional(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_positional_98(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioLoadRequest)) {
    return nullptr;
  }
  // 1-inline bool AudioLoadRequest::get_positional(void) const
  bool return_value = ((*(const AudioLoadRequest*)local_this).get_positional)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_positional_98_comment =
  "C++ Interface:\n"
  "get_positional(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the positional flag associated with this asynchronous\n"
  " * AudioLoadRequest.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_positional_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AudioLoadRequest::is_ready(void) const
 */
static PyObject *Dtool_AudioLoadRequest_is_ready_99(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioLoadRequest)) {
    return nullptr;
  }
  // 1-inline bool AudioLoadRequest::is_ready(void) const
  bool return_value = ((*(const AudioLoadRequest*)local_this).is_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_is_ready_99_comment =
  "C++ Interface:\n"
  "is_ready(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns true if this request has completed, false if it is still pending.\n"
  " * When this returns true, you may retrieve the sound loaded by calling\n"
  " * get_sound().\n"
  " * Equivalent to `req.done() and not req.cancelled()`.\n"
  " * @see done()\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_is_ready_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AudioSound *AudioLoadRequest::get_sound(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_sound_100(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AudioLoadRequest)) {
    return nullptr;
  }
  // 1-inline AudioSound *AudioLoadRequest::get_sound(void) const
  AudioSound *return_value = ((*(const AudioLoadRequest*)local_this).get_sound)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AudioSound, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_sound_100_comment =
  "C++ Interface:\n"
  "get_sound(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the sound that was loaded asynchronously, if any, or nullptr if\n"
  " * there was an error.  It is an error to call this unless done() returns\n"
  " * true.\n"
  " * @deprecated Use result() instead.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_sound_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AudioLoadRequest::get_class_type(void)
 */
static PyObject *Dtool_AudioLoadRequest_get_class_type_101(PyObject *, PyObject *) {
  // 1-static TypeHandle AudioLoadRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AudioLoadRequest::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_class_type_101_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AudioLoadRequest_get_class_type_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AudioLoadRequest::AudioLoadRequest(AudioLoadRequest const &) = default
 * inline explicit AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional)
 */
static int Dtool_Init_AudioLoadRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline AudioLoadRequest::AudioLoadRequest(AudioLoadRequest const &) = default
      AudioLoadRequest const *arg_this = (AudioLoadRequest *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AudioLoadRequest, 0, "AudioLoadRequest.AudioLoadRequest", true, true);
      if (arg_this != nullptr) {
        AudioLoadRequest *return_value = new AudioLoadRequest(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AudioLoadRequest, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline explicit AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      PyObject *param2;
      static const char *keyword_list[] = {"audio_manager", "filename", "positional", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#O:AudioLoadRequest", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2)) {
        AudioManager *param0_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioManager, 0, "AudioLoadRequest.AudioLoadRequest", false, true);
        if (param0_this != nullptr) {
          AudioLoadRequest *return_value = new AudioLoadRequest(param0_this, std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AudioLoadRequest, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AudioLoadRequest() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AudioLoadRequest(const AudioLoadRequest param0)\n"
      "AudioLoadRequest(AudioManager audio_manager, str filename, bool positional)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AudioLoadRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AudioLoadRequest) {
    printf("AudioLoadRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AudioLoadRequest *local_this = (AudioLoadRequest *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AudioLoadRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AudioLoadRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AudioLoadRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for FilterProperties (FilterProperties)
 */
static PyMethodDef Dtool_Methods_FilterProperties[] = {
  {"clear", &Dtool_FilterProperties_clear_4, METH_NOARGS, (const char *)Dtool_FilterProperties_clear_4_comment},
  {"add_lowpass", (PyCFunction) &Dtool_FilterProperties_add_lowpass_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_lowpass_5_comment},
  {"addLowpass", (PyCFunction) &Dtool_FilterProperties_add_lowpass_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_lowpass_5_comment},
  {"add_highpass", (PyCFunction) &Dtool_FilterProperties_add_highpass_6, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_highpass_6_comment},
  {"addHighpass", (PyCFunction) &Dtool_FilterProperties_add_highpass_6, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_highpass_6_comment},
  {"add_echo", (PyCFunction) &Dtool_FilterProperties_add_echo_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_echo_7_comment},
  {"addEcho", (PyCFunction) &Dtool_FilterProperties_add_echo_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_echo_7_comment},
  {"add_flange", (PyCFunction) &Dtool_FilterProperties_add_flange_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_flange_8_comment},
  {"addFlange", (PyCFunction) &Dtool_FilterProperties_add_flange_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_flange_8_comment},
  {"add_distort", &Dtool_FilterProperties_add_distort_9, METH_O, (const char *)Dtool_FilterProperties_add_distort_9_comment},
  {"addDistort", &Dtool_FilterProperties_add_distort_9, METH_O, (const char *)Dtool_FilterProperties_add_distort_9_comment},
  {"add_normalize", (PyCFunction) &Dtool_FilterProperties_add_normalize_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_normalize_10_comment},
  {"addNormalize", (PyCFunction) &Dtool_FilterProperties_add_normalize_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_normalize_10_comment},
  {"add_parameq", (PyCFunction) &Dtool_FilterProperties_add_parameq_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_parameq_11_comment},
  {"addParameq", (PyCFunction) &Dtool_FilterProperties_add_parameq_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_parameq_11_comment},
  {"add_pitchshift", (PyCFunction) &Dtool_FilterProperties_add_pitchshift_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_pitchshift_12_comment},
  {"addPitchshift", (PyCFunction) &Dtool_FilterProperties_add_pitchshift_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_pitchshift_12_comment},
  {"add_chorus", (PyCFunction) &Dtool_FilterProperties_add_chorus_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_chorus_13_comment},
  {"addChorus", (PyCFunction) &Dtool_FilterProperties_add_chorus_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_chorus_13_comment},
  {"add_sfxreverb", (PyCFunction) &Dtool_FilterProperties_add_sfxreverb_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_sfxreverb_14_comment},
  {"addSfxreverb", (PyCFunction) &Dtool_FilterProperties_add_sfxreverb_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_sfxreverb_14_comment},
  {"add_compress", (PyCFunction) &Dtool_FilterProperties_add_compress_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_compress_15_comment},
  {"addCompress", (PyCFunction) &Dtool_FilterProperties_add_compress_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_compress_15_comment},
  {"get_class_type", &Dtool_FilterProperties_get_class_type_16, METH_NOARGS | METH_STATIC, (const char *)Dtool_FilterProperties_get_class_type_16_comment},
  {"getClassType", &Dtool_FilterProperties_get_class_type_16, METH_NOARGS | METH_STATIC, (const char *)Dtool_FilterProperties_get_class_type_16_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_FilterProperties = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FilterProperties = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FilterProperties = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FilterProperties = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FilterProperties = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FilterProperties = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FilterProperties",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FilterProperties,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FilterProperties,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FilterProperties,
    &Dtool_SequenceMethods_FilterProperties,
    &Dtool_MappingMethods_FilterProperties,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FilterProperties,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FilterProperties,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FilterProperties,
    PyType_GenericAlloc,
    Dtool_new_FilterProperties,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FilterProperties,
  Dtool_UpcastInterface_FilterProperties,
  Dtool_DowncastInterface_FilterProperties,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FilterProperties(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_FilterProperties._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_FilterProperties._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FilterProperties._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FilterProperties) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FilterProperties)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FilterProperties);
  }
}

/**
 * Python method tables for AudioSound (AudioSound)
 */
static PyMethodDef Dtool_Methods_AudioSound[] = {
  {"play", &Dtool_AudioSound_play_18, METH_NOARGS, (const char *)Dtool_AudioSound_play_18_comment},
  {"stop", &Dtool_AudioSound_stop_19, METH_NOARGS, (const char *)Dtool_AudioSound_stop_19_comment},
  {"set_loop", (PyCFunction) &Dtool_AudioSound_set_loop_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_20_comment},
  {"setLoop", (PyCFunction) &Dtool_AudioSound_set_loop_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_20_comment},
  {"get_loop", &Dtool_AudioSound_get_loop_21, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_21_comment},
  {"getLoop", &Dtool_AudioSound_get_loop_21, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_21_comment},
  {"set_loop_count", (PyCFunction) &Dtool_AudioSound_set_loop_count_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_count_22_comment},
  {"setLoopCount", (PyCFunction) &Dtool_AudioSound_set_loop_count_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_count_22_comment},
  {"get_loop_count", &Dtool_AudioSound_get_loop_count_23, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_count_23_comment},
  {"getLoopCount", &Dtool_AudioSound_get_loop_count_23, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_count_23_comment},
  {"set_time", (PyCFunction) &Dtool_AudioSound_set_time_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_time_24_comment},
  {"setTime", (PyCFunction) &Dtool_AudioSound_set_time_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_time_24_comment},
  {"get_time", &Dtool_AudioSound_get_time_25, METH_NOARGS, (const char *)Dtool_AudioSound_get_time_25_comment},
  {"getTime", &Dtool_AudioSound_get_time_25, METH_NOARGS, (const char *)Dtool_AudioSound_get_time_25_comment},
  {"set_volume", (PyCFunction) &Dtool_AudioSound_set_volume_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_volume_26_comment},
  {"setVolume", (PyCFunction) &Dtool_AudioSound_set_volume_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_volume_26_comment},
  {"get_volume", &Dtool_AudioSound_get_volume_27, METH_NOARGS, (const char *)Dtool_AudioSound_get_volume_27_comment},
  {"getVolume", &Dtool_AudioSound_get_volume_27, METH_NOARGS, (const char *)Dtool_AudioSound_get_volume_27_comment},
  {"set_balance", (PyCFunction) &Dtool_AudioSound_set_balance_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_balance_28_comment},
  {"setBalance", (PyCFunction) &Dtool_AudioSound_set_balance_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_balance_28_comment},
  {"get_balance", &Dtool_AudioSound_get_balance_29, METH_NOARGS, (const char *)Dtool_AudioSound_get_balance_29_comment},
  {"getBalance", &Dtool_AudioSound_get_balance_29, METH_NOARGS, (const char *)Dtool_AudioSound_get_balance_29_comment},
  {"set_play_rate", (PyCFunction) &Dtool_AudioSound_set_play_rate_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_play_rate_30_comment},
  {"setPlayRate", (PyCFunction) &Dtool_AudioSound_set_play_rate_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_play_rate_30_comment},
  {"get_play_rate", &Dtool_AudioSound_get_play_rate_31, METH_NOARGS, (const char *)Dtool_AudioSound_get_play_rate_31_comment},
  {"getPlayRate", &Dtool_AudioSound_get_play_rate_31, METH_NOARGS, (const char *)Dtool_AudioSound_get_play_rate_31_comment},
  {"set_active", (PyCFunction) &Dtool_AudioSound_set_active_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_active_32_comment},
  {"setActive", (PyCFunction) &Dtool_AudioSound_set_active_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_active_32_comment},
  {"get_active", &Dtool_AudioSound_get_active_33, METH_NOARGS, (const char *)Dtool_AudioSound_get_active_33_comment},
  {"getActive", &Dtool_AudioSound_get_active_33, METH_NOARGS, (const char *)Dtool_AudioSound_get_active_33_comment},
  {"set_finished_event", &Dtool_AudioSound_set_finished_event_34, METH_O, (const char *)Dtool_AudioSound_set_finished_event_34_comment},
  {"setFinishedEvent", &Dtool_AudioSound_set_finished_event_34, METH_O, (const char *)Dtool_AudioSound_set_finished_event_34_comment},
  {"get_finished_event", &Dtool_AudioSound_get_finished_event_35, METH_NOARGS, (const char *)Dtool_AudioSound_get_finished_event_35_comment},
  {"getFinishedEvent", &Dtool_AudioSound_get_finished_event_35, METH_NOARGS, (const char *)Dtool_AudioSound_get_finished_event_35_comment},
  {"get_name", &Dtool_AudioSound_get_name_36, METH_NOARGS, (const char *)Dtool_AudioSound_get_name_36_comment},
  {"getName", &Dtool_AudioSound_get_name_36, METH_NOARGS, (const char *)Dtool_AudioSound_get_name_36_comment},
  {"length", &Dtool_AudioSound_length_37, METH_NOARGS, (const char *)Dtool_AudioSound_length_37_comment},
  {"set_3d_attributes", (PyCFunction) &Dtool_AudioSound_set_3d_attributes_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_3d_attributes_38_comment},
  {"set3dAttributes", (PyCFunction) &Dtool_AudioSound_set_3d_attributes_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_3d_attributes_38_comment},
  {"set_3d_min_distance", &Dtool_AudioSound_set_3d_min_distance_40, METH_O, (const char *)Dtool_AudioSound_set_3d_min_distance_40_comment},
  {"set3dMinDistance", &Dtool_AudioSound_set_3d_min_distance_40, METH_O, (const char *)Dtool_AudioSound_set_3d_min_distance_40_comment},
  {"get_3d_min_distance", &Dtool_AudioSound_get_3d_min_distance_41, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_min_distance_41_comment},
  {"get3dMinDistance", &Dtool_AudioSound_get_3d_min_distance_41, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_min_distance_41_comment},
  {"set_3d_max_distance", &Dtool_AudioSound_set_3d_max_distance_42, METH_O, (const char *)Dtool_AudioSound_set_3d_max_distance_42_comment},
  {"set3dMaxDistance", &Dtool_AudioSound_set_3d_max_distance_42, METH_O, (const char *)Dtool_AudioSound_set_3d_max_distance_42_comment},
  {"get_3d_max_distance", &Dtool_AudioSound_get_3d_max_distance_43, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_max_distance_43_comment},
  {"get3dMaxDistance", &Dtool_AudioSound_get_3d_max_distance_43, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_max_distance_43_comment},
  {"get_speaker_mix", &Dtool_AudioSound_get_speaker_mix_44, METH_O, (const char *)Dtool_AudioSound_get_speaker_mix_44_comment},
  {"getSpeakerMix", &Dtool_AudioSound_get_speaker_mix_44, METH_O, (const char *)Dtool_AudioSound_get_speaker_mix_44_comment},
  {"set_speaker_mix", (PyCFunction) &Dtool_AudioSound_set_speaker_mix_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_speaker_mix_45_comment},
  {"setSpeakerMix", (PyCFunction) &Dtool_AudioSound_set_speaker_mix_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_speaker_mix_45_comment},
  {"get_priority", &Dtool_AudioSound_get_priority_46, METH_NOARGS, (const char *)Dtool_AudioSound_get_priority_46_comment},
  {"getPriority", &Dtool_AudioSound_get_priority_46, METH_NOARGS, (const char *)Dtool_AudioSound_get_priority_46_comment},
  {"set_priority", &Dtool_AudioSound_set_priority_47, METH_O, (const char *)Dtool_AudioSound_set_priority_47_comment},
  {"setPriority", &Dtool_AudioSound_set_priority_47, METH_O, (const char *)Dtool_AudioSound_set_priority_47_comment},
  {"configure_filters", &Dtool_AudioSound_configure_filters_48, METH_O, (const char *)Dtool_AudioSound_configure_filters_48_comment},
  {"configureFilters", &Dtool_AudioSound_configure_filters_48, METH_O, (const char *)Dtool_AudioSound_configure_filters_48_comment},
  {"status", &Dtool_AudioSound_status_50, METH_NOARGS, (const char *)Dtool_AudioSound_status_50_comment},
  {"output", &Dtool_AudioSound_output_51, METH_O, (const char *)Dtool_AudioSound_output_51_comment},
  {"write", &Dtool_AudioSound_write_52, METH_O, (const char *)Dtool_AudioSound_write_52_comment},
  {"get_class_type", &Dtool_AudioSound_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioSound_get_class_type_53_comment},
  {"getClassType", &Dtool_AudioSound_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioSound_get_class_type_53_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AudioSound
//////////////////
static PyObject *Dtool_Repr_AudioSound(PyObject *self) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AudioSound
//////////////////
static PyObject *Dtool_Str_AudioSound(PyObject *self) {
  AudioSound *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AudioSound = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AudioSound = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AudioSound = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AudioSound = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AudioSound = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AudioSound = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AudioSound",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioSound,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AudioSound,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AudioSound,
    &Dtool_NumberMethods_AudioSound,
    &Dtool_SequenceMethods_AudioSound,
    &Dtool_MappingMethods_AudioSound,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AudioSound,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AudioSound,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AudioSound,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AudioSound,
    PyType_GenericAlloc,
    Dtool_new_AudioSound,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioSound,
  Dtool_UpcastInterface_AudioSound,
  Dtool_DowncastInterface_AudioSound,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AudioSound(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_AudioSound._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_AudioSound._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_AudioSound._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AudioSound::SoundStatus;
    PyDict_SetItemString(dict, "BAD", Dtool_WrapValue(AudioSound::BAD));
    PyDict_SetItemString(dict, "READY", Dtool_WrapValue(AudioSound::READY));
    PyDict_SetItemString(dict, "PLAYING", Dtool_WrapValue(AudioSound::PLAYING));
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioSound) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioSound)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioSound);
  }
}

/**
 * Python method tables for AudioManager (AudioManager)
 */
static PyMethodDef Dtool_Methods_AudioManager[] = {
  {"get_speaker_setup", &Dtool_AudioManager_get_speaker_setup_58, METH_NOARGS, (const char *)Dtool_AudioManager_get_speaker_setup_58_comment},
  {"getSpeakerSetup", &Dtool_AudioManager_get_speaker_setup_58, METH_NOARGS, (const char *)Dtool_AudioManager_get_speaker_setup_58_comment},
  {"set_speaker_setup", &Dtool_AudioManager_set_speaker_setup_59, METH_O, (const char *)Dtool_AudioManager_set_speaker_setup_59_comment},
  {"setSpeakerSetup", &Dtool_AudioManager_set_speaker_setup_59, METH_O, (const char *)Dtool_AudioManager_set_speaker_setup_59_comment},
  {"configure_filters", &Dtool_AudioManager_configure_filters_60, METH_O, (const char *)Dtool_AudioManager_configure_filters_60_comment},
  {"configureFilters", &Dtool_AudioManager_configure_filters_60, METH_O, (const char *)Dtool_AudioManager_configure_filters_60_comment},
  {"create_AudioManager", &Dtool_AudioManager_create_AudioManager_61, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_create_AudioManager_61_comment},
  {"createAudioManager", &Dtool_AudioManager_create_AudioManager_61, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_create_AudioManager_61_comment},
  {"shutdown", &Dtool_AudioManager_shutdown_62, METH_NOARGS, (const char *)Dtool_AudioManager_shutdown_62_comment},
  {"is_valid", &Dtool_AudioManager_is_valid_63, METH_NOARGS, (const char *)Dtool_AudioManager_is_valid_63_comment},
  {"isValid", &Dtool_AudioManager_is_valid_63, METH_NOARGS, (const char *)Dtool_AudioManager_is_valid_63_comment},
  {"get_sound", (PyCFunction) &Dtool_AudioManager_get_sound_64, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_get_sound_64_comment},
  {"getSound", (PyCFunction) &Dtool_AudioManager_get_sound_64, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_get_sound_64_comment},
  {"get_null_sound", &Dtool_AudioManager_get_null_sound_65, METH_NOARGS, (const char *)Dtool_AudioManager_get_null_sound_65_comment},
  {"getNullSound", &Dtool_AudioManager_get_null_sound_65, METH_NOARGS, (const char *)Dtool_AudioManager_get_null_sound_65_comment},
  {"uncache_sound", &Dtool_AudioManager_uncache_sound_66, METH_O, (const char *)Dtool_AudioManager_uncache_sound_66_comment},
  {"uncacheSound", &Dtool_AudioManager_uncache_sound_66, METH_O, (const char *)Dtool_AudioManager_uncache_sound_66_comment},
  {"clear_cache", &Dtool_AudioManager_clear_cache_67, METH_NOARGS, (const char *)Dtool_AudioManager_clear_cache_67_comment},
  {"clearCache", &Dtool_AudioManager_clear_cache_67, METH_NOARGS, (const char *)Dtool_AudioManager_clear_cache_67_comment},
  {"set_cache_limit", &Dtool_AudioManager_set_cache_limit_68, METH_O, (const char *)Dtool_AudioManager_set_cache_limit_68_comment},
  {"setCacheLimit", &Dtool_AudioManager_set_cache_limit_68, METH_O, (const char *)Dtool_AudioManager_set_cache_limit_68_comment},
  {"get_cache_limit", &Dtool_AudioManager_get_cache_limit_69, METH_NOARGS, (const char *)Dtool_AudioManager_get_cache_limit_69_comment},
  {"getCacheLimit", &Dtool_AudioManager_get_cache_limit_69, METH_NOARGS, (const char *)Dtool_AudioManager_get_cache_limit_69_comment},
  {"set_volume", &Dtool_AudioManager_set_volume_70, METH_O, (const char *)Dtool_AudioManager_set_volume_70_comment},
  {"setVolume", &Dtool_AudioManager_set_volume_70, METH_O, (const char *)Dtool_AudioManager_set_volume_70_comment},
  {"get_volume", &Dtool_AudioManager_get_volume_71, METH_NOARGS, (const char *)Dtool_AudioManager_get_volume_71_comment},
  {"getVolume", &Dtool_AudioManager_get_volume_71, METH_NOARGS, (const char *)Dtool_AudioManager_get_volume_71_comment},
  {"set_active", &Dtool_AudioManager_set_active_72, METH_O, (const char *)Dtool_AudioManager_set_active_72_comment},
  {"setActive", &Dtool_AudioManager_set_active_72, METH_O, (const char *)Dtool_AudioManager_set_active_72_comment},
  {"get_active", &Dtool_AudioManager_get_active_73, METH_NOARGS, (const char *)Dtool_AudioManager_get_active_73_comment},
  {"getActive", &Dtool_AudioManager_get_active_73, METH_NOARGS, (const char *)Dtool_AudioManager_get_active_73_comment},
  {"set_concurrent_sound_limit", (PyCFunction) &Dtool_AudioManager_set_concurrent_sound_limit_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_set_concurrent_sound_limit_74_comment},
  {"setConcurrentSoundLimit", (PyCFunction) &Dtool_AudioManager_set_concurrent_sound_limit_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_set_concurrent_sound_limit_74_comment},
  {"get_concurrent_sound_limit", &Dtool_AudioManager_get_concurrent_sound_limit_75, METH_NOARGS, (const char *)Dtool_AudioManager_get_concurrent_sound_limit_75_comment},
  {"getConcurrentSoundLimit", &Dtool_AudioManager_get_concurrent_sound_limit_75, METH_NOARGS, (const char *)Dtool_AudioManager_get_concurrent_sound_limit_75_comment},
  {"reduce_sounds_playing_to", &Dtool_AudioManager_reduce_sounds_playing_to_76, METH_O, (const char *)Dtool_AudioManager_reduce_sounds_playing_to_76_comment},
  {"reduceSoundsPlayingTo", &Dtool_AudioManager_reduce_sounds_playing_to_76, METH_O, (const char *)Dtool_AudioManager_reduce_sounds_playing_to_76_comment},
  {"stop_all_sounds", &Dtool_AudioManager_stop_all_sounds_77, METH_NOARGS, (const char *)Dtool_AudioManager_stop_all_sounds_77_comment},
  {"stopAllSounds", &Dtool_AudioManager_stop_all_sounds_77, METH_NOARGS, (const char *)Dtool_AudioManager_stop_all_sounds_77_comment},
  {"update", &Dtool_AudioManager_update_78, METH_NOARGS, (const char *)Dtool_AudioManager_update_78_comment},
  {"audio_3d_set_listener_attributes", (PyCFunction) &Dtool_AudioManager_audio_3d_set_listener_attributes_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_audio_3d_set_listener_attributes_79_comment},
  {"audio3dSetListenerAttributes", (PyCFunction) &Dtool_AudioManager_audio_3d_set_listener_attributes_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_audio_3d_set_listener_attributes_79_comment},
  {"audio_3d_set_distance_factor", &Dtool_AudioManager_audio_3d_set_distance_factor_81, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_distance_factor_81_comment},
  {"audio3dSetDistanceFactor", &Dtool_AudioManager_audio_3d_set_distance_factor_81, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_distance_factor_81_comment},
  {"audio_3d_get_distance_factor", &Dtool_AudioManager_audio_3d_get_distance_factor_82, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_distance_factor_82_comment},
  {"audio3dGetDistanceFactor", &Dtool_AudioManager_audio_3d_get_distance_factor_82, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_distance_factor_82_comment},
  {"audio_3d_set_doppler_factor", &Dtool_AudioManager_audio_3d_set_doppler_factor_83, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_doppler_factor_83_comment},
  {"audio3dSetDopplerFactor", &Dtool_AudioManager_audio_3d_set_doppler_factor_83, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_doppler_factor_83_comment},
  {"audio_3d_get_doppler_factor", &Dtool_AudioManager_audio_3d_get_doppler_factor_84, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_doppler_factor_84_comment},
  {"audio3dGetDopplerFactor", &Dtool_AudioManager_audio_3d_get_doppler_factor_84, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_doppler_factor_84_comment},
  {"audio_3d_set_drop_off_factor", &Dtool_AudioManager_audio_3d_set_drop_off_factor_85, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_drop_off_factor_85_comment},
  {"audio3dSetDropOffFactor", &Dtool_AudioManager_audio_3d_set_drop_off_factor_85, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_drop_off_factor_85_comment},
  {"audio_3d_get_drop_off_factor", &Dtool_AudioManager_audio_3d_get_drop_off_factor_86, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_drop_off_factor_86_comment},
  {"audio3dGetDropOffFactor", &Dtool_AudioManager_audio_3d_get_drop_off_factor_86, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_drop_off_factor_86_comment},
  {"get_dls_pathname", &Dtool_AudioManager_get_dls_pathname_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_dls_pathname_87_comment},
  {"getDlsPathname", &Dtool_AudioManager_get_dls_pathname_87, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_dls_pathname_87_comment},
  {"output", &Dtool_AudioManager_output_90, METH_O, (const char *)Dtool_AudioManager_output_90_comment},
  {"write", &Dtool_AudioManager_write_91, METH_O, (const char *)Dtool_AudioManager_write_91_comment},
  {"get_class_type", &Dtool_AudioManager_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_class_type_92_comment},
  {"getClassType", &Dtool_AudioManager_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_class_type_92_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AudioManager
//////////////////
static PyObject *Dtool_Repr_AudioManager(PyObject *self) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AudioManager
//////////////////
static PyObject *Dtool_Str_AudioManager(PyObject *self) {
  AudioManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AudioManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AudioManager = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AudioManager = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AudioManager = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AudioManager = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AudioManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AudioManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AudioManager,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AudioManager,
    &Dtool_NumberMethods_AudioManager,
    &Dtool_SequenceMethods_AudioManager,
    &Dtool_MappingMethods_AudioManager,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AudioManager,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AudioManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AudioManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AudioManager,
    PyType_GenericAlloc,
    Dtool_new_AudioManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioManager,
  Dtool_UpcastInterface_AudioManager,
  Dtool_DowncastInterface_AudioManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AudioManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_AudioManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_AudioManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(45);
    Dtool_AudioManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AudioManager::SpeakerModeCategory;
    PyDict_SetItemString(dict, "SPEAKERMODE_raw", Dtool_WrapValue(AudioManager::SPEAKERMODE_raw));
    PyDict_SetItemString(dict, "SPEAKERMODERaw", Dtool_WrapValue(AudioManager::SPEAKERMODE_raw));
    PyDict_SetItemString(dict, "SPEAKERMODE_mono", Dtool_WrapValue(AudioManager::SPEAKERMODE_mono));
    PyDict_SetItemString(dict, "SPEAKERMODEMono", Dtool_WrapValue(AudioManager::SPEAKERMODE_mono));
    PyDict_SetItemString(dict, "SPEAKERMODE_stereo", Dtool_WrapValue(AudioManager::SPEAKERMODE_stereo));
    PyDict_SetItemString(dict, "SPEAKERMODEStereo", Dtool_WrapValue(AudioManager::SPEAKERMODE_stereo));
    PyDict_SetItemString(dict, "SPEAKERMODE_quad", Dtool_WrapValue(AudioManager::SPEAKERMODE_quad));
    PyDict_SetItemString(dict, "SPEAKERMODEQuad", Dtool_WrapValue(AudioManager::SPEAKERMODE_quad));
    PyDict_SetItemString(dict, "SPEAKERMODE_surround", Dtool_WrapValue(AudioManager::SPEAKERMODE_surround));
    PyDict_SetItemString(dict, "SPEAKERMODESurround", Dtool_WrapValue(AudioManager::SPEAKERMODE_surround));
    PyDict_SetItemString(dict, "SPEAKERMODE_5point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_5point1));
    PyDict_SetItemString(dict, "SPEAKERMODE5point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_5point1));
    PyDict_SetItemString(dict, "SPEAKERMODE_7point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_7point1));
    PyDict_SetItemString(dict, "SPEAKERMODE7point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_7point1));
    PyDict_SetItemString(dict, "SPEAKERMODE_max", Dtool_WrapValue(AudioManager::SPEAKERMODE_max));
    PyDict_SetItemString(dict, "SPEAKERMODEMax", Dtool_WrapValue(AudioManager::SPEAKERMODE_max));
    PyDict_SetItemString(dict, "SPEAKERMODE_COUNT", Dtool_WrapValue(AudioManager::SPEAKERMODE_COUNT));
    PyDict_SetItemString(dict, "SPEAKERMODECOUNT", Dtool_WrapValue(AudioManager::SPEAKERMODE_COUNT));
    // enum AudioManager::SpeakerId;
    PyDict_SetItemString(dict, "SPK_none", Dtool_WrapValue(AudioManager::SPK_none));
    PyDict_SetItemString(dict, "SPKNone", Dtool_WrapValue(AudioManager::SPK_none));
    PyDict_SetItemString(dict, "SPK_frontleft", Dtool_WrapValue(AudioManager::SPK_frontleft));
    PyDict_SetItemString(dict, "SPKFrontleft", Dtool_WrapValue(AudioManager::SPK_frontleft));
    PyDict_SetItemString(dict, "SPK_frontright", Dtool_WrapValue(AudioManager::SPK_frontright));
    PyDict_SetItemString(dict, "SPKFrontright", Dtool_WrapValue(AudioManager::SPK_frontright));
    PyDict_SetItemString(dict, "SPK_center", Dtool_WrapValue(AudioManager::SPK_center));
    PyDict_SetItemString(dict, "SPKCenter", Dtool_WrapValue(AudioManager::SPK_center));
    PyDict_SetItemString(dict, "SPK_sub", Dtool_WrapValue(AudioManager::SPK_sub));
    PyDict_SetItemString(dict, "SPKSub", Dtool_WrapValue(AudioManager::SPK_sub));
    PyDict_SetItemString(dict, "SPK_backleft", Dtool_WrapValue(AudioManager::SPK_backleft));
    PyDict_SetItemString(dict, "SPKBackleft", Dtool_WrapValue(AudioManager::SPK_backleft));
    PyDict_SetItemString(dict, "SPK_backright", Dtool_WrapValue(AudioManager::SPK_backright));
    PyDict_SetItemString(dict, "SPKBackright", Dtool_WrapValue(AudioManager::SPK_backright));
    PyDict_SetItemString(dict, "SPK_sideleft", Dtool_WrapValue(AudioManager::SPK_sideleft));
    PyDict_SetItemString(dict, "SPKSideleft", Dtool_WrapValue(AudioManager::SPK_sideleft));
    PyDict_SetItemString(dict, "SPK_sideright", Dtool_WrapValue(AudioManager::SPK_sideright));
    PyDict_SetItemString(dict, "SPKSideright", Dtool_WrapValue(AudioManager::SPK_sideright));
    PyDict_SetItemString(dict, "SPK_COUNT", Dtool_WrapValue(AudioManager::SPK_COUNT));
    PyDict_SetItemString(dict, "SPKCOUNT", Dtool_WrapValue(AudioManager::SPK_COUNT));
    // enum AudioManager::StreamMode;
    PyDict_SetItemString(dict, "SM_heuristic", Dtool_WrapValue(AudioManager::SM_heuristic));
    PyDict_SetItemString(dict, "SMHeuristic", Dtool_WrapValue(AudioManager::SM_heuristic));
    PyDict_SetItemString(dict, "SM_sample", Dtool_WrapValue(AudioManager::SM_sample));
    PyDict_SetItemString(dict, "SMSample", Dtool_WrapValue(AudioManager::SM_sample));
    PyDict_SetItemString(dict, "SM_stream", Dtool_WrapValue(AudioManager::SM_stream));
    PyDict_SetItemString(dict, "SMStream", Dtool_WrapValue(AudioManager::SM_stream));
    static const PyGetSetDef def_dls_pathname = {(char *)"dls_pathname", &Dtool_AudioManager_dls_pathname_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "dls_pathname", Dtool_NewStaticProperty(&Dtool_AudioManager._PyType, &def_dls_pathname));
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioManager);
  }
}

/**
 * Python method tables for AudioLoadRequest (AudioLoadRequest)
 */
static PyMethodDef Dtool_Methods_AudioLoadRequest[] = {
  {"get_audio_manager", &Dtool_AudioLoadRequest_get_audio_manager_96, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_audio_manager_96_comment},
  {"getAudioManager", &Dtool_AudioLoadRequest_get_audio_manager_96, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_audio_manager_96_comment},
  {"get_filename", &Dtool_AudioLoadRequest_get_filename_97, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_filename_97_comment},
  {"getFilename", &Dtool_AudioLoadRequest_get_filename_97, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_filename_97_comment},
  {"get_positional", &Dtool_AudioLoadRequest_get_positional_98, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_positional_98_comment},
  {"getPositional", &Dtool_AudioLoadRequest_get_positional_98, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_positional_98_comment},
  {"is_ready", &Dtool_AudioLoadRequest_is_ready_99, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_is_ready_99_comment},
  {"isReady", &Dtool_AudioLoadRequest_is_ready_99, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_is_ready_99_comment},
  {"get_sound", &Dtool_AudioLoadRequest_get_sound_100, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_sound_100_comment},
  {"getSound", &Dtool_AudioLoadRequest_get_sound_100, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_sound_100_comment},
  {"get_class_type", &Dtool_AudioLoadRequest_get_class_type_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioLoadRequest_get_class_type_101_comment},
  {"getClassType", &Dtool_AudioLoadRequest_get_class_type_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioLoadRequest_get_class_type_101_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AudioLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AudioLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AudioLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AudioLoadRequest = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AudioLoadRequest = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AudioLoadRequest = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AudioLoadRequest",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioLoadRequest,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AudioLoadRequest,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AudioLoadRequest,
    &Dtool_SequenceMethods_AudioLoadRequest,
    &Dtool_MappingMethods_AudioLoadRequest,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AudioLoadRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object that manages a single asynchronous audio load request.  This\n"
    " * works in conjunction with the Loader class defined in pgraph, or really\n"
    " * with any AsyncTaskManager.  Create a new AudioLoadRequest, and add it to\n"
    " * the loader via load_async(), to begin an asynchronous load.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AudioLoadRequest,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AudioLoadRequest,
    PyType_GenericAlloc,
    Dtool_new_AudioLoadRequest,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioLoadRequest,
  Dtool_UpcastInterface_AudioLoadRequest,
  Dtool_DowncastInterface_AudioLoadRequest,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AudioLoadRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTask != nullptr);
    assert(Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit(nullptr);
    Dtool_AudioLoadRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTask);
    Dtool_AudioLoadRequest._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AudioLoadRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioLoadRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioLoadRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioLoadRequest);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3audio_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    FilterProperties::init_type();
    TypeHandle handle = FilterProperties::get_class_type();
    Dtool_FilterProperties._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FilterProperties);
  }
  {
    AudioSound::init_type();
    TypeHandle handle = AudioSound::get_class_type();
    Dtool_AudioSound._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AudioSound);
  }
  {
    AudioManager::init_type();
    TypeHandle handle = AudioManager::get_class_type();
    Dtool_AudioManager._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AudioManager);
  }
  {
    AudioLoadRequest::init_type();
    TypeHandle handle = AudioLoadRequest::get_class_type();
    Dtool_AudioLoadRequest._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AudioLoadRequest);
  }
}

void Dtool_libp3audio_BuildInstants(PyObject *module) {
  (void) module;
  // FilterProperties
  Dtool_PyModuleClassInit_FilterProperties(module);
  PyModule_AddObject(module, "FilterProperties", (PyObject *)&Dtool_FilterProperties);
  // AudioSound
  Dtool_PyModuleClassInit_AudioSound(module);
  PyModule_AddObject(module, "AudioSound", (PyObject *)&Dtool_AudioSound);
  // AudioManager
  Dtool_PyModuleClassInit_AudioManager(module);
  PyModule_AddObject(module, "AudioManager", (PyObject *)&Dtool_AudioManager);
  // AudioLoadRequest
  Dtool_PyModuleClassInit_AudioLoadRequest(module);
  PyModule_AddObject(module, "AudioLoadRequest", (PyObject *)&Dtool_AudioLoadRequest);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3audio_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3audio_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612607,  /* file_identifier */
  "libp3audio",  /* library_name */
  "M_1l",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3audio.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  222  /* next_index */
};

Configure(_in_configure_libp3audio);
ConfigureFn(_in_configure_libp3audio) {
  interrogate_request_module(&_in_module_def);
}

