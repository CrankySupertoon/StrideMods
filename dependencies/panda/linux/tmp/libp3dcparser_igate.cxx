/*
 * This file was generated by:
 * built/bin/interrogate -srcdir direct/src/dcparser -Idirect/src/dcparser -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3dcparser_igate.cxx -od built/pandac/input/libp3dcparser.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idirect/src/dcparser -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -DWITHIN_PANDA=1 -module panda3d.direct -library libp3dcparser dcArrayParameter.h dcAtomicField.h dcClass.h dcClassParameter.h dcClass_ext.h dcDeclaration.h dcField.h dcField_ext.h dcFile.h dcKeyword.h dcKeywordList.h dcLexerDefs.h dcMolecularField.h dcNumericRange.h dcPackData.h dcPacker.h dcPackerCatalog.h dcPackerInterface.h dcPacker_ext.h dcParameter.h dcParserDefs.h dcSimpleParameter.h dcSubatomicType.h dcSwitch.h dcSwitchParameter.h dcTypedef.h dcbase.h dcindent.h hashGenerator.h p3dcparser_composite1.cxx p3dcparser_composite2.cxx p3dcparser_ext_composite.cxx primeNumberGenerator.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "datagramIterator.h"
#include "dcArrayParameter.h"
#include "dcAtomicField.h"
#include "dcClass.h"
#include "dcClassParameter.h"
#include "dcClass_ext.h"
#include "dcDeclaration.h"
#include "dcField.h"
#include "dcField_ext.h"
#include "dcFile.h"
#include "dcKeyword.h"
#include "dcKeywordList.h"
#include "dcLexerDefs.h"
#include "dcMolecularField.h"
#include "dcNumericRange.h"
#include "dcPackData.h"
#include "dcPacker.h"
#include "dcPackerCatalog.h"
#include "dcPackerInterface.h"
#include "dcPacker_ext.h"
#include "dcParameter.h"
#include "dcParserDefs.h"
#include "dcSimpleParameter.h"
#include "dcSubatomicType.h"
#include "dcSwitch.h"
#include "dcSwitchParameter.h"
#include "dcTypedef.h"
#include "dcbase.h"
#include "dcindent.h"
#include "dtoolbase.h"
#include "extension.h"
#include "hashGenerator.h"
#include "indent.h"
#include <math.h>
#include "pStatCollector.h"
#include "primeNumberGenerator.h"
#include "py_panda.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class DCPackerInterface
 */
typedef DCPackerInterface DCPackerInterface_localtype;
Define_Module_Class(panda3d.direct, DCPackerInterface, DCPackerInterface_localtype, DCPackerInterface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCPackerInterface = &Dtool_DCPackerInterface;
static void Dtool_PyModuleClassInit_DCPackerInterface(PyObject *module);

/**
 * Forward declarations for top-level class DCKeywordList
 */
typedef DCKeywordList DCKeywordList_localtype;
Define_Module_Class(panda3d.direct, DCKeywordList, DCKeywordList_localtype, DCKeywordList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCKeywordList = &Dtool_DCKeywordList;
static void Dtool_PyModuleClassInit_DCKeywordList(PyObject *module);

/**
 * Forward declarations for top-level class DCField
 */
typedef DCField DCField_localtype;
Define_Module_Class(panda3d.direct, DCField, DCField_localtype, DCField);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCField = &Dtool_DCField;
static void Dtool_PyModuleClassInit_DCField(PyObject *module);

/**
 * Forward declarations for top-level class DCPackData
 */
typedef DCPackData DCPackData_localtype;
Define_Module_Class(panda3d.direct, DCPackData, DCPackData_localtype, DCPackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCPackData = &Dtool_DCPackData;
static void Dtool_PyModuleClassInit_DCPackData(PyObject *module);

/**
 * Forward declarations for top-level class DCPacker
 */
typedef DCPacker DCPacker_localtype;
Define_Module_Class(panda3d.direct, DCPacker, DCPacker_localtype, DCPacker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCPacker = &Dtool_DCPacker;
static void Dtool_PyModuleClassInit_DCPacker(PyObject *module);

/**
 * Forward declarations for top-level class DCParameter
 */
typedef DCParameter DCParameter_localtype;
Define_Module_Class(panda3d.direct, DCParameter, DCParameter_localtype, DCParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCParameter = &Dtool_DCParameter;
static void Dtool_PyModuleClassInit_DCParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCArrayParameter
 */
typedef DCArrayParameter DCArrayParameter_localtype;
Define_Module_Class(panda3d.direct, DCArrayParameter, DCArrayParameter_localtype, DCArrayParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCArrayParameter = &Dtool_DCArrayParameter;
static void Dtool_PyModuleClassInit_DCArrayParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCAtomicField
 */
typedef DCAtomicField DCAtomicField_localtype;
Define_Module_Class(panda3d.direct, DCAtomicField, DCAtomicField_localtype, DCAtomicField);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCAtomicField = &Dtool_DCAtomicField;
static void Dtool_PyModuleClassInit_DCAtomicField(PyObject *module);

/**
 * Forward declarations for top-level class DCDeclaration
 */
typedef DCDeclaration DCDeclaration_localtype;
Define_Module_Class(panda3d.direct, DCDeclaration, DCDeclaration_localtype, DCDeclaration);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCDeclaration = &Dtool_DCDeclaration;
static void Dtool_PyModuleClassInit_DCDeclaration(PyObject *module);

/**
 * Forward declarations for top-level class DCClass
 */
typedef DCClass DCClass_localtype;
Define_Module_Class(panda3d.direct, DCClass, DCClass_localtype, DCClass);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCClass = &Dtool_DCClass;
static void Dtool_PyModuleClassInit_DCClass(PyObject *module);

/**
 * Forward declarations for top-level class DCClassParameter
 */
typedef DCClassParameter DCClassParameter_localtype;
Define_Module_Class(panda3d.direct, DCClassParameter, DCClassParameter_localtype, DCClassParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCClassParameter = &Dtool_DCClassParameter;
static void Dtool_PyModuleClassInit_DCClassParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCFile
 */
typedef DCFile DCFile_localtype;
Define_Module_Class(panda3d.direct, DCFile, DCFile_localtype, DCFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCFile = &Dtool_DCFile;
static void Dtool_PyModuleClassInit_DCFile(PyObject *module);

/**
 * Forward declarations for top-level class DCKeyword
 */
typedef DCKeyword DCKeyword_localtype;
Define_Module_Class(panda3d.direct, DCKeyword, DCKeyword_localtype, DCKeyword);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCKeyword = &Dtool_DCKeyword;
static void Dtool_PyModuleClassInit_DCKeyword(PyObject *module);

/**
 * Forward declarations for top-level class DCMolecularField
 */
typedef DCMolecularField DCMolecularField_localtype;
Define_Module_Class(panda3d.direct, DCMolecularField, DCMolecularField_localtype, DCMolecularField);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCMolecularField = &Dtool_DCMolecularField;
static void Dtool_PyModuleClassInit_DCMolecularField(PyObject *module);

/**
 * Forward declarations for top-level class DCSimpleParameter
 */
typedef DCSimpleParameter DCSimpleParameter_localtype;
Define_Module_Class(panda3d.direct, DCSimpleParameter, DCSimpleParameter_localtype, DCSimpleParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCSimpleParameter = &Dtool_DCSimpleParameter;
static void Dtool_PyModuleClassInit_DCSimpleParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCSwitch
 */
typedef DCSwitch DCSwitch_localtype;
Define_Module_Class(panda3d.direct, DCSwitch, DCSwitch_localtype, DCSwitch);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCSwitch = &Dtool_DCSwitch;
static void Dtool_PyModuleClassInit_DCSwitch(PyObject *module);

/**
 * Forward declarations for top-level class DCSwitchParameter
 */
typedef DCSwitchParameter DCSwitchParameter_localtype;
Define_Module_Class(panda3d.direct, DCSwitchParameter, DCSwitchParameter_localtype, DCSwitchParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCSwitchParameter = &Dtool_DCSwitchParameter;
static void Dtool_PyModuleClassInit_DCSwitchParameter(PyObject *module);

/**
 * Forward declarations for top-level class DCTypedef
 */
typedef DCTypedef DCTypedef_localtype;
Define_Module_Class(panda3d.direct, DCTypedef, DCTypedef_localtype, DCTypedef);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCTypedef = &Dtool_DCTypedef;
static void Dtool_PyModuleClassInit_DCTypedef(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"DCPackerInterface", &Dtool_DCPackerInterface},
  {"DCKeywordList", &Dtool_DCKeywordList},
  {"DCField", &Dtool_DCField},
  {"DCPackData", &Dtool_DCPackData},
  {"DCPacker", &Dtool_DCPacker},
  {"DCParameter", &Dtool_DCParameter},
  {"DCArrayParameter", &Dtool_DCArrayParameter},
  {"DCAtomicField", &Dtool_DCAtomicField},
  {"DCDeclaration", &Dtool_DCDeclaration},
  {"DCClass", &Dtool_DCClass},
  {"DCClassParameter", &Dtool_DCClassParameter},
  {"DCFile", &Dtool_DCFile},
  {"DCKeyword", &Dtool_DCKeyword},
  {"DCMolecularField", &Dtool_DCMolecularField},
  {"DCSimpleParameter", &Dtool_DCSimpleParameter},
  {"DCSwitch", &Dtool_DCSwitch},
  {"DCSwitchParameter", &Dtool_DCSwitchParameter},
  {"DCTypedef", &Dtool_DCTypedef},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[1].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[2].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[3].type)
  {"DatagramIterator", nullptr},
#define Dtool_Ptr_DatagramIterator (imports[4].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != nullptr, nullptr);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != nullptr, nullptr);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class DCPackerInterface
 */
/**
 * Python function wrapper for:
 * inline std::string const &DCPackerInterface::get_name(void) const
 */
static PyObject *Dtool_DCPackerInterface_get_name_5(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackerInterface)) {
    return nullptr;
  }
  // 1-inline std::string const &DCPackerInterface::get_name(void) const
  std::string const &return_value = ((*(const DCPackerInterface*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_get_name_5_comment =
  "C++ Interface:\n"
  "get_name(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this field, or empty string if the field is unnamed.\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_get_name_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCPackerInterface::find_seek_index(std::string const &name) const
 */
static PyObject *Dtool_DCPackerInterface_find_seek_index_6(PyObject *self, PyObject *arg) {
  DCPackerInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackerInterface)) {
    return nullptr;
  }
  // 1-int DCPackerInterface::find_seek_index(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*(const DCPackerInterface*)local_this).find_seek_index)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_seek_index(DCPackerInterface self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_find_seek_index_6_comment =
  "C++ Interface:\n"
  "find_seek_index(DCPackerInterface self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the index number to be passed to a future call to DCPacker::seek()\n"
  " * to seek directly to the named field without having to look up the field\n"
  " * name in a table later, or -1 if the named field cannot be found.\n"
  " *\n"
  " * If the named field is nested within a switch or some similar dynamic\n"
  " * structure that reveals different fields based on the contents of the data,\n"
  " * this mechanism cannot be used to pre-fetch the field index number--you must\n"
  " * seek for the field by name.\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_find_seek_index_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCField *DCPackerInterface::as_field(void)
 * virtual DCField const *DCPackerInterface::as_field(void) const
 */
static PyObject *Dtool_DCPackerInterface_as_field_7(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackerInterface)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCField *DCPackerInterface::as_field(void)
    DCField *return_value = ((*local_this).as_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }

  {
    // -2 virtual DCField const *DCPackerInterface::as_field(void) const
    DCField const *return_value = ((*(const DCPackerInterface*)local_this).as_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, true);
  }

  // No coercion possible: virtual DCField *DCPackerInterface::as_field(void)
  // No coercion possible: virtual DCField const *DCPackerInterface::as_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_as_field_7_comment =
  "C++ Interface:\n"
  "as_field(const DCPackerInterface self)\n"
  "as_field(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_as_field_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
 * virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
 */
static PyObject *Dtool_DCPackerInterface_as_switch_parameter_8(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackerInterface)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
    DCSwitchParameter *return_value = ((*local_this).as_switch_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitchParameter, false, false);
  }

  {
    // -2 virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
    DCSwitchParameter const *return_value = ((*(const DCPackerInterface*)local_this).as_switch_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitchParameter, false, true);
  }

  // No coercion possible: virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
  // No coercion possible: virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_as_switch_parameter_8_comment =
  "C++ Interface:\n"
  "as_switch_parameter(const DCPackerInterface self)\n"
  "as_switch_parameter(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_as_switch_parameter_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
 * virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
 */
static PyObject *Dtool_DCPackerInterface_as_class_parameter_9(PyObject *self, PyObject *) {
  DCPackerInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackerInterface)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
    DCClassParameter *return_value = ((*local_this).as_class_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClassParameter, false, false);
  }

  {
    // -2 virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
    DCClassParameter const *return_value = ((*(const DCPackerInterface*)local_this).as_class_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClassParameter, false, true);
  }

  // No coercion possible: virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
  // No coercion possible: virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_as_class_parameter_9_comment =
  "C++ Interface:\n"
  "as_class_parameter(const DCPackerInterface self)\n"
  "as_class_parameter(DCPackerInterface self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_as_class_parameter_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
 * bool DCPackerInterface::check_match(std::string const &description, DCFile *dcfile = nullptr) const
 */
static PyObject *Dtool_DCPackerInterface_check_match_10(PyObject *self, PyObject *args, PyObject *kwds) {
  DCPackerInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackerInterface)) {
    return nullptr;
  }
  {
    // -2 bool DCPackerInterface::check_match(std::string const &description, DCFile *dcfile = nullptr) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"description", "dcfile", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:check_match", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      DCFile *param2_this = nullptr;
      if (param2 != nullptr && param2 != Py_None) {
        param2_this = (DCFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DCFile, 2, "DCPackerInterface.check_match", false, false);
      }
      if ((param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
        bool return_value = ((*(const DCPackerInterface*)local_this).check_match)(std::string(param1_str, param1_len), param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "other")) {
      DCPackerInterface const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_DCPackerInterface);
      if (param1_this != nullptr) {
        bool return_value = ((*(const DCPackerInterface*)local_this).check_match)(param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  // No coercion possible: bool DCPackerInterface::check_match(std::string const &description, DCFile *dcfile = nullptr) const
  // No coercion possible: inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_match(DCPackerInterface self, str description, DCFile dcfile)\n"
      "check_match(DCPackerInterface self, const DCPackerInterface other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPackerInterface_check_match_10_comment =
  "C++ Interface:\n"
  "check_match(DCPackerInterface self, str description, DCFile dcfile)\n"
  "check_match(DCPackerInterface self, const DCPackerInterface other)\n"
  "\n"
  "/**\n"
  " * Returns true if the other interface is bitwise the same as this one--that\n"
  " * is, a uint32 only matches a uint32, etc.  Names of components, and range\n"
  " * limits, are not compared.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if this interface is bitwise the same as the interface\n"
  " * described with the indicated formatted string, e.g.  \"(uint8, uint8,\n"
  " * int16)\", or false otherwise.\n"
  " *\n"
  " * If DCFile is not NULL, it specifies the DCFile that was previously loaded,\n"
  " * from which some predefined structs and typedefs may be referenced in the\n"
  " * description string.\n"
  " */";
#else
static const char *Dtool_DCPackerInterface_check_match_10_comment = nullptr;
#endif

static int Dtool_Init_DCPackerInterface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCPackerInterface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCPackerInterface) {
    printf("DCPackerInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCPackerInterface *local_this = (DCPackerInterface *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCPackerInterface) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCPackerInterface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCKeywordList
 */
/**
 * Python function wrapper for:
 * bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
 * bool DCKeywordList::has_keyword(std::string const &name) const
 */
static PyObject *Dtool_DCKeywordList_has_keyword_13(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCKeywordList)) {
    return nullptr;
  }
  {
    // -2 bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
    DCKeyword const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DCKeyword);
    if (arg_this != nullptr) {
      bool return_value = ((*(const DCKeywordList*)local_this).has_keyword)(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool DCKeywordList::has_keyword(std::string const &name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*(const DCKeywordList*)local_this).has_keyword)(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
  // No coercion possible: bool DCKeywordList::has_keyword(std::string const &name) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_keyword(DCKeywordList self, const DCKeyword keyword)\n"
      "has_keyword(DCKeywordList self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_has_keyword_13_comment =
  "C++ Interface:\n"
  "has_keyword(DCKeywordList self, const DCKeyword keyword)\n"
  "has_keyword(DCKeywordList self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if this list includes the indicated keyword, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if this list includes the indicated keyword, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_has_keyword_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCKeywordList::get_num_keywords(void) const
 */
static PyObject *Dtool_DCKeywordList_get_num_keywords_14(PyObject *self, PyObject *) {
  DCKeywordList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCKeywordList)) {
    return nullptr;
  }
  // 1-int DCKeywordList::get_num_keywords(void) const
  int return_value = ((*(const DCKeywordList*)local_this).get_num_keywords)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_get_num_keywords_14_comment =
  "C++ Interface:\n"
  "get_num_keywords(DCKeywordList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of keywords in the list.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_get_num_keywords_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCKeywordList::get_keyword(int n) const
 */
static PyObject *Dtool_DCKeywordList_get_keyword_15(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCKeywordList)) {
    return nullptr;
  }
  // 1-DCKeyword const *DCKeywordList::get_keyword(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCKeyword const *return_value = ((*(const DCKeywordList*)local_this).get_keyword)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword(DCKeywordList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_get_keyword_15_comment =
  "C++ Interface:\n"
  "get_keyword(DCKeywordList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth keyword in the list.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_get_keyword_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCKeywordList::get_keyword_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCKeywordList_get_keyword_by_name_16(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCKeywordList)) {
    return nullptr;
  }
  // 1-DCKeyword const *DCKeywordList::get_keyword_by_name(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    DCKeyword const *return_value = ((*(const DCKeywordList*)local_this).get_keyword_by_name)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword_by_name(DCKeywordList self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_get_keyword_by_name_16_comment =
  "C++ Interface:\n"
  "get_keyword_by_name(DCKeywordList self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the keyword in the list with the indicated name, or NULL if there\n"
  " * is no keyword in the list with that name.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_get_keyword_by_name_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCKeywordList::compare_keywords(DCKeywordList const &other) const
 */
static PyObject *Dtool_DCKeywordList_compare_keywords_17(PyObject *self, PyObject *arg) {
  DCKeywordList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCKeywordList)) {
    return nullptr;
  }
  // 1-bool DCKeywordList::compare_keywords(DCKeywordList const &other) const
  DCKeywordList const *arg_this = (DCKeywordList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCKeywordList, 1, "DCKeywordList.compare_keywords", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const DCKeywordList*)local_this).compare_keywords)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_keywords(DCKeywordList self, const DCKeywordList other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCKeywordList_compare_keywords_17_comment =
  "C++ Interface:\n"
  "compare_keywords(DCKeywordList self, const DCKeywordList other)\n"
  "\n"
  "/**\n"
  " * Returns true if this list has the same keywords as the other list, false if\n"
  " * some keywords differ.  Order is not considered important.\n"
  " */";
#else
static const char *Dtool_DCKeywordList_compare_keywords_17_comment = nullptr;
#endif

static int Dtool_Init_DCKeywordList(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCKeywordList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCKeywordList) {
    printf("DCKeywordList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCKeywordList *local_this = (DCKeywordList *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCKeywordList) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCKeywordList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCField
 */
/**
 * Python function wrapper for:
 * inline int DCField::get_number(void) const
 */
static PyObject *Dtool_DCField_get_number_24(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline int DCField::get_number(void) const
  int return_value = ((*(const DCField*)local_this).get_number)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_get_number_24_comment =
  "C++ Interface:\n"
  "get_number(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns a unique index number associated with this field.  This is defined\n"
  " * implicitly when the .dc file(s) are read.\n"
  " */";
#else
static const char *Dtool_DCField_get_number_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DCClass *DCField::get_class(void) const
 */
static PyObject *Dtool_DCField_get_class_25(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline DCClass *DCField::get_class(void) const
  DCClass *return_value = ((*(const DCField*)local_this).get_class)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCField_get_class_25_comment =
  "C++ Interface:\n"
  "get_class(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the DCClass pointer for the class that contains this field.\n"
  " */";
#else
static const char *Dtool_DCField_get_class_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCField *DCField::as_field(void)
 * virtual DCField const *DCField::as_field(void) const
 */
static PyObject *Dtool_DCField_as_field_26(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCField *DCField::as_field(void)
    DCField *return_value = ((*local_this).as_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }

  {
    // -2 virtual DCField const *DCField::as_field(void) const
    DCField const *return_value = ((*(const DCField*)local_this).as_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, true);
  }

  // No coercion possible: virtual DCField *DCField::as_field(void)
  // No coercion possible: virtual DCField const *DCField::as_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_field_26_comment =
  "C++ Interface:\n"
  "as_field(const DCField self)\n"
  "as_field(DCField self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCField_as_field_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCAtomicField *DCField::as_atomic_field(void)
 * virtual DCAtomicField const *DCField::as_atomic_field(void) const
 */
static PyObject *Dtool_DCField_as_atomic_field_27(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCAtomicField *DCField::as_atomic_field(void)
    DCAtomicField *return_value = ((*local_this).as_atomic_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCAtomicField, false, false);
  }

  {
    // -2 virtual DCAtomicField const *DCField::as_atomic_field(void) const
    DCAtomicField const *return_value = ((*(const DCField*)local_this).as_atomic_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCAtomicField, false, true);
  }

  // No coercion possible: virtual DCAtomicField *DCField::as_atomic_field(void)
  // No coercion possible: virtual DCAtomicField const *DCField::as_atomic_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_atomic_field_27_comment =
  "C++ Interface:\n"
  "as_atomic_field(const DCField self)\n"
  "as_atomic_field(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to an atomic field pointer, if\n"
  " * this is in fact an atomic field; otherwise, returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to an atomic field pointer, if\n"
  " * this is in fact an atomic field; otherwise, returns NULL.\n"
  " */";
#else
static const char *Dtool_DCField_as_atomic_field_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCMolecularField *DCField::as_molecular_field(void)
 * virtual DCMolecularField const *DCField::as_molecular_field(void) const
 */
static PyObject *Dtool_DCField_as_molecular_field_28(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCMolecularField *DCField::as_molecular_field(void)
    DCMolecularField *return_value = ((*local_this).as_molecular_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCMolecularField, false, false);
  }

  {
    // -2 virtual DCMolecularField const *DCField::as_molecular_field(void) const
    DCMolecularField const *return_value = ((*(const DCField*)local_this).as_molecular_field)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCMolecularField, false, true);
  }

  // No coercion possible: virtual DCMolecularField *DCField::as_molecular_field(void)
  // No coercion possible: virtual DCMolecularField const *DCField::as_molecular_field(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_molecular_field_28_comment =
  "C++ Interface:\n"
  "as_molecular_field(const DCField self)\n"
  "as_molecular_field(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to a molecular field pointer, if\n"
  " * this is in fact a molecular field; otherwise, returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the same field pointer converted to a molecular field pointer, if\n"
  " * this is in fact a molecular field; otherwise, returns NULL.\n"
  " */";
#else
static const char *Dtool_DCField_as_molecular_field_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCParameter *DCField::as_parameter(void)
 * virtual DCParameter const *DCField::as_parameter(void) const
 */
static PyObject *Dtool_DCField_as_parameter_29(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCParameter *DCField::as_parameter(void)
    DCParameter *return_value = ((*local_this).as_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
  }

  {
    // -2 virtual DCParameter const *DCField::as_parameter(void) const
    DCParameter const *return_value = ((*(const DCField*)local_this).as_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, true);
  }

  // No coercion possible: virtual DCParameter *DCField::as_parameter(void)
  // No coercion possible: virtual DCParameter const *DCField::as_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCField_as_parameter_29_comment =
  "C++ Interface:\n"
  "as_parameter(const DCField self)\n"
  "as_parameter(DCField self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCField_as_parameter_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DCField::format_data(vector_uchar const &packed_data, bool show_field_names = true)
 */
static PyObject *Dtool_DCField_format_data_30(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.format_data")) {
    return nullptr;
  }
  // 1-std::string DCField::format_data(vector_uchar const &packed_data, bool show_field_names = true)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"packed_data", "show_field_names", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#|O:format_data", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    std::string return_value = ((*local_this).format_data)(vector_uchar(param1_str, param1_str + param1_len), (PyObject_IsTrue(param2) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_data(const DCField self, bytes packed_data, bool show_field_names)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_format_data_30_comment =
  "C++ Interface:\n"
  "format_data(const DCField self, bytes packed_data, bool show_field_names)\n"
  "\n"
  "/**\n"
  " * Given a blob that represents the packed data for this field, returns a\n"
  " * string formatting it for human consumption.  Returns empty string if there\n"
  " * is an error.\n"
  " */";
#else
static const char *Dtool_DCField_format_data_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * vector_uchar DCField::parse_string(std::string const &formatted_string)
 */
static PyObject *Dtool_DCField_parse_string_31(PyObject *self, PyObject *arg) {
  DCField *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.parse_string")) {
    return nullptr;
  }
  // 1-vector_uchar DCField::parse_string(std::string const &formatted_string)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    vector_uchar return_value = ((*local_this).parse_string)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_string(const DCField self, str formatted_string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_parse_string_31_comment =
  "C++ Interface:\n"
  "parse_string(const DCField self, str formatted_string)\n"
  "\n"
  "/**\n"
  " * Given a human-formatted string (for instance, as returned by format_data(),\n"
  " * above) that represents the value of this field, parse the string and return\n"
  " * the corresponding packed data.  Returns empty string if there is an error.\n"
  " */";
#else
static const char *Dtool_DCField_parse_string_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCField::validate_ranges(vector_uchar const &packed_data) const
 */
static PyObject *Dtool_DCField_validate_ranges_32(PyObject *self, PyObject *arg) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-bool DCField::validate_ranges(vector_uchar const &packed_data) const
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    bool return_value = ((*(const DCField*)local_this).validate_ranges)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "validate_ranges(DCField self, bytes packed_data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_validate_ranges_32_comment =
  "C++ Interface:\n"
  "validate_ranges(DCField self, bytes packed_data)\n"
  "\n"
  "/**\n"
  " * Verifies that all of the packed values in the field data are within the\n"
  " * specified ranges and that there are no extra bytes on the end of the\n"
  " * record.  Returns true if all fields are valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_validate_ranges_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::has_default_value(void) const
 */
static PyObject *Dtool_DCField_has_default_value_33(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::has_default_value(void) const
  bool return_value = ((*(const DCField*)local_this).has_default_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_has_default_value_33_comment =
  "C++ Interface:\n"
  "has_default_value(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if a default value has been explicitly established for this\n"
  " * field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_has_default_value_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar const &DCField::get_default_value(void) const
 */
static PyObject *Dtool_DCField_get_default_value_34(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline vector_uchar const &DCField::get_default_value(void) const
  vector_uchar return_value = ((*(const DCField*)local_this).get_default_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_get_default_value_34_comment =
  "C++ Interface:\n"
  "get_default_value(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns the default value for this field.  If a default value has been\n"
  " * explicitly set (e.g.  has_default_value() returns true), returns that\n"
  " * value; otherwise, returns an implicit default for the field.\n"
  " */";
#else
static const char *Dtool_DCField_get_default_value_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_bogus_field(void) const
 */
static PyObject *Dtool_DCField_is_bogus_field_35(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_bogus_field(void) const
  bool return_value = ((*(const DCField*)local_this).is_bogus_field)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_bogus_field_35_comment =
  "C++ Interface:\n"
  "is_bogus_field(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the field has been flagged as a bogus field.  This is set\n"
  " * for fields that are generated by the parser as placeholder for missing\n"
  " * fields, as when reading a partial file; it should not occur in a normal\n"
  " * valid dc file.\n"
  " */";
#else
static const char *Dtool_DCField_is_bogus_field_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_required(void) const
 */
static PyObject *Dtool_DCField_is_required_36(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_required(void) const
  bool return_value = ((*(const DCField*)local_this).is_required)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_required_36_comment =
  "C++ Interface:\n"
  "is_required(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"required\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_required_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_broadcast(void) const
 */
static PyObject *Dtool_DCField_is_broadcast_37(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_broadcast(void) const
  bool return_value = ((*(const DCField*)local_this).is_broadcast)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_broadcast_37_comment =
  "C++ Interface:\n"
  "is_broadcast(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"broadcast\" flag is set for this field, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_broadcast_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_ram(void) const
 */
static PyObject *Dtool_DCField_is_ram_38(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_ram(void) const
  bool return_value = ((*(const DCField*)local_this).is_ram)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_ram_38_comment =
  "C++ Interface:\n"
  "is_ram(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"ram\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_ram_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_db(void) const
 */
static PyObject *Dtool_DCField_is_db_39(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_db(void) const
  bool return_value = ((*(const DCField*)local_this).is_db)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_db_39_comment =
  "C++ Interface:\n"
  "is_db(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"db\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_db_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_clsend(void) const
 */
static PyObject *Dtool_DCField_is_clsend_40(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_clsend(void) const
  bool return_value = ((*(const DCField*)local_this).is_clsend)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_clsend_40_comment =
  "C++ Interface:\n"
  "is_clsend(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"clsend\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_clsend_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_clrecv(void) const
 */
static PyObject *Dtool_DCField_is_clrecv_41(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_clrecv(void) const
  bool return_value = ((*(const DCField*)local_this).is_clrecv)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_clrecv_41_comment =
  "C++ Interface:\n"
  "is_clrecv(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"clrecv\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_clrecv_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_ownsend(void) const
 */
static PyObject *Dtool_DCField_is_ownsend_42(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_ownsend(void) const
  bool return_value = ((*(const DCField*)local_this).is_ownsend)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_ownsend_42_comment =
  "C++ Interface:\n"
  "is_ownsend(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"ownsend\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_ownsend_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_ownrecv(void) const
 */
static PyObject *Dtool_DCField_is_ownrecv_43(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_ownrecv(void) const
  bool return_value = ((*(const DCField*)local_this).is_ownrecv)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_ownrecv_43_comment =
  "C++ Interface:\n"
  "is_ownrecv(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"ownrecv\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_ownrecv_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCField::is_airecv(void) const
 */
static PyObject *Dtool_DCField_is_airecv_44(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline bool DCField::is_airecv(void) const
  bool return_value = ((*(const DCField*)local_this).is_airecv)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCField_is_airecv_44_comment =
  "C++ Interface:\n"
  "is_airecv(DCField self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"airecv\" flag is set for this field, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCField_is_airecv_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCField::output(std::ostream &out) const
 */
static PyObject *Dtool_DCField_output_45(PyObject *self, PyObject *arg) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline void DCField::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DCField.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DCField*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DCField self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_output_45_comment =
  "C++ Interface:\n"
  "output(DCField self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCField_output_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCField::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_DCField_write_46(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-inline void DCField::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DCField.write", false, true);
    if (param1_this != nullptr) {
      ((*(const DCField*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DCField self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_write_46_comment =
  "C++ Interface:\n"
  "write(DCField self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCField_write_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCField::pack_args(DCPacker &packer, PyObject *sequence) const
 */
static PyObject *Dtool_DCField_pack_args_47(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-bool DCField::pack_args(DCPacker &packer, PyObject *sequence) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"packer", "sequence", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:pack_args", (char **)keyword_list, &param1, &param2)) {
    DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DCPacker, 1, "DCField.pack_args", false, true);
    if (param1_this != nullptr) {
      bool return_value = invoke_extension((const DCField*)local_this).pack_args(*param1_this, param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_args(DCField self, DCPacker packer, object sequence)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_pack_args_47_comment =
  "C++ Interface:\n"
  "pack_args(DCField self, DCPacker packer, object sequence)\n";
#else
static const char *Dtool_DCField_pack_args_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCField::unpack_args(DCPacker &packer) const
 */
static PyObject *Dtool_DCField_unpack_args_48(PyObject *self, PyObject *arg) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-PyObject *DCField::unpack_args(DCPacker &packer) const
  DCPacker *arg_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPacker, 1, "DCField.unpack_args", false, true);
  if (arg_this != nullptr) {
    PyObject *return_value = invoke_extension((const DCField*)local_this).unpack_args(*arg_this);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unpack_args(DCField self, DCPacker packer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_unpack_args_48_comment =
  "C++ Interface:\n"
  "unpack_args(DCField self, DCPacker packer)\n";
#else
static const char *Dtool_DCField_unpack_args_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCField::receive_update(DCPacker &packer, PyObject *distobj) const
 */
static PyObject *Dtool_DCField_receive_update_49(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-void DCField::receive_update(DCPacker &packer, PyObject *distobj) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"packer", "distobj", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update", (char **)keyword_list, &param1, &param2)) {
    DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DCPacker, 1, "DCField.receive_update", false, true);
    if (param1_this != nullptr) {
      invoke_extension((const DCField*)local_this).receive_update(*param1_this, param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update(DCField self, DCPacker packer, object distobj)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_receive_update_49_comment =
  "C++ Interface:\n"
  "receive_update(DCField self, DCPacker packer, object distobj)\n";
#else
static const char *Dtool_DCField_receive_update_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCField::client_format_update(DOID_TYPE do_id, PyObject *args) const
 */
static PyObject *Dtool_DCField_client_format_update_50(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-Datagram DCField::client_format_update(DOID_TYPE do_id, PyObject *args) const
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"do_id", "args", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:client_format_update", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCField*)local_this).client_format_update((DOID_TYPE)param1, param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_format_update(DCField self, int do_id, object args)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_client_format_update_50_comment =
  "C++ Interface:\n"
  "client_format_update(DCField self, int do_id, object args)\n";
#else
static const char *Dtool_DCField_client_format_update_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCField::ai_format_update(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
 */
static PyObject *Dtool_DCField_ai_format_update_51(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-Datagram DCField::ai_format_update(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
  unsigned long param1;
  unsigned PY_LONG_LONG param2;
  unsigned PY_LONG_LONG param3;
  PyObject *param4;
  static const char *keyword_list[] = {"do_id", "to_id", "from_id", "args", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kKKO:ai_format_update", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCField*)local_this).ai_format_update((DOID_TYPE)param1, (CHANNEL_TYPE)param2, (CHANNEL_TYPE)param3, param4));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update(DCField self, int do_id, long to_id, long from_id, object args)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_ai_format_update_51_comment =
  "C++ Interface:\n"
  "ai_format_update(DCField self, int do_id, long to_id, long from_id, object args)\n";
#else
static const char *Dtool_DCField_ai_format_update_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCField::ai_format_update_msg_type(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
 */
static PyObject *Dtool_DCField_ai_format_update_msg_type_52(PyObject *self, PyObject *args, PyObject *kwds) {
  DCField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCField)) {
    return nullptr;
  }
  // 1-Datagram DCField::ai_format_update_msg_type(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
  unsigned long param1;
  unsigned PY_LONG_LONG param2;
  unsigned PY_LONG_LONG param3;
  int param4;
  PyObject *param5;
  static const char *keyword_list[] = {"do_id", "to_id", "from_id", "msg_type", "args", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kKKiO:ai_format_update_msg_type", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCField*)local_this).ai_format_update_msg_type((DOID_TYPE)param1, (CHANNEL_TYPE)param2, (CHANNEL_TYPE)param3, (int)param4, param5));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update_msg_type(DCField self, int do_id, long to_id, long from_id, int msg_type, object args)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCField_ai_format_update_msg_type_52_comment =
  "C++ Interface:\n"
  "ai_format_update_msg_type(DCField self, int do_id, long to_id, long from_id, int msg_type, object args)\n";
#else
static const char *Dtool_DCField_ai_format_update_msg_type_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCPackerInterface *DCField::upcast_to_DCPackerInterface(void)
 */
static PyObject *Dtool_DCField_upcast_to_DCPackerInterface_19(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.upcast_to_DCPackerInterface")) {
    return nullptr;
  }
  // 1-DCPackerInterface *DCField::upcast_to_DCPackerInterface(void)
  DCPackerInterface *return_value = (DCPackerInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCField_upcast_to_DCPackerInterface_19_comment =
  "C++ Interface:\n"
  "upcast_to_DCPackerInterface(const DCField self)\n"
  "\n"
  "upcast from DCField to DCPackerInterface";
#else
static const char *Dtool_DCField_upcast_to_DCPackerInterface_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCKeywordList *DCField::upcast_to_DCKeywordList(void)
 */
static PyObject *Dtool_DCField_upcast_to_DCKeywordList_21(PyObject *self, PyObject *) {
  DCField *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCField, (void **)&local_this, "DCField.upcast_to_DCKeywordList")) {
    return nullptr;
  }
  // 1-DCKeywordList *DCField::upcast_to_DCKeywordList(void)
  DCKeywordList *return_value = (DCKeywordList *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeywordList, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCField_upcast_to_DCKeywordList_21_comment =
  "C++ Interface:\n"
  "upcast_to_DCKeywordList(const DCField self)\n"
  "\n"
  "upcast from DCField to DCKeywordList";
#else
static const char *Dtool_DCField_upcast_to_DCKeywordList_21_comment = nullptr;
#endif

static int Dtool_Init_DCField(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCField(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCField) {
    printf("DCField ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCField *local_this = (DCField *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCField) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCField(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCField) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCField*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCPackData
 */
/**
 * Python function wrapper for:
 * inline void DCPackData::clear(void)
 */
static PyObject *Dtool_DCPackData_clear_56(PyObject *self, PyObject *) {
  DCPackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPackData, (void **)&local_this, "DCPackData.clear")) {
    return nullptr;
  }
  // 1-inline void DCPackData::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPackData_clear_56_comment =
  "C++ Interface:\n"
  "clear(const DCPackData self)\n"
  "\n"
  "/**\n"
  " * Empties the contents of the data (without necessarily freeing its allocated\n"
  " * memory).\n"
  " */";
#else
static const char *Dtool_DCPackData_clear_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPackData::get_string(void) const
 */
static PyObject *Dtool_DCPackData_get_string_57(PyObject *self, PyObject *) {
  DCPackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackData)) {
    return nullptr;
  }
  // 1-inline std::string DCPackData::get_string(void) const
  std::string return_value = ((*(const DCPackData*)local_this).get_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPackData_get_string_57_comment =
  "C++ Interface:\n"
  "get_string(DCPackData self)\n"
  "\n"
  "/**\n"
  " * Returns the data buffer as a string.  Also see get_data().\n"
  " */";
#else
static const char *Dtool_DCPackData_get_string_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPackData::get_length(void) const
 */
static PyObject *Dtool_DCPackData_get_length_58(PyObject *self, PyObject *) {
  DCPackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPackData)) {
    return nullptr;
  }
  // 1-inline std::size_t DCPackData::get_length(void) const
  std::size_t return_value = ((*(const DCPackData*)local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPackData_get_length_58_comment =
  "C++ Interface:\n"
  "get_length(DCPackData self)\n"
  "\n"
  "/**\n"
  " * Returns the current length of the buffer.  This is the number of useful\n"
  " * bytes stored in the buffer, not the amount of memory it takes up.\n"
  " */";
#else
static const char *Dtool_DCPackData_get_length_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DCPackData::DCPackData(void)
 * inline DCPackData::DCPackData(DCPackData const &) = default
 */
static int Dtool_Init_DCPackData(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DCPackData() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DCPackData::DCPackData(void)
      DCPackData *return_value = new DCPackData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPackData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DCPackData::DCPackData(DCPackData const &) = default
      DCPackData const *arg_this = (DCPackData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackData, 0, "DCPackData.DCPackData", true, true);
      if (arg_this != nullptr) {
        DCPackData *return_value = new DCPackData(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPackData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DCPackData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DCPackData()\n"
      "DCPackData(const DCPackData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DCPackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCPackData) {
    printf("DCPackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCPackData *local_this = (DCPackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCPackData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCPackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCPackData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCPacker
 */
/**
 * Python function wrapper for:
 * inline void DCPacker::clear_data(void)
 */
static PyObject *Dtool_DCPacker_clear_data_62(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.clear_data")) {
    return nullptr;
  }
  // 1-inline void DCPacker::clear_data(void)
  ((*local_this).clear_data)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_clear_data_62_comment =
  "C++ Interface:\n"
  "clear_data(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Empties the data in the pack buffer and unpack buffer.  This should be\n"
  " * called between calls to begin_pack(), unless you want to concatenate all of\n"
  " * the pack results together.\n"
  " */";
#else
static const char *Dtool_DCPacker_clear_data_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::begin_pack(DCPackerInterface const *root)
 */
static PyObject *Dtool_DCPacker_begin_pack_63(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.begin_pack")) {
    return nullptr;
  }
  // 1-void DCPacker::begin_pack(DCPackerInterface const *root)
  DCPackerInterface const *arg_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackerInterface, 1, "DCPacker.begin_pack", true, true);
  if (arg_this != nullptr) {
    ((*local_this).begin_pack)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_pack(const DCPacker self, const DCPackerInterface root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_begin_pack_63_comment =
  "C++ Interface:\n"
  "begin_pack(const DCPacker self, const DCPackerInterface root)\n"
  "\n"
  "/**\n"
  " * Begins a packing session.  The parameter is the DC object that describes\n"
  " * the packing format; it may be a DCParameter or DCField.\n"
  " *\n"
  " * Unless you call clear_data() between sessions, multiple packing sessions\n"
  " * will be concatenated together into the same buffer.  If you wish to add\n"
  " * bytes to the buffer between packing sessions, use append_data() or\n"
  " * get_write_pointer().\n"
  " */";
#else
static const char *Dtool_DCPacker_begin_pack_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::end_pack(void)
 */
static PyObject *Dtool_DCPacker_end_pack_64(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.end_pack")) {
    return nullptr;
  }
  // 1-bool DCPacker::end_pack(void)
  bool return_value = ((*local_this).end_pack)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_end_pack_64_comment =
  "C++ Interface:\n"
  "end_pack(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Finishes a packing session.\n"
  " *\n"
  " * The return value is true on success, or false if there has been some error\n"
  " * during packing.\n"
  " */";
#else
static const char *Dtool_DCPacker_end_pack_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::set_unpack_data(vector_uchar const &data)
 */
static PyObject *Dtool_DCPacker_set_unpack_data_65(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.set_unpack_data")) {
    return nullptr;
  }
  // 1-void DCPacker::set_unpack_data(vector_uchar const &data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).set_unpack_data)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_unpack_data(const DCPacker self, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_set_unpack_data_65_comment =
  "C++ Interface:\n"
  "set_unpack_data(const DCPacker self, bytes data)\n"
  "\n"
  "/**\n"
  " * Sets up the unpack_data pointer.  You may call this before calling the\n"
  " * version of begin_unpack() that takes only one parameter.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up the unpack_data pointer.  You may call this before calling the\n"
  " * version of begin_unpack() that takes only one parameter.\n"
  " */";
#else
static const char *Dtool_DCPacker_set_unpack_data_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::begin_unpack(DCPackerInterface const *root)
 */
static PyObject *Dtool_DCPacker_begin_unpack_66(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.begin_unpack")) {
    return nullptr;
  }
  // 1-void DCPacker::begin_unpack(DCPackerInterface const *root)
  DCPackerInterface const *arg_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackerInterface, 1, "DCPacker.begin_unpack", true, true);
  if (arg_this != nullptr) {
    ((*local_this).begin_unpack)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_unpack(const DCPacker self, const DCPackerInterface root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_begin_unpack_66_comment =
  "C++ Interface:\n"
  "begin_unpack(const DCPacker self, const DCPackerInterface root)\n"
  "\n"
  "/**\n"
  " * Begins an unpacking session.  You must have previously called\n"
  " * set_unpack_data() to specify a buffer to unpack.\n"
  " *\n"
  " * If there was data left in the buffer after a previous begin_unpack() ..\n"
  " * end_unpack() session, the new session will resume from the current point.\n"
  " * This method may be used, therefore, to unpack a sequence of objects from\n"
  " * the same buffer.\n"
  " */";
#else
static const char *Dtool_DCPacker_begin_unpack_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::end_unpack(void)
 */
static PyObject *Dtool_DCPacker_end_unpack_67(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.end_unpack")) {
    return nullptr;
  }
  // 1-bool DCPacker::end_unpack(void)
  bool return_value = ((*local_this).end_unpack)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_end_unpack_67_comment =
  "C++ Interface:\n"
  "end_unpack(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Finishes the unpacking session.\n"
  " *\n"
  " * The return value is true on success, or false if there has been some error\n"
  " * during unpacking (or if all fields have not been unpacked).\n"
  " */";
#else
static const char *Dtool_DCPacker_end_unpack_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::begin_repack(DCPackerInterface const *root)
 */
static PyObject *Dtool_DCPacker_begin_repack_68(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.begin_repack")) {
    return nullptr;
  }
  // 1-void DCPacker::begin_repack(DCPackerInterface const *root)
  DCPackerInterface const *arg_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPackerInterface, 1, "DCPacker.begin_repack", true, true);
  if (arg_this != nullptr) {
    ((*local_this).begin_repack)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_repack(const DCPacker self, const DCPackerInterface root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_begin_repack_68_comment =
  "C++ Interface:\n"
  "begin_repack(const DCPacker self, const DCPackerInterface root)\n"
  "\n"
  "/**\n"
  " * Begins a repacking session.  You must have previously called\n"
  " * set_unpack_data() to specify a buffer to unpack.\n"
  " *\n"
  " * Unlike begin_pack() or begin_unpack() you may not concatenate the results\n"
  " * of multiple begin_repack() sessions in one buffer.\n"
  " *\n"
  " * Also, unlike in packing or unpacking modes, you may not walk through the\n"
  " * fields from beginning to end, or even pack two consecutive fields at once.\n"
  " * Instead, you must call seek() for each field you wish to modify and pack\n"
  " * only that one field; then call seek() again to modify another field.\n"
  " */";
#else
static const char *Dtool_DCPacker_begin_repack_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::end_repack(void)
 */
static PyObject *Dtool_DCPacker_end_repack_69(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.end_repack")) {
    return nullptr;
  }
  // 1-bool DCPacker::end_repack(void)
  bool return_value = ((*local_this).end_repack)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_end_repack_69_comment =
  "C++ Interface:\n"
  "end_repack(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Finishes the repacking session.\n"
  " *\n"
  " * The return value is true on success, or false if there has been some error\n"
  " * during repacking (or if all fields have not been repacked).\n"
  " */";
#else
static const char *Dtool_DCPacker_end_repack_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::seek(int seek_index)
 * bool DCPacker::seek(std::string const &field_name)
 */
static PyObject *Dtool_DCPacker_seek_70(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.seek")) {
    return nullptr;
  }
  {
    // -2 bool DCPacker::seek(std::string const &field_name)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*local_this).seek)(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCPacker::seek(int seek_index)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = ((*local_this).seek)((int)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool DCPacker::seek(std::string const &field_name)
  // No coercion possible: bool DCPacker::seek(int seek_index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seek(const DCPacker self, str field_name)\n"
      "seek(const DCPacker self, int seek_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_seek_70_comment =
  "C++ Interface:\n"
  "seek(const DCPacker self, str field_name)\n"
  "seek(const DCPacker self, int seek_index)\n"
  "\n"
  "/**\n"
  " * Sets the current unpack (or repack) position to the named field.  In unpack\n"
  " * mode, the next call to unpack_*() or push() will begin to read the named\n"
  " * field.  In repack mode, the next call to pack_*() or push() will modify the\n"
  " * named field.\n"
  " *\n"
  " * Returns true if successful, false if the field is not known (or if the\n"
  " * packer is in an invalid mode).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Seeks to the field indentified by seek_index, which was returned by an\n"
  " * earlier call to DCField::find_seek_index() to get the index of some nested\n"
  " * field.  Also see the version of seek() that accepts a field name.\n"
  " *\n"
  " * Returns true if successful, false if the field is not known (or if the\n"
  " * packer is in an invalid mode).\n"
  " */";
#else
static const char *Dtool_DCPacker_seek_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::has_nested_fields(void) const
 */
static PyObject *Dtool_DCPacker_has_nested_fields_71(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline bool DCPacker::has_nested_fields(void) const
  bool return_value = ((*(const DCPacker*)local_this).has_nested_fields)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_has_nested_fields_71_comment =
  "C++ Interface:\n"
  "has_nested_fields(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if the current field has any nested fields (and thus expects a\n"
  " * push() .. pop() interface), or false otherwise.  If this returns true,\n"
  " * get_num_nested_fields() may be called to determine how many nested fields\n"
  " * are expected.\n"
  " */";
#else
static const char *Dtool_DCPacker_has_nested_fields_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::get_num_nested_fields(void) const
 */
static PyObject *Dtool_DCPacker_get_num_nested_fields_72(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline int DCPacker::get_num_nested_fields(void) const
  int return_value = ((*(const DCPacker*)local_this).get_num_nested_fields)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_num_nested_fields_72_comment =
  "C++ Interface:\n"
  "get_num_nested_fields(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the number of nested fields associated with the current field, if\n"
  " * has_nested_fields() returned true.\n"
  " *\n"
  " * The return value may be -1 to indicate that a variable number of nested\n"
  " * fields are accepted by this field type (e.g.  a variable-length array).\n"
  " *\n"
  " * Note that this method is unreliable to determine how many fields you must\n"
  " * traverse before you can call pop(), since particularly in the presence of a\n"
  " * DCSwitch, it may change during traversal.  Use more_nested_fields()\n"
  " * instead.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_num_nested_fields_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::more_nested_fields(void) const
 */
static PyObject *Dtool_DCPacker_more_nested_fields_73(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline bool DCPacker::more_nested_fields(void) const
  bool return_value = ((*(const DCPacker*)local_this).more_nested_fields)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_more_nested_fields_73_comment =
  "C++ Interface:\n"
  "more_nested_fields(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are more nested fields to pack or unpack in the\n"
  " * current push sequence, false if it is time to call pop().\n"
  " */";
#else
static const char *Dtool_DCPacker_more_nested_fields_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DCPackerInterface const *DCPacker::get_current_parent(void) const
 */
static PyObject *Dtool_DCPacker_get_current_parent_74(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline DCPackerInterface const *DCPacker::get_current_parent(void) const
  DCPackerInterface const *return_value = ((*(const DCPacker*)local_this).get_current_parent)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_current_parent_74_comment =
  "C++ Interface:\n"
  "get_current_parent(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the field that we left in our last call to push(): the owner of the\n"
  " * current level of fields.  This may be NULL at the beginning of the pack\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_current_parent_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DCPackerInterface const *DCPacker::get_current_field(void) const
 */
static PyObject *Dtool_DCPacker_get_current_field_75(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline DCPackerInterface const *DCPacker::get_current_field(void) const
  DCPackerInterface const *return_value = ((*(const DCPacker*)local_this).get_current_field)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_current_field_75_comment =
  "C++ Interface:\n"
  "get_current_field(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the field that will be referenced by the next call to pack_*() or\n"
  " * unpack_*().  This will be NULL if we have unpacked (or packed) all fields,\n"
  " * or if it is time to call pop().\n"
  " */";
#else
static const char *Dtool_DCPacker_get_current_field_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DCSwitchParameter const *DCPacker::get_last_switch(void) const
 */
static PyObject *Dtool_DCPacker_get_last_switch_76(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline DCSwitchParameter const *DCPacker::get_last_switch(void) const
  DCSwitchParameter const *return_value = ((*(const DCPacker*)local_this).get_last_switch)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitchParameter, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_last_switch_76_comment =
  "C++ Interface:\n"
  "get_last_switch(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the last DCSwitch instance that we have passed by and\n"
  " * selected one case of during the pack/unpack process.  Each time we\n"
  " * encounter a new DCSwitch and select a case, this will change state.\n"
  " *\n"
  " * This may be used to detect when a DCSwitch has been selected.  At the\n"
  " * moment this changes state, get_current_parent() will contain the particular\n"
  " * SwitchCase that was selected by the switch.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_last_switch_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DCPackType DCPacker::get_pack_type(void) const
 */
static PyObject *Dtool_DCPacker_get_pack_type_77(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline DCPackType DCPacker::get_pack_type(void) const
  DCPackType return_value = ((*(const DCPacker*)local_this).get_pack_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_pack_type_77_comment =
  "C++ Interface:\n"
  "get_pack_type(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the type of value expected by the current field.  See the\n"
  " * enumerated type definition at the top of DCPackerInterface.h.  If this\n"
  " * returns one of PT_double, PT_int, PT_int64, or PT_string, then you should\n"
  " * call the corresponding pack_double(), pack_int() function (or\n"
  " * unpack_double(), unpack_int(), etc.) to transfer data.  Otherwise, you\n"
  " * should call push() and begin packing or unpacking the nested fields.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_pack_type_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::get_current_field_name(void) const
 */
static PyObject *Dtool_DCPacker_get_current_field_name_78(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline std::string DCPacker::get_current_field_name(void) const
  std::string return_value = ((*(const DCPacker*)local_this).get_current_field_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_current_field_name_78_comment =
  "C++ Interface:\n"
  "get_current_field_name(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the current field, if it has a name, or the empty\n"
  " * string if the field does not have a name or there is no current field.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_current_field_name_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::push(void)
 */
static PyObject *Dtool_DCPacker_push_79(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.push")) {
    return nullptr;
  }
  // 1-void DCPacker::push(void)
  ((*local_this).push)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_push_79_comment =
  "C++ Interface:\n"
  "push(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Marks the beginning of a nested series of fields.\n"
  " *\n"
  " * This must be called before filling the elements of an array or the\n"
  " * individual fields in a structure field.  It must also be balanced by a\n"
  " * matching pop().\n"
  " *\n"
  " * It is necessary to use push() / pop() only if has_nested_fields() returns\n"
  " * true.\n"
  " */";
#else
static const char *Dtool_DCPacker_push_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::pop(void)
 */
static PyObject *Dtool_DCPacker_pop_80(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pop")) {
    return nullptr;
  }
  // 1-void DCPacker::pop(void)
  ((*local_this).pop)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pop_80_comment =
  "C++ Interface:\n"
  "pop(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Marks the end of a nested series of fields.\n"
  " *\n"
  " * This must be called to match a previous push() only after all the expected\n"
  " * number of nested fields have been packed.  It is an error to call it too\n"
  " * early, or too late.\n"
  " */";
#else
static const char *Dtool_DCPacker_pop_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_double(double value)
 */
static PyObject *Dtool_DCPacker_pack_double_81(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_double")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_double(double value)
  if (PyNumber_Check(arg)) {
    ((*local_this).pack_double)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_double(const DCPacker self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_double_81_comment =
  "C++ Interface:\n"
  "pack_double(const DCPacker self, double value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_double_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_int(int value)
 */
static PyObject *Dtool_DCPacker_pack_int_82(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_int")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_int(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).pack_int)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_int(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_int_82_comment =
  "C++ Interface:\n"
  "pack_int(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_int_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_uint(unsigned int value)
 */
static PyObject *Dtool_DCPacker_pack_uint_83(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_uint")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_uint(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).pack_uint)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_uint(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_uint_83_comment =
  "C++ Interface:\n"
  "pack_uint(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_uint_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_int64(int64_t value)
 */
static PyObject *Dtool_DCPacker_pack_int64_84(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_int64")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:pack_int64", &param1)) {
    ((*local_this).pack_int64)((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_int64(const DCPacker self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_int64_84_comment =
  "C++ Interface:\n"
  "pack_int64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_int64_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_uint64(uint64_t value)
 */
static PyObject *Dtool_DCPacker_pack_uint64_85(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_uint64")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:pack_uint64", &param1)) {
    ((*local_this).pack_uint64)((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_uint64(const DCPacker self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_uint64_85_comment =
  "C++ Interface:\n"
  "pack_uint64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_uint64_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_string(std::string const &value)
 */
static PyObject *Dtool_DCPacker_pack_string_86(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_string")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_string(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).pack_string)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_string(const DCPacker self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_string_86_comment =
  "C++ Interface:\n"
  "pack_string(const DCPacker self, str value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_string_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_blob(vector_uchar const &value)
 */
static PyObject *Dtool_DCPacker_pack_blob_87(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_blob")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_blob(vector_uchar const &value)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).pack_blob)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_blob(const DCPacker self, bytes value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_blob_87_comment =
  "C++ Interface:\n"
  "pack_blob(const DCPacker self, bytes value)\n"
  "\n"
  "/**\n"
  " * Packs the indicated numeric or string value into the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_blob_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::pack_literal_value(vector_uchar const &value)
 */
static PyObject *Dtool_DCPacker_pack_literal_value_88(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_literal_value")) {
    return nullptr;
  }
  // 1-inline void DCPacker::pack_literal_value(vector_uchar const &value)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).pack_literal_value)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_literal_value(const DCPacker self, bytes value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_literal_value_88_comment =
  "C++ Interface:\n"
  "pack_literal_value(const DCPacker self, bytes value)\n"
  "\n"
  "/**\n"
  " * Adds the indicated string value into the stream, representing a single pre-\n"
  " * packed field element, or a whole group of field elements at once.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_literal_value_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::pack_default_value(void)
 */
static PyObject *Dtool_DCPacker_pack_default_value_89(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_default_value")) {
    return nullptr;
  }
  // 1-void DCPacker::pack_default_value(void)
  ((*local_this).pack_default_value)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_default_value_89_comment =
  "C++ Interface:\n"
  "pack_default_value(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Adds the default value for the current element into the stream.  If no\n"
  " * default has been set for the current element, creates a sensible default.\n"
  " */";
#else
static const char *Dtool_DCPacker_pack_default_value_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double DCPacker::unpack_double(void)
 */
static PyObject *Dtool_DCPacker_unpack_double_90(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_double")) {
    return nullptr;
  }
  // 1-inline double DCPacker::unpack_double(void)
  double return_value = ((*local_this).unpack_double)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_double_90_comment =
  "C++ Interface:\n"
  "unpack_double(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_double_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::unpack_int(void)
 */
static PyObject *Dtool_DCPacker_unpack_int_91(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_int")) {
    return nullptr;
  }
  // 1-inline int DCPacker::unpack_int(void)
  int return_value = ((*local_this).unpack_int)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_int_91_comment =
  "C++ Interface:\n"
  "unpack_int(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_int_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::unpack_uint(void)
 */
static PyObject *Dtool_DCPacker_unpack_uint_92(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_uint")) {
    return nullptr;
  }
  // 1-inline unsigned int DCPacker::unpack_uint(void)
  unsigned int return_value = ((*local_this).unpack_uint)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_uint_92_comment =
  "C++ Interface:\n"
  "unpack_uint(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_uint_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DCPacker::unpack_int64(void)
 */
static PyObject *Dtool_DCPacker_unpack_int64_93(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_int64")) {
    return nullptr;
  }
  // 1-inline int64_t DCPacker::unpack_int64(void)
  int64_t return_value = ((*local_this).unpack_int64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_int64_93_comment =
  "C++ Interface:\n"
  "unpack_int64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_int64_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DCPacker::unpack_uint64(void)
 */
static PyObject *Dtool_DCPacker_unpack_uint64_94(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_uint64")) {
    return nullptr;
  }
  // 1-inline uint64_t DCPacker::unpack_uint64(void)
  uint64_t return_value = ((*local_this).unpack_uint64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_uint64_94_comment =
  "C++ Interface:\n"
  "unpack_uint64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_uint64_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::unpack_string(void)
 */
static PyObject *Dtool_DCPacker_unpack_string_95(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_string")) {
    return nullptr;
  }
  // 1-inline std::string DCPacker::unpack_string(void)
  std::string return_value = ((*local_this).unpack_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_string_95_comment =
  "C++ Interface:\n"
  "unpack_string(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_string_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar DCPacker::unpack_blob(void)
 */
static PyObject *Dtool_DCPacker_unpack_blob_96(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_blob")) {
    return nullptr;
  }
  // 1-inline vector_uchar DCPacker::unpack_blob(void)
  vector_uchar return_value = ((*local_this).unpack_blob)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_blob_96_comment =
  "C++ Interface:\n"
  "unpack_blob(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the current binary data value from the stream.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the current numeric or string value from the stream.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_blob_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar DCPacker::unpack_literal_value(void)
 */
static PyObject *Dtool_DCPacker_unpack_literal_value_97(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_literal_value")) {
    return nullptr;
  }
  // 1-inline vector_uchar DCPacker::unpack_literal_value(void)
  vector_uchar return_value = ((*local_this).unpack_literal_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_literal_value_97_comment =
  "C++ Interface:\n"
  "unpack_literal_value(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the literal string that represents the packed value of the current\n"
  " * field, and advances the field pointer.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the literal string that represents the packed value of the current\n"
  " * field, and advances the field pointer.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_literal_value_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::unpack_validate(void)
 */
static PyObject *Dtool_DCPacker_unpack_validate_98(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_validate")) {
    return nullptr;
  }
  // 1-void DCPacker::unpack_validate(void)
  ((*local_this).unpack_validate)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_validate_98_comment =
  "C++ Interface:\n"
  "unpack_validate(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Internally unpacks the current numeric or string value and validates it\n"
  " * against the type range limits, but does not return the value.  If the\n"
  " * current field contains nested fields, validates all of them.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_validate_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::unpack_skip(void)
 */
static PyObject *Dtool_DCPacker_unpack_skip_99(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_skip")) {
    return nullptr;
  }
  // 1-void DCPacker::unpack_skip(void)
  ((*local_this).unpack_skip)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_skip_99_comment =
  "C++ Interface:\n"
  "unpack_skip(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Skips the current field without unpacking it and advances to the next\n"
  " * field.  If the current field contains nested fields, skips all of them.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_skip_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCPacker::pack_object(PyObject *object)
 */
static PyObject *Dtool_DCPacker_pack_object_100(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.pack_object")) {
    return nullptr;
  }
  // 1-void DCPacker::pack_object(PyObject *object)
  invoke_extension(local_this).pack_object(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_object(const DCPacker self, object object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_pack_object_100_comment =
  "C++ Interface:\n"
  "pack_object(const DCPacker self, object object)\n";
#else
static const char *Dtool_DCPacker_pack_object_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCPacker::unpack_object(void)
 */
static PyObject *Dtool_DCPacker_unpack_object_101(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_object")) {
    return nullptr;
  }
  // 1-PyObject *DCPacker::unpack_object(void)
  PyObject *return_value = invoke_extension(local_this).unpack_object();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_object_101_comment =
  "C++ Interface:\n"
  "unpack_object(const DCPacker self)\n";
#else
static const char *Dtool_DCPacker_unpack_object_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCPacker::parse_and_pack(std::istream &in)
 * bool DCPacker::parse_and_pack(std::string const &formatted_object)
 */
static PyObject *Dtool_DCPacker_parse_and_pack_102(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.parse_and_pack")) {
    return nullptr;
  }
  {
    // -2 bool DCPacker::parse_and_pack(std::istream &in)
    std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "DCPacker.parse_and_pack", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).parse_and_pack)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool DCPacker::parse_and_pack(std::string const &formatted_object)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*local_this).parse_and_pack)(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCPacker::parse_and_pack(std::istream &in)
  // No coercion possible: bool DCPacker::parse_and_pack(std::string const &formatted_object)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_and_pack(const DCPacker self, istream in)\n"
      "parse_and_pack(const DCPacker self, str formatted_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_parse_and_pack_102_comment =
  "C++ Interface:\n"
  "parse_and_pack(const DCPacker self, istream in)\n"
  "parse_and_pack(const DCPacker self, str formatted_object)\n"
  "\n"
  "/**\n"
  " * Parses an object's value according to the DC file syntax (e.g.  as a\n"
  " * default value string) and packs it.  Returns true on success, false on a\n"
  " * parse error.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Parses an object's value according to the DC file syntax (e.g.  as a\n"
  " * default value string) and packs it.  Returns true on success, false on a\n"
  " * parse error.\n"
  " */";
#else
static const char *Dtool_DCPacker_parse_and_pack_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DCPacker::unpack_and_format(bool show_field_names = true)
 * void DCPacker::unpack_and_format(std::ostream &out, bool show_field_names = true)
 */
static PyObject *Dtool_DCPacker_unpack_and_format_103(PyObject *self, PyObject *args, PyObject *kwds) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.unpack_and_format")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-std::string DCPacker::unpack_and_format(bool show_field_names)
      std::string return_value = ((*local_this).unpack_and_format)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 void DCPacker::unpack_and_format(std::ostream &out, bool show_field_names = true)
        PyObject *param1;
        PyObject *param2 = Py_True;
        static const char *keyword_list[] = {"out", "show_field_names", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:unpack_and_format", (char **)keyword_list, &param1, &param2)) {
          std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DCPacker.unpack_and_format", false, false);
          if (param1_this != nullptr) {
            ((*local_this).unpack_and_format)(*param1_this, (PyObject_IsTrue(param2) != 0));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 std::string DCPacker::unpack_and_format(bool show_field_names = true)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "show_field_names")) {
          std::string return_value = ((*local_this).unpack_and_format)((PyObject_IsTrue(param1) != 0));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }

      // No coercion possible: void DCPacker::unpack_and_format(std::ostream &out, bool show_field_names = true)
      // No coercion possible: std::string DCPacker::unpack_and_format(bool show_field_names = true)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "unpack_and_format() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unpack_and_format(const DCPacker self)\n"
      "unpack_and_format(const DCPacker self, ostream out, bool show_field_names)\n"
      "unpack_and_format(const DCPacker self, bool show_field_names)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_unpack_and_format_103_comment =
  "C++ Interface:\n"
  "unpack_and_format(const DCPacker self)\n"
  "unpack_and_format(const DCPacker self, ostream out, bool show_field_names)\n"
  "unpack_and_format(const DCPacker self, bool show_field_names)\n"
  "\n"
  "/**\n"
  " * Unpacks an object and formats its value into a syntax suitable for parsing\n"
  " * in the dc file (e.g.  as a default value), or as an input to parse_object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks an object and formats its value into a syntax suitable for parsing\n"
  " * in the dc file (e.g.  as a default value), or as an input to parse_object.\n"
  " */";
#else
static const char *Dtool_DCPacker_unpack_and_format_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_parse_error(void) const
 */
static PyObject *Dtool_DCPacker_had_parse_error_104(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline bool DCPacker::had_parse_error(void) const
  bool return_value = ((*(const DCPacker*)local_this).had_parse_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_parse_error_104_comment =
  "C++ Interface:\n"
  "had_parse_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been an parse error since the most recent call to\n"
  " * begin(); this can only happen if you call parse_and_pack().\n"
  " */";
#else
static const char *Dtool_DCPacker_had_parse_error_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_pack_error(void) const
 */
static PyObject *Dtool_DCPacker_had_pack_error_105(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline bool DCPacker::had_pack_error(void) const
  bool return_value = ((*(const DCPacker*)local_this).had_pack_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_pack_error_105_comment =
  "C++ Interface:\n"
  "had_pack_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been an packing error since the most recent call\n"
  " * to begin(); in particular, this may be called after end() has returned\n"
  " * false to determine the nature of the failure.\n"
  " *\n"
  " * A return value of true indicates there was a push/pop mismatch, or the\n"
  " * push/pop structure did not match the data structure, or there were the\n"
  " * wrong number of elements in a nested push/pop structure, or on unpack that\n"
  " * the data stream was truncated.\n"
  " */";
#else
static const char *Dtool_DCPacker_had_pack_error_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_range_error(void) const
 */
static PyObject *Dtool_DCPacker_had_range_error_106(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline bool DCPacker::had_range_error(void) const
  bool return_value = ((*(const DCPacker*)local_this).had_range_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_range_error_106_comment =
  "C++ Interface:\n"
  "had_range_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been an range validation error since the most\n"
  " * recent call to begin(); in particular, this may be called after end() has\n"
  " * returned false to determine the nature of the failure.\n"
  " *\n"
  " * A return value of true indicates a value that was packed or unpacked did\n"
  " * not fit within the specified legal range for a parameter, or within the\n"
  " * limits of the field size.\n"
  " */";
#else
static const char *Dtool_DCPacker_had_range_error_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCPacker::had_error(void) const
 */
static PyObject *Dtool_DCPacker_had_error_107(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline bool DCPacker::had_error(void) const
  bool return_value = ((*(const DCPacker*)local_this).had_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_had_error_107_comment =
  "C++ Interface:\n"
  "had_error(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns true if there has been any error (either a pack error or a range\n"
  " * error) since the most recent call to begin().  If this returns true, then\n"
  " * the matching call to end() will indicate an error (false).\n"
  " */";
#else
static const char *Dtool_DCPacker_had_error_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPacker::get_num_unpacked_bytes(void) const
 */
static PyObject *Dtool_DCPacker_get_num_unpacked_bytes_108(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline std::size_t DCPacker::get_num_unpacked_bytes(void) const
  std::size_t return_value = ((*(const DCPacker*)local_this).get_num_unpacked_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_num_unpacked_bytes_108_comment =
  "C++ Interface:\n"
  "get_num_unpacked_bytes(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes that have been unpacked so far, or after\n"
  " * unpack_end(), the total number of bytes that were unpacked at all.  This\n"
  " * can be used to validate that all of the bytes in the buffer were actually\n"
  " * unpacked (which is not otherwise considered an error).\n"
  " */";
#else
static const char *Dtool_DCPacker_get_num_unpacked_bytes_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPacker::get_length(void) const
 */
static PyObject *Dtool_DCPacker_get_length_109(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline std::size_t DCPacker::get_length(void) const
  std::size_t return_value = ((*(const DCPacker*)local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_length_109_comment =
  "C++ Interface:\n"
  "get_length(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the current length of the buffer.  This is the number of useful\n"
  " * bytes stored in the buffer, not the amount of memory it takes up.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_length_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::get_string(void) const
 */
static PyObject *Dtool_DCPacker_get_string_110(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline std::string DCPacker::get_string(void) const
  std::string return_value = ((*(const DCPacker*)local_this).get_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_string_110_comment =
  "C++ Interface:\n"
  "get_string(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the packed data buffer as a string.  Also see get_data().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the packed data into the indicated string.  Also see get_data().\n"
  " */";
#else
static const char *Dtool_DCPacker_get_string_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar DCPacker::get_bytes(void) const
 */
static PyObject *Dtool_DCPacker_get_bytes_111(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline vector_uchar DCPacker::get_bytes(void) const
  vector_uchar return_value = ((*(const DCPacker*)local_this).get_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_bytes_111_comment =
  "C++ Interface:\n"
  "get_bytes(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the packed data buffer as a bytes object.  Also see get_data().\n"
  " */";
#else
static const char *Dtool_DCPacker_get_bytes_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DCPacker::get_unpack_length(void) const
 */
static PyObject *Dtool_DCPacker_get_unpack_length_112(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline std::size_t DCPacker::get_unpack_length(void) const
  std::size_t return_value = ((*(const DCPacker*)local_this).get_unpack_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_unpack_length_112_comment =
  "C++ Interface:\n"
  "get_unpack_length(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes in the unpack data buffer.  This is the\n"
  " * buffer used when unpacking; it is separate from the pack data returned by\n"
  " * get_length(), which is filled during packing.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_unpack_length_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::get_unpack_string(void) const
 */
static PyObject *Dtool_DCPacker_get_unpack_string_113(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCPacker)) {
    return nullptr;
  }
  // 1-inline std::string DCPacker::get_unpack_string(void) const
  std::string return_value = ((*(const DCPacker*)local_this).get_unpack_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_unpack_string_113_comment =
  "C++ Interface:\n"
  "get_unpack_string(DCPacker self)\n"
  "\n"
  "/**\n"
  " * Returns the unpack data buffer, as a string.  This is the buffer used when\n"
  " * unpacking; it is separate from the pack data returned by get_string(),\n"
  " * which is filled during packing.  Also see get_unpack_data().\n"
  " */";
#else
static const char *Dtool_DCPacker_get_unpack_string_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int DCPacker::get_num_stack_elements_ever_allocated(void)
 */
static PyObject *Dtool_DCPacker_get_num_stack_elements_ever_allocated_114(PyObject *, PyObject *) {
  // 1-static inline int DCPacker::get_num_stack_elements_ever_allocated(void)
  int return_value = (DCPacker::get_num_stack_elements_ever_allocated)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_get_num_stack_elements_ever_allocated_114_comment =
  "C++ Interface:\n"
  "get_num_stack_elements_ever_allocated()\n"
  "\n"
  "/**\n"
  " * Returns the number of DCPacker::StackElement pointers ever simultaneously\n"
  " * allocated; these are now either in active use or have been recycled into\n"
  " * the deleted DCPacker::StackElement pool to be used again.\n"
  " */";
#else
static const char *Dtool_DCPacker_get_num_stack_elements_ever_allocated_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int8(int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int8_115(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int8")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_int8(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).raw_pack_int8)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int8(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int8_115_comment =
  "C++ Interface:\n"
  "raw_pack_int8(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int8_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int16(int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int16_116(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int16")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_int16(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).raw_pack_int16)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int16(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int16_116_comment =
  "C++ Interface:\n"
  "raw_pack_int16(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int16_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int32(int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int32_117(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int32")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_int32(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).raw_pack_int32)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int32(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int32_117_comment =
  "C++ Interface:\n"
  "raw_pack_int32(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int32_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_int64(int64_t value)
 */
static PyObject *Dtool_DCPacker_raw_pack_int64_118(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_int64")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:raw_pack_int64", &param1)) {
    ((*local_this).raw_pack_int64)((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_int64(const DCPacker self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_int64_118_comment =
  "C++ Interface:\n"
  "raw_pack_int64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_int64_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint8(unsigned int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint8_119(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint8")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_uint8(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).raw_pack_uint8)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint8(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint8_119_comment =
  "C++ Interface:\n"
  "raw_pack_uint8(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint8_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint16(unsigned int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint16_120(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint16")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_uint16(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).raw_pack_uint16)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint16(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint16_120_comment =
  "C++ Interface:\n"
  "raw_pack_uint16(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint16_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint32(unsigned int value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint32_121(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint32")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_uint32(unsigned int value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).raw_pack_uint32)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint32(const DCPacker self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint32_121_comment =
  "C++ Interface:\n"
  "raw_pack_uint32(const DCPacker self, int value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint32_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_uint64(uint64_t value)
 */
static PyObject *Dtool_DCPacker_raw_pack_uint64_122(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_uint64")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:raw_pack_uint64", &param1)) {
    ((*local_this).raw_pack_uint64)((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_uint64(const DCPacker self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_uint64_122_comment =
  "C++ Interface:\n"
  "raw_pack_uint64(const DCPacker self, long value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_uint64_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_float64(double value)
 */
static PyObject *Dtool_DCPacker_raw_pack_float64_123(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_float64")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_float64(double value)
  if (PyNumber_Check(arg)) {
    ((*local_this).raw_pack_float64)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_float64(const DCPacker self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_float64_123_comment =
  "C++ Interface:\n"
  "raw_pack_float64(const DCPacker self, double value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_float64_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_string(std::string const &value)
 */
static PyObject *Dtool_DCPacker_raw_pack_string_124(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_string")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_string(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).raw_pack_string)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_string(const DCPacker self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_string_124_comment =
  "C++ Interface:\n"
  "raw_pack_string(const DCPacker self, str value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_string_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCPacker::raw_pack_blob(vector_uchar const &value)
 */
static PyObject *Dtool_DCPacker_raw_pack_blob_125(PyObject *self, PyObject *arg) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_pack_blob")) {
    return nullptr;
  }
  // 1-inline void DCPacker::raw_pack_blob(vector_uchar const &value)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).raw_pack_blob)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_pack_blob(const DCPacker self, bytes value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_pack_blob_125_comment =
  "C++ Interface:\n"
  "raw_pack_blob(const DCPacker self, bytes value)\n"
  "\n"
  "/**\n"
  " * Packs the data into the buffer between packing sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_pack_blob_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::raw_unpack_int8(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int8_126(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int8")) {
    return nullptr;
  }
  // 1-inline int DCPacker::raw_unpack_int8(void)
  int return_value = ((*local_this).raw_unpack_int8)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int8_126_comment =
  "C++ Interface:\n"
  "raw_unpack_int8(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int8_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::raw_unpack_int16(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int16_127(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int16")) {
    return nullptr;
  }
  // 1-inline int DCPacker::raw_unpack_int16(void)
  int return_value = ((*local_this).raw_unpack_int16)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int16_127_comment =
  "C++ Interface:\n"
  "raw_unpack_int16(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int16_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DCPacker::raw_unpack_int32(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int32_128(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int32")) {
    return nullptr;
  }
  // 1-inline int DCPacker::raw_unpack_int32(void)
  int return_value = ((*local_this).raw_unpack_int32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int32_128_comment =
  "C++ Interface:\n"
  "raw_unpack_int32(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int32_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DCPacker::raw_unpack_int64(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_int64_129(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_int64")) {
    return nullptr;
  }
  // 1-inline int64_t DCPacker::raw_unpack_int64(void)
  int64_t return_value = ((*local_this).raw_unpack_int64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_int64_129_comment =
  "C++ Interface:\n"
  "raw_unpack_int64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_int64_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::raw_unpack_uint8(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint8_130(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint8")) {
    return nullptr;
  }
  // 1-inline unsigned int DCPacker::raw_unpack_uint8(void)
  unsigned int return_value = ((*local_this).raw_unpack_uint8)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint8_130_comment =
  "C++ Interface:\n"
  "raw_unpack_uint8(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint8_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::raw_unpack_uint16(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint16_131(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint16")) {
    return nullptr;
  }
  // 1-inline unsigned int DCPacker::raw_unpack_uint16(void)
  unsigned int return_value = ((*local_this).raw_unpack_uint16)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint16_131_comment =
  "C++ Interface:\n"
  "raw_unpack_uint16(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint16_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DCPacker::raw_unpack_uint32(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint32_132(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint32")) {
    return nullptr;
  }
  // 1-inline unsigned int DCPacker::raw_unpack_uint32(void)
  unsigned int return_value = ((*local_this).raw_unpack_uint32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint32_132_comment =
  "C++ Interface:\n"
  "raw_unpack_uint32(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint32_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DCPacker::raw_unpack_uint64(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_uint64_133(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_uint64")) {
    return nullptr;
  }
  // 1-inline uint64_t DCPacker::raw_unpack_uint64(void)
  uint64_t return_value = ((*local_this).raw_unpack_uint64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_uint64_133_comment =
  "C++ Interface:\n"
  "raw_unpack_uint64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_uint64_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double DCPacker::raw_unpack_float64(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_float64_134(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_float64")) {
    return nullptr;
  }
  // 1-inline double DCPacker::raw_unpack_float64(void)
  double return_value = ((*local_this).raw_unpack_float64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_float64_134_comment =
  "C++ Interface:\n"
  "raw_unpack_float64(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_float64_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string DCPacker::raw_unpack_string(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_string_135(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_string")) {
    return nullptr;
  }
  // 1-inline std::string DCPacker::raw_unpack_string(void)
  std::string return_value = ((*local_this).raw_unpack_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_string_135_comment =
  "C++ Interface:\n"
  "raw_unpack_string(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_string_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar DCPacker::raw_unpack_blob(void)
 */
static PyObject *Dtool_DCPacker_raw_unpack_blob_136(PyObject *self, PyObject *) {
  DCPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCPacker, (void **)&local_this, "DCPacker.raw_unpack_blob")) {
    return nullptr;
  }
  // 1-inline vector_uchar DCPacker::raw_unpack_blob(void)
  vector_uchar return_value = ((*local_this).raw_unpack_blob)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCPacker_raw_unpack_blob_136_comment =
  "C++ Interface:\n"
  "raw_unpack_blob(const DCPacker self)\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unpacks the data from the buffer between unpacking sessions.\n"
  " */";
#else
static const char *Dtool_DCPacker_raw_unpack_blob_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCPacker::DCPacker(void)
 * inline DCPacker::DCPacker(DCPacker const &) = default
 */
static int Dtool_Init_DCPacker(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DCPacker() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-DCPacker::DCPacker(void)
      DCPacker *return_value = new DCPacker();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPacker, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DCPacker::DCPacker(DCPacker const &) = default
      DCPacker const *arg_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCPacker, 0, "DCPacker.DCPacker", true, true);
      if (arg_this != nullptr) {
        DCPacker *return_value = new DCPacker(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCPacker, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DCPacker() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DCPacker()\n"
      "DCPacker(const DCPacker param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DCPacker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCPacker) {
    printf("DCPacker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCPacker *local_this = (DCPacker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCPacker) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCPacker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCPacker) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCParameter
 */
/**
 * Python function wrapper for:
 * virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
 * virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
 */
static PyObject *Dtool_DCParameter_as_simple_parameter_138(PyObject *self, PyObject *) {
  DCParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCParameter)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
    DCSimpleParameter *return_value = ((*local_this).as_simple_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSimpleParameter, false, false);
  }

  {
    // -2 virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
    DCSimpleParameter const *return_value = ((*(const DCParameter*)local_this).as_simple_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSimpleParameter, false, true);
  }

  // No coercion possible: virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
  // No coercion possible: virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_as_simple_parameter_138_comment =
  "C++ Interface:\n"
  "as_simple_parameter(const DCParameter self)\n"
  "as_simple_parameter(DCParameter self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCParameter_as_simple_parameter_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCArrayParameter *DCParameter::as_array_parameter(void)
 * virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
 */
static PyObject *Dtool_DCParameter_as_array_parameter_139(PyObject *self, PyObject *) {
  DCParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCParameter)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCArrayParameter *DCParameter::as_array_parameter(void)
    DCArrayParameter *return_value = ((*local_this).as_array_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCArrayParameter, false, false);
  }

  {
    // -2 virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
    DCArrayParameter const *return_value = ((*(const DCParameter*)local_this).as_array_parameter)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCArrayParameter, false, true);
  }

  // No coercion possible: virtual DCArrayParameter *DCParameter::as_array_parameter(void)
  // No coercion possible: virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_as_array_parameter_139_comment =
  "C++ Interface:\n"
  "as_array_parameter(const DCParameter self)\n"
  "as_array_parameter(DCParameter self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCParameter_as_array_parameter_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCParameter *DCParameter::make_copy(void) const = 0
 */
static PyObject *Dtool_DCParameter_make_copy_140(PyObject *self, PyObject *) {
  DCParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCParameter)) {
    return nullptr;
  }
  // 1-virtual DCParameter *DCParameter::make_copy(void) const = 0
  DCParameter *return_value = ((*(const DCParameter*)local_this).make_copy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_make_copy_140_comment =
  "C++ Interface:\n"
  "make_copy(DCParameter self)\n";
#else
static const char *Dtool_DCParameter_make_copy_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DCParameter::is_valid(void) const = 0
 */
static PyObject *Dtool_DCParameter_is_valid_141(PyObject *self, PyObject *) {
  DCParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCParameter)) {
    return nullptr;
  }
  // 1-virtual bool DCParameter::is_valid(void) const = 0
  bool return_value = ((*(const DCParameter*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_is_valid_141_comment =
  "C++ Interface:\n"
  "is_valid(DCParameter self)\n";
#else
static const char *Dtool_DCParameter_is_valid_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCTypedef const *DCParameter::get_typedef(void) const
 */
static PyObject *Dtool_DCParameter_get_typedef_142(PyObject *self, PyObject *) {
  DCParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCParameter)) {
    return nullptr;
  }
  // 1-DCTypedef const *DCParameter::get_typedef(void) const
  DCTypedef const *return_value = ((*(const DCParameter*)local_this).get_typedef)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCTypedef, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCParameter_get_typedef_142_comment =
  "C++ Interface:\n"
  "get_typedef(DCParameter self)\n"
  "\n"
  "/**\n"
  " * If this type has been referenced from a typedef, returns the DCTypedef\n"
  " * instance, or NULL if the type was declared on-the-fly.\n"
  " */";
#else
static const char *Dtool_DCParameter_get_typedef_142_comment = nullptr;
#endif

static int Dtool_Init_DCParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCParameter) {
    printf("DCParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCParameter *local_this = (DCParameter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCParameter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCArrayParameter
 */
/**
 * Python function wrapper for:
 * DCParameter *DCArrayParameter::get_element_type(void) const
 */
static PyObject *Dtool_DCArrayParameter_get_element_type_144(PyObject *self, PyObject *) {
  DCArrayParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCArrayParameter)) {
    return nullptr;
  }
  // 1-DCParameter *DCArrayParameter::get_element_type(void) const
  DCParameter *return_value = ((*(const DCArrayParameter*)local_this).get_element_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCArrayParameter_get_element_type_144_comment =
  "C++ Interface:\n"
  "get_element_type(DCArrayParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the type of the individual elements of this array.\n"
  " */";
#else
static const char *Dtool_DCArrayParameter_get_element_type_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCArrayParameter::get_array_size(void) const
 */
static PyObject *Dtool_DCArrayParameter_get_array_size_145(PyObject *self, PyObject *) {
  DCArrayParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCArrayParameter)) {
    return nullptr;
  }
  // 1-int DCArrayParameter::get_array_size(void) const
  int return_value = ((*(const DCArrayParameter*)local_this).get_array_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCArrayParameter_get_array_size_145_comment =
  "C++ Interface:\n"
  "get_array_size(DCArrayParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the fixed number of elements in this array, or -1 if the array may\n"
  " * contain a variable number of elements.\n"
  " */";
#else
static const char *Dtool_DCArrayParameter_get_array_size_145_comment = nullptr;
#endif

static int Dtool_Init_DCArrayParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCArrayParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCArrayParameter) {
    printf("DCArrayParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCArrayParameter *local_this = (DCArrayParameter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCArrayParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCArrayParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCArrayParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCArrayParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCArrayParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCArrayParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCArrayParameter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCAtomicField
 */
/**
 * Python function wrapper for:
 * int DCAtomicField::get_num_elements(void) const
 */
static PyObject *Dtool_DCAtomicField_get_num_elements_147(PyObject *self, PyObject *) {
  DCAtomicField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCAtomicField)) {
    return nullptr;
  }
  // 1-int DCAtomicField::get_num_elements(void) const
  int return_value = ((*(const DCAtomicField*)local_this).get_num_elements)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_num_elements_147_comment =
  "C++ Interface:\n"
  "get_num_elements(DCAtomicField self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements (parameters) of the atomic field.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_num_elements_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCParameter *DCAtomicField::get_element(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_148(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCAtomicField)) {
    return nullptr;
  }
  // 1-DCParameter *DCAtomicField::get_element(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCParameter *return_value = ((*(const DCAtomicField*)local_this).get_element)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCParameter, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(DCAtomicField self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_148_comment =
  "C++ Interface:\n"
  "get_element(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the parameter object describing the nth element.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * vector_uchar DCAtomicField::get_element_default(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_default_149(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCAtomicField)) {
    return nullptr;
  }
  // 1-vector_uchar DCAtomicField::get_element_default(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    vector_uchar return_value = ((*(const DCAtomicField*)local_this).get_element_default)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_default(DCAtomicField self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_default_149_comment =
  "C++ Interface:\n"
  "get_element_default(DCAtomicField self, int n)\n"
  "\n"
  "// These five methods are deprecated and will be removed soon.\n"
  "\n"
  "/**\n"
  " * Returns the pre-formatted default value associated with the nth element of\n"
  " * the field.  This is only valid if has_element_default() returns true, in\n"
  " * which case this string represents the bytes that should be assigned to the\n"
  " * field as a default value.\n"
  " *\n"
  " * If the element is an array-type element, the returned value will include\n"
  " * the two-byte length preceding the array data.\n"
  " *\n"
  " * @deprecated use get_element() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_default_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCAtomicField::has_element_default(int n) const
 */
static PyObject *Dtool_DCAtomicField_has_element_default_150(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCAtomicField)) {
    return nullptr;
  }
  // 1-bool DCAtomicField::has_element_default(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const DCAtomicField*)local_this).has_element_default)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_element_default(DCAtomicField self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_has_element_default_150_comment =
  "C++ Interface:\n"
  "has_element_default(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth element of the field has a default value specified,\n"
  " * false otherwise.\n"
  " *\n"
  " * @deprecated use get_element() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_has_element_default_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DCAtomicField::get_element_name(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_name_151(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCAtomicField)) {
    return nullptr;
  }
  // 1-std::string DCAtomicField::get_element_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const DCAtomicField*)local_this).get_element_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_name(DCAtomicField self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_name_151_comment =
  "C++ Interface:\n"
  "get_element_name(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth element of the field.  This name is strictly\n"
  " * for documentary purposes; it does not generally affect operation.  If a\n"
  " * name is not specified, this will be the empty string.\n"
  " *\n"
  " * @deprecated use get_element()->get_name() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_name_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCSubatomicType DCAtomicField::get_element_type(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_type_152(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCAtomicField)) {
    return nullptr;
  }
  // 1-DCSubatomicType DCAtomicField::get_element_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCSubatomicType return_value = ((*(const DCAtomicField*)local_this).get_element_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_type(DCAtomicField self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_type_152_comment =
  "C++ Interface:\n"
  "get_element_type(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the numeric type of the nth element of the field.  This method is\n"
  " * deprecated; use get_element() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_type_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCAtomicField::get_element_divisor(int n) const
 */
static PyObject *Dtool_DCAtomicField_get_element_divisor_153(PyObject *self, PyObject *arg) {
  DCAtomicField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCAtomicField)) {
    return nullptr;
  }
  // 1-int DCAtomicField::get_element_divisor(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const DCAtomicField*)local_this).get_element_divisor)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element_divisor(DCAtomicField self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCAtomicField_get_element_divisor_153_comment =
  "C++ Interface:\n"
  "get_element_divisor(DCAtomicField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the divisor associated with the nth element of the field.  This\n"
  " * implements an implicit fixed-point system; floating-point values are to be\n"
  " * multiplied by this value before encoding into a packet, and divided by this\n"
  " * number after decoding.\n"
  " *\n"
  " * This method is deprecated; use get_element()->get_divisor() instead.\n"
  " */";
#else
static const char *Dtool_DCAtomicField_get_element_divisor_153_comment = nullptr;
#endif

static int Dtool_Init_DCAtomicField(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCAtomicField(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCAtomicField) {
    printf("DCAtomicField ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCAtomicField *local_this = (DCAtomicField *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCAtomicField) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCAtomicField(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCAtomicField) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCAtomicField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCAtomicField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCAtomicField*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCDeclaration
 */
/**
 * Python function wrapper for:
 * virtual DCClass *DCDeclaration::as_class(void)
 * virtual DCClass const *DCDeclaration::as_class(void) const
 */
static PyObject *Dtool_DCDeclaration_as_class_156(PyObject *self, PyObject *) {
  DCDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCDeclaration)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCClass *DCDeclaration::as_class(void)
    DCClass *return_value = ((*local_this).as_class)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }

  {
    // -2 virtual DCClass const *DCDeclaration::as_class(void) const
    DCClass const *return_value = ((*(const DCDeclaration*)local_this).as_class)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, true);
  }

  // No coercion possible: virtual DCClass *DCDeclaration::as_class(void)
  // No coercion possible: virtual DCClass const *DCDeclaration::as_class(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_as_class_156_comment =
  "C++ Interface:\n"
  "as_class(const DCDeclaration self)\n"
  "as_class(DCDeclaration self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCDeclaration_as_class_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual DCSwitch *DCDeclaration::as_switch(void)
 * virtual DCSwitch const *DCDeclaration::as_switch(void) const
 */
static PyObject *Dtool_DCDeclaration_as_switch_157(PyObject *self, PyObject *) {
  DCDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCDeclaration)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual DCSwitch *DCDeclaration::as_switch(void)
    DCSwitch *return_value = ((*local_this).as_switch)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, false);
  }

  {
    // -2 virtual DCSwitch const *DCDeclaration::as_switch(void) const
    DCSwitch const *return_value = ((*(const DCDeclaration*)local_this).as_switch)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, true);
  }

  // No coercion possible: virtual DCSwitch *DCDeclaration::as_switch(void)
  // No coercion possible: virtual DCSwitch const *DCDeclaration::as_switch(void) const
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_as_switch_157_comment =
  "C++ Interface:\n"
  "as_switch(const DCDeclaration self)\n"
  "as_switch(DCDeclaration self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DCDeclaration_as_switch_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DCDeclaration::output(std::ostream &out) const
 */
static PyObject *Dtool_DCDeclaration_output_158(PyObject *self, PyObject *arg) {
  DCDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCDeclaration)) {
    return nullptr;
  }
  // 1-virtual void DCDeclaration::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DCDeclaration.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DCDeclaration*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DCDeclaration self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_output_158_comment =
  "C++ Interface:\n"
  "output(DCDeclaration self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCDeclaration_output_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCDeclaration::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_DCDeclaration_write_159(PyObject *self, PyObject *args, PyObject *kwds) {
  DCDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCDeclaration)) {
    return nullptr;
  }
  // 1-void DCDeclaration::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DCDeclaration.write", false, true);
    if (param1_this != nullptr) {
      ((*(const DCDeclaration*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DCDeclaration self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCDeclaration_write_159_comment =
  "C++ Interface:\n"
  "write(DCDeclaration self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCDeclaration_write_159_comment = nullptr;
#endif

static int Dtool_Init_DCDeclaration(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCDeclaration(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCDeclaration) {
    printf("DCDeclaration ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCDeclaration *local_this = (DCDeclaration *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCDeclaration) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCDeclaration(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCClass
 */
/**
 * Python function wrapper for:
 * inline DCFile *DCClass::get_dc_file(void) const
 */
static PyObject *Dtool_DCClass_get_dc_file_161(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-inline DCFile *DCClass::get_dc_file(void) const
  DCFile *return_value = ((*(const DCClass*)local_this).get_dc_file)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCFile, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_dc_file_161_comment =
  "C++ Interface:\n"
  "get_dc_file(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the DCFile object that contains the class.\n"
  " */";
#else
static const char *Dtool_DCClass_get_dc_file_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &DCClass::get_name(void) const
 */
static PyObject *Dtool_DCClass_get_name_162(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-inline std::string const &DCClass::get_name(void) const
  std::string const &return_value = ((*(const DCClass*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_name_162_comment =
  "C++ Interface:\n"
  "get_name(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this class.\n"
  " */";
#else
static const char *Dtool_DCClass_get_name_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DCClass::get_number(void) const
 */
static PyObject *Dtool_DCClass_get_number_163(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-inline int DCClass::get_number(void) const
  int return_value = ((*(const DCClass*)local_this).get_number)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_number_163_comment =
  "C++ Interface:\n"
  "get_number(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns a unique index number associated with this class.  This is defined\n"
  " * implicitly when the .dc file(s) are read.\n"
  " */";
#else
static const char *Dtool_DCClass_get_number_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCClass::get_num_parents(void) const
 */
static PyObject *Dtool_DCClass_get_num_parents_164(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-int DCClass::get_num_parents(void) const
  int return_value = ((*(const DCClass*)local_this).get_num_parents)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_num_parents_164_comment =
  "C++ Interface:\n"
  "get_num_parents(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the number of base classes this class inherits from.\n"
  " */";
#else
static const char *Dtool_DCClass_get_num_parents_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCClass *DCClass::get_parent(int n) const
 */
static PyObject *Dtool_DCClass_get_parent_165(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-DCClass *DCClass::get_parent(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCClass *return_value = ((*(const DCClass*)local_this).get_parent)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent(DCClass self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_parent_165_comment =
  "C++ Interface:\n"
  "get_parent(DCClass self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth parent class this class inherits from.\n"
  " */";
#else
static const char *Dtool_DCClass_get_parent_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::has_constructor(void) const
 */
static PyObject *Dtool_DCClass_has_constructor_166(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-bool DCClass::has_constructor(void) const
  bool return_value = ((*(const DCClass*)local_this).has_constructor)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_has_constructor_166_comment =
  "C++ Interface:\n"
  "has_constructor(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if this class has a constructor method, false if it just uses\n"
  " * the default constructor.\n"
  " */";
#else
static const char *Dtool_DCClass_has_constructor_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_constructor(void) const
 */
static PyObject *Dtool_DCClass_get_constructor_167(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-DCField *DCClass::get_constructor(void) const
  DCField *return_value = ((*(const DCClass*)local_this).get_constructor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_constructor_167_comment =
  "C++ Interface:\n"
  "get_constructor(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the constructor method for this class if it is defined, or NULL if\n"
  " * the class uses the default constructor.\n"
  " */";
#else
static const char *Dtool_DCClass_get_constructor_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCClass::get_num_fields(void) const
 */
static PyObject *Dtool_DCClass_get_num_fields_168(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-int DCClass::get_num_fields(void) const
  int return_value = ((*(const DCClass*)local_this).get_num_fields)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_num_fields_168_comment =
  "C++ Interface:\n"
  "get_num_fields(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the number of fields defined directly in this class, ignoring\n"
  " * inheritance.\n"
  " */";
#else
static const char *Dtool_DCClass_get_num_fields_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_field(int n) const
 */
static PyObject *Dtool_DCClass_get_field_169(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-DCField *DCClass::get_field(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = ((*(const DCClass*)local_this).get_field)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field(DCClass self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_field_169_comment =
  "C++ Interface:\n"
  "get_field(DCClass self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth field in the class.  This is not necessarily the field with\n"
  " * index n; this is the nth field defined in the class directly, ignoring\n"
  " * inheritance.\n"
  " */";
#else
static const char *Dtool_DCClass_get_field_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_field_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCClass_get_field_by_name_170(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-DCField *DCClass::get_field_by_name(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    DCField *return_value = ((*(const DCClass*)local_this).get_field_by_name)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_name(DCClass self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_field_by_name_170_comment =
  "C++ Interface:\n"
  "get_field_by_name(DCClass self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the DCField that shares the indicated name.  If the\n"
  " * named field is not found in the current class, the parent classes will be\n"
  " * searched, so the value returned may not actually be a field within this\n"
  " * class.  Returns NULL if there is no such field defined.\n"
  " */";
#else
static const char *Dtool_DCClass_get_field_by_name_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_field_by_index(int index_number) const
 */
static PyObject *Dtool_DCClass_get_field_by_index_171(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-DCField *DCClass::get_field_by_index(int index_number) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = ((*(const DCClass*)local_this).get_field_by_index)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_index(DCClass self, int index_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_field_by_index_171_comment =
  "C++ Interface:\n"
  "get_field_by_index(DCClass self, int index_number)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the DCField that has the indicated index number.  If\n"
  " * the numbered field is not found in the current class, the parent classes\n"
  " * will be searched, so the value returned may not actually be a field within\n"
  " * this class.  Returns NULL if there is no such field defined.\n"
  " */";
#else
static const char *Dtool_DCClass_get_field_by_index_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCClass::get_num_inherited_fields(void) const
 */
static PyObject *Dtool_DCClass_get_num_inherited_fields_172(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-int DCClass::get_num_inherited_fields(void) const
  int return_value = ((*(const DCClass*)local_this).get_num_inherited_fields)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_num_inherited_fields_172_comment =
  "C++ Interface:\n"
  "get_num_inherited_fields(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of field fields defined in this class and all\n"
  " * ancestor classes.\n"
  " */";
#else
static const char *Dtool_DCClass_get_num_inherited_fields_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCClass::get_inherited_field(int n) const
 */
static PyObject *Dtool_DCClass_get_inherited_field_173(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-DCField *DCClass::get_inherited_field(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = ((*(const DCClass*)local_this).get_inherited_field)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_inherited_field(DCClass self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_inherited_field_173_comment =
  "C++ Interface:\n"
  "get_inherited_field(DCClass self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth field field in the class and all of its ancestors.\n"
  " *\n"
  " * This *used* to be the same thing as get_field_by_index(), back when the\n"
  " * fields were numbered sequentially within a class's inheritance hierarchy.\n"
  " * Now that fields have a globally unique index number, this is no longer\n"
  " * true.\n"
  " */";
#else
static const char *Dtool_DCClass_get_inherited_field_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCClass::is_struct(void) const
 */
static PyObject *Dtool_DCClass_is_struct_174(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-inline bool DCClass::is_struct(void) const
  bool return_value = ((*(const DCClass*)local_this).is_struct)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_is_struct_174_comment =
  "C++ Interface:\n"
  "is_struct(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if the class has been identified with the \"struct\" keyword in\n"
  " * the dc file, false if it was declared with \"dclass\".\n"
  " */";
#else
static const char *Dtool_DCClass_is_struct_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCClass::is_bogus_class(void) const
 */
static PyObject *Dtool_DCClass_is_bogus_class_175(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-inline bool DCClass::is_bogus_class(void) const
  bool return_value = ((*(const DCClass*)local_this).is_bogus_class)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_is_bogus_class_175_comment =
  "C++ Interface:\n"
  "is_bogus_class(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if the class has been flagged as a bogus class.  This is set\n"
  " * for classes that are generated by the parser as placeholder for missing\n"
  " * classes, as when reading a partial file; it should not occur in a normal\n"
  " * valid dc file.\n"
  " */";
#else
static const char *Dtool_DCClass_is_bogus_class_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::inherits_from_bogus_class(void) const
 */
static PyObject *Dtool_DCClass_inherits_from_bogus_class_176(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-bool DCClass::inherits_from_bogus_class(void) const
  bool return_value = ((*(const DCClass*)local_this).inherits_from_bogus_class)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_inherits_from_bogus_class_176_comment =
  "C++ Interface:\n"
  "inherits_from_bogus_class(DCClass self)\n"
  "\n"
  "/**\n"
  " * Returns true if this class, or any class in the inheritance heirarchy for\n"
  " * this class, is a \"bogus\" class--a forward reference to an as-yet-undefined\n"
  " * class.\n"
  " */";
#else
static const char *Dtool_DCClass_inherits_from_bogus_class_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCClass::start_generate(void)
 */
static PyObject *Dtool_DCClass_start_generate_177(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.start_generate")) {
    return nullptr;
  }
  // 1-inline void DCClass::start_generate(void)
  ((*local_this).start_generate)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCClass_start_generate_177_comment =
  "C++ Interface:\n"
  "start_generate(const DCClass self)\n"
  "\n"
  "/**\n"
  " * Starts the PStats timer going on the \"generate\" task, that is, marks the\n"
  " * beginning of the process of generating a new object, for the purposes of\n"
  " * timing this process.\n"
  " *\n"
  " * This should balance with a corresponding call to stop_generate().\n"
  " */";
#else
static const char *Dtool_DCClass_start_generate_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DCClass::stop_generate(void)
 */
static PyObject *Dtool_DCClass_stop_generate_178(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.stop_generate")) {
    return nullptr;
  }
  // 1-inline void DCClass::stop_generate(void)
  ((*local_this).stop_generate)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCClass_stop_generate_178_comment =
  "C++ Interface:\n"
  "stop_generate(const DCClass self)\n"
  "\n"
  "/**\n"
  " * Stops the PStats timer on the \"generate\" task.  This should balance with a\n"
  " * preceding call to start_generate().\n"
  " */";
#else
static const char *Dtool_DCClass_stop_generate_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DCClass::output(std::ostream &out) const
 */
static PyObject *Dtool_DCClass_output_179(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-virtual void DCClass::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DCClass.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DCClass*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DCClass self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_output_179_comment =
  "C++ Interface:\n"
  "output(DCClass self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DCClass_output_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::has_class_def(void) const
 */
static PyObject *Dtool_DCClass_has_class_def_180(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-bool DCClass::has_class_def(void) const
  bool return_value = invoke_extension((const DCClass*)local_this).has_class_def();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_has_class_def_180_comment =
  "C++ Interface:\n"
  "has_class_def(DCClass self)\n";
#else
static const char *Dtool_DCClass_has_class_def_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::set_class_def(PyObject *class_def)
 */
static PyObject *Dtool_DCClass_set_class_def_181(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.set_class_def")) {
    return nullptr;
  }
  // 1-void DCClass::set_class_def(PyObject *class_def)
  invoke_extension(local_this).set_class_def(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_class_def(const DCClass self, object class_def)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_set_class_def_181_comment =
  "C++ Interface:\n"
  "set_class_def(const DCClass self, object class_def)\n";
#else
static const char *Dtool_DCClass_set_class_def_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCClass::get_class_def(void) const
 */
static PyObject *Dtool_DCClass_get_class_def_182(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-PyObject *DCClass::get_class_def(void) const
  PyObject *return_value = invoke_extension((const DCClass*)local_this).get_class_def();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_class_def_182_comment =
  "C++ Interface:\n"
  "get_class_def(DCClass self)\n";
#else
static const char *Dtool_DCClass_get_class_def_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::has_owner_class_def(void) const
 */
static PyObject *Dtool_DCClass_has_owner_class_def_183(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-bool DCClass::has_owner_class_def(void) const
  bool return_value = invoke_extension((const DCClass*)local_this).has_owner_class_def();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_has_owner_class_def_183_comment =
  "C++ Interface:\n"
  "has_owner_class_def(DCClass self)\n";
#else
static const char *Dtool_DCClass_has_owner_class_def_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::set_owner_class_def(PyObject *owner_class_def)
 */
static PyObject *Dtool_DCClass_set_owner_class_def_184(PyObject *self, PyObject *arg) {
  DCClass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.set_owner_class_def")) {
    return nullptr;
  }
  // 1-void DCClass::set_owner_class_def(PyObject *owner_class_def)
  invoke_extension(local_this).set_owner_class_def(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_owner_class_def(const DCClass self, object owner_class_def)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_set_owner_class_def_184_comment =
  "C++ Interface:\n"
  "set_owner_class_def(const DCClass self, object owner_class_def)\n";
#else
static const char *Dtool_DCClass_set_owner_class_def_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *DCClass::get_owner_class_def(void) const
 */
static PyObject *Dtool_DCClass_get_owner_class_def_185(PyObject *self, PyObject *) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-PyObject *DCClass::get_owner_class_def(void) const
  PyObject *return_value = invoke_extension((const DCClass*)local_this).get_owner_class_def();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCClass_get_owner_class_def_185_comment =
  "C++ Interface:\n"
  "get_owner_class_def(DCClass self)\n";
#else
static const char *Dtool_DCClass_get_owner_class_def_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_186(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-void DCClass::receive_update(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update", "DatagramIterator");
    }
    invoke_extension((const DCClass*)local_this).receive_update(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_186_comment =
  "C++ Interface:\n"
  "receive_update(DCClass self, object distobj, DatagramIterator di)\n";
#else
static const char *Dtool_DCClass_receive_update_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_broadcast_required(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_broadcast_required_187(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-void DCClass::receive_update_broadcast_required(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_broadcast_required", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_broadcast_required", "DatagramIterator");
    }
    invoke_extension((const DCClass*)local_this).receive_update_broadcast_required(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_broadcast_required(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_broadcast_required_187_comment =
  "C++ Interface:\n"
  "receive_update_broadcast_required(DCClass self, object distobj, DatagramIterator di)\n";
#else
static const char *Dtool_DCClass_receive_update_broadcast_required_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_broadcast_required_owner(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_broadcast_required_owner_188(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-void DCClass::receive_update_broadcast_required_owner(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_broadcast_required_owner", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_broadcast_required_owner", "DatagramIterator");
    }
    invoke_extension((const DCClass*)local_this).receive_update_broadcast_required_owner(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_broadcast_required_owner(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_broadcast_required_owner_188_comment =
  "C++ Interface:\n"
  "receive_update_broadcast_required_owner(DCClass self, object distobj, DatagramIterator di)\n";
#else
static const char *Dtool_DCClass_receive_update_broadcast_required_owner_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_all_required(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_all_required_189(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-void DCClass::receive_update_all_required(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_all_required", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_all_required", "DatagramIterator");
    }
    invoke_extension((const DCClass*)local_this).receive_update_all_required(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_all_required(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_all_required_189_comment =
  "C++ Interface:\n"
  "receive_update_all_required(DCClass self, object distobj, DatagramIterator di)\n";
#else
static const char *Dtool_DCClass_receive_update_all_required_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::receive_update_other(PyObject *distobj, DatagramIterator &di) const
 */
static PyObject *Dtool_DCClass_receive_update_other_190(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-void DCClass::receive_update_other(PyObject *distobj, DatagramIterator &di) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"distobj", "di", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:receive_update_other", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param2_local;
    DatagramIterator *param2_this = Dtool_Coerce_DatagramIterator(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DCClass.receive_update_other", "DatagramIterator");
    }
    invoke_extension((const DCClass*)local_this).receive_update_other(param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_update_other(DCClass self, object distobj, DatagramIterator di)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_receive_update_other_190_comment =
  "C++ Interface:\n"
  "receive_update_other(DCClass self, object distobj, DatagramIterator di)\n";
#else
static const char *Dtool_DCClass_receive_update_other_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DCClass::direct_update(PyObject *distobj, std::string const &field_name, Datagram const &datagram)
 * void DCClass::direct_update(PyObject *distobj, std::string const &field_name, vector_uchar const &value_blob)
 */
static PyObject *Dtool_DCClass_direct_update_191(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCClass, (void **)&local_this, "DCClass.direct_update")) {
    return nullptr;
  }
  {
    // -2 void DCClass::direct_update(PyObject *distobj, std::string const &field_name, Datagram const &datagram)
    PyObject *param1;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    PyObject *param3;
    static const char *keyword_list[] = {"distobj", "field_name", "datagram", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#O:direct_update", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      Datagram const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_Datagram);
      if (param3_this != nullptr) {
        invoke_extension(local_this).direct_update(param1, std::string(param2_str, param2_len), *param3_this);
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != nullptr) {
          return nullptr;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void DCClass::direct_update(PyObject *distobj, std::string const &field_name, vector_uchar const &value_blob)
    PyObject *param1;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    unsigned char *param3_str = nullptr;
    Py_ssize_t param3_len;
    static const char *keyword_list[] = {"distobj", "field_name", "value_blob", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#" FMTCHAR_BYTES "#:direct_update", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len)) {
      invoke_extension(local_this).direct_update(param1, std::string(param2_str, param2_len), vector_uchar(param3_str, param3_str + param3_len));
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void DCClass::direct_update(PyObject *distobj, std::string const &field_name, Datagram const &datagram)
    PyObject *param1;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    PyObject *param3;
    static const char *keyword_list[] = {"distobj", "field_name", "datagram", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#O:direct_update", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      Datagram param3_local;
      Datagram const *param3_this = Dtool_Coerce_Datagram(param3, param3_local);
      if ((param3_this != nullptr)) {
        invoke_extension(local_this).direct_update(param1, std::string(param2_str, param2_len), *param3_this);
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != nullptr) {
          return nullptr;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void DCClass::direct_update(PyObject *distobj, std::string const &field_name, vector_uchar const &value_blob)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "direct_update(const DCClass self, object distobj, str field_name, const Datagram datagram)\n"
      "direct_update(const DCClass self, object distobj, str field_name, bytes value_blob)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_direct_update_191_comment =
  "C++ Interface:\n"
  "direct_update(const DCClass self, object distobj, str field_name, const Datagram datagram)\n"
  "direct_update(const DCClass self, object distobj, str field_name, bytes value_blob)\n";
#else
static const char *Dtool_DCClass_direct_update_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
 * bool DCClass::pack_required_field(Datagram &datagram, PyObject *distobj, DCField const *field) const
 */
static PyObject *Dtool_DCClass_pack_required_field_192(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  {
    // -2 bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"packer", "distobj", "field", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:pack_required_field", (char **)keyword_list, &param1, &param2, &param3)) {
      DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DCPacker, 1, "DCClass.pack_required_field", false, false);
      DCField const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_DCField);
      if (param1_this != nullptr && param3_this != nullptr) {
        bool return_value = invoke_extension((const DCClass*)local_this).pack_required_field(*param1_this, param2, param3_this);
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != nullptr) {
          return nullptr;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
  {
    // -2 bool DCClass::pack_required_field(Datagram &datagram, PyObject *distobj, DCField const *field) const
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    static const char *keyword_list[] = {"datagram", "distobj", "field", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:pack_required_field", (char **)keyword_list, &param1, &param2, &param3)) {
      Datagram param1_local;
      Datagram *param1_this = Dtool_Coerce_Datagram(param1, param1_local);
      DCField const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_DCField);
      if ((param1_this != nullptr) && param3_this != nullptr) {
        bool return_value = invoke_extension((const DCClass*)local_this).pack_required_field(*param1_this, param2, param3_this);
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != nullptr) {
          return nullptr;
        } else {
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pack_required_field(DCClass self, DCPacker packer, object distobj, const DCField field)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_pack_required_field_192_comment =
  "C++ Interface:\n"
  "pack_required_field(DCClass self, DCPacker packer, object distobj, const DCField field)\n";
#else
static const char *Dtool_DCClass_pack_required_field_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::client_format_update(std::string const &field_name, DOID_TYPE do_id, PyObject *args) const
 */
static PyObject *Dtool_DCClass_client_format_update_193(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-Datagram DCClass::client_format_update(std::string const &field_name, DOID_TYPE do_id, PyObject *args) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  unsigned long param2;
  PyObject *param3;
  static const char *keyword_list[] = {"field_name", "do_id", "args", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#kO:client_format_update", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCClass*)local_this).client_format_update(std::string(param1_str, param1_len), (DOID_TYPE)param2, param3));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_format_update(DCClass self, str field_name, int do_id, object args)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_client_format_update_193_comment =
  "C++ Interface:\n"
  "client_format_update(DCClass self, str field_name, int do_id, object args)\n";
#else
static const char *Dtool_DCClass_client_format_update_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::ai_format_update(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
 */
static PyObject *Dtool_DCClass_ai_format_update_194(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-Datagram DCClass::ai_format_update(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  unsigned long param2;
  unsigned PY_LONG_LONG param3;
  unsigned PY_LONG_LONG param4;
  PyObject *param5;
  static const char *keyword_list[] = {"field_name", "do_id", "to_id", "from_id", "args", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#kKKO:ai_format_update", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCClass*)local_this).ai_format_update(std::string(param1_str, param1_len), (DOID_TYPE)param2, (CHANNEL_TYPE)param3, (CHANNEL_TYPE)param4, param5));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update(DCClass self, str field_name, int do_id, long to_id, long from_id, object args)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_ai_format_update_194_comment =
  "C++ Interface:\n"
  "ai_format_update(DCClass self, str field_name, int do_id, long to_id, long from_id, object args)\n";
#else
static const char *Dtool_DCClass_ai_format_update_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::ai_format_update_msg_type(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
 */
static PyObject *Dtool_DCClass_ai_format_update_msg_type_195(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-Datagram DCClass::ai_format_update_msg_type(std::string const &field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  unsigned long param2;
  unsigned PY_LONG_LONG param3;
  unsigned PY_LONG_LONG param4;
  int param5;
  PyObject *param6;
  static const char *keyword_list[] = {"field_name", "do_id", "to_id", "from_id", "msg_type", "args", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#kKKiO:ai_format_update_msg_type", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCClass*)local_this).ai_format_update_msg_type(std::string(param1_str, param1_len), (DOID_TYPE)param2, (CHANNEL_TYPE)param3, (CHANNEL_TYPE)param4, (int)param5, param6));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_update_msg_type(DCClass self, str field_name, int do_id, long to_id, long from_id, int msg_type, object args)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_ai_format_update_msg_type_195_comment =
  "C++ Interface:\n"
  "ai_format_update_msg_type(DCClass self, str field_name, int do_id, long to_id, long from_id, int msg_type, object args)\n";
#else
static const char *Dtool_DCClass_ai_format_update_msg_type_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::ai_format_generate(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE parent_id, ZONEID_TYPE zone_id, CHANNEL_TYPE district_channel_id, CHANNEL_TYPE from_channel_id, PyObject *optional_fields) const
 */
static PyObject *Dtool_DCClass_ai_format_generate_196(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-Datagram DCClass::ai_format_generate(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE parent_id, ZONEID_TYPE zone_id, CHANNEL_TYPE district_channel_id, CHANNEL_TYPE from_channel_id, PyObject *optional_fields) const
  PyObject *param1;
  unsigned long param2;
  unsigned long param3;
  unsigned long param4;
  unsigned PY_LONG_LONG param5;
  unsigned PY_LONG_LONG param6;
  PyObject *param7;
  static const char *keyword_list[] = {"distobj", "do_id", "parent_id", "zone_id", "district_channel_id", "from_channel_id", "optional_fields", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OkkkKKO:ai_format_generate", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param3 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param3);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param4 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param4);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCClass*)local_this).ai_format_generate(param1, (DOID_TYPE)param2, (ZONEID_TYPE)param3, (ZONEID_TYPE)param4, (CHANNEL_TYPE)param5, (CHANNEL_TYPE)param6, param7));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ai_format_generate(DCClass self, object distobj, int do_id, int parent_id, int zone_id, long district_channel_id, long from_channel_id, object optional_fields)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_ai_format_generate_196_comment =
  "C++ Interface:\n"
  "ai_format_generate(DCClass self, object distobj, int do_id, int parent_id, int zone_id, long district_channel_id, long from_channel_id, object optional_fields)\n";
#else
static const char *Dtool_DCClass_ai_format_generate_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Datagram DCClass::client_format_generate_CMU(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE zone_id, PyObject *optional_fields) const
 */
static PyObject *Dtool_DCClass_client_format_generate_CMU_197(PyObject *self, PyObject *args, PyObject *kwds) {
  DCClass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClass)) {
    return nullptr;
  }
  // 1-Datagram DCClass::client_format_generate_CMU(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE zone_id, PyObject *optional_fields) const
  PyObject *param1;
  unsigned long param2;
  unsigned long param3;
  PyObject *param4;
  static const char *keyword_list[] = {"distobj", "do_id", "zone_id", "optional_fields", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OkkO:client_format_generate_CMU", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param3 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param3);
    }
#endif
    Datagram *return_value = new Datagram(invoke_extension((const DCClass*)local_this).client_format_generate_CMU(param1, (DOID_TYPE)param2, (ZONEID_TYPE)param3, param4));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_format_generate_CMU(DCClass self, object distobj, int do_id, int zone_id, object optional_fields)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCClass_client_format_generate_CMU_197_comment =
  "C++ Interface:\n"
  "client_format_generate_CMU(DCClass self, object distobj, int do_id, int zone_id, object optional_fields)\n";
#else
static const char *Dtool_DCClass_client_format_generate_CMU_197_comment = nullptr;
#endif

static int Dtool_Init_DCClass(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCClass(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCClass) {
    printf("DCClass ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCClass *local_this = (DCClass *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCClass) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCClass(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCClass) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCClass*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCClassParameter
 */
/**
 * Python function wrapper for:
 * DCClass const *DCClassParameter::get_class(void) const
 */
static PyObject *Dtool_DCClassParameter_get_class_199(PyObject *self, PyObject *) {
  DCClassParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCClassParameter)) {
    return nullptr;
  }
  // 1-DCClass const *DCClassParameter::get_class(void) const
  DCClass const *return_value = ((*(const DCClassParameter*)local_this).get_class)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCClassParameter_get_class_199_comment =
  "C++ Interface:\n"
  "get_class(DCClassParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the class object this parameter represents.\n"
  " */";
#else
static const char *Dtool_DCClassParameter_get_class_199_comment = nullptr;
#endif

static int Dtool_Init_DCClassParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCClassParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCClassParameter) {
    printf("DCClassParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCClassParameter *local_this = (DCClassParameter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCClassParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCClassParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCClassParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCClassParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCClassParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCClassParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCClassParameter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCFile
 */
/**
 * Python function wrapper for:
 * void DCFile::clear(void)
 */
static PyObject *Dtool_DCFile_clear_204(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCFile, (void **)&local_this, "DCFile.clear")) {
    return nullptr;
  }
  // 1-void DCFile::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DCFile_clear_204_comment =
  "C++ Interface:\n"
  "clear(const DCFile self)\n"
  "\n"
  "/**\n"
  " * Removes all of the classes defined within the DCFile and prepares it for\n"
  " * reading a new file.\n"
  " */";
#else
static const char *Dtool_DCFile_clear_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCFile::read_all(void)
 */
static PyObject *Dtool_DCFile_read_all_205(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCFile, (void **)&local_this, "DCFile.read_all")) {
    return nullptr;
  }
  // 1-bool DCFile::read_all(void)
  bool return_value = ((*local_this).read_all)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_read_all_205_comment =
  "C++ Interface:\n"
  "read_all(const DCFile self)\n"
  "\n"
  "/**\n"
  " * This special method reads all of the .dc files named by the \"dc-file\"\n"
  " * config.prc variable, and loads them into the DCFile namespace.\n"
  " */";
#else
static const char *Dtool_DCFile_read_all_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCFile::read(Filename filename)
 * bool DCFile::read(std::istream &in, std::string const &filename = string())
 */
static PyObject *Dtool_DCFile_read_206(PyObject *self, PyObject *args, PyObject *kwds) {
  DCFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DCFile, (void **)&local_this, "DCFile.read")) {
    return nullptr;
  }
  {
    // -2 bool DCFile::read(std::istream &in, std::string const &filename = string())
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"in", "filename", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:read", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "DCFile.read", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).read)(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCFile::read(std::istream &in, std::string const &filename = string())
  {
    // -2 bool DCFile::read(Filename filename)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "filename")) {
      Filename param1_local;
      Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        bool return_value = ((*local_this).read)(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const DCFile self, istream in, str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_read_206_comment =
  "C++ Interface:\n"
  "read(const DCFile self, istream in, str filename)\n"
  "\n"
  "/**\n"
  " * Opens and reads the indicated .dc file by name.  The distributed classes\n"
  " * defined in the file will be appended to the set of distributed classes\n"
  " * already recorded, if any.\n"
  " *\n"
  " * Returns true if the file is successfully read, false if there was an error\n"
  " * (in which case the file might have been partially read).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Parses the already-opened input stream for distributed class descriptions.\n"
  " * The filename parameter is optional and is only used when reporting errors.\n"
  " *\n"
  " * The distributed classes defined in the file will be appended to the set of\n"
  " * distributed classes already recorded, if any.\n"
  " *\n"
  " * Returns true if the file is successfully read, false if there was an error\n"
  " * (in which case the file might have been partially read).\n"
  " */";
#else
static const char *Dtool_DCFile_read_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCFile::write(Filename filename, bool brief) const
 * bool DCFile::write(std::ostream &out, bool brief) const
 */
static PyObject *Dtool_DCFile_write_207(PyObject *self, PyObject *args, PyObject *kwds) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  {
    // -2 bool DCFile::write(Filename filename, bool brief) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"filename", "brief", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write", (char **)keyword_list, &param1, &param2)) {
      Filename *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr) {
        bool return_value = ((*(const DCFile*)local_this).write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCFile::write(std::ostream &out, bool brief) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"out", "brief", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write", (char **)keyword_list, &param1, &param2)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DCFile.write", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*(const DCFile*)local_this).write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DCFile::write(Filename filename, bool brief) const
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"filename", "brief", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        bool return_value = ((*(const DCFile*)local_this).write)(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool DCFile::write(std::ostream &out, bool brief) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DCFile self, Filename filename, bool brief)\n"
      "write(DCFile self, ostream out, bool brief)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_write_207_comment =
  "C++ Interface:\n"
  "write(DCFile self, Filename filename, bool brief)\n"
  "write(DCFile self, ostream out, bool brief)\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for output and writes a parseable description\n"
  " * of all the known distributed classes to the file.\n"
  " *\n"
  " * Returns true if the description is successfully written, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes a parseable description of all the known distributed classes to the\n"
  " * stream.\n"
  " *\n"
  " * Returns true if the description is successfully written, false otherwise.\n"
  " */";
#else
static const char *Dtool_DCFile_write_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_classes(void) const
 */
static PyObject *Dtool_DCFile_get_num_classes_208(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-int DCFile::get_num_classes(void) const
  int return_value = ((*(const DCFile*)local_this).get_num_classes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_classes_208_comment =
  "C++ Interface:\n"
  "get_num_classes(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of classes read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_classes_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCClass *DCFile::get_class(int n) const
 */
static PyObject *Dtool_DCFile_get_class_209(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCClass *DCFile::get_class(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCClass *return_value = ((*(const DCFile*)local_this).get_class)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_class(DCFile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_class_209_comment =
  "C++ Interface:\n"
  "get_class(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth class read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_class_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCClass *DCFile::get_class_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_class_by_name_210(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCClass *DCFile::get_class_by_name(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    DCClass *return_value = ((*(const DCFile*)local_this).get_class_by_name)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCClass, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_class_by_name(DCFile self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_class_by_name_210_comment =
  "C++ Interface:\n"
  "get_class_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the class that has the indicated name, or NULL if there is no such\n"
  " * class.\n"
  " */";
#else
static const char *Dtool_DCFile_get_class_by_name_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCSwitch *DCFile::get_switch_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_switch_by_name_211(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCSwitch *DCFile::get_switch_by_name(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    DCSwitch *return_value = ((*(const DCFile*)local_this).get_switch_by_name)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_switch_by_name(DCFile self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_switch_by_name_211_comment =
  "C++ Interface:\n"
  "get_switch_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the switch that has the indicated name, or NULL if there is no such\n"
  " * switch.\n"
  " */";
#else
static const char *Dtool_DCFile_get_switch_by_name_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCFile::get_field_by_index(int index_number) const
 */
static PyObject *Dtool_DCFile_get_field_by_index_212(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCField *DCFile::get_field_by_index(int index_number) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCField *return_value = ((*(const DCFile*)local_this).get_field_by_index)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_index(DCFile self, int index_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_field_by_index_212_comment =
  "C++ Interface:\n"
  "get_field_by_index(DCFile self, int index_number)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one DCField that has the indicated index number,\n"
  " * of all the DCFields across all classes in the file.\n"
  " *\n"
  " * This method is only valid if dc-multiple-inheritance is set true in the\n"
  " * Config.prc file.  Without this setting, different DCFields may share the\n"
  " * same index number, so this global lookup is not possible.\n"
  " */";
#else
static const char *Dtool_DCFile_get_field_by_index_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DCFile::all_objects_valid(void) const
 */
static PyObject *Dtool_DCFile_all_objects_valid_213(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-inline bool DCFile::all_objects_valid(void) const
  bool return_value = ((*(const DCFile*)local_this).all_objects_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_all_objects_valid_213_comment =
  "C++ Interface:\n"
  "all_objects_valid(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the classes read from the DC file were defined and\n"
  " * valid, or false if any of them were undefined (\"bogus classes\").  If this\n"
  " * is true, we might have read a partial file.\n"
  " */";
#else
static const char *Dtool_DCFile_all_objects_valid_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_import_modules(void) const
 */
static PyObject *Dtool_DCFile_get_num_import_modules_214(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-int DCFile::get_num_import_modules(void) const
  int return_value = ((*(const DCFile*)local_this).get_num_import_modules)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_import_modules_214_comment =
  "C++ Interface:\n"
  "get_num_import_modules(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of import lines read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_import_modules_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DCFile::get_import_module(int n) const
 */
static PyObject *Dtool_DCFile_get_import_module_215(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-std::string DCFile::get_import_module(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const DCFile*)local_this).get_import_module)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_import_module(DCFile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_import_module_215_comment =
  "C++ Interface:\n"
  "get_import_module(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the module named by the nth import line read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_import_module_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_import_symbols(int n) const
 */
static PyObject *Dtool_DCFile_get_num_import_symbols_216(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-int DCFile::get_num_import_symbols(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const DCFile*)local_this).get_num_import_symbols)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_import_symbols(DCFile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_import_symbols_216_comment =
  "C++ Interface:\n"
  "get_num_import_symbols(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of symbols explicitly imported by the nth import line.\n"
  " * If this is 0, the line is \"import modulename\"; if it is more than 0, the\n"
  " * line is \"from modulename import symbol, symbol ... \".\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_import_symbols_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DCFile::get_import_symbol(int n, int i) const
 */
static PyObject *Dtool_DCFile_get_import_symbol_217(PyObject *self, PyObject *args, PyObject *kwds) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-std::string DCFile::get_import_symbol(int n, int i) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"n", "i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_import_symbol", (char **)keyword_list, &param1, &param2)) {
    std::string return_value = ((*(const DCFile*)local_this).get_import_symbol)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_import_symbol(DCFile self, int n, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_import_symbol_217_comment =
  "C++ Interface:\n"
  "get_import_symbol(DCFile self, int n, int i)\n"
  "\n"
  "/**\n"
  " * Returns the ith symbol named by the nth import line read from the .dc\n"
  " * file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_import_symbol_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_typedefs(void) const
 */
static PyObject *Dtool_DCFile_get_num_typedefs_218(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-int DCFile::get_num_typedefs(void) const
  int return_value = ((*(const DCFile*)local_this).get_num_typedefs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_typedefs_218_comment =
  "C++ Interface:\n"
  "get_num_typedefs(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of typedefs read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_typedefs_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCTypedef *DCFile::get_typedef(int n) const
 */
static PyObject *Dtool_DCFile_get_typedef_219(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCTypedef *DCFile::get_typedef(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCTypedef *return_value = ((*(const DCFile*)local_this).get_typedef)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCTypedef, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typedef(DCFile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_typedef_219_comment =
  "C++ Interface:\n"
  "get_typedef(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth typedef read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_typedef_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCTypedef *DCFile::get_typedef_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_typedef_by_name_220(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCTypedef *DCFile::get_typedef_by_name(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    DCTypedef *return_value = ((*(const DCFile*)local_this).get_typedef_by_name)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCTypedef, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typedef_by_name(DCFile self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_typedef_by_name_220_comment =
  "C++ Interface:\n"
  "get_typedef_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the typedef that has the indicated name, or NULL if there is no\n"
  " * such typedef name.\n"
  " */";
#else
static const char *Dtool_DCFile_get_typedef_by_name_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCFile::get_num_keywords(void) const
 */
static PyObject *Dtool_DCFile_get_num_keywords_221(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-int DCFile::get_num_keywords(void) const
  int return_value = ((*(const DCFile*)local_this).get_num_keywords)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_num_keywords_221_comment =
  "C++ Interface:\n"
  "get_num_keywords(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of keywords read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_num_keywords_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCFile::get_keyword(int n) const
 */
static PyObject *Dtool_DCFile_get_keyword_222(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCKeyword const *DCFile::get_keyword(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCKeyword const *return_value = ((*(const DCFile*)local_this).get_keyword)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword(DCFile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_keyword_222_comment =
  "C++ Interface:\n"
  "get_keyword(DCFile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth keyword read from the .dc file(s).\n"
  " */";
#else
static const char *Dtool_DCFile_get_keyword_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCKeyword const *DCFile::get_keyword_by_name(std::string const &name) const
 */
static PyObject *Dtool_DCFile_get_keyword_by_name_223(PyObject *self, PyObject *arg) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-DCKeyword const *DCFile::get_keyword_by_name(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    DCKeyword const *return_value = ((*(const DCFile*)local_this).get_keyword_by_name)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCKeyword, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyword_by_name(DCFile self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_keyword_by_name_223_comment =
  "C++ Interface:\n"
  "get_keyword_by_name(DCFile self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the keyword that has the indicated name, or NULL if there is no\n"
  " * such keyword name.\n"
  " */";
#else
static const char *Dtool_DCFile_get_keyword_by_name_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned long int DCFile::get_hash(void) const
 */
static PyObject *Dtool_DCFile_get_hash_224(PyObject *self, PyObject *) {
  DCFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCFile)) {
    return nullptr;
  }
  // 1-unsigned long int DCFile::get_hash(void) const
  unsigned long int return_value = ((*(const DCFile*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCFile_get_hash_224_comment =
  "C++ Interface:\n"
  "get_hash(DCFile self)\n"
  "\n"
  "/**\n"
  " * Returns a 32-bit hash index associated with this file.  This number is\n"
  " * guaranteed to be consistent if the contents of the file have not changed,\n"
  " * and it is very likely to be different if the contents of the file do\n"
  " * change.\n"
  " */";
#else
static const char *Dtool_DCFile_get_hash_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCFile::DCFile(void)
 * inline DCFile::DCFile(DCFile const &) = default
 */
static int Dtool_Init_DCFile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DCFile() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-DCFile::DCFile(void)
      DCFile *return_value = new DCFile();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCFile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DCFile::DCFile(DCFile const &) = default
      DCFile const *arg_this = (DCFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DCFile, 0, "DCFile.DCFile", true, true);
      if (arg_this != nullptr) {
        DCFile *return_value = new DCFile(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DCFile, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DCFile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DCFile()\n"
      "DCFile(const DCFile param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DCFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCFile) {
    printf("DCFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCFile *local_this = (DCFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCFile) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCFile) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCKeyword
 */
/**
 * Python function wrapper for:
 * std::string const &DCKeyword::get_name(void) const
 */
static PyObject *Dtool_DCKeyword_get_name_226(PyObject *self, PyObject *) {
  DCKeyword *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCKeyword)) {
    return nullptr;
  }
  // 1-std::string const &DCKeyword::get_name(void) const
  std::string const &return_value = ((*(const DCKeyword*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCKeyword_get_name_226_comment =
  "C++ Interface:\n"
  "get_name(DCKeyword self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this keyword.\n"
  " */";
#else
static const char *Dtool_DCKeyword_get_name_226_comment = nullptr;
#endif

static int Dtool_Init_DCKeyword(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCKeyword(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCKeyword) {
    printf("DCKeyword ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCKeyword *local_this = (DCKeyword *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCKeyword) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCKeyword(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCKeyword) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCKeyword*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCMolecularField
 */
/**
 * Python function wrapper for:
 * int DCMolecularField::get_num_atomics(void) const
 */
static PyObject *Dtool_DCMolecularField_get_num_atomics_228(PyObject *self, PyObject *) {
  DCMolecularField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCMolecularField)) {
    return nullptr;
  }
  // 1-int DCMolecularField::get_num_atomics(void) const
  int return_value = ((*(const DCMolecularField*)local_this).get_num_atomics)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCMolecularField_get_num_atomics_228_comment =
  "C++ Interface:\n"
  "get_num_atomics(DCMolecularField self)\n"
  "\n"
  "/**\n"
  " * Returns the number of atomic fields that make up this molecular field.\n"
  " */";
#else
static const char *Dtool_DCMolecularField_get_num_atomics_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCAtomicField *DCMolecularField::get_atomic(int n) const
 */
static PyObject *Dtool_DCMolecularField_get_atomic_229(PyObject *self, PyObject *arg) {
  DCMolecularField *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCMolecularField)) {
    return nullptr;
  }
  // 1-DCAtomicField *DCMolecularField::get_atomic(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCAtomicField *return_value = ((*(const DCMolecularField*)local_this).get_atomic)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCAtomicField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_atomic(DCMolecularField self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCMolecularField_get_atomic_229_comment =
  "C++ Interface:\n"
  "get_atomic(DCMolecularField self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth atomic field that makes up this molecular field.  This may\n"
  " * or may not be a field of this particular class; it might be defined in a\n"
  " * parent class.\n"
  " */";
#else
static const char *Dtool_DCMolecularField_get_atomic_229_comment = nullptr;
#endif

static int Dtool_Init_DCMolecularField(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCMolecularField(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCMolecularField) {
    printf("DCMolecularField ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCMolecularField *local_this = (DCMolecularField *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCMolecularField) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCMolecularField(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCMolecularField) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCMolecularField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCMolecularField*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCMolecularField*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCSimpleParameter
 */
/**
 * Python function wrapper for:
 * DCSubatomicType DCSimpleParameter::get_type(void) const
 */
static PyObject *Dtool_DCSimpleParameter_get_type_232(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSimpleParameter)) {
    return nullptr;
  }
  // 1-DCSubatomicType DCSimpleParameter::get_type(void) const
  DCSubatomicType return_value = ((*(const DCSimpleParameter*)local_this).get_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_get_type_232_comment =
  "C++ Interface:\n"
  "get_type(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the particular subatomic type represented by this instance.\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_get_type_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCSimpleParameter::has_modulus(void) const
 */
static PyObject *Dtool_DCSimpleParameter_has_modulus_233(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSimpleParameter)) {
    return nullptr;
  }
  // 1-bool DCSimpleParameter::has_modulus(void) const
  bool return_value = ((*(const DCSimpleParameter*)local_this).has_modulus)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_has_modulus_233_comment =
  "C++ Interface:\n"
  "has_modulus(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a modulus associated, false otherwise.,\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_has_modulus_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double DCSimpleParameter::get_modulus(void) const
 */
static PyObject *Dtool_DCSimpleParameter_get_modulus_234(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSimpleParameter)) {
    return nullptr;
  }
  // 1-double DCSimpleParameter::get_modulus(void) const
  double return_value = ((*(const DCSimpleParameter*)local_this).get_modulus)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_get_modulus_234_comment =
  "C++ Interface:\n"
  "get_modulus(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the modulus associated with this type, if any.  It is an error to\n"
  " * call this if has_modulus() returned false.\n"
  " *\n"
  " * If present, this is the modulus that is used to constrain the numeric value\n"
  " * of the field before it is packed (and range-checked).\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_get_modulus_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCSimpleParameter::get_divisor(void) const
 */
static PyObject *Dtool_DCSimpleParameter_get_divisor_235(PyObject *self, PyObject *) {
  DCSimpleParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSimpleParameter)) {
    return nullptr;
  }
  // 1-int DCSimpleParameter::get_divisor(void) const
  int return_value = ((*(const DCSimpleParameter*)local_this).get_divisor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSimpleParameter_get_divisor_235_comment =
  "C++ Interface:\n"
  "get_divisor(DCSimpleParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the divisor associated with this type.  This is 1 by default, but\n"
  " * if this is other than one it represents the scale to apply when packing and\n"
  " * unpacking numeric values (to store fixed-point values in an integer field).\n"
  " * It is only meaningful for numeric-type fields.\n"
  " */";
#else
static const char *Dtool_DCSimpleParameter_get_divisor_235_comment = nullptr;
#endif

static int Dtool_Init_DCSimpleParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCSimpleParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCSimpleParameter) {
    printf("DCSimpleParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCSimpleParameter *local_this = (DCSimpleParameter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCSimpleParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCSimpleParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCSimpleParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCSimpleParameter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCSwitch
 */
/**
 * Python function wrapper for:
 * std::string const &DCSwitch::get_name(void) const
 */
static PyObject *Dtool_DCSwitch_get_name_238(PyObject *self, PyObject *) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-std::string const &DCSwitch::get_name(void) const
  std::string const &return_value = ((*(const DCSwitch*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_name_238_comment =
  "C++ Interface:\n"
  "get_name(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this switch.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_name_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCSwitch::get_key_parameter(void) const
 */
static PyObject *Dtool_DCSwitch_get_key_parameter_239(PyObject *self, PyObject *) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-DCField *DCSwitch::get_key_parameter(void) const
  DCField *return_value = ((*(const DCSwitch*)local_this).get_key_parameter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_key_parameter_239_comment =
  "C++ Interface:\n"
  "get_key_parameter(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the key parameter on which the switch is based.  The value of this\n"
  " * parameter in the record determines which one of the several cases within\n"
  " * the switch will be used.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_key_parameter_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCSwitch::get_num_cases(void) const
 */
static PyObject *Dtool_DCSwitch_get_num_cases_240(PyObject *self, PyObject *) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-int DCSwitch::get_num_cases(void) const
  int return_value = ((*(const DCSwitch*)local_this).get_num_cases)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_num_cases_240_comment =
  "C++ Interface:\n"
  "get_num_cases(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different cases within the switch.  The legal values\n"
  " * for case_index range from 0 to get_num_cases() - 1.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_num_cases_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCSwitch::get_case_by_value(vector_uchar const &case_value) const
 */
static PyObject *Dtool_DCSwitch_get_case_by_value_241(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-int DCSwitch::get_case_by_value(vector_uchar const &case_value) const
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    int return_value = ((*(const DCSwitch*)local_this).get_case_by_value)(vector_uchar(param1_str, param1_str + param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_case_by_value(DCSwitch self, bytes case_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_case_by_value_241_comment =
  "C++ Interface:\n"
  "get_case_by_value(DCSwitch self, bytes case_value)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the case with the indicated packed value, or -1\n"
  " * if no case has this value.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_case_by_value_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCPackerInterface *DCSwitch::get_case(int n) const
 */
static PyObject *Dtool_DCSwitch_get_case_242(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-DCPackerInterface *DCSwitch::get_case(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DCPackerInterface *return_value = ((*(const DCSwitch*)local_this).get_case)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_case(DCSwitch self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_case_242_comment =
  "C++ Interface:\n"
  "get_case(DCSwitch self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the DCPackerInterface that packs the nth case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_case_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCPackerInterface *DCSwitch::get_default_case(void) const
 */
static PyObject *Dtool_DCSwitch_get_default_case_243(PyObject *self, PyObject *) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-DCPackerInterface *DCSwitch::get_default_case(void) const
  DCPackerInterface *return_value = ((*(const DCSwitch*)local_this).get_default_case)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCPackerInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_default_case_243_comment =
  "C++ Interface:\n"
  "get_default_case(DCSwitch self)\n"
  "\n"
  "/**\n"
  " * Returns the DCPackerInterface that packs the default case, or NULL if there\n"
  " * is no default case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_default_case_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * vector_uchar DCSwitch::get_value(int case_index) const
 */
static PyObject *Dtool_DCSwitch_get_value_244(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-vector_uchar DCSwitch::get_value(int case_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    vector_uchar return_value = ((*(const DCSwitch*)local_this).get_value)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(DCSwitch self, int case_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_value_244_comment =
  "C++ Interface:\n"
  "get_value(DCSwitch self, int case_index)\n"
  "\n"
  "/**\n"
  " * Returns the packed value associated with the indicated case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_value_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DCSwitch::get_num_fields(int case_index) const
 */
static PyObject *Dtool_DCSwitch_get_num_fields_245(PyObject *self, PyObject *arg) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-int DCSwitch::get_num_fields(int case_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const DCSwitch*)local_this).get_num_fields)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_fields(DCSwitch self, int case_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_num_fields_245_comment =
  "C++ Interface:\n"
  "get_num_fields(DCSwitch self, int case_index)\n"
  "\n"
  "/**\n"
  " * Returns the number of fields in the indicated case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_num_fields_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCSwitch::get_field(int case_index, int n) const
 */
static PyObject *Dtool_DCSwitch_get_field_246(PyObject *self, PyObject *args, PyObject *kwds) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-DCField *DCSwitch::get_field(int case_index, int n) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"case_index", "n", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_field", (char **)keyword_list, &param1, &param2)) {
    DCField *return_value = ((*(const DCSwitch*)local_this).get_field)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field(DCSwitch self, int case_index, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_field_246_comment =
  "C++ Interface:\n"
  "get_field(DCSwitch self, int case_index, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth field in the indicated case.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_field_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DCField *DCSwitch::get_field_by_name(int case_index, std::string const &name) const
 */
static PyObject *Dtool_DCSwitch_get_field_by_name_247(PyObject *self, PyObject *args, PyObject *kwds) {
  DCSwitch *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitch)) {
    return nullptr;
  }
  // 1-DCField *DCSwitch::get_field_by_name(int case_index, std::string const &name) const
  int param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"case_index", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "is#:get_field_by_name", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    DCField *return_value = ((*(const DCSwitch*)local_this).get_field_by_name)((int)param1, std::string(param2_str, param2_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCField, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_field_by_name(DCSwitch self, int case_index, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DCSwitch_get_field_by_name_247_comment =
  "C++ Interface:\n"
  "get_field_by_name(DCSwitch self, int case_index, str name)\n"
  "\n"
  "/**\n"
  " * Returns the field with the given name from the indicated case, or NULL if\n"
  " * no field has this name.\n"
  " */";
#else
static const char *Dtool_DCSwitch_get_field_by_name_247_comment = nullptr;
#endif

static int Dtool_Init_DCSwitch(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCSwitch(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCSwitch) {
    printf("DCSwitch ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCSwitch *local_this = (DCSwitch *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCSwitch) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCSwitch(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCSwitch) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCSwitch*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCSwitchParameter
 */
/**
 * Python function wrapper for:
 * DCSwitch const *DCSwitchParameter::get_switch(void) const
 */
static PyObject *Dtool_DCSwitchParameter_get_switch_249(PyObject *self, PyObject *) {
  DCSwitchParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCSwitchParameter)) {
    return nullptr;
  }
  // 1-DCSwitch const *DCSwitchParameter::get_switch(void) const
  DCSwitch const *return_value = ((*(const DCSwitchParameter*)local_this).get_switch)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCSwitch, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DCSwitchParameter_get_switch_249_comment =
  "C++ Interface:\n"
  "get_switch(DCSwitchParameter self)\n"
  "\n"
  "/**\n"
  " * Returns the switch object this parameter represents.\n"
  " */";
#else
static const char *Dtool_DCSwitchParameter_get_switch_249_comment = nullptr;
#endif

static int Dtool_Init_DCSwitchParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCSwitchParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCSwitchParameter) {
    printf("DCSwitchParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCSwitchParameter *local_this = (DCSwitchParameter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCSwitchParameter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCField) {
    return (DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCKeywordList) {
    return (DCKeywordList *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCPackerInterface) {
    return (DCPackerInterface *)(DCField *)(DCParameter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DCParameter) {
    return (DCParameter *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCSwitchParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCSwitchParameter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCField) {
    DCField* other_this = (DCField*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCKeywordList) {
    DCKeywordList* other_this = (DCKeywordList*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCPackerInterface) {
    DCPackerInterface* other_this = (DCPackerInterface*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  if (from_type == Dtool_Ptr_DCParameter) {
    DCParameter* other_this = (DCParameter*)from_this;
    return (DCSwitchParameter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DCTypedef
 */
/**
 * Python function wrapper for:
 * int DCTypedef::get_number(void) const
 */
static PyObject *Dtool_DCTypedef_get_number_252(PyObject *self, PyObject *) {
  DCTypedef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCTypedef)) {
    return nullptr;
  }
  // 1-int DCTypedef::get_number(void) const
  int return_value = ((*(const DCTypedef*)local_this).get_number)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_get_number_252_comment =
  "C++ Interface:\n"
  "get_number(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns a unique index number associated with this typedef definition.\n"
  " * This is defined implicitly when the .dc file(s) are read.\n"
  " */";
#else
static const char *Dtool_DCTypedef_get_number_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &DCTypedef::get_name(void) const
 */
static PyObject *Dtool_DCTypedef_get_name_253(PyObject *self, PyObject *) {
  DCTypedef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCTypedef)) {
    return nullptr;
  }
  // 1-std::string const &DCTypedef::get_name(void) const
  std::string const &return_value = ((*(const DCTypedef*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_get_name_253_comment =
  "C++ Interface:\n"
  "get_name(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns the name of this typedef.\n"
  " */";
#else
static const char *Dtool_DCTypedef_get_name_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DCTypedef::get_description(void) const
 */
static PyObject *Dtool_DCTypedef_get_description_254(PyObject *self, PyObject *) {
  DCTypedef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCTypedef)) {
    return nullptr;
  }
  // 1-std::string DCTypedef::get_description(void) const
  std::string return_value = ((*(const DCTypedef*)local_this).get_description)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_get_description_254_comment =
  "C++ Interface:\n"
  "get_description(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns a brief decription of the typedef, useful for human consumption.\n"
  " */";
#else
static const char *Dtool_DCTypedef_get_description_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCTypedef::is_bogus_typedef(void) const
 */
static PyObject *Dtool_DCTypedef_is_bogus_typedef_255(PyObject *self, PyObject *) {
  DCTypedef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCTypedef)) {
    return nullptr;
  }
  // 1-bool DCTypedef::is_bogus_typedef(void) const
  bool return_value = ((*(const DCTypedef*)local_this).is_bogus_typedef)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_is_bogus_typedef_255_comment =
  "C++ Interface:\n"
  "is_bogus_typedef(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns true if the typedef has been flagged as a bogus typedef.  This is\n"
  " * set for typedefs that are generated by the parser as placeholder for\n"
  " * missing typedefs, as when reading a partial file; it should not occur in a\n"
  " * normal valid dc file.\n"
  " */";
#else
static const char *Dtool_DCTypedef_is_bogus_typedef_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DCTypedef::is_implicit_typedef(void) const
 */
static PyObject *Dtool_DCTypedef_is_implicit_typedef_256(PyObject *self, PyObject *) {
  DCTypedef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DCTypedef)) {
    return nullptr;
  }
  // 1-bool DCTypedef::is_implicit_typedef(void) const
  bool return_value = ((*(const DCTypedef*)local_this).is_implicit_typedef)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DCTypedef_is_implicit_typedef_256_comment =
  "C++ Interface:\n"
  "is_implicit_typedef(DCTypedef self)\n"
  "\n"
  "/**\n"
  " * Returns true if the typedef has been flagged as an implicit typedef,\n"
  " * meaning it was created for a DCClass that was referenced inline as a type.\n"
  " */";
#else
static const char *Dtool_DCTypedef_is_implicit_typedef_256_comment = nullptr;
#endif

static int Dtool_Init_DCTypedef(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DCTypedef(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DCTypedef) {
    printf("DCTypedef ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DCTypedef *local_this = (DCTypedef *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DCTypedef) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DCDeclaration) {
    return (DCDeclaration *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DCTypedef(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DCTypedef) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DCDeclaration) {
    DCDeclaration* other_this = (DCDeclaration*)from_this;
    return (DCTypedef*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for DCPackerInterface (DCPackerInterface)
 */
static PyMethodDef Dtool_Methods_DCPackerInterface[] = {
  {"get_name", &Dtool_DCPackerInterface_get_name_5, METH_NOARGS, (const char *)Dtool_DCPackerInterface_get_name_5_comment},
  {"getName", &Dtool_DCPackerInterface_get_name_5, METH_NOARGS, (const char *)Dtool_DCPackerInterface_get_name_5_comment},
  {"find_seek_index", &Dtool_DCPackerInterface_find_seek_index_6, METH_O, (const char *)Dtool_DCPackerInterface_find_seek_index_6_comment},
  {"findSeekIndex", &Dtool_DCPackerInterface_find_seek_index_6, METH_O, (const char *)Dtool_DCPackerInterface_find_seek_index_6_comment},
  {"as_field", &Dtool_DCPackerInterface_as_field_7, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_field_7_comment},
  {"asField", &Dtool_DCPackerInterface_as_field_7, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_field_7_comment},
  {"as_switch_parameter", &Dtool_DCPackerInterface_as_switch_parameter_8, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_switch_parameter_8_comment},
  {"asSwitchParameter", &Dtool_DCPackerInterface_as_switch_parameter_8, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_switch_parameter_8_comment},
  {"as_class_parameter", &Dtool_DCPackerInterface_as_class_parameter_9, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_class_parameter_9_comment},
  {"asClassParameter", &Dtool_DCPackerInterface_as_class_parameter_9, METH_NOARGS, (const char *)Dtool_DCPackerInterface_as_class_parameter_9_comment},
  {"check_match", (PyCFunction) &Dtool_DCPackerInterface_check_match_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPackerInterface_check_match_10_comment},
  {"checkMatch", (PyCFunction) &Dtool_DCPackerInterface_check_match_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPackerInterface_check_match_10_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCPackerInterface = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DCPackerInterface = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCPackerInterface",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCPackerInterface,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCPackerInterface,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines the internal interface for packing values into a DCField.  The\n"
    " * various different DC objects inherit from this.\n"
    " *\n"
    " * Normally these methods are called only by the DCPacker object; the user\n"
    " * wouldn't normally call these directly.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCPackerInterface,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCPackerInterface,
    PyType_GenericAlloc,
    Dtool_new_DCPackerInterface,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCPackerInterface,
  Dtool_UpcastInterface_DCPackerInterface,
  Dtool_DowncastInterface_DCPackerInterface,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCPackerInterface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCPackerInterface._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCPackerInterface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCPackerInterface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCPackerInterface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCPackerInterface);
  }
}

/**
 * Python method tables for DCKeywordList (DCKeywordList)
 */
static PyMethodDef Dtool_Methods_DCKeywordList[] = {
  {"has_keyword", &Dtool_DCKeywordList_has_keyword_13, METH_O, (const char *)Dtool_DCKeywordList_has_keyword_13_comment},
  {"hasKeyword", &Dtool_DCKeywordList_has_keyword_13, METH_O, (const char *)Dtool_DCKeywordList_has_keyword_13_comment},
  {"get_num_keywords", &Dtool_DCKeywordList_get_num_keywords_14, METH_NOARGS, (const char *)Dtool_DCKeywordList_get_num_keywords_14_comment},
  {"getNumKeywords", &Dtool_DCKeywordList_get_num_keywords_14, METH_NOARGS, (const char *)Dtool_DCKeywordList_get_num_keywords_14_comment},
  {"get_keyword", &Dtool_DCKeywordList_get_keyword_15, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_15_comment},
  {"getKeyword", &Dtool_DCKeywordList_get_keyword_15, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_15_comment},
  {"get_keyword_by_name", &Dtool_DCKeywordList_get_keyword_by_name_16, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_by_name_16_comment},
  {"getKeywordByName", &Dtool_DCKeywordList_get_keyword_by_name_16, METH_O, (const char *)Dtool_DCKeywordList_get_keyword_by_name_16_comment},
  {"compare_keywords", &Dtool_DCKeywordList_compare_keywords_17, METH_O, (const char *)Dtool_DCKeywordList_compare_keywords_17_comment},
  {"compareKeywords", &Dtool_DCKeywordList_compare_keywords_17, METH_O, (const char *)Dtool_DCKeywordList_compare_keywords_17_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCKeywordList = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DCKeywordList = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCKeywordList",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCKeywordList,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCKeywordList,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a list of keywords (see DCKeyword) that may be set on a particular\n"
    " * field.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCKeywordList,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCKeywordList,
    PyType_GenericAlloc,
    Dtool_new_DCKeywordList,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCKeywordList,
  Dtool_UpcastInterface_DCKeywordList,
  Dtool_DowncastInterface_DCKeywordList,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCKeywordList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCKeywordList._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCKeywordList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCKeywordList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCKeywordList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCKeywordList);
  }
}

/**
 * Python method tables for DCField (DCField)
 */
static PyMethodDef Dtool_Methods_DCField[] = {
  {"get_number", &Dtool_DCField_get_number_24, METH_NOARGS, (const char *)Dtool_DCField_get_number_24_comment},
  {"getNumber", &Dtool_DCField_get_number_24, METH_NOARGS, (const char *)Dtool_DCField_get_number_24_comment},
  {"get_class", &Dtool_DCField_get_class_25, METH_NOARGS, (const char *)Dtool_DCField_get_class_25_comment},
  {"getClass", &Dtool_DCField_get_class_25, METH_NOARGS, (const char *)Dtool_DCField_get_class_25_comment},
  {"as_field", &Dtool_DCField_as_field_26, METH_NOARGS, (const char *)Dtool_DCField_as_field_26_comment},
  {"asField", &Dtool_DCField_as_field_26, METH_NOARGS, (const char *)Dtool_DCField_as_field_26_comment},
  {"as_atomic_field", &Dtool_DCField_as_atomic_field_27, METH_NOARGS, (const char *)Dtool_DCField_as_atomic_field_27_comment},
  {"asAtomicField", &Dtool_DCField_as_atomic_field_27, METH_NOARGS, (const char *)Dtool_DCField_as_atomic_field_27_comment},
  {"as_molecular_field", &Dtool_DCField_as_molecular_field_28, METH_NOARGS, (const char *)Dtool_DCField_as_molecular_field_28_comment},
  {"asMolecularField", &Dtool_DCField_as_molecular_field_28, METH_NOARGS, (const char *)Dtool_DCField_as_molecular_field_28_comment},
  {"as_parameter", &Dtool_DCField_as_parameter_29, METH_NOARGS, (const char *)Dtool_DCField_as_parameter_29_comment},
  {"asParameter", &Dtool_DCField_as_parameter_29, METH_NOARGS, (const char *)Dtool_DCField_as_parameter_29_comment},
  {"format_data", (PyCFunction) &Dtool_DCField_format_data_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_format_data_30_comment},
  {"formatData", (PyCFunction) &Dtool_DCField_format_data_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_format_data_30_comment},
  {"parse_string", &Dtool_DCField_parse_string_31, METH_O, (const char *)Dtool_DCField_parse_string_31_comment},
  {"parseString", &Dtool_DCField_parse_string_31, METH_O, (const char *)Dtool_DCField_parse_string_31_comment},
  {"validate_ranges", &Dtool_DCField_validate_ranges_32, METH_O, (const char *)Dtool_DCField_validate_ranges_32_comment},
  {"validateRanges", &Dtool_DCField_validate_ranges_32, METH_O, (const char *)Dtool_DCField_validate_ranges_32_comment},
  {"has_default_value", &Dtool_DCField_has_default_value_33, METH_NOARGS, (const char *)Dtool_DCField_has_default_value_33_comment},
  {"hasDefaultValue", &Dtool_DCField_has_default_value_33, METH_NOARGS, (const char *)Dtool_DCField_has_default_value_33_comment},
  {"get_default_value", &Dtool_DCField_get_default_value_34, METH_NOARGS, (const char *)Dtool_DCField_get_default_value_34_comment},
  {"getDefaultValue", &Dtool_DCField_get_default_value_34, METH_NOARGS, (const char *)Dtool_DCField_get_default_value_34_comment},
  {"is_bogus_field", &Dtool_DCField_is_bogus_field_35, METH_NOARGS, (const char *)Dtool_DCField_is_bogus_field_35_comment},
  {"isBogusField", &Dtool_DCField_is_bogus_field_35, METH_NOARGS, (const char *)Dtool_DCField_is_bogus_field_35_comment},
  {"is_required", &Dtool_DCField_is_required_36, METH_NOARGS, (const char *)Dtool_DCField_is_required_36_comment},
  {"isRequired", &Dtool_DCField_is_required_36, METH_NOARGS, (const char *)Dtool_DCField_is_required_36_comment},
  {"is_broadcast", &Dtool_DCField_is_broadcast_37, METH_NOARGS, (const char *)Dtool_DCField_is_broadcast_37_comment},
  {"isBroadcast", &Dtool_DCField_is_broadcast_37, METH_NOARGS, (const char *)Dtool_DCField_is_broadcast_37_comment},
  {"is_ram", &Dtool_DCField_is_ram_38, METH_NOARGS, (const char *)Dtool_DCField_is_ram_38_comment},
  {"isRam", &Dtool_DCField_is_ram_38, METH_NOARGS, (const char *)Dtool_DCField_is_ram_38_comment},
  {"is_db", &Dtool_DCField_is_db_39, METH_NOARGS, (const char *)Dtool_DCField_is_db_39_comment},
  {"isDb", &Dtool_DCField_is_db_39, METH_NOARGS, (const char *)Dtool_DCField_is_db_39_comment},
  {"is_clsend", &Dtool_DCField_is_clsend_40, METH_NOARGS, (const char *)Dtool_DCField_is_clsend_40_comment},
  {"isClsend", &Dtool_DCField_is_clsend_40, METH_NOARGS, (const char *)Dtool_DCField_is_clsend_40_comment},
  {"is_clrecv", &Dtool_DCField_is_clrecv_41, METH_NOARGS, (const char *)Dtool_DCField_is_clrecv_41_comment},
  {"isClrecv", &Dtool_DCField_is_clrecv_41, METH_NOARGS, (const char *)Dtool_DCField_is_clrecv_41_comment},
  {"is_ownsend", &Dtool_DCField_is_ownsend_42, METH_NOARGS, (const char *)Dtool_DCField_is_ownsend_42_comment},
  {"isOwnsend", &Dtool_DCField_is_ownsend_42, METH_NOARGS, (const char *)Dtool_DCField_is_ownsend_42_comment},
  {"is_ownrecv", &Dtool_DCField_is_ownrecv_43, METH_NOARGS, (const char *)Dtool_DCField_is_ownrecv_43_comment},
  {"isOwnrecv", &Dtool_DCField_is_ownrecv_43, METH_NOARGS, (const char *)Dtool_DCField_is_ownrecv_43_comment},
  {"is_airecv", &Dtool_DCField_is_airecv_44, METH_NOARGS, (const char *)Dtool_DCField_is_airecv_44_comment},
  {"isAirecv", &Dtool_DCField_is_airecv_44, METH_NOARGS, (const char *)Dtool_DCField_is_airecv_44_comment},
  {"output", &Dtool_DCField_output_45, METH_O, (const char *)Dtool_DCField_output_45_comment},
  {"write", (PyCFunction) &Dtool_DCField_write_46, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_write_46_comment},
  {"pack_args", (PyCFunction) &Dtool_DCField_pack_args_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_pack_args_47_comment},
  {"packArgs", (PyCFunction) &Dtool_DCField_pack_args_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_pack_args_47_comment},
  {"unpack_args", &Dtool_DCField_unpack_args_48, METH_O, (const char *)Dtool_DCField_unpack_args_48_comment},
  {"unpackArgs", &Dtool_DCField_unpack_args_48, METH_O, (const char *)Dtool_DCField_unpack_args_48_comment},
  {"receive_update", (PyCFunction) &Dtool_DCField_receive_update_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_receive_update_49_comment},
  {"receiveUpdate", (PyCFunction) &Dtool_DCField_receive_update_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_receive_update_49_comment},
  {"client_format_update", (PyCFunction) &Dtool_DCField_client_format_update_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_client_format_update_50_comment},
  {"clientFormatUpdate", (PyCFunction) &Dtool_DCField_client_format_update_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_client_format_update_50_comment},
  {"ai_format_update", (PyCFunction) &Dtool_DCField_ai_format_update_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_51_comment},
  {"aiFormatUpdate", (PyCFunction) &Dtool_DCField_ai_format_update_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_51_comment},
  {"ai_format_update_msg_type", (PyCFunction) &Dtool_DCField_ai_format_update_msg_type_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_msg_type_52_comment},
  {"aiFormatUpdateMsgType", (PyCFunction) &Dtool_DCField_ai_format_update_msg_type_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCField_ai_format_update_msg_type_52_comment},
  {"upcast_to_DCPackerInterface", &Dtool_DCField_upcast_to_DCPackerInterface_19, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCPackerInterface_19_comment},
  {"upcastToDCPackerInterface", &Dtool_DCField_upcast_to_DCPackerInterface_19, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCPackerInterface_19_comment},
  {"upcast_to_DCKeywordList", &Dtool_DCField_upcast_to_DCKeywordList_21, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCKeywordList_21_comment},
  {"upcastToDCKeywordList", &Dtool_DCField_upcast_to_DCKeywordList_21, METH_NOARGS, (const char *)Dtool_DCField_upcast_to_DCKeywordList_21_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     DCField
//////////////////
static PyObject *Dtool_Repr_DCField(PyObject *self) {
  DCField *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DCField
//////////////////
static PyObject *Dtool_Str_DCField(PyObject *self) {
  DCField *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCField, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DCField = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCField = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCField = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCField = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCField = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCField = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCField",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCField,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCField,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_DCField,
    &Dtool_NumberMethods_DCField,
    &Dtool_SequenceMethods_DCField,
    &Dtool_MappingMethods_DCField,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_DCField,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCField,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single field of a Distributed Class, either atomic or molecular.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCField,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCField,
    PyType_GenericAlloc,
    Dtool_new_DCField,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCField,
  Dtool_UpcastInterface_DCField,
  Dtool_DowncastInterface_DCField,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCField(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCPackerInterface(nullptr);
    Dtool_PyModuleClassInit_DCKeywordList(nullptr);
    Dtool_DCField._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_DCPackerInterface, (PyTypeObject *)&Dtool_DCKeywordList);
    Dtool_DCField._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCField._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCField) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCField)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCField);
  }
}

/**
 * Python method tables for DCPackData (DCPackData)
 */
static PyMethodDef Dtool_Methods_DCPackData[] = {
  {"clear", &Dtool_DCPackData_clear_56, METH_NOARGS, (const char *)Dtool_DCPackData_clear_56_comment},
  {"get_string", &Dtool_DCPackData_get_string_57, METH_NOARGS, (const char *)Dtool_DCPackData_get_string_57_comment},
  {"getString", &Dtool_DCPackData_get_string_57, METH_NOARGS, (const char *)Dtool_DCPackData_get_string_57_comment},
  {"get_length", &Dtool_DCPackData_get_length_58, METH_NOARGS, (const char *)Dtool_DCPackData_get_length_58_comment},
  {"getLength", &Dtool_DCPackData_get_length_58, METH_NOARGS, (const char *)Dtool_DCPackData_get_length_58_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCPackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DCPackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCPackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCPackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCPackData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a block of data that receives the results of DCPacker.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCPackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCPackData,
    PyType_GenericAlloc,
    Dtool_new_DCPackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCPackData,
  Dtool_UpcastInterface_DCPackData,
  Dtool_DowncastInterface_DCPackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCPackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCPackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCPackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCPackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCPackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCPackData);
  }
}

/**
 * Python method tables for DCPacker (DCPacker)
 */
static PyMethodDef Dtool_Methods_DCPacker[] = {
  {"clear_data", &Dtool_DCPacker_clear_data_62, METH_NOARGS, (const char *)Dtool_DCPacker_clear_data_62_comment},
  {"clearData", &Dtool_DCPacker_clear_data_62, METH_NOARGS, (const char *)Dtool_DCPacker_clear_data_62_comment},
  {"begin_pack", &Dtool_DCPacker_begin_pack_63, METH_O, (const char *)Dtool_DCPacker_begin_pack_63_comment},
  {"beginPack", &Dtool_DCPacker_begin_pack_63, METH_O, (const char *)Dtool_DCPacker_begin_pack_63_comment},
  {"end_pack", &Dtool_DCPacker_end_pack_64, METH_NOARGS, (const char *)Dtool_DCPacker_end_pack_64_comment},
  {"endPack", &Dtool_DCPacker_end_pack_64, METH_NOARGS, (const char *)Dtool_DCPacker_end_pack_64_comment},
  {"set_unpack_data", &Dtool_DCPacker_set_unpack_data_65, METH_O, (const char *)Dtool_DCPacker_set_unpack_data_65_comment},
  {"setUnpackData", &Dtool_DCPacker_set_unpack_data_65, METH_O, (const char *)Dtool_DCPacker_set_unpack_data_65_comment},
  {"begin_unpack", &Dtool_DCPacker_begin_unpack_66, METH_O, (const char *)Dtool_DCPacker_begin_unpack_66_comment},
  {"beginUnpack", &Dtool_DCPacker_begin_unpack_66, METH_O, (const char *)Dtool_DCPacker_begin_unpack_66_comment},
  {"end_unpack", &Dtool_DCPacker_end_unpack_67, METH_NOARGS, (const char *)Dtool_DCPacker_end_unpack_67_comment},
  {"endUnpack", &Dtool_DCPacker_end_unpack_67, METH_NOARGS, (const char *)Dtool_DCPacker_end_unpack_67_comment},
  {"begin_repack", &Dtool_DCPacker_begin_repack_68, METH_O, (const char *)Dtool_DCPacker_begin_repack_68_comment},
  {"beginRepack", &Dtool_DCPacker_begin_repack_68, METH_O, (const char *)Dtool_DCPacker_begin_repack_68_comment},
  {"end_repack", &Dtool_DCPacker_end_repack_69, METH_NOARGS, (const char *)Dtool_DCPacker_end_repack_69_comment},
  {"endRepack", &Dtool_DCPacker_end_repack_69, METH_NOARGS, (const char *)Dtool_DCPacker_end_repack_69_comment},
  {"seek", &Dtool_DCPacker_seek_70, METH_O, (const char *)Dtool_DCPacker_seek_70_comment},
  {"has_nested_fields", &Dtool_DCPacker_has_nested_fields_71, METH_NOARGS, (const char *)Dtool_DCPacker_has_nested_fields_71_comment},
  {"hasNestedFields", &Dtool_DCPacker_has_nested_fields_71, METH_NOARGS, (const char *)Dtool_DCPacker_has_nested_fields_71_comment},
  {"get_num_nested_fields", &Dtool_DCPacker_get_num_nested_fields_72, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_nested_fields_72_comment},
  {"getNumNestedFields", &Dtool_DCPacker_get_num_nested_fields_72, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_nested_fields_72_comment},
  {"more_nested_fields", &Dtool_DCPacker_more_nested_fields_73, METH_NOARGS, (const char *)Dtool_DCPacker_more_nested_fields_73_comment},
  {"moreNestedFields", &Dtool_DCPacker_more_nested_fields_73, METH_NOARGS, (const char *)Dtool_DCPacker_more_nested_fields_73_comment},
  {"get_current_parent", &Dtool_DCPacker_get_current_parent_74, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_parent_74_comment},
  {"getCurrentParent", &Dtool_DCPacker_get_current_parent_74, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_parent_74_comment},
  {"get_current_field", &Dtool_DCPacker_get_current_field_75, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_75_comment},
  {"getCurrentField", &Dtool_DCPacker_get_current_field_75, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_75_comment},
  {"get_last_switch", &Dtool_DCPacker_get_last_switch_76, METH_NOARGS, (const char *)Dtool_DCPacker_get_last_switch_76_comment},
  {"getLastSwitch", &Dtool_DCPacker_get_last_switch_76, METH_NOARGS, (const char *)Dtool_DCPacker_get_last_switch_76_comment},
  {"get_pack_type", &Dtool_DCPacker_get_pack_type_77, METH_NOARGS, (const char *)Dtool_DCPacker_get_pack_type_77_comment},
  {"getPackType", &Dtool_DCPacker_get_pack_type_77, METH_NOARGS, (const char *)Dtool_DCPacker_get_pack_type_77_comment},
  {"get_current_field_name", &Dtool_DCPacker_get_current_field_name_78, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_name_78_comment},
  {"getCurrentFieldName", &Dtool_DCPacker_get_current_field_name_78, METH_NOARGS, (const char *)Dtool_DCPacker_get_current_field_name_78_comment},
  {"push", &Dtool_DCPacker_push_79, METH_NOARGS, (const char *)Dtool_DCPacker_push_79_comment},
  {"pop", &Dtool_DCPacker_pop_80, METH_NOARGS, (const char *)Dtool_DCPacker_pop_80_comment},
  {"pack_double", &Dtool_DCPacker_pack_double_81, METH_O, (const char *)Dtool_DCPacker_pack_double_81_comment},
  {"packDouble", &Dtool_DCPacker_pack_double_81, METH_O, (const char *)Dtool_DCPacker_pack_double_81_comment},
  {"pack_int", &Dtool_DCPacker_pack_int_82, METH_O, (const char *)Dtool_DCPacker_pack_int_82_comment},
  {"packInt", &Dtool_DCPacker_pack_int_82, METH_O, (const char *)Dtool_DCPacker_pack_int_82_comment},
  {"pack_uint", &Dtool_DCPacker_pack_uint_83, METH_O, (const char *)Dtool_DCPacker_pack_uint_83_comment},
  {"packUint", &Dtool_DCPacker_pack_uint_83, METH_O, (const char *)Dtool_DCPacker_pack_uint_83_comment},
  {"pack_int64", &Dtool_DCPacker_pack_int64_84, METH_O, (const char *)Dtool_DCPacker_pack_int64_84_comment},
  {"packInt64", &Dtool_DCPacker_pack_int64_84, METH_O, (const char *)Dtool_DCPacker_pack_int64_84_comment},
  {"pack_uint64", &Dtool_DCPacker_pack_uint64_85, METH_O, (const char *)Dtool_DCPacker_pack_uint64_85_comment},
  {"packUint64", &Dtool_DCPacker_pack_uint64_85, METH_O, (const char *)Dtool_DCPacker_pack_uint64_85_comment},
  {"pack_string", &Dtool_DCPacker_pack_string_86, METH_O, (const char *)Dtool_DCPacker_pack_string_86_comment},
  {"packString", &Dtool_DCPacker_pack_string_86, METH_O, (const char *)Dtool_DCPacker_pack_string_86_comment},
  {"pack_blob", &Dtool_DCPacker_pack_blob_87, METH_O, (const char *)Dtool_DCPacker_pack_blob_87_comment},
  {"packBlob", &Dtool_DCPacker_pack_blob_87, METH_O, (const char *)Dtool_DCPacker_pack_blob_87_comment},
  {"pack_literal_value", &Dtool_DCPacker_pack_literal_value_88, METH_O, (const char *)Dtool_DCPacker_pack_literal_value_88_comment},
  {"packLiteralValue", &Dtool_DCPacker_pack_literal_value_88, METH_O, (const char *)Dtool_DCPacker_pack_literal_value_88_comment},
  {"pack_default_value", &Dtool_DCPacker_pack_default_value_89, METH_NOARGS, (const char *)Dtool_DCPacker_pack_default_value_89_comment},
  {"packDefaultValue", &Dtool_DCPacker_pack_default_value_89, METH_NOARGS, (const char *)Dtool_DCPacker_pack_default_value_89_comment},
  {"unpack_double", &Dtool_DCPacker_unpack_double_90, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_double_90_comment},
  {"unpackDouble", &Dtool_DCPacker_unpack_double_90, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_double_90_comment},
  {"unpack_int", &Dtool_DCPacker_unpack_int_91, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int_91_comment},
  {"unpackInt", &Dtool_DCPacker_unpack_int_91, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int_91_comment},
  {"unpack_uint", &Dtool_DCPacker_unpack_uint_92, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint_92_comment},
  {"unpackUint", &Dtool_DCPacker_unpack_uint_92, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint_92_comment},
  {"unpack_int64", &Dtool_DCPacker_unpack_int64_93, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int64_93_comment},
  {"unpackInt64", &Dtool_DCPacker_unpack_int64_93, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_int64_93_comment},
  {"unpack_uint64", &Dtool_DCPacker_unpack_uint64_94, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint64_94_comment},
  {"unpackUint64", &Dtool_DCPacker_unpack_uint64_94, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_uint64_94_comment},
  {"unpack_string", &Dtool_DCPacker_unpack_string_95, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_string_95_comment},
  {"unpackString", &Dtool_DCPacker_unpack_string_95, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_string_95_comment},
  {"unpack_blob", &Dtool_DCPacker_unpack_blob_96, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_blob_96_comment},
  {"unpackBlob", &Dtool_DCPacker_unpack_blob_96, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_blob_96_comment},
  {"unpack_literal_value", &Dtool_DCPacker_unpack_literal_value_97, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_literal_value_97_comment},
  {"unpackLiteralValue", &Dtool_DCPacker_unpack_literal_value_97, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_literal_value_97_comment},
  {"unpack_validate", &Dtool_DCPacker_unpack_validate_98, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_validate_98_comment},
  {"unpackValidate", &Dtool_DCPacker_unpack_validate_98, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_validate_98_comment},
  {"unpack_skip", &Dtool_DCPacker_unpack_skip_99, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_skip_99_comment},
  {"unpackSkip", &Dtool_DCPacker_unpack_skip_99, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_skip_99_comment},
  {"pack_object", &Dtool_DCPacker_pack_object_100, METH_O, (const char *)Dtool_DCPacker_pack_object_100_comment},
  {"packObject", &Dtool_DCPacker_pack_object_100, METH_O, (const char *)Dtool_DCPacker_pack_object_100_comment},
  {"unpack_object", &Dtool_DCPacker_unpack_object_101, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_object_101_comment},
  {"unpackObject", &Dtool_DCPacker_unpack_object_101, METH_NOARGS, (const char *)Dtool_DCPacker_unpack_object_101_comment},
  {"parse_and_pack", &Dtool_DCPacker_parse_and_pack_102, METH_O, (const char *)Dtool_DCPacker_parse_and_pack_102_comment},
  {"parseAndPack", &Dtool_DCPacker_parse_and_pack_102, METH_O, (const char *)Dtool_DCPacker_parse_and_pack_102_comment},
  {"unpack_and_format", (PyCFunction) &Dtool_DCPacker_unpack_and_format_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPacker_unpack_and_format_103_comment},
  {"unpackAndFormat", (PyCFunction) &Dtool_DCPacker_unpack_and_format_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCPacker_unpack_and_format_103_comment},
  {"had_parse_error", &Dtool_DCPacker_had_parse_error_104, METH_NOARGS, (const char *)Dtool_DCPacker_had_parse_error_104_comment},
  {"hadParseError", &Dtool_DCPacker_had_parse_error_104, METH_NOARGS, (const char *)Dtool_DCPacker_had_parse_error_104_comment},
  {"had_pack_error", &Dtool_DCPacker_had_pack_error_105, METH_NOARGS, (const char *)Dtool_DCPacker_had_pack_error_105_comment},
  {"hadPackError", &Dtool_DCPacker_had_pack_error_105, METH_NOARGS, (const char *)Dtool_DCPacker_had_pack_error_105_comment},
  {"had_range_error", &Dtool_DCPacker_had_range_error_106, METH_NOARGS, (const char *)Dtool_DCPacker_had_range_error_106_comment},
  {"hadRangeError", &Dtool_DCPacker_had_range_error_106, METH_NOARGS, (const char *)Dtool_DCPacker_had_range_error_106_comment},
  {"had_error", &Dtool_DCPacker_had_error_107, METH_NOARGS, (const char *)Dtool_DCPacker_had_error_107_comment},
  {"hadError", &Dtool_DCPacker_had_error_107, METH_NOARGS, (const char *)Dtool_DCPacker_had_error_107_comment},
  {"get_num_unpacked_bytes", &Dtool_DCPacker_get_num_unpacked_bytes_108, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_unpacked_bytes_108_comment},
  {"getNumUnpackedBytes", &Dtool_DCPacker_get_num_unpacked_bytes_108, METH_NOARGS, (const char *)Dtool_DCPacker_get_num_unpacked_bytes_108_comment},
  {"get_length", &Dtool_DCPacker_get_length_109, METH_NOARGS, (const char *)Dtool_DCPacker_get_length_109_comment},
  {"getLength", &Dtool_DCPacker_get_length_109, METH_NOARGS, (const char *)Dtool_DCPacker_get_length_109_comment},
  {"get_string", &Dtool_DCPacker_get_string_110, METH_NOARGS, (const char *)Dtool_DCPacker_get_string_110_comment},
  {"getString", &Dtool_DCPacker_get_string_110, METH_NOARGS, (const char *)Dtool_DCPacker_get_string_110_comment},
  {"get_bytes", &Dtool_DCPacker_get_bytes_111, METH_NOARGS, (const char *)Dtool_DCPacker_get_bytes_111_comment},
  {"getBytes", &Dtool_DCPacker_get_bytes_111, METH_NOARGS, (const char *)Dtool_DCPacker_get_bytes_111_comment},
  {"get_unpack_length", &Dtool_DCPacker_get_unpack_length_112, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_length_112_comment},
  {"getUnpackLength", &Dtool_DCPacker_get_unpack_length_112, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_length_112_comment},
  {"get_unpack_string", &Dtool_DCPacker_get_unpack_string_113, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_string_113_comment},
  {"getUnpackString", &Dtool_DCPacker_get_unpack_string_113, METH_NOARGS, (const char *)Dtool_DCPacker_get_unpack_string_113_comment},
  {"get_num_stack_elements_ever_allocated", &Dtool_DCPacker_get_num_stack_elements_ever_allocated_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_DCPacker_get_num_stack_elements_ever_allocated_114_comment},
  {"getNumStackElementsEverAllocated", &Dtool_DCPacker_get_num_stack_elements_ever_allocated_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_DCPacker_get_num_stack_elements_ever_allocated_114_comment},
  {"raw_pack_int8", &Dtool_DCPacker_raw_pack_int8_115, METH_O, (const char *)Dtool_DCPacker_raw_pack_int8_115_comment},
  {"rawPackInt8", &Dtool_DCPacker_raw_pack_int8_115, METH_O, (const char *)Dtool_DCPacker_raw_pack_int8_115_comment},
  {"raw_pack_int16", &Dtool_DCPacker_raw_pack_int16_116, METH_O, (const char *)Dtool_DCPacker_raw_pack_int16_116_comment},
  {"rawPackInt16", &Dtool_DCPacker_raw_pack_int16_116, METH_O, (const char *)Dtool_DCPacker_raw_pack_int16_116_comment},
  {"raw_pack_int32", &Dtool_DCPacker_raw_pack_int32_117, METH_O, (const char *)Dtool_DCPacker_raw_pack_int32_117_comment},
  {"rawPackInt32", &Dtool_DCPacker_raw_pack_int32_117, METH_O, (const char *)Dtool_DCPacker_raw_pack_int32_117_comment},
  {"raw_pack_int64", &Dtool_DCPacker_raw_pack_int64_118, METH_O, (const char *)Dtool_DCPacker_raw_pack_int64_118_comment},
  {"rawPackInt64", &Dtool_DCPacker_raw_pack_int64_118, METH_O, (const char *)Dtool_DCPacker_raw_pack_int64_118_comment},
  {"raw_pack_uint8", &Dtool_DCPacker_raw_pack_uint8_119, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint8_119_comment},
  {"rawPackUint8", &Dtool_DCPacker_raw_pack_uint8_119, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint8_119_comment},
  {"raw_pack_uint16", &Dtool_DCPacker_raw_pack_uint16_120, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint16_120_comment},
  {"rawPackUint16", &Dtool_DCPacker_raw_pack_uint16_120, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint16_120_comment},
  {"raw_pack_uint32", &Dtool_DCPacker_raw_pack_uint32_121, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint32_121_comment},
  {"rawPackUint32", &Dtool_DCPacker_raw_pack_uint32_121, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint32_121_comment},
  {"raw_pack_uint64", &Dtool_DCPacker_raw_pack_uint64_122, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint64_122_comment},
  {"rawPackUint64", &Dtool_DCPacker_raw_pack_uint64_122, METH_O, (const char *)Dtool_DCPacker_raw_pack_uint64_122_comment},
  {"raw_pack_float64", &Dtool_DCPacker_raw_pack_float64_123, METH_O, (const char *)Dtool_DCPacker_raw_pack_float64_123_comment},
  {"rawPackFloat64", &Dtool_DCPacker_raw_pack_float64_123, METH_O, (const char *)Dtool_DCPacker_raw_pack_float64_123_comment},
  {"raw_pack_string", &Dtool_DCPacker_raw_pack_string_124, METH_O, (const char *)Dtool_DCPacker_raw_pack_string_124_comment},
  {"rawPackString", &Dtool_DCPacker_raw_pack_string_124, METH_O, (const char *)Dtool_DCPacker_raw_pack_string_124_comment},
  {"raw_pack_blob", &Dtool_DCPacker_raw_pack_blob_125, METH_O, (const char *)Dtool_DCPacker_raw_pack_blob_125_comment},
  {"rawPackBlob", &Dtool_DCPacker_raw_pack_blob_125, METH_O, (const char *)Dtool_DCPacker_raw_pack_blob_125_comment},
  {"raw_unpack_int8", &Dtool_DCPacker_raw_unpack_int8_126, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int8_126_comment},
  {"rawUnpackInt8", &Dtool_DCPacker_raw_unpack_int8_126, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int8_126_comment},
  {"raw_unpack_int16", &Dtool_DCPacker_raw_unpack_int16_127, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int16_127_comment},
  {"rawUnpackInt16", &Dtool_DCPacker_raw_unpack_int16_127, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int16_127_comment},
  {"raw_unpack_int32", &Dtool_DCPacker_raw_unpack_int32_128, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int32_128_comment},
  {"rawUnpackInt32", &Dtool_DCPacker_raw_unpack_int32_128, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int32_128_comment},
  {"raw_unpack_int64", &Dtool_DCPacker_raw_unpack_int64_129, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int64_129_comment},
  {"rawUnpackInt64", &Dtool_DCPacker_raw_unpack_int64_129, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_int64_129_comment},
  {"raw_unpack_uint8", &Dtool_DCPacker_raw_unpack_uint8_130, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint8_130_comment},
  {"rawUnpackUint8", &Dtool_DCPacker_raw_unpack_uint8_130, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint8_130_comment},
  {"raw_unpack_uint16", &Dtool_DCPacker_raw_unpack_uint16_131, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint16_131_comment},
  {"rawUnpackUint16", &Dtool_DCPacker_raw_unpack_uint16_131, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint16_131_comment},
  {"raw_unpack_uint32", &Dtool_DCPacker_raw_unpack_uint32_132, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint32_132_comment},
  {"rawUnpackUint32", &Dtool_DCPacker_raw_unpack_uint32_132, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint32_132_comment},
  {"raw_unpack_uint64", &Dtool_DCPacker_raw_unpack_uint64_133, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint64_133_comment},
  {"rawUnpackUint64", &Dtool_DCPacker_raw_unpack_uint64_133, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_uint64_133_comment},
  {"raw_unpack_float64", &Dtool_DCPacker_raw_unpack_float64_134, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_float64_134_comment},
  {"rawUnpackFloat64", &Dtool_DCPacker_raw_unpack_float64_134, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_float64_134_comment},
  {"raw_unpack_string", &Dtool_DCPacker_raw_unpack_string_135, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_string_135_comment},
  {"rawUnpackString", &Dtool_DCPacker_raw_unpack_string_135, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_string_135_comment},
  {"raw_unpack_blob", &Dtool_DCPacker_raw_unpack_blob_136, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_blob_136_comment},
  {"rawUnpackBlob", &Dtool_DCPacker_raw_unpack_blob_136, METH_NOARGS, (const char *)Dtool_DCPacker_raw_unpack_blob_136_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCPacker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DCPacker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCPacker",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCPacker,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCPacker,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used for packing a series of numeric and string data into\n"
    " * a binary stream, according to the DC specification.\n"
    " *\n"
    " * See also direct/src/doc/dcPacker.txt for a more complete description and\n"
    " * examples of using this class.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCPacker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCPacker,
    PyType_GenericAlloc,
    Dtool_new_DCPacker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCPacker,
  Dtool_UpcastInterface_DCPacker,
  Dtool_DowncastInterface_DCPacker,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCPacker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCPacker._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCPacker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCPacker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCPacker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCPacker);
  }
}

/**
 * Python method tables for DCParameter (DCParameter)
 */
static PyMethodDef Dtool_Methods_DCParameter[] = {
  {"as_simple_parameter", &Dtool_DCParameter_as_simple_parameter_138, METH_NOARGS, (const char *)Dtool_DCParameter_as_simple_parameter_138_comment},
  {"asSimpleParameter", &Dtool_DCParameter_as_simple_parameter_138, METH_NOARGS, (const char *)Dtool_DCParameter_as_simple_parameter_138_comment},
  {"as_array_parameter", &Dtool_DCParameter_as_array_parameter_139, METH_NOARGS, (const char *)Dtool_DCParameter_as_array_parameter_139_comment},
  {"asArrayParameter", &Dtool_DCParameter_as_array_parameter_139, METH_NOARGS, (const char *)Dtool_DCParameter_as_array_parameter_139_comment},
  {"make_copy", &Dtool_DCParameter_make_copy_140, METH_NOARGS, (const char *)Dtool_DCParameter_make_copy_140_comment},
  {"makeCopy", &Dtool_DCParameter_make_copy_140, METH_NOARGS, (const char *)Dtool_DCParameter_make_copy_140_comment},
  {"is_valid", &Dtool_DCParameter_is_valid_141, METH_NOARGS, (const char *)Dtool_DCParameter_is_valid_141_comment},
  {"isValid", &Dtool_DCParameter_is_valid_141, METH_NOARGS, (const char *)Dtool_DCParameter_is_valid_141_comment},
  {"get_typedef", &Dtool_DCParameter_get_typedef_142, METH_NOARGS, (const char *)Dtool_DCParameter_get_typedef_142_comment},
  {"getTypedef", &Dtool_DCParameter_get_typedef_142, METH_NOARGS, (const char *)Dtool_DCParameter_get_typedef_142_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCParameter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCParameter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCParameter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCParameter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCParameter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCParameter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCParameter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCParameter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCParameter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCParameter,
    &Dtool_SequenceMethods_DCParameter,
    &Dtool_MappingMethods_DCParameter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents the type specification for a single parameter within a field\n"
    " * specification.  This may be a simple type, or it may be a class or an array\n"
    " * reference.\n"
    " *\n"
    " * This may also be a typedef reference to another type, which has the same\n"
    " * properties as the referenced type, but a different name.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCParameter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCParameter,
    PyType_GenericAlloc,
    Dtool_new_DCParameter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCParameter,
  Dtool_UpcastInterface_DCParameter,
  Dtool_DowncastInterface_DCParameter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCField(nullptr);
    Dtool_DCParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCField);
    Dtool_DCParameter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCParameter);
  }
}

/**
 * Python method tables for DCArrayParameter (DCArrayParameter)
 */
static PyMethodDef Dtool_Methods_DCArrayParameter[] = {
  {"get_element_type", &Dtool_DCArrayParameter_get_element_type_144, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_element_type_144_comment},
  {"getElementType", &Dtool_DCArrayParameter_get_element_type_144, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_element_type_144_comment},
  {"get_array_size", &Dtool_DCArrayParameter_get_array_size_145, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_array_size_145_comment},
  {"getArraySize", &Dtool_DCArrayParameter_get_array_size_145, METH_NOARGS, (const char *)Dtool_DCArrayParameter_get_array_size_145_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCArrayParameter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCArrayParameter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCArrayParameter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCArrayParameter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCArrayParameter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCArrayParameter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCArrayParameter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCArrayParameter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCArrayParameter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCArrayParameter,
    &Dtool_SequenceMethods_DCArrayParameter,
    &Dtool_MappingMethods_DCArrayParameter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCArrayParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents an array of some other kind of object, meaning this\n"
    " * parameter type accepts an arbitrary (or possibly fixed) number of nested\n"
    " * fields, all of which are of the same type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCArrayParameter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCArrayParameter,
    PyType_GenericAlloc,
    Dtool_new_DCArrayParameter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCArrayParameter,
  Dtool_UpcastInterface_DCArrayParameter,
  Dtool_DowncastInterface_DCArrayParameter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCArrayParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(nullptr);
    Dtool_DCArrayParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    Dtool_DCArrayParameter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCArrayParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCArrayParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCArrayParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCArrayParameter);
  }
}

/**
 * Python method tables for DCAtomicField (DCAtomicField)
 */
static PyMethodDef Dtool_Methods_DCAtomicField[] = {
  {"get_num_elements", &Dtool_DCAtomicField_get_num_elements_147, METH_NOARGS, (const char *)Dtool_DCAtomicField_get_num_elements_147_comment},
  {"getNumElements", &Dtool_DCAtomicField_get_num_elements_147, METH_NOARGS, (const char *)Dtool_DCAtomicField_get_num_elements_147_comment},
  {"get_element", &Dtool_DCAtomicField_get_element_148, METH_O, (const char *)Dtool_DCAtomicField_get_element_148_comment},
  {"getElement", &Dtool_DCAtomicField_get_element_148, METH_O, (const char *)Dtool_DCAtomicField_get_element_148_comment},
  {"get_element_default", &Dtool_DCAtomicField_get_element_default_149, METH_O, (const char *)Dtool_DCAtomicField_get_element_default_149_comment},
  {"getElementDefault", &Dtool_DCAtomicField_get_element_default_149, METH_O, (const char *)Dtool_DCAtomicField_get_element_default_149_comment},
  {"has_element_default", &Dtool_DCAtomicField_has_element_default_150, METH_O, (const char *)Dtool_DCAtomicField_has_element_default_150_comment},
  {"hasElementDefault", &Dtool_DCAtomicField_has_element_default_150, METH_O, (const char *)Dtool_DCAtomicField_has_element_default_150_comment},
  {"get_element_name", &Dtool_DCAtomicField_get_element_name_151, METH_O, (const char *)Dtool_DCAtomicField_get_element_name_151_comment},
  {"getElementName", &Dtool_DCAtomicField_get_element_name_151, METH_O, (const char *)Dtool_DCAtomicField_get_element_name_151_comment},
  {"get_element_type", &Dtool_DCAtomicField_get_element_type_152, METH_O, (const char *)Dtool_DCAtomicField_get_element_type_152_comment},
  {"getElementType", &Dtool_DCAtomicField_get_element_type_152, METH_O, (const char *)Dtool_DCAtomicField_get_element_type_152_comment},
  {"get_element_divisor", &Dtool_DCAtomicField_get_element_divisor_153, METH_O, (const char *)Dtool_DCAtomicField_get_element_divisor_153_comment},
  {"getElementDivisor", &Dtool_DCAtomicField_get_element_divisor_153, METH_O, (const char *)Dtool_DCAtomicField_get_element_divisor_153_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCAtomicField = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCAtomicField = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCAtomicField = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCAtomicField = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCAtomicField = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCAtomicField = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCAtomicField",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCAtomicField,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCAtomicField,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCAtomicField,
    &Dtool_SequenceMethods_DCAtomicField,
    &Dtool_MappingMethods_DCAtomicField,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCAtomicField,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single atomic field of a Distributed Class, as read from a .dc file.\n"
    " * This defines an interface to the Distributed Class, and is always\n"
    " * implemented as a remote procedure method.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCAtomicField,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCAtomicField,
    PyType_GenericAlloc,
    Dtool_new_DCAtomicField,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCAtomicField,
  Dtool_UpcastInterface_DCAtomicField,
  Dtool_DowncastInterface_DCAtomicField,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCAtomicField(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCField(nullptr);
    Dtool_DCAtomicField._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCField);
    Dtool_DCAtomicField._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCAtomicField._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCAtomicField) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCAtomicField)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCAtomicField);
  }
}

/**
 * Python method tables for DCDeclaration (DCDeclaration)
 */
static PyMethodDef Dtool_Methods_DCDeclaration[] = {
  {"as_class", &Dtool_DCDeclaration_as_class_156, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_class_156_comment},
  {"asClass", &Dtool_DCDeclaration_as_class_156, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_class_156_comment},
  {"as_switch", &Dtool_DCDeclaration_as_switch_157, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_switch_157_comment},
  {"asSwitch", &Dtool_DCDeclaration_as_switch_157, METH_NOARGS, (const char *)Dtool_DCDeclaration_as_switch_157_comment},
  {"output", &Dtool_DCDeclaration_output_158, METH_O, (const char *)Dtool_DCDeclaration_output_158_comment},
  {"write", (PyCFunction) &Dtool_DCDeclaration_write_159, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCDeclaration_write_159_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     DCDeclaration
//////////////////
static PyObject *Dtool_Repr_DCDeclaration(PyObject *self) {
  DCDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DCDeclaration
//////////////////
static PyObject *Dtool_Str_DCDeclaration(PyObject *self) {
  DCDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCDeclaration, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DCDeclaration = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DCDeclaration = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCDeclaration",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCDeclaration,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_DCDeclaration,
    &Dtool_NumberMethods_DCDeclaration,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_DCDeclaration,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a common interface for a declaration in a DC file.  Currently, this\n"
    " * is either a class or a typedef declaration (import declarations are still\n"
    " * collected together at the top, and don't inherit from this object).  Its\n"
    " * only purpose is so that classes and typedefs can be stored in one list\n"
    " * together so they can be ordered correctly on output.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCDeclaration,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCDeclaration,
    PyType_GenericAlloc,
    Dtool_new_DCDeclaration,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCDeclaration,
  Dtool_UpcastInterface_DCDeclaration,
  Dtool_DowncastInterface_DCDeclaration,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCDeclaration(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCDeclaration._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCDeclaration._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCDeclaration) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCDeclaration)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCDeclaration);
  }
}

/**
 * Python method tables for DCClass (DCClass)
 */
static PyMethodDef Dtool_Methods_DCClass[] = {
  {"get_dc_file", &Dtool_DCClass_get_dc_file_161, METH_NOARGS, (const char *)Dtool_DCClass_get_dc_file_161_comment},
  {"getDcFile", &Dtool_DCClass_get_dc_file_161, METH_NOARGS, (const char *)Dtool_DCClass_get_dc_file_161_comment},
  {"get_name", &Dtool_DCClass_get_name_162, METH_NOARGS, (const char *)Dtool_DCClass_get_name_162_comment},
  {"getName", &Dtool_DCClass_get_name_162, METH_NOARGS, (const char *)Dtool_DCClass_get_name_162_comment},
  {"get_number", &Dtool_DCClass_get_number_163, METH_NOARGS, (const char *)Dtool_DCClass_get_number_163_comment},
  {"getNumber", &Dtool_DCClass_get_number_163, METH_NOARGS, (const char *)Dtool_DCClass_get_number_163_comment},
  {"get_num_parents", &Dtool_DCClass_get_num_parents_164, METH_NOARGS, (const char *)Dtool_DCClass_get_num_parents_164_comment},
  {"getNumParents", &Dtool_DCClass_get_num_parents_164, METH_NOARGS, (const char *)Dtool_DCClass_get_num_parents_164_comment},
  {"get_parent", &Dtool_DCClass_get_parent_165, METH_O, (const char *)Dtool_DCClass_get_parent_165_comment},
  {"getParent", &Dtool_DCClass_get_parent_165, METH_O, (const char *)Dtool_DCClass_get_parent_165_comment},
  {"has_constructor", &Dtool_DCClass_has_constructor_166, METH_NOARGS, (const char *)Dtool_DCClass_has_constructor_166_comment},
  {"hasConstructor", &Dtool_DCClass_has_constructor_166, METH_NOARGS, (const char *)Dtool_DCClass_has_constructor_166_comment},
  {"get_constructor", &Dtool_DCClass_get_constructor_167, METH_NOARGS, (const char *)Dtool_DCClass_get_constructor_167_comment},
  {"getConstructor", &Dtool_DCClass_get_constructor_167, METH_NOARGS, (const char *)Dtool_DCClass_get_constructor_167_comment},
  {"get_num_fields", &Dtool_DCClass_get_num_fields_168, METH_NOARGS, (const char *)Dtool_DCClass_get_num_fields_168_comment},
  {"getNumFields", &Dtool_DCClass_get_num_fields_168, METH_NOARGS, (const char *)Dtool_DCClass_get_num_fields_168_comment},
  {"get_field", &Dtool_DCClass_get_field_169, METH_O, (const char *)Dtool_DCClass_get_field_169_comment},
  {"getField", &Dtool_DCClass_get_field_169, METH_O, (const char *)Dtool_DCClass_get_field_169_comment},
  {"get_field_by_name", &Dtool_DCClass_get_field_by_name_170, METH_O, (const char *)Dtool_DCClass_get_field_by_name_170_comment},
  {"getFieldByName", &Dtool_DCClass_get_field_by_name_170, METH_O, (const char *)Dtool_DCClass_get_field_by_name_170_comment},
  {"get_field_by_index", &Dtool_DCClass_get_field_by_index_171, METH_O, (const char *)Dtool_DCClass_get_field_by_index_171_comment},
  {"getFieldByIndex", &Dtool_DCClass_get_field_by_index_171, METH_O, (const char *)Dtool_DCClass_get_field_by_index_171_comment},
  {"get_num_inherited_fields", &Dtool_DCClass_get_num_inherited_fields_172, METH_NOARGS, (const char *)Dtool_DCClass_get_num_inherited_fields_172_comment},
  {"getNumInheritedFields", &Dtool_DCClass_get_num_inherited_fields_172, METH_NOARGS, (const char *)Dtool_DCClass_get_num_inherited_fields_172_comment},
  {"get_inherited_field", &Dtool_DCClass_get_inherited_field_173, METH_O, (const char *)Dtool_DCClass_get_inherited_field_173_comment},
  {"getInheritedField", &Dtool_DCClass_get_inherited_field_173, METH_O, (const char *)Dtool_DCClass_get_inherited_field_173_comment},
  {"is_struct", &Dtool_DCClass_is_struct_174, METH_NOARGS, (const char *)Dtool_DCClass_is_struct_174_comment},
  {"isStruct", &Dtool_DCClass_is_struct_174, METH_NOARGS, (const char *)Dtool_DCClass_is_struct_174_comment},
  {"is_bogus_class", &Dtool_DCClass_is_bogus_class_175, METH_NOARGS, (const char *)Dtool_DCClass_is_bogus_class_175_comment},
  {"isBogusClass", &Dtool_DCClass_is_bogus_class_175, METH_NOARGS, (const char *)Dtool_DCClass_is_bogus_class_175_comment},
  {"inherits_from_bogus_class", &Dtool_DCClass_inherits_from_bogus_class_176, METH_NOARGS, (const char *)Dtool_DCClass_inherits_from_bogus_class_176_comment},
  {"inheritsFromBogusClass", &Dtool_DCClass_inherits_from_bogus_class_176, METH_NOARGS, (const char *)Dtool_DCClass_inherits_from_bogus_class_176_comment},
  {"start_generate", &Dtool_DCClass_start_generate_177, METH_NOARGS, (const char *)Dtool_DCClass_start_generate_177_comment},
  {"startGenerate", &Dtool_DCClass_start_generate_177, METH_NOARGS, (const char *)Dtool_DCClass_start_generate_177_comment},
  {"stop_generate", &Dtool_DCClass_stop_generate_178, METH_NOARGS, (const char *)Dtool_DCClass_stop_generate_178_comment},
  {"stopGenerate", &Dtool_DCClass_stop_generate_178, METH_NOARGS, (const char *)Dtool_DCClass_stop_generate_178_comment},
  {"output", &Dtool_DCClass_output_179, METH_O, (const char *)Dtool_DCClass_output_179_comment},
  {"has_class_def", &Dtool_DCClass_has_class_def_180, METH_NOARGS, (const char *)Dtool_DCClass_has_class_def_180_comment},
  {"hasClassDef", &Dtool_DCClass_has_class_def_180, METH_NOARGS, (const char *)Dtool_DCClass_has_class_def_180_comment},
  {"set_class_def", &Dtool_DCClass_set_class_def_181, METH_O, (const char *)Dtool_DCClass_set_class_def_181_comment},
  {"setClassDef", &Dtool_DCClass_set_class_def_181, METH_O, (const char *)Dtool_DCClass_set_class_def_181_comment},
  {"get_class_def", &Dtool_DCClass_get_class_def_182, METH_NOARGS, (const char *)Dtool_DCClass_get_class_def_182_comment},
  {"getClassDef", &Dtool_DCClass_get_class_def_182, METH_NOARGS, (const char *)Dtool_DCClass_get_class_def_182_comment},
  {"has_owner_class_def", &Dtool_DCClass_has_owner_class_def_183, METH_NOARGS, (const char *)Dtool_DCClass_has_owner_class_def_183_comment},
  {"hasOwnerClassDef", &Dtool_DCClass_has_owner_class_def_183, METH_NOARGS, (const char *)Dtool_DCClass_has_owner_class_def_183_comment},
  {"set_owner_class_def", &Dtool_DCClass_set_owner_class_def_184, METH_O, (const char *)Dtool_DCClass_set_owner_class_def_184_comment},
  {"setOwnerClassDef", &Dtool_DCClass_set_owner_class_def_184, METH_O, (const char *)Dtool_DCClass_set_owner_class_def_184_comment},
  {"get_owner_class_def", &Dtool_DCClass_get_owner_class_def_185, METH_NOARGS, (const char *)Dtool_DCClass_get_owner_class_def_185_comment},
  {"getOwnerClassDef", &Dtool_DCClass_get_owner_class_def_185, METH_NOARGS, (const char *)Dtool_DCClass_get_owner_class_def_185_comment},
  {"receive_update", (PyCFunction) &Dtool_DCClass_receive_update_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_186_comment},
  {"receiveUpdate", (PyCFunction) &Dtool_DCClass_receive_update_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_186_comment},
  {"receive_update_broadcast_required", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_187_comment},
  {"receiveUpdateBroadcastRequired", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_187_comment},
  {"receive_update_broadcast_required_owner", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_owner_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_owner_188_comment},
  {"receiveUpdateBroadcastRequiredOwner", (PyCFunction) &Dtool_DCClass_receive_update_broadcast_required_owner_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_broadcast_required_owner_188_comment},
  {"receive_update_all_required", (PyCFunction) &Dtool_DCClass_receive_update_all_required_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_all_required_189_comment},
  {"receiveUpdateAllRequired", (PyCFunction) &Dtool_DCClass_receive_update_all_required_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_all_required_189_comment},
  {"receive_update_other", (PyCFunction) &Dtool_DCClass_receive_update_other_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_other_190_comment},
  {"receiveUpdateOther", (PyCFunction) &Dtool_DCClass_receive_update_other_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_receive_update_other_190_comment},
  {"direct_update", (PyCFunction) &Dtool_DCClass_direct_update_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_direct_update_191_comment},
  {"directUpdate", (PyCFunction) &Dtool_DCClass_direct_update_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_direct_update_191_comment},
  {"pack_required_field", (PyCFunction) &Dtool_DCClass_pack_required_field_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_pack_required_field_192_comment},
  {"packRequiredField", (PyCFunction) &Dtool_DCClass_pack_required_field_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_pack_required_field_192_comment},
  {"client_format_update", (PyCFunction) &Dtool_DCClass_client_format_update_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_update_193_comment},
  {"clientFormatUpdate", (PyCFunction) &Dtool_DCClass_client_format_update_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_update_193_comment},
  {"ai_format_update", (PyCFunction) &Dtool_DCClass_ai_format_update_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_194_comment},
  {"aiFormatUpdate", (PyCFunction) &Dtool_DCClass_ai_format_update_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_194_comment},
  {"ai_format_update_msg_type", (PyCFunction) &Dtool_DCClass_ai_format_update_msg_type_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_msg_type_195_comment},
  {"aiFormatUpdateMsgType", (PyCFunction) &Dtool_DCClass_ai_format_update_msg_type_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_update_msg_type_195_comment},
  {"ai_format_generate", (PyCFunction) &Dtool_DCClass_ai_format_generate_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_generate_196_comment},
  {"aiFormatGenerate", (PyCFunction) &Dtool_DCClass_ai_format_generate_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_ai_format_generate_196_comment},
  {"client_format_generate_CMU", (PyCFunction) &Dtool_DCClass_client_format_generate_CMU_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_generate_CMU_197_comment},
  {"clientFormatGenerateCMU", (PyCFunction) &Dtool_DCClass_client_format_generate_CMU_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCClass_client_format_generate_CMU_197_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     DCClass
//////////////////
static PyObject *Dtool_Repr_DCClass(PyObject *self) {
  DCClass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCClass, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DCClass = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCClass = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCClass = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCClass = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCClass = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCClass = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCClass",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCClass,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCClass,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_DCClass,
    &Dtool_NumberMethods_DCClass,
    &Dtool_SequenceMethods_DCClass,
    &Dtool_MappingMethods_DCClass,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_DCClass,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCClass,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a particular DistributedClass as read from an input .dc file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCClass,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCClass,
    PyType_GenericAlloc,
    Dtool_new_DCClass,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCClass,
  Dtool_UpcastInterface_DCClass,
  Dtool_DowncastInterface_DCClass,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCClass(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(nullptr);
    Dtool_DCClass._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    Dtool_DCClass._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCClass._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCClass) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCClass)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCClass);
  }
}

/**
 * Python method tables for DCClassParameter (DCClassParameter)
 */
static PyMethodDef Dtool_Methods_DCClassParameter[] = {
  {"get_class", &Dtool_DCClassParameter_get_class_199, METH_NOARGS, (const char *)Dtool_DCClassParameter_get_class_199_comment},
  {"getClass", &Dtool_DCClassParameter_get_class_199, METH_NOARGS, (const char *)Dtool_DCClassParameter_get_class_199_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCClassParameter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCClassParameter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCClassParameter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCClassParameter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCClassParameter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCClassParameter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCClassParameter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCClassParameter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCClassParameter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCClassParameter,
    &Dtool_SequenceMethods_DCClassParameter,
    &Dtool_MappingMethods_DCClassParameter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCClassParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a class (or struct) object used as a parameter itself.\n"
    " * This means that all the fields of the class get packed into the message.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCClassParameter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCClassParameter,
    PyType_GenericAlloc,
    Dtool_new_DCClassParameter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCClassParameter,
  Dtool_UpcastInterface_DCClassParameter,
  Dtool_DowncastInterface_DCClassParameter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCClassParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(nullptr);
    Dtool_DCClassParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    Dtool_DCClassParameter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCClassParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCClassParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCClassParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCClassParameter);
  }
}

/**
 * Python method tables for DCFile (DCFile)
 */
static PyMethodDef Dtool_Methods_DCFile[] = {
  {"clear", &Dtool_DCFile_clear_204, METH_NOARGS, (const char *)Dtool_DCFile_clear_204_comment},
  {"read_all", &Dtool_DCFile_read_all_205, METH_NOARGS, (const char *)Dtool_DCFile_read_all_205_comment},
  {"readAll", &Dtool_DCFile_read_all_205, METH_NOARGS, (const char *)Dtool_DCFile_read_all_205_comment},
  {"read", (PyCFunction) &Dtool_DCFile_read_206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_read_206_comment},
  {"write", (PyCFunction) &Dtool_DCFile_write_207, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_write_207_comment},
  {"get_num_classes", &Dtool_DCFile_get_num_classes_208, METH_NOARGS, (const char *)Dtool_DCFile_get_num_classes_208_comment},
  {"getNumClasses", &Dtool_DCFile_get_num_classes_208, METH_NOARGS, (const char *)Dtool_DCFile_get_num_classes_208_comment},
  {"get_class", &Dtool_DCFile_get_class_209, METH_O, (const char *)Dtool_DCFile_get_class_209_comment},
  {"getClass", &Dtool_DCFile_get_class_209, METH_O, (const char *)Dtool_DCFile_get_class_209_comment},
  {"get_class_by_name", &Dtool_DCFile_get_class_by_name_210, METH_O, (const char *)Dtool_DCFile_get_class_by_name_210_comment},
  {"getClassByName", &Dtool_DCFile_get_class_by_name_210, METH_O, (const char *)Dtool_DCFile_get_class_by_name_210_comment},
  {"get_switch_by_name", &Dtool_DCFile_get_switch_by_name_211, METH_O, (const char *)Dtool_DCFile_get_switch_by_name_211_comment},
  {"getSwitchByName", &Dtool_DCFile_get_switch_by_name_211, METH_O, (const char *)Dtool_DCFile_get_switch_by_name_211_comment},
  {"get_field_by_index", &Dtool_DCFile_get_field_by_index_212, METH_O, (const char *)Dtool_DCFile_get_field_by_index_212_comment},
  {"getFieldByIndex", &Dtool_DCFile_get_field_by_index_212, METH_O, (const char *)Dtool_DCFile_get_field_by_index_212_comment},
  {"all_objects_valid", &Dtool_DCFile_all_objects_valid_213, METH_NOARGS, (const char *)Dtool_DCFile_all_objects_valid_213_comment},
  {"allObjectsValid", &Dtool_DCFile_all_objects_valid_213, METH_NOARGS, (const char *)Dtool_DCFile_all_objects_valid_213_comment},
  {"get_num_import_modules", &Dtool_DCFile_get_num_import_modules_214, METH_NOARGS, (const char *)Dtool_DCFile_get_num_import_modules_214_comment},
  {"getNumImportModules", &Dtool_DCFile_get_num_import_modules_214, METH_NOARGS, (const char *)Dtool_DCFile_get_num_import_modules_214_comment},
  {"get_import_module", &Dtool_DCFile_get_import_module_215, METH_O, (const char *)Dtool_DCFile_get_import_module_215_comment},
  {"getImportModule", &Dtool_DCFile_get_import_module_215, METH_O, (const char *)Dtool_DCFile_get_import_module_215_comment},
  {"get_num_import_symbols", &Dtool_DCFile_get_num_import_symbols_216, METH_O, (const char *)Dtool_DCFile_get_num_import_symbols_216_comment},
  {"getNumImportSymbols", &Dtool_DCFile_get_num_import_symbols_216, METH_O, (const char *)Dtool_DCFile_get_num_import_symbols_216_comment},
  {"get_import_symbol", (PyCFunction) &Dtool_DCFile_get_import_symbol_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_get_import_symbol_217_comment},
  {"getImportSymbol", (PyCFunction) &Dtool_DCFile_get_import_symbol_217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCFile_get_import_symbol_217_comment},
  {"get_num_typedefs", &Dtool_DCFile_get_num_typedefs_218, METH_NOARGS, (const char *)Dtool_DCFile_get_num_typedefs_218_comment},
  {"getNumTypedefs", &Dtool_DCFile_get_num_typedefs_218, METH_NOARGS, (const char *)Dtool_DCFile_get_num_typedefs_218_comment},
  {"get_typedef", &Dtool_DCFile_get_typedef_219, METH_O, (const char *)Dtool_DCFile_get_typedef_219_comment},
  {"getTypedef", &Dtool_DCFile_get_typedef_219, METH_O, (const char *)Dtool_DCFile_get_typedef_219_comment},
  {"get_typedef_by_name", &Dtool_DCFile_get_typedef_by_name_220, METH_O, (const char *)Dtool_DCFile_get_typedef_by_name_220_comment},
  {"getTypedefByName", &Dtool_DCFile_get_typedef_by_name_220, METH_O, (const char *)Dtool_DCFile_get_typedef_by_name_220_comment},
  {"get_num_keywords", &Dtool_DCFile_get_num_keywords_221, METH_NOARGS, (const char *)Dtool_DCFile_get_num_keywords_221_comment},
  {"getNumKeywords", &Dtool_DCFile_get_num_keywords_221, METH_NOARGS, (const char *)Dtool_DCFile_get_num_keywords_221_comment},
  {"get_keyword", &Dtool_DCFile_get_keyword_222, METH_O, (const char *)Dtool_DCFile_get_keyword_222_comment},
  {"getKeyword", &Dtool_DCFile_get_keyword_222, METH_O, (const char *)Dtool_DCFile_get_keyword_222_comment},
  {"get_keyword_by_name", &Dtool_DCFile_get_keyword_by_name_223, METH_O, (const char *)Dtool_DCFile_get_keyword_by_name_223_comment},
  {"getKeywordByName", &Dtool_DCFile_get_keyword_by_name_223, METH_O, (const char *)Dtool_DCFile_get_keyword_by_name_223_comment},
  {"get_hash", &Dtool_DCFile_get_hash_224, METH_NOARGS, (const char *)Dtool_DCFile_get_hash_224_comment},
  {"getHash", &Dtool_DCFile_get_hash_224, METH_NOARGS, (const char *)Dtool_DCFile_get_hash_224_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DCFile slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_DCFile_get_hash_224_tp_hash(PyObject *self) {
  DCFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DCFile, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

static PyNumberMethods Dtool_NumberMethods_DCFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DCFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_DCFile,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_DCFile_get_hash_224_tp_hash,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents the complete list of Distributed Class descriptions as read from\n"
    " * a .dc file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DtoolInstance_RichComparePointers,
#else
    nullptr, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCFile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCFile,
    PyType_GenericAlloc,
    Dtool_new_DCFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCFile,
  Dtool_UpcastInterface_DCFile,
  Dtool_DowncastInterface_DCFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DCFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCFile);
  }
}

/**
 * Python method tables for DCKeyword (DCKeyword)
 */
static PyMethodDef Dtool_Methods_DCKeyword[] = {
  {"get_name", &Dtool_DCKeyword_get_name_226, METH_NOARGS, (const char *)Dtool_DCKeyword_get_name_226_comment},
  {"getName", &Dtool_DCKeyword_get_name_226, METH_NOARGS, (const char *)Dtool_DCKeyword_get_name_226_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCKeyword = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCKeyword = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCKeyword = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCKeyword = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCKeyword = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCKeyword = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCKeyword",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCKeyword,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCKeyword,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCKeyword,
    &Dtool_SequenceMethods_DCKeyword,
    &Dtool_MappingMethods_DCKeyword,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCKeyword,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a single keyword declaration in the dc file.  It is used to\n"
    " * define a communication property associated with a field, for instance\n"
    " * \"broadcast\" or \"airecv\".\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCKeyword,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCKeyword,
    PyType_GenericAlloc,
    Dtool_new_DCKeyword,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCKeyword,
  Dtool_UpcastInterface_DCKeyword,
  Dtool_DowncastInterface_DCKeyword,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCKeyword(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(nullptr);
    Dtool_DCKeyword._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    Dtool_DCKeyword._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCKeyword._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCKeyword) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCKeyword)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCKeyword);
  }
}

/**
 * Python method tables for DCMolecularField (DCMolecularField)
 */
static PyMethodDef Dtool_Methods_DCMolecularField[] = {
  {"get_num_atomics", &Dtool_DCMolecularField_get_num_atomics_228, METH_NOARGS, (const char *)Dtool_DCMolecularField_get_num_atomics_228_comment},
  {"getNumAtomics", &Dtool_DCMolecularField_get_num_atomics_228, METH_NOARGS, (const char *)Dtool_DCMolecularField_get_num_atomics_228_comment},
  {"get_atomic", &Dtool_DCMolecularField_get_atomic_229, METH_O, (const char *)Dtool_DCMolecularField_get_atomic_229_comment},
  {"getAtomic", &Dtool_DCMolecularField_get_atomic_229, METH_O, (const char *)Dtool_DCMolecularField_get_atomic_229_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCMolecularField = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCMolecularField = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCMolecularField = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCMolecularField = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCMolecularField = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCMolecularField = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCMolecularField",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCMolecularField,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCMolecularField,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCMolecularField,
    &Dtool_SequenceMethods_DCMolecularField,
    &Dtool_MappingMethods_DCMolecularField,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCMolecularField,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single molecular field of a Distributed Class, as read from a .dc file.\n"
    " * This represents a combination of two or more related atomic fields, that\n"
    " * will often be treated as a unit.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCMolecularField,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCMolecularField,
    PyType_GenericAlloc,
    Dtool_new_DCMolecularField,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCMolecularField,
  Dtool_UpcastInterface_DCMolecularField,
  Dtool_DowncastInterface_DCMolecularField,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCMolecularField(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCField(nullptr);
    Dtool_DCMolecularField._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCField);
    Dtool_DCMolecularField._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCMolecularField._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCMolecularField) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCMolecularField)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCMolecularField);
  }
}

/**
 * Python method tables for DCSimpleParameter (DCSimpleParameter)
 */
static PyMethodDef Dtool_Methods_DCSimpleParameter[] = {
  {"get_type", &Dtool_DCSimpleParameter_get_type_232, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_type_232_comment},
  {"getType", &Dtool_DCSimpleParameter_get_type_232, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_type_232_comment},
  {"has_modulus", &Dtool_DCSimpleParameter_has_modulus_233, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_has_modulus_233_comment},
  {"hasModulus", &Dtool_DCSimpleParameter_has_modulus_233, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_has_modulus_233_comment},
  {"get_modulus", &Dtool_DCSimpleParameter_get_modulus_234, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_modulus_234_comment},
  {"getModulus", &Dtool_DCSimpleParameter_get_modulus_234, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_modulus_234_comment},
  {"get_divisor", &Dtool_DCSimpleParameter_get_divisor_235, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_divisor_235_comment},
  {"getDivisor", &Dtool_DCSimpleParameter_get_divisor_235, METH_NOARGS, (const char *)Dtool_DCSimpleParameter_get_divisor_235_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCSimpleParameter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCSimpleParameter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCSimpleParameter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCSimpleParameter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCSimpleParameter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCSimpleParameter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCSimpleParameter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCSimpleParameter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCSimpleParameter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCSimpleParameter,
    &Dtool_SequenceMethods_DCSimpleParameter,
    &Dtool_MappingMethods_DCSimpleParameter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCSimpleParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the most fundamental kind of parameter type: a single number or\n"
    " * string, one of the DCSubatomicType elements.  It may also optionally have a\n"
    " * divisor, which is meaningful only for the numeric type elements (and\n"
    " * represents a fixed-point numeric convention).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCSimpleParameter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCSimpleParameter,
    PyType_GenericAlloc,
    Dtool_new_DCSimpleParameter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCSimpleParameter,
  Dtool_UpcastInterface_DCSimpleParameter,
  Dtool_DowncastInterface_DCSimpleParameter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCSimpleParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(nullptr);
    Dtool_DCSimpleParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    Dtool_DCSimpleParameter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCSimpleParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCSimpleParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCSimpleParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCSimpleParameter);
  }
}

/**
 * Python method tables for DCSwitch (DCSwitch)
 */
static PyMethodDef Dtool_Methods_DCSwitch[] = {
  {"get_name", &Dtool_DCSwitch_get_name_238, METH_NOARGS, (const char *)Dtool_DCSwitch_get_name_238_comment},
  {"getName", &Dtool_DCSwitch_get_name_238, METH_NOARGS, (const char *)Dtool_DCSwitch_get_name_238_comment},
  {"get_key_parameter", &Dtool_DCSwitch_get_key_parameter_239, METH_NOARGS, (const char *)Dtool_DCSwitch_get_key_parameter_239_comment},
  {"getKeyParameter", &Dtool_DCSwitch_get_key_parameter_239, METH_NOARGS, (const char *)Dtool_DCSwitch_get_key_parameter_239_comment},
  {"get_num_cases", &Dtool_DCSwitch_get_num_cases_240, METH_NOARGS, (const char *)Dtool_DCSwitch_get_num_cases_240_comment},
  {"getNumCases", &Dtool_DCSwitch_get_num_cases_240, METH_NOARGS, (const char *)Dtool_DCSwitch_get_num_cases_240_comment},
  {"get_case_by_value", &Dtool_DCSwitch_get_case_by_value_241, METH_O, (const char *)Dtool_DCSwitch_get_case_by_value_241_comment},
  {"getCaseByValue", &Dtool_DCSwitch_get_case_by_value_241, METH_O, (const char *)Dtool_DCSwitch_get_case_by_value_241_comment},
  {"get_case", &Dtool_DCSwitch_get_case_242, METH_O, (const char *)Dtool_DCSwitch_get_case_242_comment},
  {"getCase", &Dtool_DCSwitch_get_case_242, METH_O, (const char *)Dtool_DCSwitch_get_case_242_comment},
  {"get_default_case", &Dtool_DCSwitch_get_default_case_243, METH_NOARGS, (const char *)Dtool_DCSwitch_get_default_case_243_comment},
  {"getDefaultCase", &Dtool_DCSwitch_get_default_case_243, METH_NOARGS, (const char *)Dtool_DCSwitch_get_default_case_243_comment},
  {"get_value", &Dtool_DCSwitch_get_value_244, METH_O, (const char *)Dtool_DCSwitch_get_value_244_comment},
  {"getValue", &Dtool_DCSwitch_get_value_244, METH_O, (const char *)Dtool_DCSwitch_get_value_244_comment},
  {"get_num_fields", &Dtool_DCSwitch_get_num_fields_245, METH_O, (const char *)Dtool_DCSwitch_get_num_fields_245_comment},
  {"getNumFields", &Dtool_DCSwitch_get_num_fields_245, METH_O, (const char *)Dtool_DCSwitch_get_num_fields_245_comment},
  {"get_field", (PyCFunction) &Dtool_DCSwitch_get_field_246, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_246_comment},
  {"getField", (PyCFunction) &Dtool_DCSwitch_get_field_246, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_246_comment},
  {"get_field_by_name", (PyCFunction) &Dtool_DCSwitch_get_field_by_name_247, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_by_name_247_comment},
  {"getFieldByName", (PyCFunction) &Dtool_DCSwitch_get_field_by_name_247, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DCSwitch_get_field_by_name_247_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCSwitch = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCSwitch = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCSwitch = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCSwitch = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCSwitch = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCSwitch = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCSwitch",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCSwitch,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCSwitch,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCSwitch,
    &Dtool_SequenceMethods_DCSwitch,
    &Dtool_MappingMethods_DCSwitch,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCSwitch,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a switch statement, which can appear inside a class body\n"
    " * and represents two or more alternative unpacking schemes based on the first\n"
    " * field read.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCSwitch,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCSwitch,
    PyType_GenericAlloc,
    Dtool_new_DCSwitch,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCSwitch,
  Dtool_UpcastInterface_DCSwitch,
  Dtool_DowncastInterface_DCSwitch,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCSwitch(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(nullptr);
    Dtool_DCSwitch._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    Dtool_DCSwitch._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCSwitch._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCSwitch) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCSwitch)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCSwitch);
  }
}

/**
 * Python method tables for DCSwitchParameter (DCSwitchParameter)
 */
static PyMethodDef Dtool_Methods_DCSwitchParameter[] = {
  {"get_switch", &Dtool_DCSwitchParameter_get_switch_249, METH_NOARGS, (const char *)Dtool_DCSwitchParameter_get_switch_249_comment},
  {"getSwitch", &Dtool_DCSwitchParameter_get_switch_249, METH_NOARGS, (const char *)Dtool_DCSwitchParameter_get_switch_249_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCSwitchParameter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCSwitchParameter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCSwitchParameter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCSwitchParameter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCSwitchParameter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCSwitchParameter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCSwitchParameter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCSwitchParameter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCSwitchParameter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCSwitchParameter,
    &Dtool_SequenceMethods_DCSwitchParameter,
    &Dtool_MappingMethods_DCSwitchParameter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCSwitchParameter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a switch object used as a parameter itself, which packs the\n"
    " * appropriate fields of the switch into the message.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCSwitchParameter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCSwitchParameter,
    PyType_GenericAlloc,
    Dtool_new_DCSwitchParameter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCSwitchParameter,
  Dtool_UpcastInterface_DCSwitchParameter,
  Dtool_DowncastInterface_DCSwitchParameter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCSwitchParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCParameter(nullptr);
    Dtool_DCSwitchParameter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCParameter);
    Dtool_DCSwitchParameter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCSwitchParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCSwitchParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCSwitchParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCSwitchParameter);
  }
}

/**
 * Python method tables for DCTypedef (DCTypedef)
 */
static PyMethodDef Dtool_Methods_DCTypedef[] = {
  {"get_number", &Dtool_DCTypedef_get_number_252, METH_NOARGS, (const char *)Dtool_DCTypedef_get_number_252_comment},
  {"getNumber", &Dtool_DCTypedef_get_number_252, METH_NOARGS, (const char *)Dtool_DCTypedef_get_number_252_comment},
  {"get_name", &Dtool_DCTypedef_get_name_253, METH_NOARGS, (const char *)Dtool_DCTypedef_get_name_253_comment},
  {"getName", &Dtool_DCTypedef_get_name_253, METH_NOARGS, (const char *)Dtool_DCTypedef_get_name_253_comment},
  {"get_description", &Dtool_DCTypedef_get_description_254, METH_NOARGS, (const char *)Dtool_DCTypedef_get_description_254_comment},
  {"getDescription", &Dtool_DCTypedef_get_description_254, METH_NOARGS, (const char *)Dtool_DCTypedef_get_description_254_comment},
  {"is_bogus_typedef", &Dtool_DCTypedef_is_bogus_typedef_255, METH_NOARGS, (const char *)Dtool_DCTypedef_is_bogus_typedef_255_comment},
  {"isBogusTypedef", &Dtool_DCTypedef_is_bogus_typedef_255, METH_NOARGS, (const char *)Dtool_DCTypedef_is_bogus_typedef_255_comment},
  {"is_implicit_typedef", &Dtool_DCTypedef_is_implicit_typedef_256, METH_NOARGS, (const char *)Dtool_DCTypedef_is_implicit_typedef_256_comment},
  {"isImplicitTypedef", &Dtool_DCTypedef_is_implicit_typedef_256, METH_NOARGS, (const char *)Dtool_DCTypedef_is_implicit_typedef_256_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DCTypedef = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DCTypedef = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DCTypedef = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DCTypedef = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DCTypedef = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DCTypedef = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.DCTypedef",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DCTypedef,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DCTypedef,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DCTypedef,
    &Dtool_SequenceMethods_DCTypedef,
    &Dtool_MappingMethods_DCTypedef,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DCTypedef,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents a single typedef declaration in the dc file.  It assigns a\n"
    " * particular type to a new name, just like a C typedef.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DCTypedef,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DCTypedef,
    PyType_GenericAlloc,
    Dtool_new_DCTypedef,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DCTypedef,
  Dtool_UpcastInterface_DCTypedef,
  Dtool_DowncastInterface_DCTypedef,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DCTypedef(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DCDeclaration(nullptr);
    Dtool_DCTypedef._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DCDeclaration);
    Dtool_DCTypedef._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DCTypedef._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DCTypedef) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DCTypedef)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DCTypedef);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3dcparser_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3dcparser_BuildInstants(PyObject *module) {
  (void) module;
  // enum DCSubatomicType
  PyModule_AddObject(module, "ST_int8", Dtool_WrapValue(::ST_int8));
  PyModule_AddObject(module, "STInt8", Dtool_WrapValue(::ST_int8));
  PyModule_AddObject(module, "ST_int16", Dtool_WrapValue(::ST_int16));
  PyModule_AddObject(module, "STInt16", Dtool_WrapValue(::ST_int16));
  PyModule_AddObject(module, "ST_int32", Dtool_WrapValue(::ST_int32));
  PyModule_AddObject(module, "STInt32", Dtool_WrapValue(::ST_int32));
  PyModule_AddObject(module, "ST_int64", Dtool_WrapValue(::ST_int64));
  PyModule_AddObject(module, "STInt64", Dtool_WrapValue(::ST_int64));
  PyModule_AddObject(module, "ST_uint8", Dtool_WrapValue(::ST_uint8));
  PyModule_AddObject(module, "STUint8", Dtool_WrapValue(::ST_uint8));
  PyModule_AddObject(module, "ST_uint16", Dtool_WrapValue(::ST_uint16));
  PyModule_AddObject(module, "STUint16", Dtool_WrapValue(::ST_uint16));
  PyModule_AddObject(module, "ST_uint32", Dtool_WrapValue(::ST_uint32));
  PyModule_AddObject(module, "STUint32", Dtool_WrapValue(::ST_uint32));
  PyModule_AddObject(module, "ST_uint64", Dtool_WrapValue(::ST_uint64));
  PyModule_AddObject(module, "STUint64", Dtool_WrapValue(::ST_uint64));
  PyModule_AddObject(module, "ST_float64", Dtool_WrapValue(::ST_float64));
  PyModule_AddObject(module, "STFloat64", Dtool_WrapValue(::ST_float64));
  PyModule_AddObject(module, "ST_string", Dtool_WrapValue(::ST_string));
  PyModule_AddObject(module, "STString", Dtool_WrapValue(::ST_string));
  PyModule_AddObject(module, "ST_blob", Dtool_WrapValue(::ST_blob));
  PyModule_AddObject(module, "STBlob", Dtool_WrapValue(::ST_blob));
  PyModule_AddObject(module, "ST_blob32", Dtool_WrapValue(::ST_blob32));
  PyModule_AddObject(module, "STBlob32", Dtool_WrapValue(::ST_blob32));
  PyModule_AddObject(module, "ST_int16array", Dtool_WrapValue(::ST_int16array));
  PyModule_AddObject(module, "STInt16array", Dtool_WrapValue(::ST_int16array));
  PyModule_AddObject(module, "ST_int32array", Dtool_WrapValue(::ST_int32array));
  PyModule_AddObject(module, "STInt32array", Dtool_WrapValue(::ST_int32array));
  PyModule_AddObject(module, "ST_uint16array", Dtool_WrapValue(::ST_uint16array));
  PyModule_AddObject(module, "STUint16array", Dtool_WrapValue(::ST_uint16array));
  PyModule_AddObject(module, "ST_uint32array", Dtool_WrapValue(::ST_uint32array));
  PyModule_AddObject(module, "STUint32array", Dtool_WrapValue(::ST_uint32array));
  PyModule_AddObject(module, "ST_int8array", Dtool_WrapValue(::ST_int8array));
  PyModule_AddObject(module, "STInt8array", Dtool_WrapValue(::ST_int8array));
  PyModule_AddObject(module, "ST_uint8array", Dtool_WrapValue(::ST_uint8array));
  PyModule_AddObject(module, "STUint8array", Dtool_WrapValue(::ST_uint8array));
  PyModule_AddObject(module, "ST_uint32uint8array", Dtool_WrapValue(::ST_uint32uint8array));
  PyModule_AddObject(module, "STUint32uint8array", Dtool_WrapValue(::ST_uint32uint8array));
  PyModule_AddObject(module, "ST_char", Dtool_WrapValue(::ST_char));
  PyModule_AddObject(module, "STChar", Dtool_WrapValue(::ST_char));
  PyModule_AddObject(module, "ST_invalid", Dtool_WrapValue(::ST_invalid));
  PyModule_AddObject(module, "STInvalid", Dtool_WrapValue(::ST_invalid));
  // enum DCPackType
  PyModule_AddObject(module, "PT_invalid", Dtool_WrapValue(::PT_invalid));
  PyModule_AddObject(module, "PTInvalid", Dtool_WrapValue(::PT_invalid));
  PyModule_AddObject(module, "PT_double", Dtool_WrapValue(::PT_double));
  PyModule_AddObject(module, "PTDouble", Dtool_WrapValue(::PT_double));
  PyModule_AddObject(module, "PT_int", Dtool_WrapValue(::PT_int));
  PyModule_AddObject(module, "PTInt", Dtool_WrapValue(::PT_int));
  PyModule_AddObject(module, "PT_uint", Dtool_WrapValue(::PT_uint));
  PyModule_AddObject(module, "PTUint", Dtool_WrapValue(::PT_uint));
  PyModule_AddObject(module, "PT_int64", Dtool_WrapValue(::PT_int64));
  PyModule_AddObject(module, "PTInt64", Dtool_WrapValue(::PT_int64));
  PyModule_AddObject(module, "PT_uint64", Dtool_WrapValue(::PT_uint64));
  PyModule_AddObject(module, "PTUint64", Dtool_WrapValue(::PT_uint64));
  PyModule_AddObject(module, "PT_string", Dtool_WrapValue(::PT_string));
  PyModule_AddObject(module, "PTString", Dtool_WrapValue(::PT_string));
  PyModule_AddObject(module, "PT_blob", Dtool_WrapValue(::PT_blob));
  PyModule_AddObject(module, "PTBlob", Dtool_WrapValue(::PT_blob));
  PyModule_AddObject(module, "PT_array", Dtool_WrapValue(::PT_array));
  PyModule_AddObject(module, "PTArray", Dtool_WrapValue(::PT_array));
  PyModule_AddObject(module, "PT_field", Dtool_WrapValue(::PT_field));
  PyModule_AddObject(module, "PTField", Dtool_WrapValue(::PT_field));
  PyModule_AddObject(module, "PT_class", Dtool_WrapValue(::PT_class));
  PyModule_AddObject(module, "PTClass", Dtool_WrapValue(::PT_class));
  PyModule_AddObject(module, "PT_switch", Dtool_WrapValue(::PT_switch));
  PyModule_AddObject(module, "PTSwitch", Dtool_WrapValue(::PT_switch));
  // DCPackerInterface
  Dtool_PyModuleClassInit_DCPackerInterface(module);
  PyModule_AddObject(module, "DCPackerInterface", (PyObject *)&Dtool_DCPackerInterface);
  // DCKeywordList
  Dtool_PyModuleClassInit_DCKeywordList(module);
  PyModule_AddObject(module, "DCKeywordList", (PyObject *)&Dtool_DCKeywordList);
  // DCField
  Dtool_PyModuleClassInit_DCField(module);
  PyModule_AddObject(module, "DCField", (PyObject *)&Dtool_DCField);
  // DCPackData
  Dtool_PyModuleClassInit_DCPackData(module);
  PyModule_AddObject(module, "DCPackData", (PyObject *)&Dtool_DCPackData);
  // DCPacker
  Dtool_PyModuleClassInit_DCPacker(module);
  PyModule_AddObject(module, "DCPacker", (PyObject *)&Dtool_DCPacker);
  // DCParameter
  Dtool_PyModuleClassInit_DCParameter(module);
  PyModule_AddObject(module, "DCParameter", (PyObject *)&Dtool_DCParameter);
  // DCArrayParameter
  Dtool_PyModuleClassInit_DCArrayParameter(module);
  PyModule_AddObject(module, "DCArrayParameter", (PyObject *)&Dtool_DCArrayParameter);
  // DCAtomicField
  Dtool_PyModuleClassInit_DCAtomicField(module);
  PyModule_AddObject(module, "DCAtomicField", (PyObject *)&Dtool_DCAtomicField);
  // DCDeclaration
  Dtool_PyModuleClassInit_DCDeclaration(module);
  PyModule_AddObject(module, "DCDeclaration", (PyObject *)&Dtool_DCDeclaration);
  // DCClass
  Dtool_PyModuleClassInit_DCClass(module);
  PyModule_AddObject(module, "DCClass", (PyObject *)&Dtool_DCClass);
  // DCClassParameter
  Dtool_PyModuleClassInit_DCClassParameter(module);
  PyModule_AddObject(module, "DCClassParameter", (PyObject *)&Dtool_DCClassParameter);
  // DCFile
  Dtool_PyModuleClassInit_DCFile(module);
  PyModule_AddObject(module, "DCFile", (PyObject *)&Dtool_DCFile);
  // DCKeyword
  Dtool_PyModuleClassInit_DCKeyword(module);
  PyModule_AddObject(module, "DCKeyword", (PyObject *)&Dtool_DCKeyword);
  // DCMolecularField
  Dtool_PyModuleClassInit_DCMolecularField(module);
  PyModule_AddObject(module, "DCMolecularField", (PyObject *)&Dtool_DCMolecularField);
  // DCSimpleParameter
  Dtool_PyModuleClassInit_DCSimpleParameter(module);
  PyModule_AddObject(module, "DCSimpleParameter", (PyObject *)&Dtool_DCSimpleParameter);
  // DCSwitch
  Dtool_PyModuleClassInit_DCSwitch(module);
  PyModule_AddObject(module, "DCSwitch", (PyObject *)&Dtool_DCSwitch);
  // DCSwitchParameter
  Dtool_PyModuleClassInit_DCSwitchParameter(module);
  PyModule_AddObject(module, "DCSwitchParameter", (PyObject *)&Dtool_DCSwitchParameter);
  // DCTypedef
  Dtool_PyModuleClassInit_DCTypedef(module);
  PyModule_AddObject(module, "DCTypedef", (PyObject *)&Dtool_DCTypedef);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3dcparser_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3dcparser_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614757,  /* file_identifier */
  "libp3dcparser",  /* library_name */
  "zIbG",  /* library_hash_name */
  "panda3d.direct",  /* module_name */
  "libp3dcparser.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  589  /* next_index */
};

Configure(_in_configure_libp3dcparser);
ConfigureFn(_in_configure_libp3dcparser) {
  interrogate_request_module(&_in_module_def);
}

