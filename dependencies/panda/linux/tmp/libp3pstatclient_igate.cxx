/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/pstatclient -Ipanda/src/pstatclient -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3pstatclient_igate.cxx -od built/pandac/input/libp3pstatclient.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pstatclient -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3pstatclient config_pstatclient.h p3pstatclient_composite1.cxx p3pstatclient_composite2.cxx pStatClient.h pStatClientControlMessage.h pStatClientImpl.h pStatClientVersion.h pStatCollector.h pStatCollectorDef.h pStatCollectorForward.h pStatFrameData.h pStatProperties.h pStatServerControlMessage.h pStatThread.h pStatTimer.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_pstatclient.h"
#include "dconfig.h"
#include "notifyCategoryProxy.h"
#include "pStatClient.h"
#include "pStatClientControlMessage.h"
#include "pStatClientImpl.h"
#include "pStatClientVersion.h"
#include "pStatCollector.h"
#include "pStatCollectorDef.h"
#include "pStatCollectorForward.h"
#include "pStatFrameData.h"
#include "pStatProperties.h"
#include "pStatServerControlMessage.h"
#include "pStatThread.h"
#include "pStatTimer.h"
#include "pandabase.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class PStatClient
 */
typedef PStatClient PStatClient_localtype;
Define_Module_Class(panda3d.core, PStatClient, PStatClient_localtype, PStatClient);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PStatClient = &Dtool_PStatClient;
static void Dtool_PyModuleClassInit_PStatClient(PyObject *module);

/**
 * Forward declarations for top-level class PStatCollector
 */
typedef PStatCollector PStatCollector_localtype;
Define_Module_Class(panda3d.core, PStatCollector, PStatCollector_localtype, PStatCollector);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PStatCollector = &Dtool_PStatCollector;
static void Dtool_PyModuleClassInit_PStatCollector(PyObject *module);

/**
 * Forward declarations for top-level class PStatThread
 */
typedef PStatThread PStatThread_localtype;
Define_Module_Class(panda3d.core, PStatThread, PStatThread_localtype, PStatThread);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PStatThread = &Dtool_PStatThread;
static void Dtool_PyModuleClassInit_PStatThread(PyObject *module);
PStatThread *Dtool_Coerce_PStatThread(PyObject *args, PStatThread &coerced);

/**
 * Forward declarations for top-level class PStatCollectorForward
 */
typedef PStatCollectorForward PStatCollectorForward_localtype;
Define_Module_ClassRef(panda3d.core, PStatCollectorForward, PStatCollectorForward_localtype, PStatCollectorForward);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PStatCollectorForward = &Dtool_PStatCollectorForward;
static void Dtool_PyModuleClassInit_PStatCollectorForward(PyObject *module);
bool Dtool_ConstCoerce_PStatCollectorForward(PyObject *args, CPT(PStatCollectorForward) &coerced);
bool Dtool_Coerce_PStatCollectorForward(PyObject *args, PT(PStatCollectorForward) &coerced);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"PStatClient", &Dtool_PStatClient},
  {"PStatCollector", &Dtool_PStatCollector},
  {"PStatThread", &Dtool_PStatThread},
  {"PStatCollectorForward", &Dtool_PStatCollectorForward},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[1].type)
  {"Thread", nullptr},
#define Dtool_Ptr_Thread (imports[2].type)
  {"PStatCollectorForwardBase", nullptr},
#define Dtool_Ptr_PStatCollectorForwardBase (imports[3].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Thread
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Thread;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
#endif
// PStatCollectorForwardBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PStatCollectorForwardBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PStatCollectorForwardBase = &Dtool_PStatCollectorForwardBase;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class PStatClient
 */
/**
 * Python function wrapper for:
 * void PStatClient::set_client_name(std::string const &name)
 */
static PyObject *Dtool_PStatClient_set_client_name_4(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.set_client_name")) {
    return nullptr;
  }
  // 1-void PStatClient::set_client_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_client_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_name(const PStatClient self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_set_client_name_4_comment =
  "C++ Interface:\n"
  "set_client_name(const PStatClient self, str name)\n"
  "\n"
  "/**\n"
  " * Sets the name of the client.  This is reported to the PStatsServer, and\n"
  " * will presumably be written in the title bar or something.\n"
  " */";
#else
static const char *Dtool_PStatClient_set_client_name_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string PStatClient::get_client_name(void) const
 */
static PyObject *Dtool_PStatClient_get_client_name_5(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-std::string PStatClient::get_client_name(void) const
  std::string return_value = ((*(const PStatClient*)local_this).get_client_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_client_name_5_comment =
  "C++ Interface:\n"
  "get_client_name(PStatClient self)\n"
  "\n"
  "/**\n"
  " * Retrieves the name of the client as set.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_client_name_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PStatClient::set_max_rate(double rate)
 */
static PyObject *Dtool_PStatClient_set_max_rate_6(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.set_max_rate")) {
    return nullptr;
  }
  // 1-void PStatClient::set_max_rate(double rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_rate)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_rate(const PStatClient self, double rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_set_max_rate_6_comment =
  "C++ Interface:\n"
  "set_max_rate(const PStatClient self, double rate)\n"
  "\n"
  "/**\n"
  " * Controls the number of packets that will be sent to the server.  Normally,\n"
  " * one packet is sent per frame, but this can flood the server with more\n"
  " * packets than it can handle if the frame rate is especially good (e.g.  if\n"
  " * nothing is onscreen at the moment).  Set this parameter to a reasonable\n"
  " * number to prevent this from happening.\n"
  " *\n"
  " * This number specifies the maximum number of packets that will be sent to\n"
  " * the server per second, per thread.\n"
  " */";
#else
static const char *Dtool_PStatClient_set_max_rate_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double PStatClient::get_max_rate(void) const
 */
static PyObject *Dtool_PStatClient_get_max_rate_7(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-double PStatClient::get_max_rate(void) const
  double return_value = ((*(const PStatClient*)local_this).get_max_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_max_rate_7_comment =
  "C++ Interface:\n"
  "get_max_rate(PStatClient self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of packets that will be sent to the server per\n"
  " * second, per thread.  See set_max_rate().\n"
  " */";
#else
static const char *Dtool_PStatClient_get_max_rate_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PStatClient::get_num_collectors(void) const
 */
static PyObject *Dtool_PStatClient_get_num_collectors_8(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-inline int PStatClient::get_num_collectors(void) const
  int return_value = ((*(const PStatClient*)local_this).get_num_collectors)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_num_collectors_8_comment =
  "C++ Interface:\n"
  "get_num_collectors(PStatClient self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of collectors the Client knows about.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_num_collectors_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PStatCollector PStatClient::get_collector(int index) const
 */
static PyObject *Dtool_PStatClient_get_collector_9(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-PStatCollector PStatClient::get_collector(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PStatCollector *return_value = new PStatCollector(((*(const PStatClient*)local_this).get_collector)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatCollector, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collector(PStatClient self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_collector_9_comment =
  "C++ Interface:\n"
  "get_collector(PStatClient self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth collector.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_collector_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string PStatClient::get_collector_name(int index) const
 */
static PyObject *Dtool_PStatClient_get_collector_name_12(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-std::string PStatClient::get_collector_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const PStatClient*)local_this).get_collector_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collector_name(PStatClient self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_collector_name_12_comment =
  "C++ Interface:\n"
  "get_collector_name(PStatClient self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the name of the indicated collector.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_collector_name_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string PStatClient::get_collector_fullname(int index) const
 */
static PyObject *Dtool_PStatClient_get_collector_fullname_13(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-std::string PStatClient::get_collector_fullname(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const PStatClient*)local_this).get_collector_fullname)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collector_fullname(PStatClient self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_collector_fullname_13_comment =
  "C++ Interface:\n"
  "get_collector_fullname(PStatClient self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the \"full name\" of the indicated collector.  This will be the\n"
  " * concatenation of all of the collector's parents' names (except Frame) and\n"
  " * the collector's own name.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_collector_fullname_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PStatClient::get_num_threads(void) const
 */
static PyObject *Dtool_PStatClient_get_num_threads_14(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-inline int PStatClient::get_num_threads(void) const
  int return_value = ((*(const PStatClient*)local_this).get_num_threads)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_num_threads_14_comment =
  "C++ Interface:\n"
  "get_num_threads(PStatClient self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of threads the Client knows about.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_num_threads_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PStatThread PStatClient::get_thread(int index) const
 */
static PyObject *Dtool_PStatClient_get_thread_15(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-PStatThread PStatClient::get_thread(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PStatThread *return_value = new PStatThread(((*(const PStatClient*)local_this).get_thread)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatThread, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_thread(PStatClient self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_thread_15_comment =
  "C++ Interface:\n"
  "get_thread(PStatClient self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth thread.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_thread_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string PStatClient::get_thread_name(int index) const
 */
static PyObject *Dtool_PStatClient_get_thread_name_17(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-inline std::string PStatClient::get_thread_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const PStatClient*)local_this).get_thread_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_thread_name(PStatClient self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_thread_name_17_comment =
  "C++ Interface:\n"
  "get_thread_name(PStatClient self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the name of the indicated thread.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_thread_name_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string PStatClient::get_thread_sync_name(int index) const
 */
static PyObject *Dtool_PStatClient_get_thread_sync_name_18(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-inline std::string PStatClient::get_thread_sync_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const PStatClient*)local_this).get_thread_sync_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_thread_sync_name(PStatClient self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_thread_sync_name_18_comment =
  "C++ Interface:\n"
  "get_thread_sync_name(PStatClient self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the sync_name of the indicated thread.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_thread_sync_name_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Thread > PStatClient::get_thread_object(int index) const
 */
static PyObject *Dtool_PStatClient_get_thread_object_19(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-inline PointerTo< Thread > PStatClient::get_thread_object(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< Thread > return_value = ((*(const PStatClient*)local_this).get_thread_object)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    Thread *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Thread, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_thread_object(PStatClient self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_thread_object_19_comment =
  "C++ Interface:\n"
  "get_thread_object(PStatClient self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the Panda Thread object associated with the indicated PStatThread.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_thread_object_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PStatThread PStatClient::get_main_thread(void) const
 */
static PyObject *Dtool_PStatClient_get_main_thread_20(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-PStatThread PStatClient::get_main_thread(void) const
  PStatThread *return_value = new PStatThread(((*(const PStatClient*)local_this).get_main_thread)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatThread, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_main_thread_20_comment =
  "C++ Interface:\n"
  "get_main_thread(PStatClient self)\n"
  "\n"
  "/**\n"
  " * Returns a handle to the client's Main thread.  This is the thread that\n"
  " * started the application.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_main_thread_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PStatThread PStatClient::get_current_thread(void) const
 */
static PyObject *Dtool_PStatClient_get_current_thread_21(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-PStatThread PStatClient::get_current_thread(void) const
  PStatThread *return_value = new PStatThread(((*(const PStatClient*)local_this).get_current_thread)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatThread, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_current_thread_21_comment =
  "C++ Interface:\n"
  "get_current_thread(PStatClient self)\n"
  "\n"
  "/**\n"
  " * Returns a handle to the currently-executing thread.  This is the thread\n"
  " * that PStatCollectors will be counted in if they do not specify otherwise.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_current_thread_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double PStatClient::get_real_time(void) const
 */
static PyObject *Dtool_PStatClient_get_real_time_22(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-double PStatClient::get_real_time(void) const
  double return_value = ((*(const PStatClient*)local_this).get_real_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_real_time_22_comment =
  "C++ Interface:\n"
  "get_real_time(PStatClient self)\n"
  "\n"
  "/**\n"
  " * Returns the time according to to the PStatClient's clock object.  It keeps\n"
  " * its own clock, instead of using the global clock object, so the stats won't\n"
  " * get mucked up if you put the global clock in non-real-time mode or\n"
  " * something.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_real_time_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool PStatClient::connect(std::string const &hostname = string(), int port = -1)
 */
static PyObject *Dtool_PStatClient_connect_71(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline bool PStatClient::connect(std::string const &hostname = string(), int port = -1)
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  int param1 = -1;
  static const char *keyword_list[] = {"hostname", "port", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#i:connect", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    bool return_value = (PStatClient::connect)(std::string(param0_str, param0_len), (int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "connect(str hostname, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_connect_71_comment =
  "C++ Interface:\n"
  "connect(str hostname, int port)\n"
  "\n"
  "/**\n"
  " * Attempts to establish a connection to the indicated PStatServer.  Returns\n"
  " * true if successful, false on failure.\n"
  " */";
#else
static const char *Dtool_PStatClient_connect_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void PStatClient::disconnect(void)
 */
static PyObject *Dtool_PStatClient_disconnect_72(PyObject *, PyObject *) {
  // 1-static inline void PStatClient::disconnect(void)
  (PStatClient::disconnect)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_disconnect_72_comment =
  "C++ Interface:\n"
  "disconnect()\n"
  "\n"
  "/**\n"
  " * Closes the connection previously established.\n"
  " */";
#else
static const char *Dtool_PStatClient_disconnect_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool PStatClient::is_connected(void)
 */
static PyObject *Dtool_PStatClient_is_connected_73(PyObject *, PyObject *) {
  // 1-static inline bool PStatClient::is_connected(void)
  bool return_value = (PStatClient::is_connected)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_is_connected_73_comment =
  "C++ Interface:\n"
  "is_connected()\n"
  "\n"
  "/**\n"
  " * Returns true if the client believes it is connected to a working\n"
  " * PStatServer, false otherwise.\n"
  " */";
#else
static const char *Dtool_PStatClient_is_connected_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void PStatClient::resume_after_pause(void)
 */
static PyObject *Dtool_PStatClient_resume_after_pause_74(PyObject *, PyObject *) {
  // 1-static inline void PStatClient::resume_after_pause(void)
  (PStatClient::resume_after_pause)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_resume_after_pause_74_comment =
  "C++ Interface:\n"
  "resume_after_pause()\n"
  "\n"
  "/**\n"
  " * Resumes the PStatClient after the simulation has been paused for a while.\n"
  " * This allows the stats to continue exactly where it left off, instead of\n"
  " * leaving a big gap that would represent a chug.\n"
  " */";
#else
static const char *Dtool_PStatClient_resume_after_pause_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void PStatClient::main_tick(void)
 */
static PyObject *Dtool_PStatClient_main_tick_75(PyObject *, PyObject *) {
  // 1-static void PStatClient::main_tick(void)
  (PStatClient::main_tick)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_main_tick_75_comment =
  "C++ Interface:\n"
  "main_tick()\n"
  "\n"
  "/**\n"
  " * A convenience function to call new_frame() on the global PStatClient's main\n"
  " * thread, and any other threads with a sync_name of \"Main\".\n"
  " */";
#else
static const char *Dtool_PStatClient_main_tick_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void PStatClient::thread_tick(std::string const &sync_name)
 */
static PyObject *Dtool_PStatClient_thread_tick_76(PyObject *, PyObject *arg) {
  // 1-static void PStatClient::thread_tick(std::string const &sync_name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    (PStatClient::thread_tick)(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "thread_tick(str sync_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_thread_tick_76_comment =
  "C++ Interface:\n"
  "thread_tick(str sync_name)\n"
  "\n"
  "/**\n"
  " * A convenience function to call new_frame() on any threads with the\n"
  " * indicated sync_name\n"
  " */";
#else
static const char *Dtool_PStatClient_thread_tick_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PStatClient::client_main_tick(void)
 */
static PyObject *Dtool_PStatClient_client_main_tick_77(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.client_main_tick")) {
    return nullptr;
  }
  // 1-void PStatClient::client_main_tick(void)
  ((*local_this).client_main_tick)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_client_main_tick_77_comment =
  "C++ Interface:\n"
  "client_main_tick(const PStatClient self)\n"
  "\n"
  "/**\n"
  " * A convenience function to call new_frame() on the given PStatClient's main\n"
  " * thread, and any other threads with a sync_name of \"Main\".\n"
  " */";
#else
static const char *Dtool_PStatClient_client_main_tick_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PStatClient::client_thread_tick(std::string const &sync_name)
 */
static PyObject *Dtool_PStatClient_client_thread_tick_78(PyObject *self, PyObject *arg) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.client_thread_tick")) {
    return nullptr;
  }
  // 1-void PStatClient::client_thread_tick(std::string const &sync_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).client_thread_tick)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_thread_tick(const PStatClient self, str sync_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_client_thread_tick_78_comment =
  "C++ Interface:\n"
  "client_thread_tick(const PStatClient self, str sync_name)\n"
  "\n"
  "/**\n"
  " * A convenience function to call new_frame() on all of the threads with the\n"
  " * indicated sync name.\n"
  " */";
#else
static const char *Dtool_PStatClient_client_thread_tick_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PStatClient::client_connect(std::string hostname, int port)
 */
static PyObject *Dtool_PStatClient_client_connect_79(PyObject *self, PyObject *args, PyObject *kwds) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.client_connect")) {
    return nullptr;
  }
  // 1-bool PStatClient::client_connect(std::string hostname, int port)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"hostname", "port", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:client_connect", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    bool return_value = ((*local_this).client_connect)(std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_connect(const PStatClient self, str hostname, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_client_connect_79_comment =
  "C++ Interface:\n"
  "client_connect(const PStatClient self, str hostname, int port)\n"
  "\n"
  "/**\n"
  " * The nonstatic implementation of connect().\n"
  " */";
#else
static const char *Dtool_PStatClient_client_connect_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PStatClient::client_disconnect(void)
 */
static PyObject *Dtool_PStatClient_client_disconnect_80(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.client_disconnect")) {
    return nullptr;
  }
  // 1-void PStatClient::client_disconnect(void)
  ((*local_this).client_disconnect)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_client_disconnect_80_comment =
  "C++ Interface:\n"
  "client_disconnect(const PStatClient self)\n"
  "\n"
  "/**\n"
  " * The nonstatic implementation of disconnect().\n"
  " */";
#else
static const char *Dtool_PStatClient_client_disconnect_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PStatClient::client_is_connected(void) const
 */
static PyObject *Dtool_PStatClient_client_is_connected_81(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatClient)) {
    return nullptr;
  }
  // 1-bool PStatClient::client_is_connected(void) const
  bool return_value = ((*(const PStatClient*)local_this).client_is_connected)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_client_is_connected_81_comment =
  "C++ Interface:\n"
  "client_is_connected(PStatClient self)\n"
  "\n"
  "/**\n"
  " * The nonstatic implementation of is_connected().\n"
  " */";
#else
static const char *Dtool_PStatClient_client_is_connected_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PStatClient::client_resume_after_pause(void)
 */
static PyObject *Dtool_PStatClient_client_resume_after_pause_82(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.client_resume_after_pause")) {
    return nullptr;
  }
  // 1-void PStatClient::client_resume_after_pause(void)
  ((*local_this).client_resume_after_pause)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_client_resume_after_pause_82_comment =
  "C++ Interface:\n"
  "client_resume_after_pause(const PStatClient self)\n"
  "\n"
  "/**\n"
  " * Resumes the PStatClient after the simulation has been paused for a while.\n"
  " * This allows the stats to continue exactly where it left off, instead of\n"
  " * leaving a big gap that would represent a chug.\n"
  " */";
#else
static const char *Dtool_PStatClient_client_resume_after_pause_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PStatClient *PStatClient::get_global_pstats(void)
 */
static PyObject *Dtool_PStatClient_get_global_pstats_83(PyObject *, PyObject *) {
  // 1-static PStatClient *PStatClient::get_global_pstats(void)
  PStatClient *return_value = (PStatClient::get_global_pstats)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatClient, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PStatClient_get_global_pstats_83_comment =
  "C++ Interface:\n"
  "get_global_pstats()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global PStatClient object.  It's legal to declare\n"
  " * your own PStatClient locally, but it's also convenient to have a global one\n"
  " * that everyone can register with.  This is the global one.\n"
  " */";
#else
static const char *Dtool_PStatClient_get_global_pstats_83_comment = nullptr;
#endif

static PyObject *Dtool_PStatClient_client_name_Getter(PyObject *self, void *) {
  const PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }

  // 1-std::string PStatClient::get_client_name(void) const
  std::string return_value = ((*(const PStatClient*)local_this).get_client_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PStatClient_client_name_Setter(PyObject *self, PyObject *arg, void *) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.client_name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete client_name attribute");
    return -1;
  }
  // 1-void PStatClient::set_client_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_client_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_client_name(const PStatClient self, str name)\n");
  }
  return -1;
}

static PyObject *Dtool_PStatClient_max_rate_Getter(PyObject *self, void *) {
  const PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double PStatClient::get_max_rate(void) const
  double return_value = ((*(const PStatClient*)local_this).get_max_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PStatClient_max_rate_Setter(PyObject *self, PyObject *arg, void *) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatClient, (void **)&local_this, "PStatClient.max_rate")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_rate attribute");
    return -1;
  }
  // 1-void PStatClient::set_max_rate(double rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_rate)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_rate(const PStatClient self, double rate)\n");
  }
  return -1;
}

/**
 * sequence length function for property PStatClient::collectors
 */
static Py_ssize_t Dtool_PStatClient_collectors_Len(PyObject *self) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_collectors)();
}

/**
 * sequence getter for property PStatClient::collectors
 */
static PyObject *Dtool_PStatClient_collectors_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_collectors)()) {
    PyErr_SetString(PyExc_IndexError, "PStatClient.collectors[] index out of range");
    return nullptr;
  }
  // 1-PStatCollector PStatClient::get_collector(int index) const
  PStatCollector *return_value = new PStatCollector(((*(const PStatClient*)local_this).get_collector)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatCollector, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collector(PStatClient self, index)\n");
  }
}

static PyObject *Dtool_PStatClient_collectors_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PStatClient.collectors");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PStatClient_collectors_Len;
    wrap->_getitem_func = &Dtool_PStatClient_collectors_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property PStatClient::threads
 */
static Py_ssize_t Dtool_PStatClient_threads_Len(PyObject *self) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_threads)();
}

/**
 * sequence getter for property PStatClient::threads
 */
static PyObject *Dtool_PStatClient_threads_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_threads)()) {
    PyErr_SetString(PyExc_IndexError, "PStatClient.threads[] index out of range");
    return nullptr;
  }
  // 1-PStatThread PStatClient::get_thread(int index) const
  PStatThread *return_value = new PStatThread(((*(const PStatClient*)local_this).get_thread)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatThread, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_thread(PStatClient self, index)\n");
  }
}

static PyObject *Dtool_PStatClient_threads_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PStatClient.threads");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PStatClient_threads_Len;
    wrap->_getitem_func = &Dtool_PStatClient_threads_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_PStatClient_main_thread_Getter(PyObject *self, void *) {
  const PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PStatThread PStatClient::get_main_thread(void) const
  PStatThread *return_value = new PStatThread(((*(const PStatClient*)local_this).get_main_thread)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatThread, true, false);
}

static PyObject *Dtool_PStatClient_current_thread_Getter(PyObject *self, void *) {
  const PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PStatThread PStatClient::get_current_thread(void) const
  PStatThread *return_value = new PStatThread(((*(const PStatClient*)local_this).get_current_thread)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatThread, true, false);
}

static PyObject *Dtool_PStatClient_real_time_Getter(PyObject *self, void *) {
  const PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double PStatClient::get_real_time(void) const
  double return_value = ((*(const PStatClient*)local_this).get_real_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_PStatClient(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PStatClient_get_collectors(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_collectors)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PStatClient_get_collector_9(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PStatClient_get_threads(PyObject *self, PyObject *) {
  PStatClient *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatClient, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_threads)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PStatClient_get_thread_15(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PStatClient(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PStatClient) {
    printf("PStatClient ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PStatClient *local_this = (PStatClient *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PStatClient) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PStatClient(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PStatClient) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PStatCollector
 */
/**
 * Python function wrapper for:
 * inline void PStatCollector::operator =(PStatCollector const &copy)
 */
static PyObject *Dtool_PStatCollector_operator_31(PyObject *self, PyObject *arg) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.assign")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::operator =(PStatCollector const &copy)
  PStatCollector const *arg_this = (PStatCollector *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PStatCollector, 1, "PStatCollector.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PStatCollector *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatCollector, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PStatCollector self, const PStatCollector copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_operator_31_comment =
  "C++ Interface:\n"
  "assign(const PStatCollector self, const PStatCollector copy)\n";
#else
static const char *Dtool_PStatCollector_operator_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PStatCollector::is_valid(void) const
 */
static PyObject *Dtool_PStatCollector_is_valid_32(PyObject *self, PyObject *) {
  PStatCollector *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatCollector)) {
    return nullptr;
  }
  // 1-inline bool PStatCollector::is_valid(void) const
  bool return_value = ((*(const PStatCollector*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_is_valid_32_comment =
  "C++ Interface:\n"
  "is_valid(PStatCollector self)\n"
  "\n"
  "/**\n"
  " * Returns true if collector is valid and may be used, or false if it was\n"
  " * constructed with the default constructor (in which case any attempt to use\n"
  " * it will crash).\n"
  " */";
#else
static const char *Dtool_PStatCollector_is_valid_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string PStatCollector::get_name(void) const
 */
static PyObject *Dtool_PStatCollector_get_name_33(PyObject *self, PyObject *) {
  PStatCollector *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatCollector)) {
    return nullptr;
  }
  // 1-inline std::string PStatCollector::get_name(void) const
  std::string return_value = ((*(const PStatCollector*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_get_name_33_comment =
  "C++ Interface:\n"
  "get_name(PStatCollector self)\n"
  "\n"
  "/**\n"
  " * Returns the local name of this collector.  This is the rightmost part of\n"
  " * the fullname, after the rightmost colon.\n"
  " */";
#else
static const char *Dtool_PStatCollector_get_name_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string PStatCollector::get_fullname(void) const
 */
static PyObject *Dtool_PStatCollector_get_fullname_34(PyObject *self, PyObject *) {
  PStatCollector *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatCollector)) {
    return nullptr;
  }
  // 1-inline std::string PStatCollector::get_fullname(void) const
  std::string return_value = ((*(const PStatCollector*)local_this).get_fullname)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_get_fullname_34_comment =
  "C++ Interface:\n"
  "get_fullname(PStatCollector self)\n"
  "\n"
  "/**\n"
  " * Returns the full name of this collector.  This includes the names of all\n"
  " * the collector's parents, concatenated together with colons.\n"
  " */";
#else
static const char *Dtool_PStatCollector_get_fullname_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::output(std::ostream &out) const
 */
static PyObject *Dtool_PStatCollector_output_35(PyObject *self, PyObject *arg) {
  PStatCollector *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatCollector)) {
    return nullptr;
  }
  // 1-inline void PStatCollector::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PStatCollector.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PStatCollector*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PStatCollector self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_output_35_comment =
  "C++ Interface:\n"
  "output(PStatCollector self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PStatCollector_output_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PStatCollector::is_active(void)
 * inline bool PStatCollector::is_active(PStatThread const &thread)
 */
static PyObject *Dtool_PStatCollector_is_active_36(PyObject *self, PyObject *args) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.is_active")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool PStatCollector::is_active(void)
      bool return_value = ((*local_this).is_active)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool PStatCollector::is_active(PStatThread const &thread)
      PStatThread arg_local;
      PStatThread const *arg_this = Dtool_Coerce_PStatThread(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PStatCollector.is_active", "PStatThread");
      }
      bool return_value = ((*local_this).is_active)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_active() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_active(const PStatCollector self)\n"
      "is_active(const PStatCollector self, const PStatThread thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_is_active_36_comment =
  "C++ Interface:\n"
  "is_active(const PStatCollector self)\n"
  "is_active(const PStatCollector self, const PStatThread thread)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular collector is active on the default thread,\n"
  " * and we are currently transmitting PStats data.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if this particular collector is active on the indicated\n"
  " * thread, and we are currently transmitting PStats data.\n"
  " */";
#else
static const char *Dtool_PStatCollector_is_active_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PStatCollector::is_started(void)
 * inline bool PStatCollector::is_started(PStatThread const &thread)
 */
static PyObject *Dtool_PStatCollector_is_started_37(PyObject *self, PyObject *args) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.is_started")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool PStatCollector::is_started(void)
      bool return_value = ((*local_this).is_started)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool PStatCollector::is_started(PStatThread const &thread)
      PStatThread arg_local;
      PStatThread const *arg_this = Dtool_Coerce_PStatThread(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PStatCollector.is_started", "PStatThread");
      }
      bool return_value = ((*local_this).is_started)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_started() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_started(const PStatCollector self)\n"
      "is_started(const PStatCollector self, const PStatThread thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_is_started_37_comment =
  "C++ Interface:\n"
  "is_started(const PStatCollector self)\n"
  "is_started(const PStatCollector self, const PStatThread thread)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular collector has been started on the default\n"
  " * thread, or false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if this particular collector has been started on the indicated\n"
  " * thread, or false otherwise.\n"
  " */";
#else
static const char *Dtool_PStatCollector_is_started_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::start(void)
 * inline void PStatCollector::start(PStatThread const &thread)
 * inline void PStatCollector::start(PStatThread const &thread, double as_of)
 */
static PyObject *Dtool_PStatCollector_start_38(PyObject *self, PyObject *args, PyObject *kwds) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.start")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PStatCollector::start(void)
      ((*local_this).start)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "thread")) {
        // 1-inline void PStatCollector::start(PStatThread const &thread)
        PStatThread arg_local;
        PStatThread const *arg_this = Dtool_Coerce_PStatThread(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "PStatCollector.start", "PStatThread");
        }
        ((*local_this).start)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void PStatCollector::start(PStatThread const &thread, double as_of)
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"thread", "as_of", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:start", (char **)keyword_list, &param1, &param2)) {
        PStatThread param1_local;
        PStatThread const *param1_this = Dtool_Coerce_PStatThread(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PStatCollector.start", "PStatThread");
        }
        ((*local_this).start)(*param1_this, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "start() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start(const PStatCollector self)\n"
      "start(const PStatCollector self, const PStatThread thread)\n"
      "start(const PStatCollector self, const PStatThread thread, double as_of)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_start_38_comment =
  "C++ Interface:\n"
  "start(const PStatCollector self)\n"
  "start(const PStatCollector self, const PStatThread thread)\n"
  "start(const PStatCollector self, const PStatThread thread, double as_of)\n"
  "\n"
  "/**\n"
  " * Starts this particular timer ticking.  This should be called before the\n"
  " * code you want to measure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts this timer ticking within a particular thread.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Marks that the timer should have been started as of the indicated time.\n"
  " * This must be a time based on the PStatClient's clock (see\n"
  " * PStatClient::get_clock()), and care should be taken that all such calls\n"
  " * exhibit a monotonically increasing series of time values.\n"
  " */";
#else
static const char *Dtool_PStatCollector_start_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::stop(void)
 * inline void PStatCollector::stop(PStatThread const &thread)
 * inline void PStatCollector::stop(PStatThread const &thread, double as_of)
 */
static PyObject *Dtool_PStatCollector_stop_39(PyObject *self, PyObject *args, PyObject *kwds) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.stop")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PStatCollector::stop(void)
      ((*local_this).stop)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "thread")) {
        // 1-inline void PStatCollector::stop(PStatThread const &thread)
        PStatThread arg_local;
        PStatThread const *arg_this = Dtool_Coerce_PStatThread(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "PStatCollector.stop", "PStatThread");
        }
        ((*local_this).stop)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void PStatCollector::stop(PStatThread const &thread, double as_of)
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"thread", "as_of", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:stop", (char **)keyword_list, &param1, &param2)) {
        PStatThread param1_local;
        PStatThread const *param1_this = Dtool_Coerce_PStatThread(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PStatCollector.stop", "PStatThread");
        }
        ((*local_this).stop)(*param1_this, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "stop() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stop(const PStatCollector self)\n"
      "stop(const PStatCollector self, const PStatThread thread)\n"
      "stop(const PStatCollector self, const PStatThread thread, double as_of)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_stop_39_comment =
  "C++ Interface:\n"
  "stop(const PStatCollector self)\n"
  "stop(const PStatCollector self, const PStatThread thread)\n"
  "stop(const PStatCollector self, const PStatThread thread, double as_of)\n"
  "\n"
  "/**\n"
  " * Stops this timer.  This should be called after the code you want to\n"
  " * measure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stops this timer within a particular thread.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Marks that the timer should have been stopped as of the indicated time.\n"
  " * This must be a time based on the PStatClient's clock (see\n"
  " * PStatClient::get_clock()), and care should be taken that all such calls\n"
  " * exhibit a monotonically increasing series of time values.\n"
  " */";
#else
static const char *Dtool_PStatCollector_stop_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::clear_level(void)
 * inline void PStatCollector::clear_level(PStatThread const &thread)
 */
static PyObject *Dtool_PStatCollector_clear_level_40(PyObject *self, PyObject *args) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.clear_level")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PStatCollector::clear_level(void)
      ((*local_this).clear_level)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline void PStatCollector::clear_level(PStatThread const &thread)
      PStatThread arg_local;
      PStatThread const *arg_this = Dtool_Coerce_PStatThread(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PStatCollector.clear_level", "PStatThread");
      }
      ((*local_this).clear_level)(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_level() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_level(const PStatCollector self)\n"
      "clear_level(const PStatCollector self, const PStatThread thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_clear_level_40_comment =
  "C++ Interface:\n"
  "clear_level(const PStatCollector self)\n"
  "clear_level(const PStatCollector self, const PStatThread thread)\n"
  "\n"
  "/**\n"
  " * Removes the level setting associated with this collector for the main\n"
  " * thread.  The collector will no longer show up on any level graphs in the\n"
  " * main thread.  This implicitly calls flush_level().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the level setting associated with this collector for the indicated\n"
  " * thread.  The collector will no longer show up on any level graphs in this\n"
  " * thread.\n"
  " */";
#else
static const char *Dtool_PStatCollector_clear_level_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::set_level(PStatThread const &thread, double level)
 * inline void PStatCollector::set_level(double level)
 */
static PyObject *Dtool_PStatCollector_set_level_41(PyObject *self, PyObject *args, PyObject *kwds) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.set_level")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "level")) {
        // 1-inline void PStatCollector::set_level(double level)
        if (PyNumber_Check(arg)) {
          ((*local_this).set_level)(PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline void PStatCollector::set_level(PStatThread const &thread, double level)
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"thread", "level", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:set_level", (char **)keyword_list, &param1, &param2)) {
        PStatThread param1_local;
        PStatThread const *param1_this = Dtool_Coerce_PStatThread(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PStatCollector.set_level", "PStatThread");
        }
        ((*local_this).set_level)(*param1_this, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_level() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_level(const PStatCollector self, double level)\n"
      "set_level(const PStatCollector self, const PStatThread thread, double level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_set_level_41_comment =
  "C++ Interface:\n"
  "set_level(const PStatCollector self, double level)\n"
  "set_level(const PStatCollector self, const PStatThread thread, double level)\n"
  "\n"
  "/**\n"
  " * Sets the level setting associated with this collector for the main thread\n"
  " * to the indicated value.  This implicitly calls flush_level().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the level setting associated with this collector for the indicated\n"
  " * thread to the indicated value.\n"
  " */";
#else
static const char *Dtool_PStatCollector_set_level_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::add_level(PStatThread const &thread, double increment)
 * inline void PStatCollector::add_level(double increment)
 */
static PyObject *Dtool_PStatCollector_add_level_42(PyObject *self, PyObject *args, PyObject *kwds) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.add_level")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "increment")) {
        // 1-inline void PStatCollector::add_level(double increment)
        if (PyNumber_Check(arg)) {
          ((*local_this).add_level)(PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline void PStatCollector::add_level(PStatThread const &thread, double increment)
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"thread", "increment", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:add_level", (char **)keyword_list, &param1, &param2)) {
        PStatThread param1_local;
        PStatThread const *param1_this = Dtool_Coerce_PStatThread(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PStatCollector.add_level", "PStatThread");
        }
        ((*local_this).add_level)(*param1_this, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_level() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level(const PStatCollector self, double increment)\n"
      "add_level(const PStatCollector self, const PStatThread thread, double increment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_add_level_42_comment =
  "C++ Interface:\n"
  "add_level(const PStatCollector self, double increment)\n"
  "add_level(const PStatCollector self, const PStatThread thread, double increment)\n"
  "\n"
  "/**\n"
  " * Adds the indicated increment (which may be negative) to the level setting\n"
  " * associated with this collector for the main thread.  If the collector did\n"
  " * not already have a level setting for the main thread, it is initialized to\n"
  " * 0.\n"
  " *\n"
  " * As an optimization, the data is not immediately set to the PStatClient.  It\n"
  " * will be sent the next time flush_level() is called.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the indicated increment (which may be negative) to the level setting\n"
  " * associated with this collector for the indicated thread.  If the collector\n"
  " * did not already have a level setting for this thread, it is initialized to\n"
  " * 0.\n"
  " */";
#else
static const char *Dtool_PStatCollector_add_level_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::sub_level(PStatThread const &thread, double decrement)
 * inline void PStatCollector::sub_level(double decrement)
 */
static PyObject *Dtool_PStatCollector_sub_level_43(PyObject *self, PyObject *args, PyObject *kwds) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.sub_level")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "decrement")) {
        // 1-inline void PStatCollector::sub_level(double decrement)
        if (PyNumber_Check(arg)) {
          ((*local_this).sub_level)(PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline void PStatCollector::sub_level(PStatThread const &thread, double decrement)
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"thread", "decrement", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:sub_level", (char **)keyword_list, &param1, &param2)) {
        PStatThread param1_local;
        PStatThread const *param1_this = Dtool_Coerce_PStatThread(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PStatCollector.sub_level", "PStatThread");
        }
        ((*local_this).sub_level)(*param1_this, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "sub_level() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sub_level(const PStatCollector self, double decrement)\n"
      "sub_level(const PStatCollector self, const PStatThread thread, double decrement)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_sub_level_43_comment =
  "C++ Interface:\n"
  "sub_level(const PStatCollector self, double decrement)\n"
  "sub_level(const PStatCollector self, const PStatThread thread, double decrement)\n"
  "\n"
  "/**\n"
  " * Subtracts the indicated decrement (which may be negative) to the level\n"
  " * setting associated with this collector for the main thread.  If the\n"
  " * collector did not already have a level setting for the main thread, it is\n"
  " * initialized to 0.\n"
  " *\n"
  " * As an optimization, the data is not immediately set to the PStatClient.  It\n"
  " * will be sent the next time flush_level() is called.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Subtracts the indicated decrement (which may be negative) to the level\n"
  " * setting associated with this collector for the indicated thread.  If the\n"
  " * collector did not already have a level setting for this thread, it is\n"
  " * initialized to 0.\n"
  " */";
#else
static const char *Dtool_PStatCollector_sub_level_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::add_level_now(double increment)
 */
static PyObject *Dtool_PStatCollector_add_level_now_44(PyObject *self, PyObject *arg) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.add_level_now")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::add_level_now(double increment)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_level_now)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level_now(const PStatCollector self, double increment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_add_level_now_44_comment =
  "C++ Interface:\n"
  "add_level_now(const PStatCollector self, double increment)\n"
  "\n"
  "/**\n"
  " * Calls add_level() and immediately calls flush_level().\n"
  " */";
#else
static const char *Dtool_PStatCollector_add_level_now_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::sub_level_now(double decrement)
 */
static PyObject *Dtool_PStatCollector_sub_level_now_45(PyObject *self, PyObject *arg) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.sub_level_now")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::sub_level_now(double decrement)
  if (PyNumber_Check(arg)) {
    ((*local_this).sub_level_now)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sub_level_now(const PStatCollector self, double decrement)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_sub_level_now_45_comment =
  "C++ Interface:\n"
  "sub_level_now(const PStatCollector self, double decrement)\n"
  "\n"
  "/**\n"
  " * Calls sub_level() and immediately calls flush_level().\n"
  " */";
#else
static const char *Dtool_PStatCollector_sub_level_now_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::flush_level(void)
 */
static PyObject *Dtool_PStatCollector_flush_level_46(PyObject *self, PyObject *) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.flush_level")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::flush_level(void)
  ((*local_this).flush_level)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_flush_level_46_comment =
  "C++ Interface:\n"
  "flush_level(const PStatCollector self)\n"
  "\n"
  "/**\n"
  " * Updates the PStatClient with the recent results from add_level() and\n"
  " * sub_level().\n"
  " */";
#else
static const char *Dtool_PStatCollector_flush_level_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PStatCollector::get_level(void)
 * inline double PStatCollector::get_level(PStatThread const &thread)
 */
static PyObject *Dtool_PStatCollector_get_level_47(PyObject *self, PyObject *args) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.get_level")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline double PStatCollector::get_level(void)
      double return_value = ((*local_this).get_level)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline double PStatCollector::get_level(PStatThread const &thread)
      PStatThread arg_local;
      PStatThread const *arg_this = Dtool_Coerce_PStatThread(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "PStatCollector.get_level", "PStatThread");
      }
      double return_value = ((*local_this).get_level)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_level() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_level(const PStatCollector self)\n"
      "get_level(const PStatCollector self, const PStatThread thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_get_level_47_comment =
  "C++ Interface:\n"
  "get_level(const PStatCollector self)\n"
  "get_level(const PStatCollector self, const PStatThread thread)\n"
  "\n"
  "/**\n"
  " * Returns the current level value of the given collector in the main thread.\n"
  " * This implicitly calls flush_level().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the current level value of the given collector.\n"
  " */";
#else
static const char *Dtool_PStatCollector_get_level_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::clear_thread_level(void)
 */
static PyObject *Dtool_PStatCollector_clear_thread_level_48(PyObject *self, PyObject *) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.clear_thread_level")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::clear_thread_level(void)
  ((*local_this).clear_thread_level)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_clear_thread_level_48_comment =
  "C++ Interface:\n"
  "clear_thread_level(const PStatCollector self)\n"
  "\n"
  "/**\n"
  " * Removes the level setting associated with this collector for the current\n"
  " * thread.  The collector will no longer show up on any level graphs in the\n"
  " * current thread.\n"
  " */";
#else
static const char *Dtool_PStatCollector_clear_thread_level_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::set_thread_level(double level)
 */
static PyObject *Dtool_PStatCollector_set_thread_level_49(PyObject *self, PyObject *arg) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.set_thread_level")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::set_thread_level(double level)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_thread_level)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thread_level(const PStatCollector self, double level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_set_thread_level_49_comment =
  "C++ Interface:\n"
  "set_thread_level(const PStatCollector self, double level)\n"
  "\n"
  "/**\n"
  " * Sets the level setting associated with this collector for the current\n"
  " * thread to the indicated value.\n"
  " */";
#else
static const char *Dtool_PStatCollector_set_thread_level_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::add_thread_level(double increment)
 */
static PyObject *Dtool_PStatCollector_add_thread_level_50(PyObject *self, PyObject *arg) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.add_thread_level")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::add_thread_level(double increment)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_thread_level)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_thread_level(const PStatCollector self, double increment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_add_thread_level_50_comment =
  "C++ Interface:\n"
  "add_thread_level(const PStatCollector self, double increment)\n"
  "\n"
  "/**\n"
  " * Adds the indicated increment (which may be negative) to the level setting\n"
  " * associated with this collector for the current thread.  If the collector\n"
  " * did not already have a level setting for the current thread, it is\n"
  " * initialized to 0.\n"
  " */";
#else
static const char *Dtool_PStatCollector_add_thread_level_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PStatCollector::sub_thread_level(double decrement)
 */
static PyObject *Dtool_PStatCollector_sub_thread_level_51(PyObject *self, PyObject *arg) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.sub_thread_level")) {
    return nullptr;
  }
  // 1-inline void PStatCollector::sub_thread_level(double decrement)
  if (PyNumber_Check(arg)) {
    ((*local_this).sub_thread_level)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sub_thread_level(const PStatCollector self, double decrement)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_sub_thread_level_51_comment =
  "C++ Interface:\n"
  "sub_thread_level(const PStatCollector self, double decrement)\n"
  "\n"
  "/**\n"
  " * Subtracts the indicated decrement (which may be negative) to the level\n"
  " * setting associated with this collector for the current thread.  If the\n"
  " * collector did not already have a level setting for the current thread, it\n"
  " * is initialized to 0.\n"
  " */";
#else
static const char *Dtool_PStatCollector_sub_thread_level_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PStatCollector::get_thread_level(void)
 */
static PyObject *Dtool_PStatCollector_get_thread_level_52(PyObject *self, PyObject *) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollector, (void **)&local_this, "PStatCollector.get_thread_level")) {
    return nullptr;
  }
  // 1-inline double PStatCollector::get_thread_level(void)
  double return_value = ((*local_this).get_thread_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_get_thread_level_52_comment =
  "C++ Interface:\n"
  "get_thread_level(const PStatCollector self)\n"
  "\n"
  "/**\n"
  " * Returns the current level value of the given collector in the current\n"
  " * thread.\n"
  " */";
#else
static const char *Dtool_PStatCollector_get_thread_level_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PStatCollector::get_index(void) const
 */
static PyObject *Dtool_PStatCollector_get_index_53(PyObject *self, PyObject *) {
  PStatCollector *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatCollector)) {
    return nullptr;
  }
  // 1-inline int PStatCollector::get_index(void) const
  int return_value = ((*(const PStatCollector*)local_this).get_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatCollector_get_index_53_comment =
  "C++ Interface:\n"
  "get_index(PStatCollector self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of this particular collector within the\n"
  " * PStatClient.\n"
  " */";
#else
static const char *Dtool_PStatCollector_get_index_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PStatCollector::PStatCollector(PStatCollector const &copy)
 * inline explicit PStatCollector::PStatCollector(PStatCollector const &parent, std::string const &name)
 * inline explicit PStatCollector::PStatCollector(std::string const &name, PStatClient *client = nullptr)
 */
static int Dtool_Init_PStatCollector(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline explicit PStatCollector::PStatCollector(std::string const &name, PStatClient *client)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:PStatCollector", (char **)keyword_list, &param0_str, &param0_len)) {
          PStatCollector *return_value = new PStatCollector(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatCollector, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline PStatCollector::PStatCollector(PStatCollector const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PStatCollector const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PStatCollector);
          if (param0_this != nullptr) {
            PStatCollector *return_value = new PStatCollector(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatCollector, true, false);
          }
        }
      }

      // No coercion possible: inline explicit PStatCollector::PStatCollector(std::string const &name, PStatClient *client)
      // No coercion possible: inline PStatCollector::PStatCollector(PStatCollector const &copy)
    }
    break;
  case 2:
    {
      {
        // -2 inline explicit PStatCollector::PStatCollector(PStatCollector const &parent, std::string const &name)
        PyObject *param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        static const char *keyword_list[] = {"parent", "name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:PStatCollector", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
          PStatCollector const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PStatCollector);
          if (param0_this != nullptr) {
            PStatCollector *return_value = new PStatCollector(*param0_this, std::string(param1_str, param1_len));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatCollector, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit PStatCollector::PStatCollector(std::string const &name, PStatClient *client)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "client", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:PStatCollector", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          PStatClient *param1_this = nullptr;
          if (param1 != Py_None) {
            param1_this = (PStatClient *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PStatClient, 1, "PStatCollector.PStatCollector", false, false);
          }
          if ((param1 == Py_None || param1_this != nullptr)) {
            PStatCollector *return_value = new PStatCollector(std::string(param0_str, param0_len), param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatCollector, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline explicit PStatCollector::PStatCollector(PStatCollector const &parent, std::string const &name)
      // No coercion possible: inline explicit PStatCollector::PStatCollector(std::string const &name, PStatClient *client)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PStatCollector() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PStatCollector(str name)\n"
      "PStatCollector(const PStatCollector copy)\n"
      "PStatCollector(const PStatCollector parent, str name)\n"
      "PStatCollector(str name, PStatClient client)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PStatCollector(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PStatCollector) {
    printf("PStatCollector ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PStatCollector *local_this = (PStatCollector *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PStatCollector) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PStatCollector(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PStatCollector) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PStatThread
 */
/**
 * Python function wrapper for:
 * inline void PStatThread::operator =(PStatThread const &copy)
 */
static PyObject *Dtool_PStatThread_operator_58(PyObject *self, PyObject *arg) {
  PStatThread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatThread, (void **)&local_this, "PStatThread.assign")) {
    return nullptr;
  }
  // 1-inline void PStatThread::operator =(PStatThread const &copy)
  PStatThread arg_local;
  PStatThread const *arg_this = Dtool_Coerce_PStatThread(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PStatThread.assign", "PStatThread");
  }
  ((*local_this).operator =)(*arg_this);
  PStatThread *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PStatThread, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PStatThread self, const PStatThread copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatThread_operator_58_comment =
  "C++ Interface:\n"
  "assign(const PStatThread self, const PStatThread copy)\n";
#else
static const char *Dtool_PStatThread_operator_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PStatThread::new_frame(void)
 */
static PyObject *Dtool_PStatThread_new_frame_59(PyObject *self, PyObject *) {
  PStatThread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatThread, (void **)&local_this, "PStatThread.new_frame")) {
    return nullptr;
  }
  // 1-void PStatThread::new_frame(void)
  ((*local_this).new_frame)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PStatThread_new_frame_59_comment =
  "C++ Interface:\n"
  "new_frame(const PStatThread self)\n"
  "\n"
  "/**\n"
  " * This must be called at the start of every \"frame\", whatever a frame may be\n"
  " * deemed to be, to accumulate all the stats that have collected so far for\n"
  " * the thread and ship them off to the server.\n"
  " *\n"
  " * Calling PStatClient::thread_tick() will automatically call this for any\n"
  " * threads with the indicated sync name.\n"
  " */";
#else
static const char *Dtool_PStatThread_new_frame_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Thread *PStatThread::get_thread(void) const
 */
static PyObject *Dtool_PStatThread_get_thread_61(PyObject *self, PyObject *) {
  PStatThread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatThread)) {
    return nullptr;
  }
  // 1-Thread *PStatThread::get_thread(void) const
  Thread *return_value = ((*(const PStatThread*)local_this).get_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PStatThread_get_thread_61_comment =
  "C++ Interface:\n"
  "get_thread(PStatThread self)\n"
  "\n"
  "/**\n"
  " * Returns the Panda Thread object associated with this particular\n"
  " * PStatThread.\n"
  " */";
#else
static const char *Dtool_PStatThread_get_thread_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PStatThread::get_index(void) const
 */
static PyObject *Dtool_PStatThread_get_index_62(PyObject *self, PyObject *) {
  PStatThread *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PStatThread)) {
    return nullptr;
  }
  // 1-inline int PStatThread::get_index(void) const
  int return_value = ((*(const PStatThread*)local_this).get_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PStatThread_get_index_62_comment =
  "C++ Interface:\n"
  "get_index(PStatThread self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of this particular thread within the PStatClient.\n"
  " */";
#else
static const char *Dtool_PStatThread_get_index_62_comment = nullptr;
#endif

static PyObject *Dtool_PStatThread_thread_Getter(PyObject *self, void *) {
  const PStatThread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatThread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-Thread *PStatThread::get_thread(void) const
  Thread *return_value = ((*(const PStatThread*)local_this).get_thread)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Thread, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_PStatThread_index_Getter(PyObject *self, void *) {
  const PStatThread *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatThread, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int PStatThread::get_index(void) const
  int return_value = ((*(const PStatThread*)local_this).get_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline PStatThread::PStatThread(PStatClient *client, int index)
 * inline PStatThread::PStatThread(PStatThread const &copy)
 * inline PStatThread::PStatThread(Thread *thread, PStatClient *client = nullptr)
 */
static int Dtool_Init_PStatThread(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "thread")) {
          Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Thread, 0, "PStatThread.PStatThread", false, false);
          if (param0_this != nullptr) {
            PStatThread *return_value = new PStatThread(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatThread, true, false);
          }
        }
      }

      // No coercion possible: inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
      {
        // -2 inline PStatThread::PStatThread(PStatThread const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PStatThread param0_local;
          PStatThread const *param0_this = Dtool_Coerce_PStatThread(param0, param0_local);
          if ((param0_this != nullptr)) {
            PStatThread *return_value = new PStatThread(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatThread, true, false);
          }
        }
      }

    }
    break;
  case 2:
    {
      {
        // -2 inline PStatThread::PStatThread(PStatClient *client, int index)
        PyObject *param0;
        int param1;
        static const char *keyword_list[] = {"client", "index", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:PStatThread", (char **)keyword_list, &param0, &param1)) {
          PStatClient *param0_this = (PStatClient *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PStatClient, 0, "PStatThread.PStatThread", false, false);
          if (param0_this != nullptr) {
            PStatThread *return_value = new PStatThread(param0_this, (int)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatThread, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"thread", "client", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:PStatThread", (char **)keyword_list, &param0, &param1)) {
          Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Thread, 0, "PStatThread.PStatThread", false, false);
          PStatClient *param1_this = nullptr;
          if (param1 != Py_None) {
            param1_this = (PStatClient *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PStatClient, 1, "PStatThread.PStatThread", false, false);
          }
          if (param0_this != nullptr && (param1 == Py_None || param1_this != nullptr)) {
            PStatThread *return_value = new PStatThread(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatThread, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline PStatThread::PStatThread(PStatClient *client, int index)
      // No coercion possible: inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PStatThread() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PStatThread(Thread thread)\n"
      "PStatThread(PStatClient client, int index)\n"
      "PStatThread(Thread thread, PStatClient client)\n");
  }
  return -1;
}

PStatThread *Dtool_Coerce_PStatThread(PyObject *args, PStatThread &coerced) {
  PStatThread *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PStatThread)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PStatThread *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
    Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 0, "PStatThread.PStatThread", false, false);
    if (arg_this != nullptr) {
      coerced = PStatThread(arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 inline PStatThread::PStatThread(PStatClient *client, int index)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:PStatThread", &param0, &param1)) {
          PStatClient *param0_this = (PStatClient *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PStatClient, 0, "PStatThread.PStatThread", false, false);
          if (param0_this != nullptr) {
            coerced = PStatThread(param0_this, (int)param1);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "PStatThread", 2, 2, &param0, &param1)) {
          Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Thread, 0, "PStatThread.PStatThread", false, false);
          PStatClient *param1_this = (PStatClient *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PStatClient, 1, "PStatThread.PStatThread", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = PStatThread(param0_this, param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_PStatThread(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PStatThread) {
    printf("PStatThread ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PStatThread *local_this = (PStatThread *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PStatThread) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PStatThread(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PStatThread) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PStatCollectorForward
 */
/**
 * Python function wrapper for:
 * inline PStatCollectorForward::PStatCollectorForward(PStatCollector const &col)
 */
static int Dtool_Init_PStatCollectorForward(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PStatCollectorForward() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "col")) {
    // 1-inline PStatCollectorForward::PStatCollectorForward(PStatCollector const &col)
    PStatCollector const *arg_this = (PStatCollector *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PStatCollector, 0, "PStatCollectorForward.PStatCollectorForward", true, true);
    if (arg_this != nullptr) {
      PStatCollectorForward *return_value = new PStatCollectorForward(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PStatCollectorForward, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PStatCollectorForward(const PStatCollector col)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PStatCollectorForward(PyObject *args, CPT(PStatCollectorForward) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PStatCollectorForward)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PStatCollectorForward::PStatCollectorForward(PStatCollector const &col)
    PStatCollector const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PStatCollector);
    if (arg_this != nullptr) {
      PStatCollectorForward *return_value = new PStatCollectorForward(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_PStatCollectorForward(PyObject *args, PT(PStatCollectorForward) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PStatCollectorForward)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PStatCollectorForward::PStatCollectorForward(PStatCollector const &col)
    PStatCollector const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PStatCollector);
    if (arg_this != nullptr) {
      PStatCollectorForward *return_value = new PStatCollectorForward(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PStatCollectorForward(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PStatCollectorForward) {
    printf("PStatCollectorForward ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PStatCollectorForward *local_this = (PStatCollectorForward *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PStatCollectorForward) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PStatCollectorForwardBase) {
    return (PStatCollectorForwardBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(PStatCollectorForwardBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PStatCollectorForward(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PStatCollectorForward) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PStatCollectorForwardBase) {
    PStatCollectorForwardBase* other_this = (PStatCollectorForwardBase*)from_this;
    return (PStatCollectorForward*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PStatCollectorForward*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for PStatClient (PStatClient)
 */
static PyMethodDef Dtool_Methods_PStatClient[] = {
  {"set_client_name", &Dtool_PStatClient_set_client_name_4, METH_O, (const char *)Dtool_PStatClient_set_client_name_4_comment},
  {"setClientName", &Dtool_PStatClient_set_client_name_4, METH_O, (const char *)Dtool_PStatClient_set_client_name_4_comment},
  {"get_client_name", &Dtool_PStatClient_get_client_name_5, METH_NOARGS, (const char *)Dtool_PStatClient_get_client_name_5_comment},
  {"getClientName", &Dtool_PStatClient_get_client_name_5, METH_NOARGS, (const char *)Dtool_PStatClient_get_client_name_5_comment},
  {"set_max_rate", &Dtool_PStatClient_set_max_rate_6, METH_O, (const char *)Dtool_PStatClient_set_max_rate_6_comment},
  {"setMaxRate", &Dtool_PStatClient_set_max_rate_6, METH_O, (const char *)Dtool_PStatClient_set_max_rate_6_comment},
  {"get_max_rate", &Dtool_PStatClient_get_max_rate_7, METH_NOARGS, (const char *)Dtool_PStatClient_get_max_rate_7_comment},
  {"getMaxRate", &Dtool_PStatClient_get_max_rate_7, METH_NOARGS, (const char *)Dtool_PStatClient_get_max_rate_7_comment},
  {"get_num_collectors", &Dtool_PStatClient_get_num_collectors_8, METH_NOARGS, (const char *)Dtool_PStatClient_get_num_collectors_8_comment},
  {"getNumCollectors", &Dtool_PStatClient_get_num_collectors_8, METH_NOARGS, (const char *)Dtool_PStatClient_get_num_collectors_8_comment},
  {"get_collector", &Dtool_PStatClient_get_collector_9, METH_O, (const char *)Dtool_PStatClient_get_collector_9_comment},
  {"getCollector", &Dtool_PStatClient_get_collector_9, METH_O, (const char *)Dtool_PStatClient_get_collector_9_comment},
  {"get_collector_name", &Dtool_PStatClient_get_collector_name_12, METH_O, (const char *)Dtool_PStatClient_get_collector_name_12_comment},
  {"getCollectorName", &Dtool_PStatClient_get_collector_name_12, METH_O, (const char *)Dtool_PStatClient_get_collector_name_12_comment},
  {"get_collector_fullname", &Dtool_PStatClient_get_collector_fullname_13, METH_O, (const char *)Dtool_PStatClient_get_collector_fullname_13_comment},
  {"getCollectorFullname", &Dtool_PStatClient_get_collector_fullname_13, METH_O, (const char *)Dtool_PStatClient_get_collector_fullname_13_comment},
  {"get_num_threads", &Dtool_PStatClient_get_num_threads_14, METH_NOARGS, (const char *)Dtool_PStatClient_get_num_threads_14_comment},
  {"getNumThreads", &Dtool_PStatClient_get_num_threads_14, METH_NOARGS, (const char *)Dtool_PStatClient_get_num_threads_14_comment},
  {"get_thread", &Dtool_PStatClient_get_thread_15, METH_O, (const char *)Dtool_PStatClient_get_thread_15_comment},
  {"getThread", &Dtool_PStatClient_get_thread_15, METH_O, (const char *)Dtool_PStatClient_get_thread_15_comment},
  {"get_thread_name", &Dtool_PStatClient_get_thread_name_17, METH_O, (const char *)Dtool_PStatClient_get_thread_name_17_comment},
  {"getThreadName", &Dtool_PStatClient_get_thread_name_17, METH_O, (const char *)Dtool_PStatClient_get_thread_name_17_comment},
  {"get_thread_sync_name", &Dtool_PStatClient_get_thread_sync_name_18, METH_O, (const char *)Dtool_PStatClient_get_thread_sync_name_18_comment},
  {"getThreadSyncName", &Dtool_PStatClient_get_thread_sync_name_18, METH_O, (const char *)Dtool_PStatClient_get_thread_sync_name_18_comment},
  {"get_thread_object", &Dtool_PStatClient_get_thread_object_19, METH_O, (const char *)Dtool_PStatClient_get_thread_object_19_comment},
  {"getThreadObject", &Dtool_PStatClient_get_thread_object_19, METH_O, (const char *)Dtool_PStatClient_get_thread_object_19_comment},
  {"get_main_thread", &Dtool_PStatClient_get_main_thread_20, METH_NOARGS, (const char *)Dtool_PStatClient_get_main_thread_20_comment},
  {"getMainThread", &Dtool_PStatClient_get_main_thread_20, METH_NOARGS, (const char *)Dtool_PStatClient_get_main_thread_20_comment},
  {"get_current_thread", &Dtool_PStatClient_get_current_thread_21, METH_NOARGS, (const char *)Dtool_PStatClient_get_current_thread_21_comment},
  {"getCurrentThread", &Dtool_PStatClient_get_current_thread_21, METH_NOARGS, (const char *)Dtool_PStatClient_get_current_thread_21_comment},
  {"get_real_time", &Dtool_PStatClient_get_real_time_22, METH_NOARGS, (const char *)Dtool_PStatClient_get_real_time_22_comment},
  {"getRealTime", &Dtool_PStatClient_get_real_time_22, METH_NOARGS, (const char *)Dtool_PStatClient_get_real_time_22_comment},
  {"connect", (PyCFunction) &Dtool_PStatClient_connect_71, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PStatClient_connect_71_comment},
  {"disconnect", &Dtool_PStatClient_disconnect_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_disconnect_72_comment},
  {"is_connected", &Dtool_PStatClient_is_connected_73, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_is_connected_73_comment},
  {"isConnected", &Dtool_PStatClient_is_connected_73, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_is_connected_73_comment},
  {"resume_after_pause", &Dtool_PStatClient_resume_after_pause_74, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_resume_after_pause_74_comment},
  {"resumeAfterPause", &Dtool_PStatClient_resume_after_pause_74, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_resume_after_pause_74_comment},
  {"main_tick", &Dtool_PStatClient_main_tick_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_main_tick_75_comment},
  {"mainTick", &Dtool_PStatClient_main_tick_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_main_tick_75_comment},
  {"thread_tick", &Dtool_PStatClient_thread_tick_76, METH_O | METH_STATIC, (const char *)Dtool_PStatClient_thread_tick_76_comment},
  {"threadTick", &Dtool_PStatClient_thread_tick_76, METH_O | METH_STATIC, (const char *)Dtool_PStatClient_thread_tick_76_comment},
  {"client_main_tick", &Dtool_PStatClient_client_main_tick_77, METH_NOARGS, (const char *)Dtool_PStatClient_client_main_tick_77_comment},
  {"clientMainTick", &Dtool_PStatClient_client_main_tick_77, METH_NOARGS, (const char *)Dtool_PStatClient_client_main_tick_77_comment},
  {"client_thread_tick", &Dtool_PStatClient_client_thread_tick_78, METH_O, (const char *)Dtool_PStatClient_client_thread_tick_78_comment},
  {"clientThreadTick", &Dtool_PStatClient_client_thread_tick_78, METH_O, (const char *)Dtool_PStatClient_client_thread_tick_78_comment},
  {"client_connect", (PyCFunction) &Dtool_PStatClient_client_connect_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatClient_client_connect_79_comment},
  {"clientConnect", (PyCFunction) &Dtool_PStatClient_client_connect_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatClient_client_connect_79_comment},
  {"client_disconnect", &Dtool_PStatClient_client_disconnect_80, METH_NOARGS, (const char *)Dtool_PStatClient_client_disconnect_80_comment},
  {"clientDisconnect", &Dtool_PStatClient_client_disconnect_80, METH_NOARGS, (const char *)Dtool_PStatClient_client_disconnect_80_comment},
  {"client_is_connected", &Dtool_PStatClient_client_is_connected_81, METH_NOARGS, (const char *)Dtool_PStatClient_client_is_connected_81_comment},
  {"clientIsConnected", &Dtool_PStatClient_client_is_connected_81, METH_NOARGS, (const char *)Dtool_PStatClient_client_is_connected_81_comment},
  {"client_resume_after_pause", &Dtool_PStatClient_client_resume_after_pause_82, METH_NOARGS, (const char *)Dtool_PStatClient_client_resume_after_pause_82_comment},
  {"clientResumeAfterPause", &Dtool_PStatClient_client_resume_after_pause_82, METH_NOARGS, (const char *)Dtool_PStatClient_client_resume_after_pause_82_comment},
  {"get_global_pstats", &Dtool_PStatClient_get_global_pstats_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_get_global_pstats_83_comment},
  {"getGlobalPstats", &Dtool_PStatClient_get_global_pstats_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_PStatClient_get_global_pstats_83_comment},
  {"get_collectors", (PyCFunction) &MakeSeq_PStatClient_get_collectors, METH_NOARGS, nullptr},
  { "getCollectors", (PyCFunction) &MakeSeq_PStatClient_get_collectors, METH_NOARGS, nullptr},
  {"get_threads", (PyCFunction) &MakeSeq_PStatClient_get_threads, METH_NOARGS, nullptr},
  { "getThreads", (PyCFunction) &MakeSeq_PStatClient_get_threads, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PStatClient[] = {
  {(char *)"client_name", &Dtool_PStatClient_client_name_Getter, &Dtool_PStatClient_client_name_Setter, nullptr, nullptr},
  {(char *)"max_rate", &Dtool_PStatClient_max_rate_Getter, &Dtool_PStatClient_max_rate_Setter, nullptr, nullptr},
  {(char *)"collectors", &Dtool_PStatClient_collectors_Getter, nullptr, nullptr, nullptr},
  {(char *)"threads", &Dtool_PStatClient_threads_Getter, nullptr, nullptr, nullptr},
  {(char *)"main_thread", &Dtool_PStatClient_main_thread_Getter, nullptr, nullptr, nullptr},
  {(char *)"current_thread", &Dtool_PStatClient_current_thread_Getter, nullptr, nullptr, nullptr},
  {(char *)"real_time", &Dtool_PStatClient_real_time_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PStatClient = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PStatClient = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PStatClient = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PStatClient = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PStatClient = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PStatClient = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PStatClient",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PStatClient,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PStatClient,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PStatClient,
    &Dtool_SequenceMethods_PStatClient,
    &Dtool_MappingMethods_PStatClient,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PStatClient,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PStatClient,
    nullptr, // tp_members
    Dtool_Properties_PStatClient,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PStatClient,
    PyType_GenericAlloc,
    Dtool_new_PStatClient,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PStatClient,
  Dtool_UpcastInterface_PStatClient,
  Dtool_DowncastInterface_PStatClient,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PStatClient(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PStatClient._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PStatClient._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PStatClient) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PStatClient)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PStatClient);
  }
}

/**
 * Python method tables for PStatCollector (PStatCollector)
 */
static PyMethodDef Dtool_Methods_PStatCollector[] = {
  {"assign", &Dtool_PStatCollector_operator_31, METH_O, (const char *)Dtool_PStatCollector_operator_31_comment},
  {"is_valid", &Dtool_PStatCollector_is_valid_32, METH_NOARGS, (const char *)Dtool_PStatCollector_is_valid_32_comment},
  {"isValid", &Dtool_PStatCollector_is_valid_32, METH_NOARGS, (const char *)Dtool_PStatCollector_is_valid_32_comment},
  {"get_name", &Dtool_PStatCollector_get_name_33, METH_NOARGS, (const char *)Dtool_PStatCollector_get_name_33_comment},
  {"getName", &Dtool_PStatCollector_get_name_33, METH_NOARGS, (const char *)Dtool_PStatCollector_get_name_33_comment},
  {"get_fullname", &Dtool_PStatCollector_get_fullname_34, METH_NOARGS, (const char *)Dtool_PStatCollector_get_fullname_34_comment},
  {"getFullname", &Dtool_PStatCollector_get_fullname_34, METH_NOARGS, (const char *)Dtool_PStatCollector_get_fullname_34_comment},
  {"output", &Dtool_PStatCollector_output_35, METH_O, (const char *)Dtool_PStatCollector_output_35_comment},
  {"is_active", &Dtool_PStatCollector_is_active_36, METH_VARARGS, (const char *)Dtool_PStatCollector_is_active_36_comment},
  {"isActive", &Dtool_PStatCollector_is_active_36, METH_VARARGS, (const char *)Dtool_PStatCollector_is_active_36_comment},
  {"is_started", &Dtool_PStatCollector_is_started_37, METH_VARARGS, (const char *)Dtool_PStatCollector_is_started_37_comment},
  {"isStarted", &Dtool_PStatCollector_is_started_37, METH_VARARGS, (const char *)Dtool_PStatCollector_is_started_37_comment},
  {"start", (PyCFunction) &Dtool_PStatCollector_start_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_start_38_comment},
  {"stop", (PyCFunction) &Dtool_PStatCollector_stop_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_stop_39_comment},
  {"clear_level", &Dtool_PStatCollector_clear_level_40, METH_VARARGS, (const char *)Dtool_PStatCollector_clear_level_40_comment},
  {"clearLevel", &Dtool_PStatCollector_clear_level_40, METH_VARARGS, (const char *)Dtool_PStatCollector_clear_level_40_comment},
  {"set_level", (PyCFunction) &Dtool_PStatCollector_set_level_41, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_set_level_41_comment},
  {"setLevel", (PyCFunction) &Dtool_PStatCollector_set_level_41, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_set_level_41_comment},
  {"add_level", (PyCFunction) &Dtool_PStatCollector_add_level_42, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_add_level_42_comment},
  {"addLevel", (PyCFunction) &Dtool_PStatCollector_add_level_42, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_add_level_42_comment},
  {"sub_level", (PyCFunction) &Dtool_PStatCollector_sub_level_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_sub_level_43_comment},
  {"subLevel", (PyCFunction) &Dtool_PStatCollector_sub_level_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PStatCollector_sub_level_43_comment},
  {"add_level_now", &Dtool_PStatCollector_add_level_now_44, METH_O, (const char *)Dtool_PStatCollector_add_level_now_44_comment},
  {"addLevelNow", &Dtool_PStatCollector_add_level_now_44, METH_O, (const char *)Dtool_PStatCollector_add_level_now_44_comment},
  {"sub_level_now", &Dtool_PStatCollector_sub_level_now_45, METH_O, (const char *)Dtool_PStatCollector_sub_level_now_45_comment},
  {"subLevelNow", &Dtool_PStatCollector_sub_level_now_45, METH_O, (const char *)Dtool_PStatCollector_sub_level_now_45_comment},
  {"flush_level", &Dtool_PStatCollector_flush_level_46, METH_NOARGS, (const char *)Dtool_PStatCollector_flush_level_46_comment},
  {"flushLevel", &Dtool_PStatCollector_flush_level_46, METH_NOARGS, (const char *)Dtool_PStatCollector_flush_level_46_comment},
  {"get_level", &Dtool_PStatCollector_get_level_47, METH_VARARGS, (const char *)Dtool_PStatCollector_get_level_47_comment},
  {"getLevel", &Dtool_PStatCollector_get_level_47, METH_VARARGS, (const char *)Dtool_PStatCollector_get_level_47_comment},
  {"clear_thread_level", &Dtool_PStatCollector_clear_thread_level_48, METH_NOARGS, (const char *)Dtool_PStatCollector_clear_thread_level_48_comment},
  {"clearThreadLevel", &Dtool_PStatCollector_clear_thread_level_48, METH_NOARGS, (const char *)Dtool_PStatCollector_clear_thread_level_48_comment},
  {"set_thread_level", &Dtool_PStatCollector_set_thread_level_49, METH_O, (const char *)Dtool_PStatCollector_set_thread_level_49_comment},
  {"setThreadLevel", &Dtool_PStatCollector_set_thread_level_49, METH_O, (const char *)Dtool_PStatCollector_set_thread_level_49_comment},
  {"add_thread_level", &Dtool_PStatCollector_add_thread_level_50, METH_O, (const char *)Dtool_PStatCollector_add_thread_level_50_comment},
  {"addThreadLevel", &Dtool_PStatCollector_add_thread_level_50, METH_O, (const char *)Dtool_PStatCollector_add_thread_level_50_comment},
  {"sub_thread_level", &Dtool_PStatCollector_sub_thread_level_51, METH_O, (const char *)Dtool_PStatCollector_sub_thread_level_51_comment},
  {"subThreadLevel", &Dtool_PStatCollector_sub_thread_level_51, METH_O, (const char *)Dtool_PStatCollector_sub_thread_level_51_comment},
  {"get_thread_level", &Dtool_PStatCollector_get_thread_level_52, METH_NOARGS, (const char *)Dtool_PStatCollector_get_thread_level_52_comment},
  {"getThreadLevel", &Dtool_PStatCollector_get_thread_level_52, METH_NOARGS, (const char *)Dtool_PStatCollector_get_thread_level_52_comment},
  {"get_index", &Dtool_PStatCollector_get_index_53, METH_NOARGS, (const char *)Dtool_PStatCollector_get_index_53_comment},
  {"getIndex", &Dtool_PStatCollector_get_index_53, METH_NOARGS, (const char *)Dtool_PStatCollector_get_index_53_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PStatCollector
//////////////////
static PyObject *Dtool_Repr_PStatCollector(PyObject *self) {
  PStatCollector *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PStatCollector, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PStatCollector = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PStatCollector = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PStatCollector",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PStatCollector,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PStatCollector,
    &Dtool_NumberMethods_PStatCollector,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PStatCollector,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A lightweight class that represents a single element that may be timed\n"
    " * and/or counted via stats.\n"
    " *\n"
    " * Collectors can be used to measure two different kinds of values: elapsed\n"
    " * time, and \"other\".\n"
    " *\n"
    " * To measure elapsed time, call start() and stop() as appropriate to bracket\n"
    " * the section of code you want to time (or use a PStatTimer to do this\n"
    " * automatically).\n"
    " *\n"
    " * To measure anything else, call set_level() and/or add_level() to set the\n"
    " * \"level\" value associated with this collector.  The meaning of the value set\n"
    " * for the \"level\" is entirely up to the user; it may represent the number of\n"
    " * triangles rendered or the kilobytes of texture memory consumed, for\n"
    " * instance.  The level set will remain fixed across multiple frames until it\n"
    " * is reset via another set_level() or adjusted via a call to add_level().  It\n"
    " * may also be completely removed via clear_level().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PStatCollector,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PStatCollector,
    PyType_GenericAlloc,
    Dtool_new_PStatCollector,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PStatCollector,
  Dtool_UpcastInterface_PStatCollector,
  Dtool_DowncastInterface_PStatCollector,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PStatCollector(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PStatCollector._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PStatCollector._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PStatCollector) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PStatCollector)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PStatCollector);
  }
}

/**
 * Python method tables for PStatThread (PStatThread)
 */
static PyMethodDef Dtool_Methods_PStatThread[] = {
  {"assign", &Dtool_PStatThread_operator_58, METH_O, (const char *)Dtool_PStatThread_operator_58_comment},
  {"new_frame", &Dtool_PStatThread_new_frame_59, METH_NOARGS, (const char *)Dtool_PStatThread_new_frame_59_comment},
  {"newFrame", &Dtool_PStatThread_new_frame_59, METH_NOARGS, (const char *)Dtool_PStatThread_new_frame_59_comment},
  {"get_thread", &Dtool_PStatThread_get_thread_61, METH_NOARGS, (const char *)Dtool_PStatThread_get_thread_61_comment},
  {"getThread", &Dtool_PStatThread_get_thread_61, METH_NOARGS, (const char *)Dtool_PStatThread_get_thread_61_comment},
  {"get_index", &Dtool_PStatThread_get_index_62, METH_NOARGS, (const char *)Dtool_PStatThread_get_index_62_comment},
  {"getIndex", &Dtool_PStatThread_get_index_62, METH_NOARGS, (const char *)Dtool_PStatThread_get_index_62_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PStatThread[] = {
  {(char *)"thread", &Dtool_PStatThread_thread_Getter, nullptr, nullptr, nullptr},
  {(char *)"index", &Dtool_PStatThread_index_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PStatThread = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PStatThread = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PStatThread",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PStatThread,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PStatThread,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A lightweight class that represents a single thread of execution to PStats.\n"
    " * It corresponds one-to-one with Panda's Thread instance.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PStatThread,
    nullptr, // tp_members
    Dtool_Properties_PStatThread,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PStatThread,
    PyType_GenericAlloc,
    Dtool_new_PStatThread,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PStatThread,
  Dtool_UpcastInterface_PStatThread,
  Dtool_DowncastInterface_PStatThread,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PStatThread,
};

static void Dtool_PyModuleClassInit_PStatThread(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PStatThread._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PStatThread._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PStatThread) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PStatThread)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PStatThread);
  }
}

/**
 * Python method tables for PStatCollectorForward (PStatCollectorForward)
 */
static PyMethodDef Dtool_Methods_PStatCollectorForward[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PStatCollectorForward = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PStatCollectorForward = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PStatCollectorForward = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PStatCollectorForward = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PStatCollectorForward = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PStatCollectorForward = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PStatCollectorForward",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PStatCollectorForward,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PStatCollectorForward,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PStatCollectorForward,
    &Dtool_SequenceMethods_PStatCollectorForward,
    &Dtool_MappingMethods_PStatCollectorForward,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PStatCollectorForward,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class serves as a cheap forward reference to a PStatCollector, so that\n"
    " * classes that are defined before the pstats module may access the\n"
    " * PStatCollector.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PStatCollectorForward,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PStatCollectorForward,
    PyType_GenericAlloc,
    Dtool_new_PStatCollectorForward,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PStatCollectorForward,
  Dtool_UpcastInterface_PStatCollectorForward,
  Dtool_DowncastInterface_PStatCollectorForward,
  (CoerceFunction)Dtool_ConstCoerce_PStatCollectorForward,
  (CoerceFunction)Dtool_Coerce_PStatCollectorForward,
};

static void Dtool_PyModuleClassInit_PStatCollectorForward(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PStatCollectorForwardBase != nullptr);
    assert(Dtool_Ptr_PStatCollectorForwardBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PStatCollectorForwardBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_PStatCollectorForward._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PStatCollectorForwardBase);
    Dtool_PStatCollectorForward._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PStatCollectorForward._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PStatCollectorForward) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PStatCollectorForward)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PStatCollectorForward);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pstatclient_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3pstatclient_BuildInstants(PyObject *module) {
  (void) module;
  // PStatClient
  Dtool_PyModuleClassInit_PStatClient(module);
  PyModule_AddObject(module, "PStatClient", (PyObject *)&Dtool_PStatClient);
  // PStatCollector
  Dtool_PyModuleClassInit_PStatCollector(module);
  PyModule_AddObject(module, "PStatCollector", (PyObject *)&Dtool_PStatCollector);
  // PStatThread
  Dtool_PyModuleClassInit_PStatThread(module);
  PyModule_AddObject(module, "PStatThread", (PyObject *)&Dtool_PStatThread);
  // PStatCollectorForward
  Dtool_PyModuleClassInit_PStatCollectorForward(module);
  PyModule_AddObject(module, "PStatCollectorForward", (PyObject *)&Dtool_PStatCollectorForward);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3pstatclient_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3pstatclient_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613127,  /* file_identifier */
  "libp3pstatclient",  /* library_name */
  "__OL",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pstatclient.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  184  /* next_index */
};

Configure(_in_configure_libp3pstatclient);
ConfigureFn(_in_configure_libp3pstatclient) {
  interrogate_request_module(&_in_module_def);
}

